
ArduinoUnoFreertos_6_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000014  00800100  00000e44  00000ed8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000e44  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000063e  00800114  00800114  00000eec  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000eec  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000f1c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001f0  00000000  00000000  00000f5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000023ec  00000000  00000000  0000114c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008a9  00000000  00000000  00003538  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000c96  00000000  00000000  00003de1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000005b8  00000000  00000000  00004a78  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000d4b  00000000  00000000  00005030  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000205e  00000000  00000000  00005d7b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000218  00000000  00000000  00007dd9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 88 02 	jmp	0x510	; 0x510 <__vector_11>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e4 e4       	ldi	r30, 0x44	; 68
  7c:	fe e0       	ldi	r31, 0x0E	; 14
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a4 31       	cpi	r26, 0x14	; 20
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	27 e0       	ldi	r18, 0x07	; 7
  8c:	a4 e1       	ldi	r26, 0x14	; 20
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a2 35       	cpi	r26, 0x52	; 82
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 83 00 	call	0x106	; 0x106 <main>
  9e:	0c 94 20 07 	jmp	0xe40	; 0xe40 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <led1>:
}

//-----------------------------------------------------------

// method1 implementation 
void led1(void* pvParameters){
  a6:	cf 93       	push	r28
  a8:	df 93       	push	r29
  aa:	00 d0       	rcall	.+0      	; 0xac <led1+0x6>
  ac:	cd b7       	in	r28, 0x3d	; 61
  ae:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime = xTaskGetTickCount();
  b0:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <xTaskGetTickCount>
  b4:	9a 83       	std	Y+2, r25	; 0x02
  b6:	89 83       	std	Y+1, r24	; 0x01
	while (1){
		PORTB|=(1<<PORTB3);
  b8:	2b 9a       	sbi	0x05, 3	; 5
		vTaskDelayUntil(&xLastWakeTime,pdMS_TO_TICKS(1000));
  ba:	60 e1       	ldi	r22, 0x10	; 16
  bc:	70 e0       	ldi	r23, 0x00	; 0
  be:	ce 01       	movw	r24, r28
  c0:	01 96       	adiw	r24, 0x01	; 1
  c2:	0e 94 34 06 	call	0xc68	; 0xc68 <vTaskDelayUntil>
	    PORTB &= ~(1 << PORTB3);
  c6:	2b 98       	cbi	0x05, 3	; 5
		
	    vTaskDelayUntil(&xLastWakeTime,pdMS_TO_TICKS(1000));
  c8:	60 e1       	ldi	r22, 0x10	; 16
  ca:	70 e0       	ldi	r23, 0x00	; 0
  cc:	ce 01       	movw	r24, r28
  ce:	01 96       	adiw	r24, 0x01	; 1
  d0:	0e 94 34 06 	call	0xc68	; 0xc68 <vTaskDelayUntil>
	}
  d4:	f1 cf       	rjmp	.-30     	; 0xb8 <led1+0x12>

000000d6 <led2>:




// method2 implementation 
void led2(void* pvParameters){
  d6:	cf 93       	push	r28
  d8:	df 93       	push	r29
  da:	00 d0       	rcall	.+0      	; 0xdc <led2+0x6>
  dc:	cd b7       	in	r28, 0x3d	; 61
  de:	de b7       	in	r29, 0x3e	; 62
	TickType_t xLastWakeTime = xTaskGetTickCount();
  e0:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <xTaskGetTickCount>
  e4:	9a 83       	std	Y+2, r25	; 0x02
  e6:	89 83       	std	Y+1, r24	; 0x01
	while (1){
		PORTB|=(1<<PORTB5);
  e8:	2d 9a       	sbi	0x05, 5	; 5
		vTaskDelayUntil(&xLastWakeTime,pdMS_TO_TICKS(500));
  ea:	69 e2       	ldi	r22, 0x29	; 41
  ec:	70 e0       	ldi	r23, 0x00	; 0
  ee:	ce 01       	movw	r24, r28
  f0:	01 96       	adiw	r24, 0x01	; 1
  f2:	0e 94 34 06 	call	0xc68	; 0xc68 <vTaskDelayUntil>

		//vTaskDelayUntil(&xLastWakeTime, (500/portTICK_RATE_MS));
		PORTB&=~(1<<PORTB5);
  f6:	2d 98       	cbi	0x05, 5	; 5
		vTaskDelayUntil(&xLastWakeTime,pdMS_TO_TICKS(500));
  f8:	69 e2       	ldi	r22, 0x29	; 41
  fa:	70 e0       	ldi	r23, 0x00	; 0
  fc:	ce 01       	movw	r24, r28
  fe:	01 96       	adiw	r24, 0x01	; 1
 100:	0e 94 34 06 	call	0xc68	; 0xc68 <vTaskDelayUntil>

		//vTaskDelayUntil(&xLastWakeTime, (500/portTICK_RATE_MS));
	}
 104:	f1 cf       	rjmp	.-30     	; 0xe8 <led2+0x12>

00000106 <main>:
	xTaskHandle 		*pxCreatedTask
	);
	*/
	

	DDRB=0xFF;
 106:	8f ef       	ldi	r24, 0xFF	; 255
 108:	84 b9       	out	0x04, r24	; 4
	xTaskCreate(led1,"led1",256,NULL,1,NULL);
 10a:	a1 2c       	mov	r10, r1
 10c:	b1 2c       	mov	r11, r1
 10e:	c1 2c       	mov	r12, r1
 110:	d1 2c       	mov	r13, r1
 112:	e1 2c       	mov	r14, r1
 114:	f1 2c       	mov	r15, r1
 116:	01 e0       	ldi	r16, 0x01	; 1
 118:	20 e0       	ldi	r18, 0x00	; 0
 11a:	30 e0       	ldi	r19, 0x00	; 0
 11c:	40 e0       	ldi	r20, 0x00	; 0
 11e:	51 e0       	ldi	r21, 0x01	; 1
 120:	64 e0       	ldi	r22, 0x04	; 4
 122:	71 e0       	ldi	r23, 0x01	; 1
 124:	83 e5       	ldi	r24, 0x53	; 83
 126:	90 e0       	ldi	r25, 0x00	; 0
 128:	0e 94 ae 03 	call	0x75c	; 0x75c <xTaskGenericCreate>
	xTaskCreate(led2,"led2",256,NULL,1,NULL);
 12c:	20 e0       	ldi	r18, 0x00	; 0
 12e:	30 e0       	ldi	r19, 0x00	; 0
 130:	40 e0       	ldi	r20, 0x00	; 0
 132:	51 e0       	ldi	r21, 0x01	; 1
 134:	69 e0       	ldi	r22, 0x09	; 9
 136:	71 e0       	ldi	r23, 0x01	; 1
 138:	8b e6       	ldi	r24, 0x6B	; 107
 13a:	90 e0       	ldi	r25, 0x00	; 0
 13c:	0e 94 ae 03 	call	0x75c	; 0x75c <xTaskGenericCreate>
	vTaskStartScheduler();
 140:	0e 94 ba 04 	call	0x974	; 0x974 <vTaskStartScheduler>
	for (;;)
	;;
 144:	ff cf       	rjmp	.-2      	; 0x144 <main+0x3e>

00000146 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 146:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 148:	03 96       	adiw	r24, 0x03	; 3
 14a:	92 83       	std	Z+2, r25	; 0x02
 14c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 14e:	2f ef       	ldi	r18, 0xFF	; 255
 150:	3f ef       	ldi	r19, 0xFF	; 255
 152:	34 83       	std	Z+4, r19	; 0x04
 154:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 156:	96 83       	std	Z+6, r25	; 0x06
 158:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 15a:	90 87       	std	Z+8, r25	; 0x08
 15c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 15e:	10 82       	st	Z, r1
 160:	08 95       	ret

00000162 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 162:	fc 01       	movw	r30, r24
 164:	11 86       	std	Z+9, r1	; 0x09
 166:	10 86       	std	Z+8, r1	; 0x08
 168:	08 95       	ret

0000016a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 16a:	cf 93       	push	r28
 16c:	df 93       	push	r29
 16e:	9c 01       	movw	r18, r24
 170:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 172:	dc 01       	movw	r26, r24
 174:	11 96       	adiw	r26, 0x01	; 1
 176:	cd 91       	ld	r28, X+
 178:	dc 91       	ld	r29, X
 17a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 17c:	d3 83       	std	Z+3, r29	; 0x03
 17e:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 180:	8c 81       	ldd	r24, Y+4	; 0x04
 182:	9d 81       	ldd	r25, Y+5	; 0x05
 184:	95 83       	std	Z+5, r25	; 0x05
 186:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 188:	8c 81       	ldd	r24, Y+4	; 0x04
 18a:	9d 81       	ldd	r25, Y+5	; 0x05
 18c:	dc 01       	movw	r26, r24
 18e:	13 96       	adiw	r26, 0x03	; 3
 190:	7c 93       	st	X, r23
 192:	6e 93       	st	-X, r22
 194:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 196:	7d 83       	std	Y+5, r23	; 0x05
 198:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 19a:	31 87       	std	Z+9, r19	; 0x09
 19c:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 19e:	f9 01       	movw	r30, r18
 1a0:	80 81       	ld	r24, Z
 1a2:	8f 5f       	subi	r24, 0xFF	; 255
 1a4:	80 83       	st	Z, r24
}
 1a6:	df 91       	pop	r29
 1a8:	cf 91       	pop	r28
 1aa:	08 95       	ret

000001ac <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 1ac:	cf 93       	push	r28
 1ae:	df 93       	push	r29
 1b0:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 1b2:	48 81       	ld	r20, Y
 1b4:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 1b6:	4f 3f       	cpi	r20, 0xFF	; 255
 1b8:	2f ef       	ldi	r18, 0xFF	; 255
 1ba:	52 07       	cpc	r21, r18
 1bc:	21 f4       	brne	.+8      	; 0x1c6 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 1be:	fc 01       	movw	r30, r24
 1c0:	a7 81       	ldd	r26, Z+7	; 0x07
 1c2:	b0 85       	ldd	r27, Z+8	; 0x08
 1c4:	0d c0       	rjmp	.+26     	; 0x1e0 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1c6:	dc 01       	movw	r26, r24
 1c8:	13 96       	adiw	r26, 0x03	; 3
 1ca:	01 c0       	rjmp	.+2      	; 0x1ce <vListInsert+0x22>
 1cc:	df 01       	movw	r26, r30
 1ce:	12 96       	adiw	r26, 0x02	; 2
 1d0:	ed 91       	ld	r30, X+
 1d2:	fc 91       	ld	r31, X
 1d4:	13 97       	sbiw	r26, 0x03	; 3
 1d6:	20 81       	ld	r18, Z
 1d8:	31 81       	ldd	r19, Z+1	; 0x01
 1da:	42 17       	cp	r20, r18
 1dc:	53 07       	cpc	r21, r19
 1de:	b0 f7       	brcc	.-20     	; 0x1cc <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1e0:	12 96       	adiw	r26, 0x02	; 2
 1e2:	ed 91       	ld	r30, X+
 1e4:	fc 91       	ld	r31, X
 1e6:	13 97       	sbiw	r26, 0x03	; 3
 1e8:	fb 83       	std	Y+3, r31	; 0x03
 1ea:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 1ec:	d5 83       	std	Z+5, r29	; 0x05
 1ee:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 1f0:	bd 83       	std	Y+5, r27	; 0x05
 1f2:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 1f4:	13 96       	adiw	r26, 0x03	; 3
 1f6:	dc 93       	st	X, r29
 1f8:	ce 93       	st	-X, r28
 1fa:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1fc:	99 87       	std	Y+9, r25	; 0x09
 1fe:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 200:	fc 01       	movw	r30, r24
 202:	20 81       	ld	r18, Z
 204:	2f 5f       	subi	r18, 0xFF	; 255
 206:	20 83       	st	Z, r18
}
 208:	df 91       	pop	r29
 20a:	cf 91       	pop	r28
 20c:	08 95       	ret

0000020e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 20e:	cf 93       	push	r28
 210:	df 93       	push	r29
 212:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 214:	a0 85       	ldd	r26, Z+8	; 0x08
 216:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 218:	c2 81       	ldd	r28, Z+2	; 0x02
 21a:	d3 81       	ldd	r29, Z+3	; 0x03
 21c:	84 81       	ldd	r24, Z+4	; 0x04
 21e:	95 81       	ldd	r25, Z+5	; 0x05
 220:	9d 83       	std	Y+5, r25	; 0x05
 222:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 224:	c4 81       	ldd	r28, Z+4	; 0x04
 226:	d5 81       	ldd	r29, Z+5	; 0x05
 228:	82 81       	ldd	r24, Z+2	; 0x02
 22a:	93 81       	ldd	r25, Z+3	; 0x03
 22c:	9b 83       	std	Y+3, r25	; 0x03
 22e:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 230:	11 96       	adiw	r26, 0x01	; 1
 232:	cd 91       	ld	r28, X+
 234:	dc 91       	ld	r29, X
 236:	12 97       	sbiw	r26, 0x02	; 2
 238:	ce 17       	cp	r28, r30
 23a:	df 07       	cpc	r29, r31
 23c:	31 f4       	brne	.+12     	; 0x24a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 23e:	8c 81       	ldd	r24, Y+4	; 0x04
 240:	9d 81       	ldd	r25, Y+5	; 0x05
 242:	12 96       	adiw	r26, 0x02	; 2
 244:	9c 93       	st	X, r25
 246:	8e 93       	st	-X, r24
 248:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 24a:	11 86       	std	Z+9, r1	; 0x09
 24c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 24e:	8c 91       	ld	r24, X
 250:	81 50       	subi	r24, 0x01	; 1
 252:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 254:	df 91       	pop	r29
 256:	cf 91       	pop	r28
 258:	08 95       	ret

0000025a <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
 25a:	31 e1       	ldi	r19, 0x11	; 17
 25c:	fc 01       	movw	r30, r24
 25e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
 260:	31 97       	sbiw	r30, 0x01	; 1
 262:	22 e2       	ldi	r18, 0x22	; 34
 264:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
 266:	31 97       	sbiw	r30, 0x01	; 1
 268:	a3 e3       	ldi	r26, 0x33	; 51
 26a:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 26c:	31 97       	sbiw	r30, 0x01	; 1
 26e:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 270:	31 97       	sbiw	r30, 0x01	; 1
 272:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
 274:	31 97       	sbiw	r30, 0x01	; 1
 276:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
 278:	31 97       	sbiw	r30, 0x01	; 1
 27a:	60 e8       	ldi	r22, 0x80	; 128
 27c:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
 27e:	31 97       	sbiw	r30, 0x01	; 1
 280:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
 282:	31 97       	sbiw	r30, 0x01	; 1
 284:	62 e0       	ldi	r22, 0x02	; 2
 286:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
 288:	31 97       	sbiw	r30, 0x01	; 1
 28a:	63 e0       	ldi	r22, 0x03	; 3
 28c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
 28e:	31 97       	sbiw	r30, 0x01	; 1
 290:	64 e0       	ldi	r22, 0x04	; 4
 292:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
 294:	31 97       	sbiw	r30, 0x01	; 1
 296:	65 e0       	ldi	r22, 0x05	; 5
 298:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
 29a:	31 97       	sbiw	r30, 0x01	; 1
 29c:	66 e0       	ldi	r22, 0x06	; 6
 29e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
 2a0:	31 97       	sbiw	r30, 0x01	; 1
 2a2:	67 e0       	ldi	r22, 0x07	; 7
 2a4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
 2a6:	31 97       	sbiw	r30, 0x01	; 1
 2a8:	68 e0       	ldi	r22, 0x08	; 8
 2aa:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
 2ac:	31 97       	sbiw	r30, 0x01	; 1
 2ae:	69 e0       	ldi	r22, 0x09	; 9
 2b0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
 2b2:	31 97       	sbiw	r30, 0x01	; 1
 2b4:	60 e1       	ldi	r22, 0x10	; 16
 2b6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
 2b8:	31 97       	sbiw	r30, 0x01	; 1
 2ba:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
 2bc:	31 97       	sbiw	r30, 0x01	; 1
 2be:	32 e1       	ldi	r19, 0x12	; 18
 2c0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
 2c2:	31 97       	sbiw	r30, 0x01	; 1
 2c4:	33 e1       	ldi	r19, 0x13	; 19
 2c6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
 2c8:	31 97       	sbiw	r30, 0x01	; 1
 2ca:	34 e1       	ldi	r19, 0x14	; 20
 2cc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
 2ce:	31 97       	sbiw	r30, 0x01	; 1
 2d0:	35 e1       	ldi	r19, 0x15	; 21
 2d2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
 2d4:	31 97       	sbiw	r30, 0x01	; 1
 2d6:	36 e1       	ldi	r19, 0x16	; 22
 2d8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
 2da:	31 97       	sbiw	r30, 0x01	; 1
 2dc:	37 e1       	ldi	r19, 0x17	; 23
 2de:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
 2e0:	31 97       	sbiw	r30, 0x01	; 1
 2e2:	38 e1       	ldi	r19, 0x18	; 24
 2e4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
 2e6:	31 97       	sbiw	r30, 0x01	; 1
 2e8:	39 e1       	ldi	r19, 0x19	; 25
 2ea:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
 2ec:	31 97       	sbiw	r30, 0x01	; 1
 2ee:	30 e2       	ldi	r19, 0x20	; 32
 2f0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
 2f2:	31 97       	sbiw	r30, 0x01	; 1
 2f4:	31 e2       	ldi	r19, 0x21	; 33
 2f6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
 2f8:	31 97       	sbiw	r30, 0x01	; 1
 2fa:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
 2fc:	31 97       	sbiw	r30, 0x01	; 1
 2fe:	23 e2       	ldi	r18, 0x23	; 35
 300:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 302:	31 97       	sbiw	r30, 0x01	; 1
 304:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 306:	31 97       	sbiw	r30, 0x01	; 1
 308:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
 30a:	31 97       	sbiw	r30, 0x01	; 1
 30c:	26 e2       	ldi	r18, 0x26	; 38
 30e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
 310:	31 97       	sbiw	r30, 0x01	; 1
 312:	27 e2       	ldi	r18, 0x27	; 39
 314:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
 316:	31 97       	sbiw	r30, 0x01	; 1
 318:	28 e2       	ldi	r18, 0x28	; 40
 31a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
 31c:	31 97       	sbiw	r30, 0x01	; 1
 31e:	29 e2       	ldi	r18, 0x29	; 41
 320:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
 322:	31 97       	sbiw	r30, 0x01	; 1
 324:	20 e3       	ldi	r18, 0x30	; 48
 326:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
 328:	31 97       	sbiw	r30, 0x01	; 1
 32a:	21 e3       	ldi	r18, 0x31	; 49
 32c:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
 32e:	86 97       	sbiw	r24, 0x26	; 38
 330:	08 95       	ret

00000332 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
 332:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
 336:	8c e7       	ldi	r24, 0x7C	; 124
 338:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
 33c:	8b e0       	ldi	r24, 0x0B	; 11
 33e:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
 342:	ef e6       	ldi	r30, 0x6F	; 111
 344:	f0 e0       	ldi	r31, 0x00	; 0
 346:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
 348:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
 34a:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
 34c:	a0 91 50 07 	lds	r26, 0x0750
 350:	b0 91 51 07 	lds	r27, 0x0751
 354:	cd 91       	ld	r28, X+
 356:	cd bf       	out	0x3d, r28	; 61
 358:	dd 91       	ld	r29, X+
 35a:	de bf       	out	0x3e, r29	; 62
 35c:	ff 91       	pop	r31
 35e:	ef 91       	pop	r30
 360:	df 91       	pop	r29
 362:	cf 91       	pop	r28
 364:	bf 91       	pop	r27
 366:	af 91       	pop	r26
 368:	9f 91       	pop	r25
 36a:	8f 91       	pop	r24
 36c:	7f 91       	pop	r23
 36e:	6f 91       	pop	r22
 370:	5f 91       	pop	r21
 372:	4f 91       	pop	r20
 374:	3f 91       	pop	r19
 376:	2f 91       	pop	r18
 378:	1f 91       	pop	r17
 37a:	0f 91       	pop	r16
 37c:	ff 90       	pop	r15
 37e:	ef 90       	pop	r14
 380:	df 90       	pop	r13
 382:	cf 90       	pop	r12
 384:	bf 90       	pop	r11
 386:	af 90       	pop	r10
 388:	9f 90       	pop	r9
 38a:	8f 90       	pop	r8
 38c:	7f 90       	pop	r7
 38e:	6f 90       	pop	r6
 390:	5f 90       	pop	r5
 392:	4f 90       	pop	r4
 394:	3f 90       	pop	r3
 396:	2f 90       	pop	r2
 398:	1f 90       	pop	r1
 39a:	0f 90       	pop	r0
 39c:	0f be       	out	0x3f, r0	; 63
 39e:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
 3a0:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
 3a2:	81 e0       	ldi	r24, 0x01	; 1
 3a4:	08 95       	ret

000003a6 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 3a6:	0f 92       	push	r0
 3a8:	0f b6       	in	r0, 0x3f	; 63
 3aa:	f8 94       	cli
 3ac:	0f 92       	push	r0
 3ae:	1f 92       	push	r1
 3b0:	11 24       	eor	r1, r1
 3b2:	2f 92       	push	r2
 3b4:	3f 92       	push	r3
 3b6:	4f 92       	push	r4
 3b8:	5f 92       	push	r5
 3ba:	6f 92       	push	r6
 3bc:	7f 92       	push	r7
 3be:	8f 92       	push	r8
 3c0:	9f 92       	push	r9
 3c2:	af 92       	push	r10
 3c4:	bf 92       	push	r11
 3c6:	cf 92       	push	r12
 3c8:	df 92       	push	r13
 3ca:	ef 92       	push	r14
 3cc:	ff 92       	push	r15
 3ce:	0f 93       	push	r16
 3d0:	1f 93       	push	r17
 3d2:	2f 93       	push	r18
 3d4:	3f 93       	push	r19
 3d6:	4f 93       	push	r20
 3d8:	5f 93       	push	r21
 3da:	6f 93       	push	r22
 3dc:	7f 93       	push	r23
 3de:	8f 93       	push	r24
 3e0:	9f 93       	push	r25
 3e2:	af 93       	push	r26
 3e4:	bf 93       	push	r27
 3e6:	cf 93       	push	r28
 3e8:	df 93       	push	r29
 3ea:	ef 93       	push	r30
 3ec:	ff 93       	push	r31
 3ee:	a0 91 50 07 	lds	r26, 0x0750
 3f2:	b0 91 51 07 	lds	r27, 0x0751
 3f6:	0d b6       	in	r0, 0x3d	; 61
 3f8:	0d 92       	st	X+, r0
 3fa:	0e b6       	in	r0, 0x3e	; 62
 3fc:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 3fe:	0e 94 b3 06 	call	0xd66	; 0xd66 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 402:	a0 91 50 07 	lds	r26, 0x0750
 406:	b0 91 51 07 	lds	r27, 0x0751
 40a:	cd 91       	ld	r28, X+
 40c:	cd bf       	out	0x3d, r28	; 61
 40e:	dd 91       	ld	r29, X+
 410:	de bf       	out	0x3e, r29	; 62
 412:	ff 91       	pop	r31
 414:	ef 91       	pop	r30
 416:	df 91       	pop	r29
 418:	cf 91       	pop	r28
 41a:	bf 91       	pop	r27
 41c:	af 91       	pop	r26
 41e:	9f 91       	pop	r25
 420:	8f 91       	pop	r24
 422:	7f 91       	pop	r23
 424:	6f 91       	pop	r22
 426:	5f 91       	pop	r21
 428:	4f 91       	pop	r20
 42a:	3f 91       	pop	r19
 42c:	2f 91       	pop	r18
 42e:	1f 91       	pop	r17
 430:	0f 91       	pop	r16
 432:	ff 90       	pop	r15
 434:	ef 90       	pop	r14
 436:	df 90       	pop	r13
 438:	cf 90       	pop	r12
 43a:	bf 90       	pop	r11
 43c:	af 90       	pop	r10
 43e:	9f 90       	pop	r9
 440:	8f 90       	pop	r8
 442:	7f 90       	pop	r7
 444:	6f 90       	pop	r6
 446:	5f 90       	pop	r5
 448:	4f 90       	pop	r4
 44a:	3f 90       	pop	r3
 44c:	2f 90       	pop	r2
 44e:	1f 90       	pop	r1
 450:	0f 90       	pop	r0
 452:	0f be       	out	0x3f, r0	; 63
 454:	0f 90       	pop	r0

	asm volatile ( "ret" );
 456:	08 95       	ret

00000458 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 458:	0f 92       	push	r0
 45a:	0f b6       	in	r0, 0x3f	; 63
 45c:	f8 94       	cli
 45e:	0f 92       	push	r0
 460:	1f 92       	push	r1
 462:	11 24       	eor	r1, r1
 464:	2f 92       	push	r2
 466:	3f 92       	push	r3
 468:	4f 92       	push	r4
 46a:	5f 92       	push	r5
 46c:	6f 92       	push	r6
 46e:	7f 92       	push	r7
 470:	8f 92       	push	r8
 472:	9f 92       	push	r9
 474:	af 92       	push	r10
 476:	bf 92       	push	r11
 478:	cf 92       	push	r12
 47a:	df 92       	push	r13
 47c:	ef 92       	push	r14
 47e:	ff 92       	push	r15
 480:	0f 93       	push	r16
 482:	1f 93       	push	r17
 484:	2f 93       	push	r18
 486:	3f 93       	push	r19
 488:	4f 93       	push	r20
 48a:	5f 93       	push	r21
 48c:	6f 93       	push	r22
 48e:	7f 93       	push	r23
 490:	8f 93       	push	r24
 492:	9f 93       	push	r25
 494:	af 93       	push	r26
 496:	bf 93       	push	r27
 498:	cf 93       	push	r28
 49a:	df 93       	push	r29
 49c:	ef 93       	push	r30
 49e:	ff 93       	push	r31
 4a0:	a0 91 50 07 	lds	r26, 0x0750
 4a4:	b0 91 51 07 	lds	r27, 0x0751
 4a8:	0d b6       	in	r0, 0x3d	; 61
 4aa:	0d 92       	st	X+, r0
 4ac:	0e b6       	in	r0, 0x3e	; 62
 4ae:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 4b0:	0e 94 f5 04 	call	0x9ea	; 0x9ea <xTaskIncrementTick>
 4b4:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 4b6:	0e 94 b3 06 	call	0xd66	; 0xd66 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 4ba:	a0 91 50 07 	lds	r26, 0x0750
 4be:	b0 91 51 07 	lds	r27, 0x0751
 4c2:	cd 91       	ld	r28, X+
 4c4:	cd bf       	out	0x3d, r28	; 61
 4c6:	dd 91       	ld	r29, X+
 4c8:	de bf       	out	0x3e, r29	; 62
 4ca:	ff 91       	pop	r31
 4cc:	ef 91       	pop	r30
 4ce:	df 91       	pop	r29
 4d0:	cf 91       	pop	r28
 4d2:	bf 91       	pop	r27
 4d4:	af 91       	pop	r26
 4d6:	9f 91       	pop	r25
 4d8:	8f 91       	pop	r24
 4da:	7f 91       	pop	r23
 4dc:	6f 91       	pop	r22
 4de:	5f 91       	pop	r21
 4e0:	4f 91       	pop	r20
 4e2:	3f 91       	pop	r19
 4e4:	2f 91       	pop	r18
 4e6:	1f 91       	pop	r17
 4e8:	0f 91       	pop	r16
 4ea:	ff 90       	pop	r15
 4ec:	ef 90       	pop	r14
 4ee:	df 90       	pop	r13
 4f0:	cf 90       	pop	r12
 4f2:	bf 90       	pop	r11
 4f4:	af 90       	pop	r10
 4f6:	9f 90       	pop	r9
 4f8:	8f 90       	pop	r8
 4fa:	7f 90       	pop	r7
 4fc:	6f 90       	pop	r6
 4fe:	5f 90       	pop	r5
 500:	4f 90       	pop	r4
 502:	3f 90       	pop	r3
 504:	2f 90       	pop	r2
 506:	1f 90       	pop	r1
 508:	0f 90       	pop	r0
 50a:	0f be       	out	0x3f, r0	; 63
 50c:	0f 90       	pop	r0

	asm volatile ( "ret" );
 50e:	08 95       	ret

00000510 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect(void) __attribute__ ((signal, naked));
	void TIMER1_COMPA_vect(void)
	{
		vPortYieldFromTick();
 510:	0e 94 2c 02 	call	0x458	; 0x458 <vPortYieldFromTick>
		asm volatile ( "reti" );
 514:	18 95       	reti

00000516 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 516:	0f 93       	push	r16
 518:	1f 93       	push	r17
 51a:	cf 93       	push	r28
 51c:	df 93       	push	r29
 51e:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
 520:	0e 94 e5 04 	call	0x9ca	; 0x9ca <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 524:	80 91 14 01 	lds	r24, 0x0114
 528:	81 11       	cpse	r24, r1
 52a:	1d c0       	rjmp	.+58     	; 0x566 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 52c:	e9 e1       	ldi	r30, 0x19	; 25
 52e:	f1 e0       	ldi	r31, 0x01	; 1
 530:	8e e1       	ldi	r24, 0x1E	; 30
 532:	91 e0       	ldi	r25, 0x01	; 1
 534:	91 83       	std	Z+1, r25	; 0x01
 536:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
 538:	13 82       	std	Z+3, r1	; 0x03
 53a:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
 53c:	e5 e1       	ldi	r30, 0x15	; 21
 53e:	f1 e0       	ldi	r31, 0x01	; 1
 540:	8b ed       	ldi	r24, 0xDB	; 219
 542:	95 e0       	ldi	r25, 0x05	; 5
 544:	93 83       	std	Z+3, r25	; 0x03
 546:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
 548:	11 82       	std	Z+1, r1	; 0x01
 54a:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
 54c:	ad e1       	ldi	r26, 0x1D	; 29
 54e:	b1 e0       	ldi	r27, 0x01	; 1
 550:	14 96       	adiw	r26, 0x04	; 4
 552:	9c 93       	st	X, r25
 554:	8e 93       	st	-X, r24
 556:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
 558:	12 96       	adiw	r26, 0x02	; 2
 55a:	fc 93       	st	X, r31
 55c:	ee 93       	st	-X, r30
 55e:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
 560:	81 e0       	ldi	r24, 0x01	; 1
 562:	80 93 14 01 	sts	0x0114, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 566:	20 97       	sbiw	r28, 0x00	; 0
 568:	09 f4       	brne	.+2      	; 0x56c <pvPortMalloc+0x56>
 56a:	5f c0       	rjmp	.+190    	; 0x62a <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
 56c:	9e 01       	movw	r18, r28
 56e:	2c 5f       	subi	r18, 0xFC	; 252
 570:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
 572:	23 96       	adiw	r28, 0x03	; 3
 574:	ca 3d       	cpi	r28, 0xDA	; 218
 576:	d5 40       	sbci	r29, 0x05	; 5
 578:	08 f0       	brcs	.+2      	; 0x57c <pvPortMalloc+0x66>
 57a:	5a c0       	rjmp	.+180    	; 0x630 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
 57c:	e0 91 19 01 	lds	r30, 0x0119
 580:	f0 91 1a 01 	lds	r31, 0x011A

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 584:	a9 e1       	ldi	r26, 0x19	; 25
 586:	b1 e0       	ldi	r27, 0x01	; 1
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 588:	02 c0       	rjmp	.+4      	; 0x58e <pvPortMalloc+0x78>
 58a:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
 58c:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 58e:	82 81       	ldd	r24, Z+2	; 0x02
 590:	93 81       	ldd	r25, Z+3	; 0x03
 592:	82 17       	cp	r24, r18
 594:	93 07       	cpc	r25, r19
 596:	20 f4       	brcc	.+8      	; 0x5a0 <pvPortMalloc+0x8a>
 598:	80 81       	ld	r24, Z
 59a:	91 81       	ldd	r25, Z+1	; 0x01
 59c:	00 97       	sbiw	r24, 0x00	; 0
 59e:	a9 f7       	brne	.-22     	; 0x58a <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 5a0:	c1 e0       	ldi	r28, 0x01	; 1
 5a2:	e5 31       	cpi	r30, 0x15	; 21
 5a4:	fc 07       	cpc	r31, r28
 5a6:	09 f4       	brne	.+2      	; 0x5aa <pvPortMalloc+0x94>
 5a8:	46 c0       	rjmp	.+140    	; 0x636 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 5aa:	cd 91       	ld	r28, X+
 5ac:	dc 91       	ld	r29, X
 5ae:	11 97       	sbiw	r26, 0x01	; 1
 5b0:	8e 01       	movw	r16, r28
 5b2:	0c 5f       	subi	r16, 0xFC	; 252
 5b4:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 5b6:	80 81       	ld	r24, Z
 5b8:	91 81       	ldd	r25, Z+1	; 0x01
 5ba:	8d 93       	st	X+, r24
 5bc:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 5be:	82 81       	ldd	r24, Z+2	; 0x02
 5c0:	93 81       	ldd	r25, Z+3	; 0x03
 5c2:	82 1b       	sub	r24, r18
 5c4:	93 0b       	sbc	r25, r19
 5c6:	89 30       	cpi	r24, 0x09	; 9
 5c8:	91 05       	cpc	r25, r1
 5ca:	10 f1       	brcs	.+68     	; 0x610 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 5cc:	bf 01       	movw	r22, r30
 5ce:	62 0f       	add	r22, r18
 5d0:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 5d2:	db 01       	movw	r26, r22
 5d4:	13 96       	adiw	r26, 0x03	; 3
 5d6:	9c 93       	st	X, r25
 5d8:	8e 93       	st	-X, r24
 5da:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
 5dc:	33 83       	std	Z+3, r19	; 0x03
 5de:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 5e0:	12 96       	adiw	r26, 0x02	; 2
 5e2:	4d 91       	ld	r20, X+
 5e4:	5c 91       	ld	r21, X
 5e6:	13 97       	sbiw	r26, 0x03	; 3
 5e8:	89 e1       	ldi	r24, 0x19	; 25
 5ea:	91 e0       	ldi	r25, 0x01	; 1
 5ec:	01 c0       	rjmp	.+2      	; 0x5f0 <pvPortMalloc+0xda>
 5ee:	cd 01       	movw	r24, r26
 5f0:	ec 01       	movw	r28, r24
 5f2:	a8 81       	ld	r26, Y
 5f4:	b9 81       	ldd	r27, Y+1	; 0x01
 5f6:	12 96       	adiw	r26, 0x02	; 2
 5f8:	2d 91       	ld	r18, X+
 5fa:	3c 91       	ld	r19, X
 5fc:	13 97       	sbiw	r26, 0x03	; 3
 5fe:	24 17       	cp	r18, r20
 600:	35 07       	cpc	r19, r21
 602:	a8 f3       	brcs	.-22     	; 0x5ee <pvPortMalloc+0xd8>
 604:	eb 01       	movw	r28, r22
 606:	b9 83       	std	Y+1, r27	; 0x01
 608:	a8 83       	st	Y, r26
 60a:	dc 01       	movw	r26, r24
 60c:	6d 93       	st	X+, r22
 60e:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
 610:	80 91 00 01 	lds	r24, 0x0100
 614:	90 91 01 01 	lds	r25, 0x0101
 618:	22 81       	ldd	r18, Z+2	; 0x02
 61a:	33 81       	ldd	r19, Z+3	; 0x03
 61c:	82 1b       	sub	r24, r18
 61e:	93 0b       	sbc	r25, r19
 620:	90 93 01 01 	sts	0x0101, r25
 624:	80 93 00 01 	sts	0x0100, r24
 628:	08 c0       	rjmp	.+16     	; 0x63a <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 62a:	00 e0       	ldi	r16, 0x00	; 0
 62c:	10 e0       	ldi	r17, 0x00	; 0
 62e:	05 c0       	rjmp	.+10     	; 0x63a <pvPortMalloc+0x124>
 630:	00 e0       	ldi	r16, 0x00	; 0
 632:	10 e0       	ldi	r17, 0x00	; 0
 634:	02 c0       	rjmp	.+4      	; 0x63a <pvPortMalloc+0x124>
 636:	00 e0       	ldi	r16, 0x00	; 0
 638:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 63a:	0e 94 b2 05 	call	0xb64	; 0xb64 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 63e:	c8 01       	movw	r24, r16
 640:	df 91       	pop	r29
 642:	cf 91       	pop	r28
 644:	1f 91       	pop	r17
 646:	0f 91       	pop	r16
 648:	08 95       	ret

0000064a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 64a:	0f 93       	push	r16
 64c:	1f 93       	push	r17
 64e:	cf 93       	push	r28
 650:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
 652:	00 97       	sbiw	r24, 0x00	; 0
 654:	41 f1       	breq	.+80     	; 0x6a6 <vPortFree+0x5c>
 656:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 658:	8c 01       	movw	r16, r24
 65a:	04 50       	subi	r16, 0x04	; 4
 65c:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
 65e:	0e 94 e5 04 	call	0x9ca	; 0x9ca <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 662:	f8 01       	movw	r30, r16
 664:	42 81       	ldd	r20, Z+2	; 0x02
 666:	53 81       	ldd	r21, Z+3	; 0x03
 668:	a9 e1       	ldi	r26, 0x19	; 25
 66a:	b1 e0       	ldi	r27, 0x01	; 1
 66c:	01 c0       	rjmp	.+2      	; 0x670 <vPortFree+0x26>
 66e:	df 01       	movw	r26, r30
 670:	ed 91       	ld	r30, X+
 672:	fc 91       	ld	r31, X
 674:	11 97       	sbiw	r26, 0x01	; 1
 676:	22 81       	ldd	r18, Z+2	; 0x02
 678:	33 81       	ldd	r19, Z+3	; 0x03
 67a:	24 17       	cp	r18, r20
 67c:	35 07       	cpc	r19, r21
 67e:	b8 f3       	brcs	.-18     	; 0x66e <vPortFree+0x24>
 680:	24 97       	sbiw	r28, 0x04	; 4
 682:	f9 83       	std	Y+1, r31	; 0x01
 684:	e8 83       	st	Y, r30
 686:	0d 93       	st	X+, r16
 688:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
 68a:	20 91 00 01 	lds	r18, 0x0100
 68e:	30 91 01 01 	lds	r19, 0x0101
 692:	8a 81       	ldd	r24, Y+2	; 0x02
 694:	9b 81       	ldd	r25, Y+3	; 0x03
 696:	82 0f       	add	r24, r18
 698:	93 1f       	adc	r25, r19
 69a:	90 93 01 01 	sts	0x0101, r25
 69e:	80 93 00 01 	sts	0x0100, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
 6a2:	0e 94 b2 05 	call	0xb64	; 0xb64 <xTaskResumeAll>
	}
}
 6a6:	df 91       	pop	r29
 6a8:	cf 91       	pop	r28
 6aa:	1f 91       	pop	r17
 6ac:	0f 91       	pop	r16
 6ae:	08 95       	ret

000006b0 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 6b0:	e0 91 18 07 	lds	r30, 0x0718
 6b4:	f0 91 19 07 	lds	r31, 0x0719
 6b8:	80 81       	ld	r24, Z
 6ba:	81 11       	cpse	r24, r1
 6bc:	07 c0       	rjmp	.+14     	; 0x6cc <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 6be:	8f ef       	ldi	r24, 0xFF	; 255
 6c0:	9f ef       	ldi	r25, 0xFF	; 255
 6c2:	90 93 03 01 	sts	0x0103, r25
 6c6:	80 93 02 01 	sts	0x0102, r24
 6ca:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 6cc:	e0 91 18 07 	lds	r30, 0x0718
 6d0:	f0 91 19 07 	lds	r31, 0x0719
 6d4:	05 80       	ldd	r0, Z+5	; 0x05
 6d6:	f6 81       	ldd	r31, Z+6	; 0x06
 6d8:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 6da:	06 80       	ldd	r0, Z+6	; 0x06
 6dc:	f7 81       	ldd	r31, Z+7	; 0x07
 6de:	e0 2d       	mov	r30, r0
 6e0:	82 81       	ldd	r24, Z+2	; 0x02
 6e2:	93 81       	ldd	r25, Z+3	; 0x03
 6e4:	90 93 03 01 	sts	0x0103, r25
 6e8:	80 93 02 01 	sts	0x0102, r24
 6ec:	08 95       	ret

000006ee <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
 6ee:	cf 93       	push	r28
 6f0:	df 93       	push	r29
 6f2:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 6f4:	e0 91 50 07 	lds	r30, 0x0750
 6f8:	f0 91 51 07 	lds	r31, 0x0751
 6fc:	93 83       	std	Z+3, r25	; 0x03
 6fe:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
 700:	80 91 00 07 	lds	r24, 0x0700
 704:	90 91 01 07 	lds	r25, 0x0701
 708:	c8 17       	cp	r28, r24
 70a:	d9 07       	cpc	r29, r25
 70c:	68 f4       	brcc	.+26     	; 0x728 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 70e:	60 91 50 07 	lds	r22, 0x0750
 712:	70 91 51 07 	lds	r23, 0x0751
 716:	80 91 16 07 	lds	r24, 0x0716
 71a:	90 91 17 07 	lds	r25, 0x0717
 71e:	6e 5f       	subi	r22, 0xFE	; 254
 720:	7f 4f       	sbci	r23, 0xFF	; 255
 722:	0e 94 d6 00 	call	0x1ac	; 0x1ac <vListInsert>
 726:	17 c0       	rjmp	.+46     	; 0x756 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 728:	60 91 50 07 	lds	r22, 0x0750
 72c:	70 91 51 07 	lds	r23, 0x0751
 730:	80 91 18 07 	lds	r24, 0x0718
 734:	90 91 19 07 	lds	r25, 0x0719
 738:	6e 5f       	subi	r22, 0xFE	; 254
 73a:	7f 4f       	sbci	r23, 0xFF	; 255
 73c:	0e 94 d6 00 	call	0x1ac	; 0x1ac <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 740:	80 91 02 01 	lds	r24, 0x0102
 744:	90 91 03 01 	lds	r25, 0x0103
 748:	c8 17       	cp	r28, r24
 74a:	d9 07       	cpc	r29, r25
 74c:	20 f4       	brcc	.+8      	; 0x756 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
 74e:	d0 93 03 01 	sts	0x0103, r29
 752:	c0 93 02 01 	sts	0x0102, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 756:	df 91       	pop	r29
 758:	cf 91       	pop	r28
 75a:	08 95       	ret

0000075c <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 75c:	4f 92       	push	r4
 75e:	5f 92       	push	r5
 760:	6f 92       	push	r6
 762:	7f 92       	push	r7
 764:	8f 92       	push	r8
 766:	9f 92       	push	r9
 768:	af 92       	push	r10
 76a:	bf 92       	push	r11
 76c:	cf 92       	push	r12
 76e:	df 92       	push	r13
 770:	ef 92       	push	r14
 772:	ff 92       	push	r15
 774:	0f 93       	push	r16
 776:	1f 93       	push	r17
 778:	cf 93       	push	r28
 77a:	df 93       	push	r29
 77c:	4c 01       	movw	r8, r24
 77e:	eb 01       	movw	r28, r22
 780:	5a 01       	movw	r10, r20
 782:	29 01       	movw	r4, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 784:	c1 14       	cp	r12, r1
 786:	d1 04       	cpc	r13, r1
 788:	39 f4       	brne	.+14     	; 0x798 <xTaskGenericCreate+0x3c>
 78a:	ca 01       	movw	r24, r20
 78c:	0e 94 8b 02 	call	0x516	; 0x516 <pvPortMalloc>
 790:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
 792:	89 2b       	or	r24, r25
 794:	09 f4       	brne	.+2      	; 0x798 <xTaskGenericCreate+0x3c>
 796:	dc c0       	rjmp	.+440    	; 0x950 <__stack+0x51>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 798:	86 e2       	ldi	r24, 0x26	; 38
 79a:	90 e0       	ldi	r25, 0x00	; 0
 79c:	0e 94 8b 02 	call	0x516	; 0x516 <pvPortMalloc>
 7a0:	3c 01       	movw	r6, r24

			if( pxNewTCB != NULL )
 7a2:	00 97       	sbiw	r24, 0x00	; 0
 7a4:	79 f0       	breq	.+30     	; 0x7c4 <xTaskGenericCreate+0x68>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
 7a6:	fc 01       	movw	r30, r24
 7a8:	d0 8e       	std	Z+24, r13	; 0x18
 7aa:	c7 8a       	std	Z+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 7ac:	f1 e0       	ldi	r31, 0x01	; 1
 7ae:	af 1a       	sub	r10, r31
 7b0:	b1 08       	sbc	r11, r1
 7b2:	ca 0c       	add	r12, r10
 7b4:	db 1c       	adc	r13, r11
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 7b6:	88 81       	ld	r24, Y
 7b8:	f3 01       	movw	r30, r6
 7ba:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 7bc:	88 81       	ld	r24, Y
 7be:	81 11       	cpse	r24, r1
 7c0:	05 c0       	rjmp	.+10     	; 0x7cc <xTaskGenericCreate+0x70>
 7c2:	14 c0       	rjmp	.+40     	; 0x7ec <xTaskGenericCreate+0x90>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
 7c4:	c6 01       	movw	r24, r12
 7c6:	0e 94 25 03 	call	0x64a	; 0x64a <vPortFree>
 7ca:	c2 c0       	rjmp	.+388    	; 0x950 <__stack+0x51>
 7cc:	d3 01       	movw	r26, r6
 7ce:	5a 96       	adiw	r26, 0x1a	; 26
 7d0:	fe 01       	movw	r30, r28
 7d2:	31 96       	adiw	r30, 0x01	; 1
 7d4:	9e 01       	movw	r18, r28
 7d6:	28 5f       	subi	r18, 0xF8	; 248
 7d8:	3f 4f       	sbci	r19, 0xFF	; 255
 7da:	ef 01       	movw	r28, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 7dc:	81 91       	ld	r24, Z+
 7de:	8d 93       	st	X+, r24

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 7e0:	88 81       	ld	r24, Y
 7e2:	88 23       	and	r24, r24
 7e4:	19 f0       	breq	.+6      	; 0x7ec <xTaskGenericCreate+0x90>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 7e6:	e2 17       	cp	r30, r18
 7e8:	f3 07       	cpc	r31, r19
 7ea:	b9 f7       	brne	.-18     	; 0x7da <xTaskGenericCreate+0x7e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 7ec:	f3 01       	movw	r30, r6
 7ee:	10 a2       	std	Z+32, r1	; 0x20
 7f0:	10 2f       	mov	r17, r16
 7f2:	04 30       	cpi	r16, 0x04	; 4
 7f4:	08 f0       	brcs	.+2      	; 0x7f8 <xTaskGenericCreate+0x9c>
 7f6:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
 7f8:	f3 01       	movw	r30, r6
 7fa:	16 8b       	std	Z+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 7fc:	e3 01       	movw	r28, r6
 7fe:	22 96       	adiw	r28, 0x02	; 2
 800:	ce 01       	movw	r24, r28
 802:	0e 94 b1 00 	call	0x162	; 0x162 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 806:	c3 01       	movw	r24, r6
 808:	0c 96       	adiw	r24, 0x0c	; 12
 80a:	0e 94 b1 00 	call	0x162	; 0x162 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 80e:	f3 01       	movw	r30, r6
 810:	71 86       	std	Z+9, r7	; 0x09
 812:	60 86       	std	Z+8, r6	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 814:	84 e0       	ldi	r24, 0x04	; 4
 816:	90 e0       	ldi	r25, 0x00	; 0
 818:	81 1b       	sub	r24, r17
 81a:	91 09       	sbc	r25, r1
 81c:	95 87       	std	Z+13, r25	; 0x0d
 81e:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 820:	73 8a       	std	Z+19, r7	; 0x13
 822:	62 8a       	std	Z+18, r6	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
 824:	11 a2       	std	Z+33, r1	; 0x21
 826:	12 a2       	std	Z+34, r1	; 0x22
 828:	13 a2       	std	Z+35, r1	; 0x23
 82a:	14 a2       	std	Z+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
 82c:	15 a2       	std	Z+37, r1	; 0x25
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 82e:	a2 01       	movw	r20, r4
 830:	b4 01       	movw	r22, r8
 832:	c6 01       	movw	r24, r12
 834:	0e 94 2d 01 	call	0x25a	; 0x25a <pxPortInitialiseStack>
 838:	f3 01       	movw	r30, r6
 83a:	91 83       	std	Z+1, r25	; 0x01
 83c:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
 83e:	e1 14       	cp	r14, r1
 840:	f1 04       	cpc	r15, r1
 842:	19 f0       	breq	.+6      	; 0x84a <xTaskGenericCreate+0xee>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 844:	f7 01       	movw	r30, r14
 846:	71 82       	std	Z+1, r7	; 0x01
 848:	60 82       	st	Z, r6
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
 84a:	0f b6       	in	r0, 0x3f	; 63
 84c:	f8 94       	cli
 84e:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
 850:	80 91 02 07 	lds	r24, 0x0702
 854:	8f 5f       	subi	r24, 0xFF	; 255
 856:	80 93 02 07 	sts	0x0702, r24
			if( pxCurrentTCB == NULL )
 85a:	80 91 50 07 	lds	r24, 0x0750
 85e:	90 91 51 07 	lds	r25, 0x0751
 862:	89 2b       	or	r24, r25
 864:	a9 f5       	brne	.+106    	; 0x8d0 <xTaskGenericCreate+0x174>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 866:	70 92 51 07 	sts	0x0751, r7
 86a:	60 92 50 07 	sts	0x0750, r6

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 86e:	80 91 02 07 	lds	r24, 0x0702
 872:	81 30       	cpi	r24, 0x01	; 1
 874:	e1 f5       	brne	.+120    	; 0x8ee <xTaskGenericCreate+0x192>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 876:	8c e2       	ldi	r24, 0x2C	; 44
 878:	97 e0       	ldi	r25, 0x07	; 7
 87a:	0e 94 a3 00 	call	0x146	; 0x146 <vListInitialise>
 87e:	85 e3       	ldi	r24, 0x35	; 53
 880:	97 e0       	ldi	r25, 0x07	; 7
 882:	0e 94 a3 00 	call	0x146	; 0x146 <vListInitialise>
 886:	8e e3       	ldi	r24, 0x3E	; 62
 888:	97 e0       	ldi	r25, 0x07	; 7
 88a:	0e 94 a3 00 	call	0x146	; 0x146 <vListInitialise>
 88e:	87 e4       	ldi	r24, 0x47	; 71
 890:	97 e0       	ldi	r25, 0x07	; 7
 892:	0e 94 a3 00 	call	0x146	; 0x146 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
 896:	83 e2       	ldi	r24, 0x23	; 35
 898:	97 e0       	ldi	r25, 0x07	; 7
 89a:	0e 94 a3 00 	call	0x146	; 0x146 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 89e:	8a e1       	ldi	r24, 0x1A	; 26
 8a0:	97 e0       	ldi	r25, 0x07	; 7
 8a2:	0e 94 a3 00 	call	0x146	; 0x146 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8a6:	8d e0       	ldi	r24, 0x0D	; 13
 8a8:	97 e0       	ldi	r25, 0x07	; 7
 8aa:	0e 94 a3 00 	call	0x146	; 0x146 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 8ae:	84 e0       	ldi	r24, 0x04	; 4
 8b0:	97 e0       	ldi	r25, 0x07	; 7
 8b2:	0e 94 a3 00 	call	0x146	; 0x146 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8b6:	83 e2       	ldi	r24, 0x23	; 35
 8b8:	97 e0       	ldi	r25, 0x07	; 7
 8ba:	90 93 19 07 	sts	0x0719, r25
 8be:	80 93 18 07 	sts	0x0718, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8c2:	8a e1       	ldi	r24, 0x1A	; 26
 8c4:	97 e0       	ldi	r25, 0x07	; 7
 8c6:	90 93 17 07 	sts	0x0717, r25
 8ca:	80 93 16 07 	sts	0x0716, r24
 8ce:	0f c0       	rjmp	.+30     	; 0x8ee <xTaskGenericCreate+0x192>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 8d0:	80 91 fe 06 	lds	r24, 0x06FE
 8d4:	81 11       	cpse	r24, r1
 8d6:	0b c0       	rjmp	.+22     	; 0x8ee <xTaskGenericCreate+0x192>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 8d8:	e0 91 50 07 	lds	r30, 0x0750
 8dc:	f0 91 51 07 	lds	r31, 0x0751
 8e0:	86 89       	ldd	r24, Z+22	; 0x16
 8e2:	08 17       	cp	r16, r24
 8e4:	20 f0       	brcs	.+8      	; 0x8ee <xTaskGenericCreate+0x192>
					{
						pxCurrentTCB = pxNewTCB;
 8e6:	70 92 51 07 	sts	0x0751, r7
 8ea:	60 92 50 07 	sts	0x0750, r6
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8ee:	80 91 fa 06 	lds	r24, 0x06FA
 8f2:	8f 5f       	subi	r24, 0xFF	; 255
 8f4:	80 93 fa 06 	sts	0x06FA, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 8f8:	f3 01       	movw	r30, r6
 8fa:	86 89       	ldd	r24, Z+22	; 0x16
 8fc:	90 91 ff 06 	lds	r25, 0x06FF
 900:	98 17       	cp	r25, r24
 902:	10 f4       	brcc	.+4      	; 0x908 <__stack+0x9>
 904:	80 93 ff 06 	sts	0x06FF, r24
 908:	90 e0       	ldi	r25, 0x00	; 0
 90a:	9c 01       	movw	r18, r24
 90c:	22 0f       	add	r18, r18
 90e:	33 1f       	adc	r19, r19
 910:	22 0f       	add	r18, r18
 912:	33 1f       	adc	r19, r19
 914:	22 0f       	add	r18, r18
 916:	33 1f       	adc	r19, r19
 918:	82 0f       	add	r24, r18
 91a:	93 1f       	adc	r25, r19
 91c:	be 01       	movw	r22, r28
 91e:	84 5d       	subi	r24, 0xD4	; 212
 920:	98 4f       	sbci	r25, 0xF8	; 248
 922:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 926:	0f 90       	pop	r0
 928:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 92a:	80 91 fe 06 	lds	r24, 0x06FE
 92e:	88 23       	and	r24, r24
 930:	59 f0       	breq	.+22     	; 0x948 <__stack+0x49>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 932:	e0 91 50 07 	lds	r30, 0x0750
 936:	f0 91 51 07 	lds	r31, 0x0751
 93a:	86 89       	ldd	r24, Z+22	; 0x16
 93c:	80 17       	cp	r24, r16
 93e:	30 f4       	brcc	.+12     	; 0x94c <__stack+0x4d>
			{
				taskYIELD_IF_USING_PREEMPTION();
 940:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <vPortYield>
 944:	81 e0       	ldi	r24, 0x01	; 1
 946:	05 c0       	rjmp	.+10     	; 0x952 <__stack+0x53>
 948:	81 e0       	ldi	r24, 0x01	; 1
 94a:	03 c0       	rjmp	.+6      	; 0x952 <__stack+0x53>
 94c:	81 e0       	ldi	r24, 0x01	; 1
 94e:	01 c0       	rjmp	.+2      	; 0x952 <__stack+0x53>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 950:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
 952:	df 91       	pop	r29
 954:	cf 91       	pop	r28
 956:	1f 91       	pop	r17
 958:	0f 91       	pop	r16
 95a:	ff 90       	pop	r15
 95c:	ef 90       	pop	r14
 95e:	df 90       	pop	r13
 960:	cf 90       	pop	r12
 962:	bf 90       	pop	r11
 964:	af 90       	pop	r10
 966:	9f 90       	pop	r9
 968:	8f 90       	pop	r8
 96a:	7f 90       	pop	r7
 96c:	6f 90       	pop	r6
 96e:	5f 90       	pop	r5
 970:	4f 90       	pop	r4
 972:	08 95       	ret

00000974 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 974:	af 92       	push	r10
 976:	bf 92       	push	r11
 978:	cf 92       	push	r12
 97a:	df 92       	push	r13
 97c:	ef 92       	push	r14
 97e:	ff 92       	push	r15
 980:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 982:	a1 2c       	mov	r10, r1
 984:	b1 2c       	mov	r11, r1
 986:	c1 2c       	mov	r12, r1
 988:	d1 2c       	mov	r13, r1
 98a:	e1 2c       	mov	r14, r1
 98c:	f1 2c       	mov	r15, r1
 98e:	00 e0       	ldi	r16, 0x00	; 0
 990:	20 e0       	ldi	r18, 0x00	; 0
 992:	30 e0       	ldi	r19, 0x00	; 0
 994:	45 e5       	ldi	r20, 0x55	; 85
 996:	50 e0       	ldi	r21, 0x00	; 0
 998:	6e e0       	ldi	r22, 0x0E	; 14
 99a:	71 e0       	ldi	r23, 0x01	; 1
 99c:	86 e7       	ldi	r24, 0x76	; 118
 99e:	96 e0       	ldi	r25, 0x06	; 6
 9a0:	0e 94 ae 03 	call	0x75c	; 0x75c <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 9a4:	81 30       	cpi	r24, 0x01	; 1
 9a6:	49 f4       	brne	.+18     	; 0x9ba <vTaskStartScheduler+0x46>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 9a8:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
 9aa:	80 93 fe 06 	sts	0x06FE, r24
		xTickCount = ( TickType_t ) 0U;
 9ae:	10 92 01 07 	sts	0x0701, r1
 9b2:	10 92 00 07 	sts	0x0700, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 9b6:	0e 94 99 01 	call	0x332	; 0x332 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 9ba:	0f 91       	pop	r16
 9bc:	ff 90       	pop	r15
 9be:	ef 90       	pop	r14
 9c0:	df 90       	pop	r13
 9c2:	cf 90       	pop	r12
 9c4:	bf 90       	pop	r11
 9c6:	af 90       	pop	r10
 9c8:	08 95       	ret

000009ca <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 9ca:	80 91 f9 06 	lds	r24, 0x06F9
 9ce:	8f 5f       	subi	r24, 0xFF	; 255
 9d0:	80 93 f9 06 	sts	0x06F9, r24
 9d4:	08 95       	ret

000009d6 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
 9d6:	0f b6       	in	r0, 0x3f	; 63
 9d8:	f8 94       	cli
 9da:	0f 92       	push	r0
	{
		xTicks = xTickCount;
 9dc:	80 91 00 07 	lds	r24, 0x0700
 9e0:	90 91 01 07 	lds	r25, 0x0701
	}
	portTICK_TYPE_EXIT_CRITICAL();
 9e4:	0f 90       	pop	r0
 9e6:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
 9e8:	08 95       	ret

000009ea <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 9ea:	cf 92       	push	r12
 9ec:	df 92       	push	r13
 9ee:	ef 92       	push	r14
 9f0:	ff 92       	push	r15
 9f2:	0f 93       	push	r16
 9f4:	1f 93       	push	r17
 9f6:	cf 93       	push	r28
 9f8:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 9fa:	80 91 f9 06 	lds	r24, 0x06F9
 9fe:	81 11       	cpse	r24, r1
 a00:	9b c0       	rjmp	.+310    	; 0xb38 <xTaskIncrementTick+0x14e>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 a02:	80 91 00 07 	lds	r24, 0x0700
 a06:	90 91 01 07 	lds	r25, 0x0701
 a0a:	01 96       	adiw	r24, 0x01	; 1
 a0c:	90 93 01 07 	sts	0x0701, r25
 a10:	80 93 00 07 	sts	0x0700, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 a14:	e0 90 00 07 	lds	r14, 0x0700
 a18:	f0 90 01 07 	lds	r15, 0x0701

			if( xConstTickCount == ( TickType_t ) 0U )
 a1c:	e1 14       	cp	r14, r1
 a1e:	f1 04       	cpc	r15, r1
 a20:	b9 f4       	brne	.+46     	; 0xa50 <xTaskIncrementTick+0x66>
			{
				taskSWITCH_DELAYED_LISTS();
 a22:	80 91 18 07 	lds	r24, 0x0718
 a26:	90 91 19 07 	lds	r25, 0x0719
 a2a:	20 91 16 07 	lds	r18, 0x0716
 a2e:	30 91 17 07 	lds	r19, 0x0717
 a32:	30 93 19 07 	sts	0x0719, r19
 a36:	20 93 18 07 	sts	0x0718, r18
 a3a:	90 93 17 07 	sts	0x0717, r25
 a3e:	80 93 16 07 	sts	0x0716, r24
 a42:	80 91 fb 06 	lds	r24, 0x06FB
 a46:	8f 5f       	subi	r24, 0xFF	; 255
 a48:	80 93 fb 06 	sts	0x06FB, r24
 a4c:	0e 94 58 03 	call	0x6b0	; 0x6b0 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 a50:	80 91 02 01 	lds	r24, 0x0102
 a54:	90 91 03 01 	lds	r25, 0x0103
 a58:	e8 16       	cp	r14, r24
 a5a:	f9 06       	cpc	r15, r25
 a5c:	10 f4       	brcc	.+4      	; 0xa62 <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 a5e:	d1 2c       	mov	r13, r1
 a60:	53 c0       	rjmp	.+166    	; 0xb08 <xTaskIncrementTick+0x11e>
 a62:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
 a64:	cc 24       	eor	r12, r12
 a66:	c3 94       	inc	r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 a68:	e0 91 18 07 	lds	r30, 0x0718
 a6c:	f0 91 19 07 	lds	r31, 0x0719
 a70:	90 81       	ld	r25, Z
 a72:	91 11       	cpse	r25, r1
 a74:	07 c0       	rjmp	.+14     	; 0xa84 <xTaskIncrementTick+0x9a>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 a76:	8f ef       	ldi	r24, 0xFF	; 255
 a78:	9f ef       	ldi	r25, 0xFF	; 255
 a7a:	90 93 03 01 	sts	0x0103, r25
 a7e:	80 93 02 01 	sts	0x0102, r24
						break;
 a82:	42 c0       	rjmp	.+132    	; 0xb08 <xTaskIncrementTick+0x11e>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 a84:	e0 91 18 07 	lds	r30, 0x0718
 a88:	f0 91 19 07 	lds	r31, 0x0719
 a8c:	05 80       	ldd	r0, Z+5	; 0x05
 a8e:	f6 81       	ldd	r31, Z+6	; 0x06
 a90:	e0 2d       	mov	r30, r0
 a92:	c6 81       	ldd	r28, Z+6	; 0x06
 a94:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 a96:	2a 81       	ldd	r18, Y+2	; 0x02
 a98:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
 a9a:	e2 16       	cp	r14, r18
 a9c:	f3 06       	cpc	r15, r19
 a9e:	28 f4       	brcc	.+10     	; 0xaaa <xTaskIncrementTick+0xc0>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
 aa0:	30 93 03 01 	sts	0x0103, r19
 aa4:	20 93 02 01 	sts	0x0102, r18
							break;
 aa8:	2f c0       	rjmp	.+94     	; 0xb08 <xTaskIncrementTick+0x11e>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 aaa:	8e 01       	movw	r16, r28
 aac:	0e 5f       	subi	r16, 0xFE	; 254
 aae:	1f 4f       	sbci	r17, 0xFF	; 255
 ab0:	c8 01       	movw	r24, r16
 ab2:	0e 94 07 01 	call	0x20e	; 0x20e <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 ab6:	8c 89       	ldd	r24, Y+20	; 0x14
 ab8:	9d 89       	ldd	r25, Y+21	; 0x15
 aba:	89 2b       	or	r24, r25
 abc:	21 f0       	breq	.+8      	; 0xac6 <xTaskIncrementTick+0xdc>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 abe:	ce 01       	movw	r24, r28
 ac0:	0c 96       	adiw	r24, 0x0c	; 12
 ac2:	0e 94 07 01 	call	0x20e	; 0x20e <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 ac6:	2e 89       	ldd	r18, Y+22	; 0x16
 ac8:	80 91 ff 06 	lds	r24, 0x06FF
 acc:	82 17       	cp	r24, r18
 ace:	10 f4       	brcc	.+4      	; 0xad4 <xTaskIncrementTick+0xea>
 ad0:	20 93 ff 06 	sts	0x06FF, r18
 ad4:	30 e0       	ldi	r19, 0x00	; 0
 ad6:	c9 01       	movw	r24, r18
 ad8:	88 0f       	add	r24, r24
 ada:	99 1f       	adc	r25, r25
 adc:	88 0f       	add	r24, r24
 ade:	99 1f       	adc	r25, r25
 ae0:	88 0f       	add	r24, r24
 ae2:	99 1f       	adc	r25, r25
 ae4:	82 0f       	add	r24, r18
 ae6:	93 1f       	adc	r25, r19
 ae8:	b8 01       	movw	r22, r16
 aea:	84 5d       	subi	r24, 0xD4	; 212
 aec:	98 4f       	sbci	r25, 0xF8	; 248
 aee:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 af2:	e0 91 50 07 	lds	r30, 0x0750
 af6:	f0 91 51 07 	lds	r31, 0x0751
 afa:	9e 89       	ldd	r25, Y+22	; 0x16
 afc:	86 89       	ldd	r24, Z+22	; 0x16
 afe:	98 17       	cp	r25, r24
 b00:	08 f4       	brcc	.+2      	; 0xb04 <xTaskIncrementTick+0x11a>
 b02:	b2 cf       	rjmp	.-156    	; 0xa68 <xTaskIncrementTick+0x7e>
							{
								xSwitchRequired = pdTRUE;
 b04:	dc 2c       	mov	r13, r12
 b06:	b0 cf       	rjmp	.-160    	; 0xa68 <xTaskIncrementTick+0x7e>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 b08:	e0 91 50 07 	lds	r30, 0x0750
 b0c:	f0 91 51 07 	lds	r31, 0x0751
 b10:	86 89       	ldd	r24, Z+22	; 0x16
 b12:	90 e0       	ldi	r25, 0x00	; 0
 b14:	fc 01       	movw	r30, r24
 b16:	ee 0f       	add	r30, r30
 b18:	ff 1f       	adc	r31, r31
 b1a:	ee 0f       	add	r30, r30
 b1c:	ff 1f       	adc	r31, r31
 b1e:	ee 0f       	add	r30, r30
 b20:	ff 1f       	adc	r31, r31
 b22:	8e 0f       	add	r24, r30
 b24:	9f 1f       	adc	r25, r31
 b26:	fc 01       	movw	r30, r24
 b28:	e4 5d       	subi	r30, 0xD4	; 212
 b2a:	f8 4f       	sbci	r31, 0xF8	; 248
 b2c:	80 81       	ld	r24, Z
 b2e:	82 30       	cpi	r24, 0x02	; 2
 b30:	48 f0       	brcs	.+18     	; 0xb44 <xTaskIncrementTick+0x15a>
			{
				xSwitchRequired = pdTRUE;
 b32:	dd 24       	eor	r13, r13
 b34:	d3 94       	inc	r13
 b36:	06 c0       	rjmp	.+12     	; 0xb44 <xTaskIncrementTick+0x15a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 b38:	80 91 fd 06 	lds	r24, 0x06FD
 b3c:	8f 5f       	subi	r24, 0xFF	; 255
 b3e:	80 93 fd 06 	sts	0x06FD, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 b42:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 b44:	80 91 fc 06 	lds	r24, 0x06FC
 b48:	88 23       	and	r24, r24
 b4a:	11 f0       	breq	.+4      	; 0xb50 <xTaskIncrementTick+0x166>
		{
			xSwitchRequired = pdTRUE;
 b4c:	dd 24       	eor	r13, r13
 b4e:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 b50:	8d 2d       	mov	r24, r13
 b52:	df 91       	pop	r29
 b54:	cf 91       	pop	r28
 b56:	1f 91       	pop	r17
 b58:	0f 91       	pop	r16
 b5a:	ff 90       	pop	r15
 b5c:	ef 90       	pop	r14
 b5e:	df 90       	pop	r13
 b60:	cf 90       	pop	r12
 b62:	08 95       	ret

00000b64 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 b64:	df 92       	push	r13
 b66:	ef 92       	push	r14
 b68:	ff 92       	push	r15
 b6a:	0f 93       	push	r16
 b6c:	1f 93       	push	r17
 b6e:	cf 93       	push	r28
 b70:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 b72:	0f b6       	in	r0, 0x3f	; 63
 b74:	f8 94       	cli
 b76:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
 b78:	80 91 f9 06 	lds	r24, 0x06F9
 b7c:	81 50       	subi	r24, 0x01	; 1
 b7e:	80 93 f9 06 	sts	0x06F9, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 b82:	80 91 f9 06 	lds	r24, 0x06F9
 b86:	81 11       	cpse	r24, r1
 b88:	62 c0       	rjmp	.+196    	; 0xc4e <xTaskResumeAll+0xea>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 b8a:	80 91 02 07 	lds	r24, 0x0702
 b8e:	81 11       	cpse	r24, r1
 b90:	33 c0       	rjmp	.+102    	; 0xbf8 <xTaskResumeAll+0x94>
 b92:	60 c0       	rjmp	.+192    	; 0xc54 <xTaskResumeAll+0xf0>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 b94:	d7 01       	movw	r26, r14
 b96:	15 96       	adiw	r26, 0x05	; 5
 b98:	ed 91       	ld	r30, X+
 b9a:	fc 91       	ld	r31, X
 b9c:	16 97       	sbiw	r26, 0x06	; 6
 b9e:	c6 81       	ldd	r28, Z+6	; 0x06
 ba0:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 ba2:	ce 01       	movw	r24, r28
 ba4:	0c 96       	adiw	r24, 0x0c	; 12
 ba6:	0e 94 07 01 	call	0x20e	; 0x20e <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 baa:	8e 01       	movw	r16, r28
 bac:	0e 5f       	subi	r16, 0xFE	; 254
 bae:	1f 4f       	sbci	r17, 0xFF	; 255
 bb0:	c8 01       	movw	r24, r16
 bb2:	0e 94 07 01 	call	0x20e	; 0x20e <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 bb6:	2e 89       	ldd	r18, Y+22	; 0x16
 bb8:	80 91 ff 06 	lds	r24, 0x06FF
 bbc:	82 17       	cp	r24, r18
 bbe:	10 f4       	brcc	.+4      	; 0xbc4 <xTaskResumeAll+0x60>
 bc0:	20 93 ff 06 	sts	0x06FF, r18
 bc4:	30 e0       	ldi	r19, 0x00	; 0
 bc6:	c9 01       	movw	r24, r18
 bc8:	88 0f       	add	r24, r24
 bca:	99 1f       	adc	r25, r25
 bcc:	88 0f       	add	r24, r24
 bce:	99 1f       	adc	r25, r25
 bd0:	88 0f       	add	r24, r24
 bd2:	99 1f       	adc	r25, r25
 bd4:	82 0f       	add	r24, r18
 bd6:	93 1f       	adc	r25, r19
 bd8:	b8 01       	movw	r22, r16
 bda:	84 5d       	subi	r24, 0xD4	; 212
 bdc:	98 4f       	sbci	r25, 0xF8	; 248
 bde:	0e 94 b5 00 	call	0x16a	; 0x16a <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 be2:	e0 91 50 07 	lds	r30, 0x0750
 be6:	f0 91 51 07 	lds	r31, 0x0751
 bea:	9e 89       	ldd	r25, Y+22	; 0x16
 bec:	86 89       	ldd	r24, Z+22	; 0x16
 bee:	98 17       	cp	r25, r24
 bf0:	58 f0       	brcs	.+22     	; 0xc08 <xTaskResumeAll+0xa4>
					{
						xYieldPending = pdTRUE;
 bf2:	d0 92 fc 06 	sts	0x06FC, r13
 bf6:	08 c0       	rjmp	.+16     	; 0xc08 <xTaskResumeAll+0xa4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 bf8:	0f 2e       	mov	r0, r31
 bfa:	fd e0       	ldi	r31, 0x0D	; 13
 bfc:	ef 2e       	mov	r14, r31
 bfe:	f7 e0       	ldi	r31, 0x07	; 7
 c00:	ff 2e       	mov	r15, r31
 c02:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
 c04:	dd 24       	eor	r13, r13
 c06:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 c08:	f7 01       	movw	r30, r14
 c0a:	80 81       	ld	r24, Z
 c0c:	81 11       	cpse	r24, r1
 c0e:	c2 cf       	rjmp	.-124    	; 0xb94 <xTaskResumeAll+0x30>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
 c10:	80 91 fd 06 	lds	r24, 0x06FD
 c14:	88 23       	and	r24, r24
 c16:	99 f0       	breq	.+38     	; 0xc3e <xTaskResumeAll+0xda>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 c18:	80 91 fd 06 	lds	r24, 0x06FD
 c1c:	88 23       	and	r24, r24
 c1e:	79 f0       	breq	.+30     	; 0xc3e <xTaskResumeAll+0xda>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
 c20:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
 c22:	0e 94 f5 04 	call	0x9ea	; 0x9ea <xTaskIncrementTick>
 c26:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
 c28:	c0 93 fc 06 	sts	0x06FC, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
 c2c:	80 91 fd 06 	lds	r24, 0x06FD
 c30:	81 50       	subi	r24, 0x01	; 1
 c32:	80 93 fd 06 	sts	0x06FD, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 c36:	80 91 fd 06 	lds	r24, 0x06FD
 c3a:	81 11       	cpse	r24, r1
 c3c:	f2 cf       	rjmp	.-28     	; 0xc22 <xTaskResumeAll+0xbe>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
 c3e:	80 91 fc 06 	lds	r24, 0x06FC
 c42:	81 30       	cpi	r24, 0x01	; 1
 c44:	31 f4       	brne	.+12     	; 0xc52 <xTaskResumeAll+0xee>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 c46:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 c4a:	81 e0       	ldi	r24, 0x01	; 1
 c4c:	03 c0       	rjmp	.+6      	; 0xc54 <xTaskResumeAll+0xf0>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
 c4e:	80 e0       	ldi	r24, 0x00	; 0
 c50:	01 c0       	rjmp	.+2      	; 0xc54 <xTaskResumeAll+0xf0>
 c52:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 c54:	0f 90       	pop	r0
 c56:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
 c58:	df 91       	pop	r29
 c5a:	cf 91       	pop	r28
 c5c:	1f 91       	pop	r17
 c5e:	0f 91       	pop	r16
 c60:	ff 90       	pop	r15
 c62:	ef 90       	pop	r14
 c64:	df 90       	pop	r13
 c66:	08 95       	ret

00000c68 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
 c68:	0f 93       	push	r16
 c6a:	1f 93       	push	r17
 c6c:	cf 93       	push	r28
 c6e:	df 93       	push	r29
 c70:	8c 01       	movw	r16, r24
 c72:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
 c74:	0e 94 e5 04 	call	0x9ca	; 0x9ca <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 c78:	80 91 00 07 	lds	r24, 0x0700
 c7c:	90 91 01 07 	lds	r25, 0x0701

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 c80:	f8 01       	movw	r30, r16
 c82:	20 81       	ld	r18, Z
 c84:	31 81       	ldd	r19, Z+1	; 0x01
 c86:	c2 0f       	add	r28, r18
 c88:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
 c8a:	82 17       	cp	r24, r18
 c8c:	93 07       	cpc	r25, r19
 c8e:	48 f4       	brcc	.+18     	; 0xca2 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 c90:	c2 17       	cp	r28, r18
 c92:	d3 07       	cpc	r29, r19
 c94:	10 f5       	brcc	.+68     	; 0xcda <vTaskDelayUntil+0x72>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 c96:	d1 83       	std	Z+1, r29	; 0x01
 c98:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
 c9a:	8c 17       	cp	r24, r28
 c9c:	9d 07       	cpc	r25, r29
 c9e:	90 f4       	brcc	.+36     	; 0xcc4 <vTaskDelayUntil+0x5c>
 ca0:	07 c0       	rjmp	.+14     	; 0xcb0 <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 ca2:	c2 17       	cp	r28, r18
 ca4:	d3 07       	cpc	r29, r19
 ca6:	a8 f0       	brcs	.+42     	; 0xcd2 <vTaskDelayUntil+0x6a>
 ca8:	8c 17       	cp	r24, r28
 caa:	9d 07       	cpc	r25, r29
 cac:	90 f0       	brcs	.+36     	; 0xcd2 <vTaskDelayUntil+0x6a>
 cae:	15 c0       	rjmp	.+42     	; 0xcda <vTaskDelayUntil+0x72>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 cb0:	80 91 50 07 	lds	r24, 0x0750
 cb4:	90 91 51 07 	lds	r25, 0x0751
 cb8:	02 96       	adiw	r24, 0x02	; 2
 cba:	0e 94 07 01 	call	0x20e	; 0x20e <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
 cbe:	ce 01       	movw	r24, r28
 cc0:	0e 94 77 03 	call	0x6ee	; 0x6ee <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 cc4:	0e 94 b2 05 	call	0xb64	; 0xb64 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 cc8:	81 11       	cpse	r24, r1
 cca:	0b c0       	rjmp	.+22     	; 0xce2 <vTaskDelayUntil+0x7a>
		{
			portYIELD_WITHIN_API();
 ccc:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <vPortYield>
 cd0:	08 c0       	rjmp	.+16     	; 0xce2 <vTaskDelayUntil+0x7a>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 cd2:	f8 01       	movw	r30, r16
 cd4:	d1 83       	std	Z+1, r29	; 0x01
 cd6:	c0 83       	st	Z, r28
 cd8:	eb cf       	rjmp	.-42     	; 0xcb0 <vTaskDelayUntil+0x48>
 cda:	f8 01       	movw	r30, r16
 cdc:	d1 83       	std	Z+1, r29	; 0x01
 cde:	c0 83       	st	Z, r28
 ce0:	f1 cf       	rjmp	.-30     	; 0xcc4 <vTaskDelayUntil+0x5c>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 ce2:	df 91       	pop	r29
 ce4:	cf 91       	pop	r28
 ce6:	1f 91       	pop	r17
 ce8:	0f 91       	pop	r16
 cea:	08 95       	ret

00000cec <prvIdleTask>:
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 cec:	04 e0       	ldi	r16, 0x04	; 4
 cee:	17 e0       	ldi	r17, 0x07	; 7

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 cf0:	0f 2e       	mov	r0, r31
 cf2:	fc e2       	ldi	r31, 0x2C	; 44
 cf4:	ef 2e       	mov	r14, r31
 cf6:	f7 e0       	ldi	r31, 0x07	; 7
 cf8:	ff 2e       	mov	r15, r31
 cfa:	f0 2d       	mov	r31, r0
 cfc:	29 c0       	rjmp	.+82     	; 0xd50 <prvIdleTask+0x64>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
 cfe:	0e 94 e5 04 	call	0x9ca	; 0x9ca <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 d02:	d8 01       	movw	r26, r16
 d04:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
 d06:	0e 94 b2 05 	call	0xb64	; 0xb64 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 d0a:	cc 23       	and	r28, r28
 d0c:	09 f1       	breq	.+66     	; 0xd50 <prvIdleTask+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 d0e:	0f b6       	in	r0, 0x3f	; 63
 d10:	f8 94       	cli
 d12:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 d14:	d8 01       	movw	r26, r16
 d16:	15 96       	adiw	r26, 0x05	; 5
 d18:	ed 91       	ld	r30, X+
 d1a:	fc 91       	ld	r31, X
 d1c:	16 97       	sbiw	r26, 0x06	; 6
 d1e:	c6 81       	ldd	r28, Z+6	; 0x06
 d20:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 d22:	ce 01       	movw	r24, r28
 d24:	02 96       	adiw	r24, 0x02	; 2
 d26:	0e 94 07 01 	call	0x20e	; 0x20e <uxListRemove>
					--uxCurrentNumberOfTasks;
 d2a:	80 91 02 07 	lds	r24, 0x0702
 d2e:	81 50       	subi	r24, 0x01	; 1
 d30:	80 93 02 07 	sts	0x0702, r24
					--uxTasksDeleted;
 d34:	80 91 03 07 	lds	r24, 0x0703
 d38:	81 50       	subi	r24, 0x01	; 1
 d3a:	80 93 03 07 	sts	0x0703, r24
				}
				taskEXIT_CRITICAL();
 d3e:	0f 90       	pop	r0
 d40:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
 d42:	8f 89       	ldd	r24, Y+23	; 0x17
 d44:	98 8d       	ldd	r25, Y+24	; 0x18
 d46:	0e 94 25 03 	call	0x64a	; 0x64a <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
 d4a:	ce 01       	movw	r24, r28
 d4c:	0e 94 25 03 	call	0x64a	; 0x64a <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 d50:	80 91 03 07 	lds	r24, 0x0703
 d54:	81 11       	cpse	r24, r1
 d56:	d3 cf       	rjmp	.-90     	; 0xcfe <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 d58:	f7 01       	movw	r30, r14
 d5a:	80 81       	ld	r24, Z
 d5c:	82 30       	cpi	r24, 0x02	; 2
 d5e:	c0 f3       	brcs	.-16     	; 0xd50 <prvIdleTask+0x64>
			{
				taskYIELD();
 d60:	0e 94 d3 01 	call	0x3a6	; 0x3a6 <vPortYield>
 d64:	f5 cf       	rjmp	.-22     	; 0xd50 <prvIdleTask+0x64>

00000d66 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 d66:	80 91 f9 06 	lds	r24, 0x06F9
 d6a:	88 23       	and	r24, r24
 d6c:	21 f0       	breq	.+8      	; 0xd76 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 d6e:	81 e0       	ldi	r24, 0x01	; 1
 d70:	80 93 fc 06 	sts	0x06FC, r24
 d74:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 d76:	10 92 fc 06 	sts	0x06FC, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 d7a:	80 91 ff 06 	lds	r24, 0x06FF
 d7e:	90 e0       	ldi	r25, 0x00	; 0
 d80:	fc 01       	movw	r30, r24
 d82:	ee 0f       	add	r30, r30
 d84:	ff 1f       	adc	r31, r31
 d86:	ee 0f       	add	r30, r30
 d88:	ff 1f       	adc	r31, r31
 d8a:	ee 0f       	add	r30, r30
 d8c:	ff 1f       	adc	r31, r31
 d8e:	8e 0f       	add	r24, r30
 d90:	9f 1f       	adc	r25, r31
 d92:	fc 01       	movw	r30, r24
 d94:	e4 5d       	subi	r30, 0xD4	; 212
 d96:	f8 4f       	sbci	r31, 0xF8	; 248
 d98:	80 81       	ld	r24, Z
 d9a:	81 11       	cpse	r24, r1
 d9c:	17 c0       	rjmp	.+46     	; 0xdcc <vTaskSwitchContext+0x66>
 d9e:	80 91 ff 06 	lds	r24, 0x06FF
 da2:	81 50       	subi	r24, 0x01	; 1
 da4:	80 93 ff 06 	sts	0x06FF, r24
 da8:	80 91 ff 06 	lds	r24, 0x06FF
 dac:	90 e0       	ldi	r25, 0x00	; 0
 dae:	fc 01       	movw	r30, r24
 db0:	ee 0f       	add	r30, r30
 db2:	ff 1f       	adc	r31, r31
 db4:	ee 0f       	add	r30, r30
 db6:	ff 1f       	adc	r31, r31
 db8:	ee 0f       	add	r30, r30
 dba:	ff 1f       	adc	r31, r31
 dbc:	8e 0f       	add	r24, r30
 dbe:	9f 1f       	adc	r25, r31
 dc0:	fc 01       	movw	r30, r24
 dc2:	e4 5d       	subi	r30, 0xD4	; 212
 dc4:	f8 4f       	sbci	r31, 0xF8	; 248
 dc6:	80 81       	ld	r24, Z
 dc8:	88 23       	and	r24, r24
 dca:	49 f3       	breq	.-46     	; 0xd9e <vTaskSwitchContext+0x38>
 dcc:	80 91 ff 06 	lds	r24, 0x06FF
 dd0:	90 e0       	ldi	r25, 0x00	; 0
 dd2:	9c 01       	movw	r18, r24
 dd4:	22 0f       	add	r18, r18
 dd6:	33 1f       	adc	r19, r19
 dd8:	22 0f       	add	r18, r18
 dda:	33 1f       	adc	r19, r19
 ddc:	22 0f       	add	r18, r18
 dde:	33 1f       	adc	r19, r19
 de0:	28 0f       	add	r18, r24
 de2:	39 1f       	adc	r19, r25
 de4:	d9 01       	movw	r26, r18
 de6:	a4 5d       	subi	r26, 0xD4	; 212
 de8:	b8 4f       	sbci	r27, 0xF8	; 248
 dea:	11 96       	adiw	r26, 0x01	; 1
 dec:	ed 91       	ld	r30, X+
 dee:	fc 91       	ld	r31, X
 df0:	12 97       	sbiw	r26, 0x02	; 2
 df2:	02 80       	ldd	r0, Z+2	; 0x02
 df4:	f3 81       	ldd	r31, Z+3	; 0x03
 df6:	e0 2d       	mov	r30, r0
 df8:	12 96       	adiw	r26, 0x02	; 2
 dfa:	fc 93       	st	X, r31
 dfc:	ee 93       	st	-X, r30
 dfe:	11 97       	sbiw	r26, 0x01	; 1
 e00:	21 5d       	subi	r18, 0xD1	; 209
 e02:	38 4f       	sbci	r19, 0xF8	; 248
 e04:	e2 17       	cp	r30, r18
 e06:	f3 07       	cpc	r31, r19
 e08:	29 f4       	brne	.+10     	; 0xe14 <vTaskSwitchContext+0xae>
 e0a:	22 81       	ldd	r18, Z+2	; 0x02
 e0c:	33 81       	ldd	r19, Z+3	; 0x03
 e0e:	fd 01       	movw	r30, r26
 e10:	32 83       	std	Z+2, r19	; 0x02
 e12:	21 83       	std	Z+1, r18	; 0x01
 e14:	fc 01       	movw	r30, r24
 e16:	ee 0f       	add	r30, r30
 e18:	ff 1f       	adc	r31, r31
 e1a:	ee 0f       	add	r30, r30
 e1c:	ff 1f       	adc	r31, r31
 e1e:	ee 0f       	add	r30, r30
 e20:	ff 1f       	adc	r31, r31
 e22:	8e 0f       	add	r24, r30
 e24:	9f 1f       	adc	r25, r31
 e26:	fc 01       	movw	r30, r24
 e28:	e4 5d       	subi	r30, 0xD4	; 212
 e2a:	f8 4f       	sbci	r31, 0xF8	; 248
 e2c:	01 80       	ldd	r0, Z+1	; 0x01
 e2e:	f2 81       	ldd	r31, Z+2	; 0x02
 e30:	e0 2d       	mov	r30, r0
 e32:	86 81       	ldd	r24, Z+6	; 0x06
 e34:	97 81       	ldd	r25, Z+7	; 0x07
 e36:	90 93 51 07 	sts	0x0751, r25
 e3a:	80 93 50 07 	sts	0x0750, r24
 e3e:	08 95       	ret

00000e40 <_exit>:
 e40:	f8 94       	cli

00000e42 <__stop_program>:
 e42:	ff cf       	rjmp	.-2      	; 0xe42 <__stop_program>

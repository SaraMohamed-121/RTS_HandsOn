
ArduinoUnoFreertos.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000a4  00800100  00000eae  00000f42  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000eae  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000649  008001a4  008001a4  00000fe6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000fe6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001018  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000260  00000000  00000000  00001058  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002f84  00000000  00000000  000012b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000f40  00000000  00000000  0000423c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000019e2  00000000  00000000  0000517c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006d8  00000000  00000000  00006b60  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001121  00000000  00000000  00007238  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002597  00000000  00000000  00008359  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000278  00000000  00000000  0000a8f0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 95 02 	jmp	0x52a	; 0x52a <__vector_11>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 2f 02 	jmp	0x45e	; 0x45e <__vector_16>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ee ea       	ldi	r30, 0xAE	; 174
  7c:	fe e0       	ldi	r31, 0x0E	; 14
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a4 3a       	cpi	r26, 0xA4	; 164
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	27 e0       	ldi	r18, 0x07	; 7
  8c:	a4 ea       	ldi	r26, 0xA4	; 164
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	ad 3e       	cpi	r26, 0xED	; 237
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 70 00 	call	0xe0	; 0xe0 <main>
  9e:	0c 94 55 07 	jmp	0xeaa	; 0xeaa <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vReceiverTask>:
		else
		{
			/* We did not receive anything from the queue even after waiting for 100ms.
			This must be an error as the sending tasks are free running and will be
			continuously writing to the queue. */
			USART_sendstr("Could not receive from the queue.\r\n" );
  a6:	80 e1       	ldi	r24, 0x10	; 16
  a8:	91 e0       	ldi	r25, 0x01	; 1
  aa:	0e 94 46 07 	call	0xe8c	; 0xe8c <USART_sendstr>
  ae:	fb cf       	rjmp	.-10     	; 0xa6 <vReceiverTask>

000000b0 <vSenderTask>:
	return 0;
}
/*-----------------------------------------------------------*/

static void vSenderTask( void *pvParameters )
{
  b0:	cf 93       	push	r28
  b2:	df 93       	push	r29
  b4:	00 d0       	rcall	.+0      	; 0xb6 <vSenderTask+0x6>
  b6:	cd b7       	in	r28, 0x3d	; 61
  b8:	de b7       	in	r29, 0x3e	; 62
	each instance can use a different value.  Cast the parameter to the required
	type. */
	lValueToSend =(char *)pvParameters;

	/* As per most tasks, this task is implemented within an infinite loop. */
		USART_sendstr("sender");
  ba:	84 e3       	ldi	r24, 0x34	; 52
  bc:	91 e0       	ldi	r25, 0x01	; 1
  be:	0e 94 46 07 	call	0xe8c	; 0xe8c <USART_sendstr>
		TickType_t xLastWakeTime = xTaskGetTickCount();
  c2:	0e 94 fd 04 	call	0x9fa	; 0x9fa <xTaskGetTickCount>
  c6:	9a 83       	std	Y+2, r25	; 0x02
  c8:	89 83       	std	Y+1, r24	; 0x01
		*/
		if( xStatus != pdPASS )
		{
			/* We could not write to the queue because it was full – this must
			be an error as the queue should never contain more than one item! */
			USART_sendstr("Could not send to the queue.");
  ca:	8b e3       	ldi	r24, 0x3B	; 59
  cc:	91 e0       	ldi	r25, 0x01	; 1
  ce:	0e 94 46 07 	call	0xe8c	; 0xe8c <USART_sendstr>
		}
			vTaskDelayUntil(&xLastWakeTime, (10 / portTICK_PERIOD_MS));
  d2:	6a e0       	ldi	r22, 0x0A	; 10
  d4:	70 e0       	ldi	r23, 0x00	; 0
  d6:	ce 01       	movw	r24, r28
  d8:	01 96       	adiw	r24, 0x01	; 1
  da:	0e 94 46 06 	call	0xc8c	; 0xc8c <vTaskDelayUntil>
	}
  de:	f5 cf       	rjmp	.-22     	; 0xca <vSenderTask+0x1a>

000000e0 <main>:
QueueHandle_t xQueue;


int main( void )
{
	USART_init();
  e0:	0e 94 32 07 	call	0xe64	; 0xe64 <USART_init>
	
    /* The queue is created to hold a maximum of 5 long values. 
    Create A Suitable Queue
     */
	
	if( xQueue != NULL ) // Queue Handler
  e4:	80 91 eb 07 	lds	r24, 0x07EB	; 0x8007eb <xQueue>
  e8:	90 91 ec 07 	lds	r25, 0x07EC	; 0x8007ec <xQueue+0x1>
  ec:	89 2b       	or	r24, r25
  ee:	49 f1       	breq	.+82     	; 0x142 <main+0x62>
		/* Create two instances of the task that will write to the queue.  The
		parameter is used to pass the value that the task should write to the queue,
		so one task will continuously write 100 to the queue while the other task
		will continuously write 200 to the queue.  Both tasks are created at
		priority 1. */
		xTaskCreate( vSenderTask, "Sender1", 256, "Task 1", 1, NULL );
  f0:	a1 2c       	mov	r10, r1
  f2:	b1 2c       	mov	r11, r1
  f4:	c1 2c       	mov	r12, r1
  f6:	d1 2c       	mov	r13, r1
  f8:	e1 2c       	mov	r14, r1
  fa:	f1 2c       	mov	r15, r1
  fc:	01 e0       	ldi	r16, 0x01	; 1
  fe:	28 e5       	ldi	r18, 0x58	; 88
 100:	31 e0       	ldi	r19, 0x01	; 1
 102:	40 e0       	ldi	r20, 0x00	; 0
 104:	51 e0       	ldi	r21, 0x01	; 1
 106:	6f e5       	ldi	r22, 0x5F	; 95
 108:	71 e0       	ldi	r23, 0x01	; 1
 10a:	88 e5       	ldi	r24, 0x58	; 88
 10c:	90 e0       	ldi	r25, 0x00	; 0
 10e:	0e 94 bb 03 	call	0x776	; 0x776 <xTaskGenericCreate>
		xTaskCreate( vSenderTask, "Sender2", 256, "Task 2", 1, NULL );
 112:	27 e6       	ldi	r18, 0x67	; 103
 114:	31 e0       	ldi	r19, 0x01	; 1
 116:	40 e0       	ldi	r20, 0x00	; 0
 118:	51 e0       	ldi	r21, 0x01	; 1
 11a:	6e e6       	ldi	r22, 0x6E	; 110
 11c:	71 e0       	ldi	r23, 0x01	; 1
 11e:	88 e5       	ldi	r24, 0x58	; 88
 120:	90 e0       	ldi	r25, 0x00	; 0
 122:	0e 94 bb 03 	call	0x776	; 0x776 <xTaskGenericCreate>

		/* Create the task that will read from the queue.  The task is created with
		priority 2, so above the priority of the sender tasks. */
		xTaskCreate( vReceiverTask, "Receiver", 256, NULL, 2, NULL );
 126:	02 e0       	ldi	r16, 0x02	; 2
 128:	20 e0       	ldi	r18, 0x00	; 0
 12a:	30 e0       	ldi	r19, 0x00	; 0
 12c:	40 e0       	ldi	r20, 0x00	; 0
 12e:	51 e0       	ldi	r21, 0x01	; 1
 130:	66 e7       	ldi	r22, 0x76	; 118
 132:	71 e0       	ldi	r23, 0x01	; 1
 134:	83 e5       	ldi	r24, 0x53	; 83
 136:	90 e0       	ldi	r25, 0x00	; 0
 138:	0e 94 bb 03 	call	0x776	; 0x776 <xTaskGenericCreate>

		/* Start the scheduler so the created tasks start executing. */
		vTaskStartScheduler();
 13c:	0e 94 cc 04 	call	0x998	; 0x998 <vTaskStartScheduler>
 140:	04 c0       	rjmp	.+8      	; 0x14a <main+0x6a>
	}
	else
	{
		/* The queue could not be created. */
		USART_sendstr("The queue could not be created");
 142:	8f e7       	ldi	r24, 0x7F	; 127
 144:	91 e0       	ldi	r25, 0x01	; 1
 146:	0e 94 46 07 	call	0xe8c	; 0xe8c <USART_sendstr>
 14a:	ff cf       	rjmp	.-2      	; 0x14a <main+0x6a>

0000014c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 14c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 14e:	03 96       	adiw	r24, 0x03	; 3
 150:	92 83       	std	Z+2, r25	; 0x02
 152:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 154:	2f ef       	ldi	r18, 0xFF	; 255
 156:	3f ef       	ldi	r19, 0xFF	; 255
 158:	34 83       	std	Z+4, r19	; 0x04
 15a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 15c:	96 83       	std	Z+6, r25	; 0x06
 15e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 160:	90 87       	std	Z+8, r25	; 0x08
 162:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 164:	10 82       	st	Z, r1
 166:	08 95       	ret

00000168 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 168:	fc 01       	movw	r30, r24
 16a:	11 86       	std	Z+9, r1	; 0x09
 16c:	10 86       	std	Z+8, r1	; 0x08
 16e:	08 95       	ret

00000170 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 170:	cf 93       	push	r28
 172:	df 93       	push	r29
 174:	9c 01       	movw	r18, r24
 176:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 178:	dc 01       	movw	r26, r24
 17a:	11 96       	adiw	r26, 0x01	; 1
 17c:	cd 91       	ld	r28, X+
 17e:	dc 91       	ld	r29, X
 180:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 182:	d3 83       	std	Z+3, r29	; 0x03
 184:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 186:	8c 81       	ldd	r24, Y+4	; 0x04
 188:	9d 81       	ldd	r25, Y+5	; 0x05
 18a:	95 83       	std	Z+5, r25	; 0x05
 18c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 18e:	8c 81       	ldd	r24, Y+4	; 0x04
 190:	9d 81       	ldd	r25, Y+5	; 0x05
 192:	dc 01       	movw	r26, r24
 194:	13 96       	adiw	r26, 0x03	; 3
 196:	7c 93       	st	X, r23
 198:	6e 93       	st	-X, r22
 19a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 19c:	7d 83       	std	Y+5, r23	; 0x05
 19e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1a0:	31 87       	std	Z+9, r19	; 0x09
 1a2:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 1a4:	f9 01       	movw	r30, r18
 1a6:	80 81       	ld	r24, Z
 1a8:	8f 5f       	subi	r24, 0xFF	; 255
 1aa:	80 83       	st	Z, r24
}
 1ac:	df 91       	pop	r29
 1ae:	cf 91       	pop	r28
 1b0:	08 95       	ret

000001b2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 1b2:	cf 93       	push	r28
 1b4:	df 93       	push	r29
 1b6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 1b8:	48 81       	ld	r20, Y
 1ba:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 1bc:	4f 3f       	cpi	r20, 0xFF	; 255
 1be:	2f ef       	ldi	r18, 0xFF	; 255
 1c0:	52 07       	cpc	r21, r18
 1c2:	21 f4       	brne	.+8      	; 0x1cc <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 1c4:	fc 01       	movw	r30, r24
 1c6:	a7 81       	ldd	r26, Z+7	; 0x07
 1c8:	b0 85       	ldd	r27, Z+8	; 0x08
 1ca:	0d c0       	rjmp	.+26     	; 0x1e6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1cc:	dc 01       	movw	r26, r24
 1ce:	13 96       	adiw	r26, 0x03	; 3
 1d0:	01 c0       	rjmp	.+2      	; 0x1d4 <vListInsert+0x22>
 1d2:	df 01       	movw	r26, r30
 1d4:	12 96       	adiw	r26, 0x02	; 2
 1d6:	ed 91       	ld	r30, X+
 1d8:	fc 91       	ld	r31, X
 1da:	13 97       	sbiw	r26, 0x03	; 3
 1dc:	20 81       	ld	r18, Z
 1de:	31 81       	ldd	r19, Z+1	; 0x01
 1e0:	42 17       	cp	r20, r18
 1e2:	53 07       	cpc	r21, r19
 1e4:	b0 f7       	brcc	.-20     	; 0x1d2 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1e6:	12 96       	adiw	r26, 0x02	; 2
 1e8:	ed 91       	ld	r30, X+
 1ea:	fc 91       	ld	r31, X
 1ec:	13 97       	sbiw	r26, 0x03	; 3
 1ee:	fb 83       	std	Y+3, r31	; 0x03
 1f0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 1f2:	d5 83       	std	Z+5, r29	; 0x05
 1f4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 1f6:	bd 83       	std	Y+5, r27	; 0x05
 1f8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 1fa:	13 96       	adiw	r26, 0x03	; 3
 1fc:	dc 93       	st	X, r29
 1fe:	ce 93       	st	-X, r28
 200:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 202:	99 87       	std	Y+9, r25	; 0x09
 204:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 206:	fc 01       	movw	r30, r24
 208:	20 81       	ld	r18, Z
 20a:	2f 5f       	subi	r18, 0xFF	; 255
 20c:	20 83       	st	Z, r18
}
 20e:	df 91       	pop	r29
 210:	cf 91       	pop	r28
 212:	08 95       	ret

00000214 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 214:	cf 93       	push	r28
 216:	df 93       	push	r29
 218:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 21a:	a0 85       	ldd	r26, Z+8	; 0x08
 21c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 21e:	c2 81       	ldd	r28, Z+2	; 0x02
 220:	d3 81       	ldd	r29, Z+3	; 0x03
 222:	84 81       	ldd	r24, Z+4	; 0x04
 224:	95 81       	ldd	r25, Z+5	; 0x05
 226:	9d 83       	std	Y+5, r25	; 0x05
 228:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 22a:	c4 81       	ldd	r28, Z+4	; 0x04
 22c:	d5 81       	ldd	r29, Z+5	; 0x05
 22e:	82 81       	ldd	r24, Z+2	; 0x02
 230:	93 81       	ldd	r25, Z+3	; 0x03
 232:	9b 83       	std	Y+3, r25	; 0x03
 234:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 236:	11 96       	adiw	r26, 0x01	; 1
 238:	8d 91       	ld	r24, X+
 23a:	9c 91       	ld	r25, X
 23c:	12 97       	sbiw	r26, 0x02	; 2
 23e:	e8 17       	cp	r30, r24
 240:	f9 07       	cpc	r31, r25
 242:	31 f4       	brne	.+12     	; 0x250 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 244:	84 81       	ldd	r24, Z+4	; 0x04
 246:	95 81       	ldd	r25, Z+5	; 0x05
 248:	12 96       	adiw	r26, 0x02	; 2
 24a:	9c 93       	st	X, r25
 24c:	8e 93       	st	-X, r24
 24e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 250:	11 86       	std	Z+9, r1	; 0x09
 252:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 254:	8c 91       	ld	r24, X
 256:	81 50       	subi	r24, 0x01	; 1
 258:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 25a:	df 91       	pop	r29
 25c:	cf 91       	pop	r28
 25e:	08 95       	ret

00000260 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 260:	31 e1       	ldi	r19, 0x11	; 17
 262:	fc 01       	movw	r30, r24
 264:	30 83       	st	Z, r19
 266:	31 97       	sbiw	r30, 0x01	; 1
 268:	22 e2       	ldi	r18, 0x22	; 34
 26a:	20 83       	st	Z, r18
 26c:	31 97       	sbiw	r30, 0x01	; 1
 26e:	a3 e3       	ldi	r26, 0x33	; 51
 270:	a0 83       	st	Z, r26
 272:	31 97       	sbiw	r30, 0x01	; 1
 274:	60 83       	st	Z, r22
 276:	31 97       	sbiw	r30, 0x01	; 1
 278:	70 83       	st	Z, r23
 27a:	31 97       	sbiw	r30, 0x01	; 1
 27c:	10 82       	st	Z, r1
 27e:	31 97       	sbiw	r30, 0x01	; 1
 280:	60 e8       	ldi	r22, 0x80	; 128
 282:	60 83       	st	Z, r22
 284:	31 97       	sbiw	r30, 0x01	; 1
 286:	10 82       	st	Z, r1
 288:	31 97       	sbiw	r30, 0x01	; 1
 28a:	62 e0       	ldi	r22, 0x02	; 2
 28c:	60 83       	st	Z, r22
 28e:	31 97       	sbiw	r30, 0x01	; 1
 290:	63 e0       	ldi	r22, 0x03	; 3
 292:	60 83       	st	Z, r22
 294:	31 97       	sbiw	r30, 0x01	; 1
 296:	64 e0       	ldi	r22, 0x04	; 4
 298:	60 83       	st	Z, r22
 29a:	31 97       	sbiw	r30, 0x01	; 1
 29c:	65 e0       	ldi	r22, 0x05	; 5
 29e:	60 83       	st	Z, r22
 2a0:	31 97       	sbiw	r30, 0x01	; 1
 2a2:	66 e0       	ldi	r22, 0x06	; 6
 2a4:	60 83       	st	Z, r22
 2a6:	31 97       	sbiw	r30, 0x01	; 1
 2a8:	67 e0       	ldi	r22, 0x07	; 7
 2aa:	60 83       	st	Z, r22
 2ac:	31 97       	sbiw	r30, 0x01	; 1
 2ae:	68 e0       	ldi	r22, 0x08	; 8
 2b0:	60 83       	st	Z, r22
 2b2:	31 97       	sbiw	r30, 0x01	; 1
 2b4:	69 e0       	ldi	r22, 0x09	; 9
 2b6:	60 83       	st	Z, r22
 2b8:	31 97       	sbiw	r30, 0x01	; 1
 2ba:	60 e1       	ldi	r22, 0x10	; 16
 2bc:	60 83       	st	Z, r22
 2be:	31 97       	sbiw	r30, 0x01	; 1
 2c0:	30 83       	st	Z, r19
 2c2:	31 97       	sbiw	r30, 0x01	; 1
 2c4:	32 e1       	ldi	r19, 0x12	; 18
 2c6:	30 83       	st	Z, r19
 2c8:	31 97       	sbiw	r30, 0x01	; 1
 2ca:	33 e1       	ldi	r19, 0x13	; 19
 2cc:	30 83       	st	Z, r19
 2ce:	31 97       	sbiw	r30, 0x01	; 1
 2d0:	34 e1       	ldi	r19, 0x14	; 20
 2d2:	30 83       	st	Z, r19
 2d4:	31 97       	sbiw	r30, 0x01	; 1
 2d6:	35 e1       	ldi	r19, 0x15	; 21
 2d8:	30 83       	st	Z, r19
 2da:	31 97       	sbiw	r30, 0x01	; 1
 2dc:	36 e1       	ldi	r19, 0x16	; 22
 2de:	30 83       	st	Z, r19
 2e0:	31 97       	sbiw	r30, 0x01	; 1
 2e2:	37 e1       	ldi	r19, 0x17	; 23
 2e4:	30 83       	st	Z, r19
 2e6:	31 97       	sbiw	r30, 0x01	; 1
 2e8:	38 e1       	ldi	r19, 0x18	; 24
 2ea:	30 83       	st	Z, r19
 2ec:	31 97       	sbiw	r30, 0x01	; 1
 2ee:	39 e1       	ldi	r19, 0x19	; 25
 2f0:	30 83       	st	Z, r19
 2f2:	31 97       	sbiw	r30, 0x01	; 1
 2f4:	30 e2       	ldi	r19, 0x20	; 32
 2f6:	30 83       	st	Z, r19
 2f8:	31 97       	sbiw	r30, 0x01	; 1
 2fa:	31 e2       	ldi	r19, 0x21	; 33
 2fc:	30 83       	st	Z, r19
 2fe:	31 97       	sbiw	r30, 0x01	; 1
 300:	20 83       	st	Z, r18
 302:	31 97       	sbiw	r30, 0x01	; 1
 304:	23 e2       	ldi	r18, 0x23	; 35
 306:	20 83       	st	Z, r18
 308:	31 97       	sbiw	r30, 0x01	; 1
 30a:	40 83       	st	Z, r20
 30c:	31 97       	sbiw	r30, 0x01	; 1
 30e:	50 83       	st	Z, r21
 310:	31 97       	sbiw	r30, 0x01	; 1
 312:	26 e2       	ldi	r18, 0x26	; 38
 314:	20 83       	st	Z, r18
 316:	31 97       	sbiw	r30, 0x01	; 1
 318:	27 e2       	ldi	r18, 0x27	; 39
 31a:	20 83       	st	Z, r18
 31c:	31 97       	sbiw	r30, 0x01	; 1
 31e:	28 e2       	ldi	r18, 0x28	; 40
 320:	20 83       	st	Z, r18
 322:	31 97       	sbiw	r30, 0x01	; 1
 324:	29 e2       	ldi	r18, 0x29	; 41
 326:	20 83       	st	Z, r18
 328:	31 97       	sbiw	r30, 0x01	; 1
 32a:	20 e3       	ldi	r18, 0x30	; 48
 32c:	20 83       	st	Z, r18
 32e:	31 97       	sbiw	r30, 0x01	; 1
 330:	21 e3       	ldi	r18, 0x31	; 49
 332:	20 83       	st	Z, r18
 334:	86 97       	sbiw	r24, 0x26	; 38
 336:	08 95       	ret

00000338 <xPortStartScheduler>:
 338:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 33c:	8c e7       	ldi	r24, 0x7C	; 124
 33e:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
 342:	8b e0       	ldi	r24, 0x0B	; 11
 344:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 348:	ef e6       	ldi	r30, 0x6F	; 111
 34a:	f0 e0       	ldi	r31, 0x00	; 0
 34c:	80 81       	ld	r24, Z
 34e:	82 60       	ori	r24, 0x02	; 2
 350:	80 83       	st	Z, r24
 352:	a0 91 e9 07 	lds	r26, 0x07E9	; 0x8007e9 <pxCurrentTCB>
 356:	b0 91 ea 07 	lds	r27, 0x07EA	; 0x8007ea <pxCurrentTCB+0x1>
 35a:	cd 91       	ld	r28, X+
 35c:	cd bf       	out	0x3d, r28	; 61
 35e:	dd 91       	ld	r29, X+
 360:	de bf       	out	0x3e, r29	; 62
 362:	ff 91       	pop	r31
 364:	ef 91       	pop	r30
 366:	df 91       	pop	r29
 368:	cf 91       	pop	r28
 36a:	bf 91       	pop	r27
 36c:	af 91       	pop	r26
 36e:	9f 91       	pop	r25
 370:	8f 91       	pop	r24
 372:	7f 91       	pop	r23
 374:	6f 91       	pop	r22
 376:	5f 91       	pop	r21
 378:	4f 91       	pop	r20
 37a:	3f 91       	pop	r19
 37c:	2f 91       	pop	r18
 37e:	1f 91       	pop	r17
 380:	0f 91       	pop	r16
 382:	ff 90       	pop	r15
 384:	ef 90       	pop	r14
 386:	df 90       	pop	r13
 388:	cf 90       	pop	r12
 38a:	bf 90       	pop	r11
 38c:	af 90       	pop	r10
 38e:	9f 90       	pop	r9
 390:	8f 90       	pop	r8
 392:	7f 90       	pop	r7
 394:	6f 90       	pop	r6
 396:	5f 90       	pop	r5
 398:	4f 90       	pop	r4
 39a:	3f 90       	pop	r3
 39c:	2f 90       	pop	r2
 39e:	1f 90       	pop	r1
 3a0:	0f 90       	pop	r0
 3a2:	0f be       	out	0x3f, r0	; 63
 3a4:	0f 90       	pop	r0
 3a6:	08 95       	ret
 3a8:	81 e0       	ldi	r24, 0x01	; 1
 3aa:	08 95       	ret

000003ac <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 3ac:	0f 92       	push	r0
 3ae:	0f b6       	in	r0, 0x3f	; 63
 3b0:	f8 94       	cli
 3b2:	0f 92       	push	r0
 3b4:	1f 92       	push	r1
 3b6:	11 24       	eor	r1, r1
 3b8:	2f 92       	push	r2
 3ba:	3f 92       	push	r3
 3bc:	4f 92       	push	r4
 3be:	5f 92       	push	r5
 3c0:	6f 92       	push	r6
 3c2:	7f 92       	push	r7
 3c4:	8f 92       	push	r8
 3c6:	9f 92       	push	r9
 3c8:	af 92       	push	r10
 3ca:	bf 92       	push	r11
 3cc:	cf 92       	push	r12
 3ce:	df 92       	push	r13
 3d0:	ef 92       	push	r14
 3d2:	ff 92       	push	r15
 3d4:	0f 93       	push	r16
 3d6:	1f 93       	push	r17
 3d8:	2f 93       	push	r18
 3da:	3f 93       	push	r19
 3dc:	4f 93       	push	r20
 3de:	5f 93       	push	r21
 3e0:	6f 93       	push	r22
 3e2:	7f 93       	push	r23
 3e4:	8f 93       	push	r24
 3e6:	9f 93       	push	r25
 3e8:	af 93       	push	r26
 3ea:	bf 93       	push	r27
 3ec:	cf 93       	push	r28
 3ee:	df 93       	push	r29
 3f0:	ef 93       	push	r30
 3f2:	ff 93       	push	r31
 3f4:	a0 91 e9 07 	lds	r26, 0x07E9	; 0x8007e9 <pxCurrentTCB>
 3f8:	b0 91 ea 07 	lds	r27, 0x07EA	; 0x8007ea <pxCurrentTCB+0x1>
 3fc:	0d b6       	in	r0, 0x3d	; 61
 3fe:	0d 92       	st	X+, r0
 400:	0e b6       	in	r0, 0x3e	; 62
 402:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 404:	0e 94 c5 06 	call	0xd8a	; 0xd8a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 408:	a0 91 e9 07 	lds	r26, 0x07E9	; 0x8007e9 <pxCurrentTCB>
 40c:	b0 91 ea 07 	lds	r27, 0x07EA	; 0x8007ea <pxCurrentTCB+0x1>
 410:	cd 91       	ld	r28, X+
 412:	cd bf       	out	0x3d, r28	; 61
 414:	dd 91       	ld	r29, X+
 416:	de bf       	out	0x3e, r29	; 62
 418:	ff 91       	pop	r31
 41a:	ef 91       	pop	r30
 41c:	df 91       	pop	r29
 41e:	cf 91       	pop	r28
 420:	bf 91       	pop	r27
 422:	af 91       	pop	r26
 424:	9f 91       	pop	r25
 426:	8f 91       	pop	r24
 428:	7f 91       	pop	r23
 42a:	6f 91       	pop	r22
 42c:	5f 91       	pop	r21
 42e:	4f 91       	pop	r20
 430:	3f 91       	pop	r19
 432:	2f 91       	pop	r18
 434:	1f 91       	pop	r17
 436:	0f 91       	pop	r16
 438:	ff 90       	pop	r15
 43a:	ef 90       	pop	r14
 43c:	df 90       	pop	r13
 43e:	cf 90       	pop	r12
 440:	bf 90       	pop	r11
 442:	af 90       	pop	r10
 444:	9f 90       	pop	r9
 446:	8f 90       	pop	r8
 448:	7f 90       	pop	r7
 44a:	6f 90       	pop	r6
 44c:	5f 90       	pop	r5
 44e:	4f 90       	pop	r4
 450:	3f 90       	pop	r3
 452:	2f 90       	pop	r2
 454:	1f 90       	pop	r1
 456:	0f 90       	pop	r0
 458:	0f be       	out	0x3f, r0	; 63
 45a:	0f 90       	pop	r0

	asm volatile ( "ret" );
 45c:	08 95       	ret

0000045e <__vector_16>:
}


ISR(TIMER0_OVF_vect)				//ISR for timer0 overflow
{
 45e:	1f 92       	push	r1
 460:	0f 92       	push	r0
 462:	0f b6       	in	r0, 0x3f	; 63
 464:	0f 92       	push	r0
 466:	11 24       	eor	r1, r1
  ulIsrHandler[0];	
}
 468:	0f 90       	pop	r0
 46a:	0f be       	out	0x3f, r0	; 63
 46c:	0f 90       	pop	r0
 46e:	1f 90       	pop	r1
 470:	18 95       	reti

00000472 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 472:	0f 92       	push	r0
 474:	0f b6       	in	r0, 0x3f	; 63
 476:	f8 94       	cli
 478:	0f 92       	push	r0
 47a:	1f 92       	push	r1
 47c:	11 24       	eor	r1, r1
 47e:	2f 92       	push	r2
 480:	3f 92       	push	r3
 482:	4f 92       	push	r4
 484:	5f 92       	push	r5
 486:	6f 92       	push	r6
 488:	7f 92       	push	r7
 48a:	8f 92       	push	r8
 48c:	9f 92       	push	r9
 48e:	af 92       	push	r10
 490:	bf 92       	push	r11
 492:	cf 92       	push	r12
 494:	df 92       	push	r13
 496:	ef 92       	push	r14
 498:	ff 92       	push	r15
 49a:	0f 93       	push	r16
 49c:	1f 93       	push	r17
 49e:	2f 93       	push	r18
 4a0:	3f 93       	push	r19
 4a2:	4f 93       	push	r20
 4a4:	5f 93       	push	r21
 4a6:	6f 93       	push	r22
 4a8:	7f 93       	push	r23
 4aa:	8f 93       	push	r24
 4ac:	9f 93       	push	r25
 4ae:	af 93       	push	r26
 4b0:	bf 93       	push	r27
 4b2:	cf 93       	push	r28
 4b4:	df 93       	push	r29
 4b6:	ef 93       	push	r30
 4b8:	ff 93       	push	r31
 4ba:	a0 91 e9 07 	lds	r26, 0x07E9	; 0x8007e9 <pxCurrentTCB>
 4be:	b0 91 ea 07 	lds	r27, 0x07EA	; 0x8007ea <pxCurrentTCB+0x1>
 4c2:	0d b6       	in	r0, 0x3d	; 61
 4c4:	0d 92       	st	X+, r0
 4c6:	0e b6       	in	r0, 0x3e	; 62
 4c8:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 4ca:	0e 94 07 05 	call	0xa0e	; 0xa0e <xTaskIncrementTick>
 4ce:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 4d0:	0e 94 c5 06 	call	0xd8a	; 0xd8a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 4d4:	a0 91 e9 07 	lds	r26, 0x07E9	; 0x8007e9 <pxCurrentTCB>
 4d8:	b0 91 ea 07 	lds	r27, 0x07EA	; 0x8007ea <pxCurrentTCB+0x1>
 4dc:	cd 91       	ld	r28, X+
 4de:	cd bf       	out	0x3d, r28	; 61
 4e0:	dd 91       	ld	r29, X+
 4e2:	de bf       	out	0x3e, r29	; 62
 4e4:	ff 91       	pop	r31
 4e6:	ef 91       	pop	r30
 4e8:	df 91       	pop	r29
 4ea:	cf 91       	pop	r28
 4ec:	bf 91       	pop	r27
 4ee:	af 91       	pop	r26
 4f0:	9f 91       	pop	r25
 4f2:	8f 91       	pop	r24
 4f4:	7f 91       	pop	r23
 4f6:	6f 91       	pop	r22
 4f8:	5f 91       	pop	r21
 4fa:	4f 91       	pop	r20
 4fc:	3f 91       	pop	r19
 4fe:	2f 91       	pop	r18
 500:	1f 91       	pop	r17
 502:	0f 91       	pop	r16
 504:	ff 90       	pop	r15
 506:	ef 90       	pop	r14
 508:	df 90       	pop	r13
 50a:	cf 90       	pop	r12
 50c:	bf 90       	pop	r11
 50e:	af 90       	pop	r10
 510:	9f 90       	pop	r9
 512:	8f 90       	pop	r8
 514:	7f 90       	pop	r7
 516:	6f 90       	pop	r6
 518:	5f 90       	pop	r5
 51a:	4f 90       	pop	r4
 51c:	3f 90       	pop	r3
 51e:	2f 90       	pop	r2
 520:	1f 90       	pop	r1
 522:	0f 90       	pop	r0
 524:	0f be       	out	0x3f, r0	; 63
 526:	0f 90       	pop	r0

	asm volatile ( "ret" );
 528:	08 95       	ret

0000052a <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect(void) __attribute__ ((signal, naked));
	void TIMER1_COMPA_vect(void)
	{
		vPortYieldFromTick();
 52a:	0e 94 39 02 	call	0x472	; 0x472 <vPortYieldFromTick>
		asm volatile ( "reti" );
 52e:	18 95       	reti

00000530 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 530:	0f 93       	push	r16
 532:	1f 93       	push	r17
 534:	cf 93       	push	r28
 536:	df 93       	push	r29
 538:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
 53a:	0e 94 f7 04 	call	0x9ee	; 0x9ee <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 53e:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <__data_end>
 542:	81 11       	cpse	r24, r1
 544:	1d c0       	rjmp	.+58     	; 0x580 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 546:	e9 ea       	ldi	r30, 0xA9	; 169
 548:	f1 e0       	ldi	r31, 0x01	; 1
 54a:	8e ea       	ldi	r24, 0xAE	; 174
 54c:	91 e0       	ldi	r25, 0x01	; 1
 54e:	91 83       	std	Z+1, r25	; 0x01
 550:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
 552:	13 82       	std	Z+3, r1	; 0x03
 554:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
 556:	e5 ea       	ldi	r30, 0xA5	; 165
 558:	f1 e0       	ldi	r31, 0x01	; 1
 55a:	8b ed       	ldi	r24, 0xDB	; 219
 55c:	95 e0       	ldi	r25, 0x05	; 5
 55e:	93 83       	std	Z+3, r25	; 0x03
 560:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
 562:	11 82       	std	Z+1, r1	; 0x01
 564:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
 566:	ad ea       	ldi	r26, 0xAD	; 173
 568:	b1 e0       	ldi	r27, 0x01	; 1
 56a:	14 96       	adiw	r26, 0x04	; 4
 56c:	9c 93       	st	X, r25
 56e:	8e 93       	st	-X, r24
 570:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
 572:	12 96       	adiw	r26, 0x02	; 2
 574:	fc 93       	st	X, r31
 576:	ee 93       	st	-X, r30
 578:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
 57a:	81 e0       	ldi	r24, 0x01	; 1
 57c:	80 93 a4 01 	sts	0x01A4, r24	; 0x8001a4 <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 580:	20 97       	sbiw	r28, 0x00	; 0
 582:	09 f4       	brne	.+2      	; 0x586 <pvPortMalloc+0x56>
 584:	5f c0       	rjmp	.+190    	; 0x644 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
 586:	9e 01       	movw	r18, r28
 588:	2c 5f       	subi	r18, 0xFC	; 252
 58a:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
 58c:	23 96       	adiw	r28, 0x03	; 3
 58e:	ca 3d       	cpi	r28, 0xDA	; 218
 590:	d5 40       	sbci	r29, 0x05	; 5
 592:	08 f0       	brcs	.+2      	; 0x596 <pvPortMalloc+0x66>
 594:	5a c0       	rjmp	.+180    	; 0x64a <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
 596:	e0 91 a9 01 	lds	r30, 0x01A9	; 0x8001a9 <xStart>
 59a:	f0 91 aa 01 	lds	r31, 0x01AA	; 0x8001aa <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 59e:	a9 ea       	ldi	r26, 0xA9	; 169
 5a0:	b1 e0       	ldi	r27, 0x01	; 1
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 5a2:	02 c0       	rjmp	.+4      	; 0x5a8 <pvPortMalloc+0x78>
 5a4:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
 5a6:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 5a8:	82 81       	ldd	r24, Z+2	; 0x02
 5aa:	93 81       	ldd	r25, Z+3	; 0x03
 5ac:	82 17       	cp	r24, r18
 5ae:	93 07       	cpc	r25, r19
 5b0:	20 f4       	brcc	.+8      	; 0x5ba <pvPortMalloc+0x8a>
 5b2:	80 81       	ld	r24, Z
 5b4:	91 81       	ldd	r25, Z+1	; 0x01
 5b6:	00 97       	sbiw	r24, 0x00	; 0
 5b8:	a9 f7       	brne	.-22     	; 0x5a4 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 5ba:	c1 e0       	ldi	r28, 0x01	; 1
 5bc:	e5 3a       	cpi	r30, 0xA5	; 165
 5be:	fc 07       	cpc	r31, r28
 5c0:	09 f4       	brne	.+2      	; 0x5c4 <pvPortMalloc+0x94>
 5c2:	46 c0       	rjmp	.+140    	; 0x650 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 5c4:	cd 91       	ld	r28, X+
 5c6:	dc 91       	ld	r29, X
 5c8:	11 97       	sbiw	r26, 0x01	; 1
 5ca:	8e 01       	movw	r16, r28
 5cc:	0c 5f       	subi	r16, 0xFC	; 252
 5ce:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 5d0:	80 81       	ld	r24, Z
 5d2:	91 81       	ldd	r25, Z+1	; 0x01
 5d4:	8d 93       	st	X+, r24
 5d6:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 5d8:	82 81       	ldd	r24, Z+2	; 0x02
 5da:	93 81       	ldd	r25, Z+3	; 0x03
 5dc:	82 1b       	sub	r24, r18
 5de:	93 0b       	sbc	r25, r19
 5e0:	89 30       	cpi	r24, 0x09	; 9
 5e2:	91 05       	cpc	r25, r1
 5e4:	10 f1       	brcs	.+68     	; 0x62a <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 5e6:	bf 01       	movw	r22, r30
 5e8:	62 0f       	add	r22, r18
 5ea:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 5ec:	db 01       	movw	r26, r22
 5ee:	13 96       	adiw	r26, 0x03	; 3
 5f0:	9c 93       	st	X, r25
 5f2:	8e 93       	st	-X, r24
 5f4:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
 5f6:	33 83       	std	Z+3, r19	; 0x03
 5f8:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 5fa:	12 96       	adiw	r26, 0x02	; 2
 5fc:	4d 91       	ld	r20, X+
 5fe:	5c 91       	ld	r21, X
 600:	13 97       	sbiw	r26, 0x03	; 3
 602:	89 ea       	ldi	r24, 0xA9	; 169
 604:	91 e0       	ldi	r25, 0x01	; 1
 606:	01 c0       	rjmp	.+2      	; 0x60a <pvPortMalloc+0xda>
 608:	cd 01       	movw	r24, r26
 60a:	ec 01       	movw	r28, r24
 60c:	a8 81       	ld	r26, Y
 60e:	b9 81       	ldd	r27, Y+1	; 0x01
 610:	12 96       	adiw	r26, 0x02	; 2
 612:	2d 91       	ld	r18, X+
 614:	3c 91       	ld	r19, X
 616:	13 97       	sbiw	r26, 0x03	; 3
 618:	24 17       	cp	r18, r20
 61a:	35 07       	cpc	r19, r21
 61c:	a8 f3       	brcs	.-22     	; 0x608 <pvPortMalloc+0xd8>
 61e:	eb 01       	movw	r28, r22
 620:	b9 83       	std	Y+1, r27	; 0x01
 622:	a8 83       	st	Y, r26
 624:	dc 01       	movw	r26, r24
 626:	6d 93       	st	X+, r22
 628:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
 62a:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 62e:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
 632:	22 81       	ldd	r18, Z+2	; 0x02
 634:	33 81       	ldd	r19, Z+3	; 0x03
 636:	82 1b       	sub	r24, r18
 638:	93 0b       	sbc	r25, r19
 63a:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 63e:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 642:	08 c0       	rjmp	.+16     	; 0x654 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 644:	00 e0       	ldi	r16, 0x00	; 0
 646:	10 e0       	ldi	r17, 0x00	; 0
 648:	05 c0       	rjmp	.+10     	; 0x654 <pvPortMalloc+0x124>
 64a:	00 e0       	ldi	r16, 0x00	; 0
 64c:	10 e0       	ldi	r17, 0x00	; 0
 64e:	02 c0       	rjmp	.+4      	; 0x654 <pvPortMalloc+0x124>
 650:	00 e0       	ldi	r16, 0x00	; 0
 652:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 654:	0e 94 c4 05 	call	0xb88	; 0xb88 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 658:	c8 01       	movw	r24, r16
 65a:	df 91       	pop	r29
 65c:	cf 91       	pop	r28
 65e:	1f 91       	pop	r17
 660:	0f 91       	pop	r16
 662:	08 95       	ret

00000664 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 664:	0f 93       	push	r16
 666:	1f 93       	push	r17
 668:	cf 93       	push	r28
 66a:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
 66c:	00 97       	sbiw	r24, 0x00	; 0
 66e:	41 f1       	breq	.+80     	; 0x6c0 <vPortFree+0x5c>
 670:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 672:	8c 01       	movw	r16, r24
 674:	04 50       	subi	r16, 0x04	; 4
 676:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
 678:	0e 94 f7 04 	call	0x9ee	; 0x9ee <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 67c:	f8 01       	movw	r30, r16
 67e:	42 81       	ldd	r20, Z+2	; 0x02
 680:	53 81       	ldd	r21, Z+3	; 0x03
 682:	a9 ea       	ldi	r26, 0xA9	; 169
 684:	b1 e0       	ldi	r27, 0x01	; 1
 686:	01 c0       	rjmp	.+2      	; 0x68a <vPortFree+0x26>
 688:	df 01       	movw	r26, r30
 68a:	ed 91       	ld	r30, X+
 68c:	fc 91       	ld	r31, X
 68e:	11 97       	sbiw	r26, 0x01	; 1
 690:	22 81       	ldd	r18, Z+2	; 0x02
 692:	33 81       	ldd	r19, Z+3	; 0x03
 694:	24 17       	cp	r18, r20
 696:	35 07       	cpc	r19, r21
 698:	b8 f3       	brcs	.-18     	; 0x688 <vPortFree+0x24>
 69a:	24 97       	sbiw	r28, 0x04	; 4
 69c:	f9 83       	std	Y+1, r31	; 0x01
 69e:	e8 83       	st	Y, r30
 6a0:	0d 93       	st	X+, r16
 6a2:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
 6a4:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
 6a8:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
 6ac:	8a 81       	ldd	r24, Y+2	; 0x02
 6ae:	9b 81       	ldd	r25, Y+3	; 0x03
 6b0:	82 0f       	add	r24, r18
 6b2:	93 1f       	adc	r25, r19
 6b4:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 6b8:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
 6bc:	0e 94 c4 05 	call	0xb88	; 0xb88 <xTaskResumeAll>
	}
}
 6c0:	df 91       	pop	r29
 6c2:	cf 91       	pop	r28
 6c4:	1f 91       	pop	r17
 6c6:	0f 91       	pop	r16
 6c8:	08 95       	ret

000006ca <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 6ca:	e0 91 b1 07 	lds	r30, 0x07B1	; 0x8007b1 <pxDelayedTaskList>
 6ce:	f0 91 b2 07 	lds	r31, 0x07B2	; 0x8007b2 <pxDelayedTaskList+0x1>
 6d2:	80 81       	ld	r24, Z
 6d4:	81 11       	cpse	r24, r1
 6d6:	07 c0       	rjmp	.+14     	; 0x6e6 <prvResetNextTaskUnblockTime+0x1c>
 6d8:	8f ef       	ldi	r24, 0xFF	; 255
 6da:	9f ef       	ldi	r25, 0xFF	; 255
 6dc:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
 6e0:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
 6e4:	08 95       	ret
 6e6:	e0 91 b1 07 	lds	r30, 0x07B1	; 0x8007b1 <pxDelayedTaskList>
 6ea:	f0 91 b2 07 	lds	r31, 0x07B2	; 0x8007b2 <pxDelayedTaskList+0x1>
 6ee:	05 80       	ldd	r0, Z+5	; 0x05
 6f0:	f6 81       	ldd	r31, Z+6	; 0x06
 6f2:	e0 2d       	mov	r30, r0
 6f4:	06 80       	ldd	r0, Z+6	; 0x06
 6f6:	f7 81       	ldd	r31, Z+7	; 0x07
 6f8:	e0 2d       	mov	r30, r0
 6fa:	82 81       	ldd	r24, Z+2	; 0x02
 6fc:	93 81       	ldd	r25, Z+3	; 0x03
 6fe:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
 702:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
 706:	08 95       	ret

00000708 <prvAddCurrentTaskToDelayedList>:
 708:	cf 93       	push	r28
 70a:	df 93       	push	r29
 70c:	ec 01       	movw	r28, r24
 70e:	e0 91 e9 07 	lds	r30, 0x07E9	; 0x8007e9 <pxCurrentTCB>
 712:	f0 91 ea 07 	lds	r31, 0x07EA	; 0x8007ea <pxCurrentTCB+0x1>
 716:	93 83       	std	Z+3, r25	; 0x03
 718:	82 83       	std	Z+2, r24	; 0x02
 71a:	80 91 90 07 	lds	r24, 0x0790	; 0x800790 <xTickCount>
 71e:	90 91 91 07 	lds	r25, 0x0791	; 0x800791 <xTickCount+0x1>
 722:	c8 17       	cp	r28, r24
 724:	d9 07       	cpc	r29, r25
 726:	68 f4       	brcc	.+26     	; 0x742 <prvAddCurrentTaskToDelayedList+0x3a>
 728:	60 91 e9 07 	lds	r22, 0x07E9	; 0x8007e9 <pxCurrentTCB>
 72c:	70 91 ea 07 	lds	r23, 0x07EA	; 0x8007ea <pxCurrentTCB+0x1>
 730:	80 91 af 07 	lds	r24, 0x07AF	; 0x8007af <pxOverflowDelayedTaskList>
 734:	90 91 b0 07 	lds	r25, 0x07B0	; 0x8007b0 <pxOverflowDelayedTaskList+0x1>
 738:	6e 5f       	subi	r22, 0xFE	; 254
 73a:	7f 4f       	sbci	r23, 0xFF	; 255
 73c:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <vListInsert>
 740:	17 c0       	rjmp	.+46     	; 0x770 <prvAddCurrentTaskToDelayedList+0x68>
 742:	60 91 e9 07 	lds	r22, 0x07E9	; 0x8007e9 <pxCurrentTCB>
 746:	70 91 ea 07 	lds	r23, 0x07EA	; 0x8007ea <pxCurrentTCB+0x1>
 74a:	80 91 b1 07 	lds	r24, 0x07B1	; 0x8007b1 <pxDelayedTaskList>
 74e:	90 91 b2 07 	lds	r25, 0x07B2	; 0x8007b2 <pxDelayedTaskList+0x1>
 752:	6e 5f       	subi	r22, 0xFE	; 254
 754:	7f 4f       	sbci	r23, 0xFF	; 255
 756:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <vListInsert>
 75a:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xNextTaskUnblockTime>
 75e:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <xNextTaskUnblockTime+0x1>
 762:	c8 17       	cp	r28, r24
 764:	d9 07       	cpc	r29, r25
 766:	20 f4       	brcc	.+8      	; 0x770 <prvAddCurrentTaskToDelayedList+0x68>
 768:	d0 93 03 01 	sts	0x0103, r29	; 0x800103 <xNextTaskUnblockTime+0x1>
 76c:	c0 93 02 01 	sts	0x0102, r28	; 0x800102 <xNextTaskUnblockTime>
 770:	df 91       	pop	r29
 772:	cf 91       	pop	r28
 774:	08 95       	ret

00000776 <xTaskGenericCreate>:
 776:	4f 92       	push	r4
 778:	5f 92       	push	r5
 77a:	6f 92       	push	r6
 77c:	7f 92       	push	r7
 77e:	8f 92       	push	r8
 780:	9f 92       	push	r9
 782:	af 92       	push	r10
 784:	bf 92       	push	r11
 786:	cf 92       	push	r12
 788:	df 92       	push	r13
 78a:	ef 92       	push	r14
 78c:	ff 92       	push	r15
 78e:	0f 93       	push	r16
 790:	1f 93       	push	r17
 792:	cf 93       	push	r28
 794:	df 93       	push	r29
 796:	4c 01       	movw	r8, r24
 798:	eb 01       	movw	r28, r22
 79a:	5a 01       	movw	r10, r20
 79c:	29 01       	movw	r4, r18
 79e:	c1 14       	cp	r12, r1
 7a0:	d1 04       	cpc	r13, r1
 7a2:	39 f4       	brne	.+14     	; 0x7b2 <xTaskGenericCreate+0x3c>
 7a4:	ca 01       	movw	r24, r20
 7a6:	0e 94 98 02 	call	0x530	; 0x530 <pvPortMalloc>
 7aa:	6c 01       	movw	r12, r24
 7ac:	89 2b       	or	r24, r25
 7ae:	09 f4       	brne	.+2      	; 0x7b2 <xTaskGenericCreate+0x3c>
 7b0:	e1 c0       	rjmp	.+450    	; 0x974 <__stack+0x75>
 7b2:	86 e2       	ldi	r24, 0x26	; 38
 7b4:	90 e0       	ldi	r25, 0x00	; 0
 7b6:	0e 94 98 02 	call	0x530	; 0x530 <pvPortMalloc>
 7ba:	3c 01       	movw	r6, r24
 7bc:	00 97       	sbiw	r24, 0x00	; 0
 7be:	79 f0       	breq	.+30     	; 0x7de <xTaskGenericCreate+0x68>
 7c0:	fc 01       	movw	r30, r24
 7c2:	d0 8e       	std	Z+24, r13	; 0x18
 7c4:	c7 8a       	std	Z+23, r12	; 0x17
 7c6:	f1 e0       	ldi	r31, 0x01	; 1
 7c8:	af 1a       	sub	r10, r31
 7ca:	b1 08       	sbc	r11, r1
 7cc:	ca 0c       	add	r12, r10
 7ce:	db 1c       	adc	r13, r11
 7d0:	88 81       	ld	r24, Y
 7d2:	f3 01       	movw	r30, r6
 7d4:	81 8f       	std	Z+25, r24	; 0x19
 7d6:	88 81       	ld	r24, Y
 7d8:	81 11       	cpse	r24, r1
 7da:	05 c0       	rjmp	.+10     	; 0x7e6 <xTaskGenericCreate+0x70>
 7dc:	14 c0       	rjmp	.+40     	; 0x806 <xTaskGenericCreate+0x90>
 7de:	c6 01       	movw	r24, r12
 7e0:	0e 94 32 03 	call	0x664	; 0x664 <vPortFree>
 7e4:	c7 c0       	rjmp	.+398    	; 0x974 <__stack+0x75>
 7e6:	d3 01       	movw	r26, r6
 7e8:	5a 96       	adiw	r26, 0x1a	; 26
 7ea:	fe 01       	movw	r30, r28
 7ec:	31 96       	adiw	r30, 0x01	; 1
 7ee:	9e 01       	movw	r18, r28
 7f0:	28 5f       	subi	r18, 0xF8	; 248
 7f2:	3f 4f       	sbci	r19, 0xFF	; 255
 7f4:	ef 01       	movw	r28, r30
 7f6:	81 91       	ld	r24, Z+
 7f8:	8d 93       	st	X+, r24
 7fa:	88 81       	ld	r24, Y
 7fc:	88 23       	and	r24, r24
 7fe:	19 f0       	breq	.+6      	; 0x806 <xTaskGenericCreate+0x90>
 800:	e2 17       	cp	r30, r18
 802:	f3 07       	cpc	r31, r19
 804:	b9 f7       	brne	.-18     	; 0x7f4 <xTaskGenericCreate+0x7e>
 806:	f3 01       	movw	r30, r6
 808:	10 a2       	std	Z+32, r1	; 0x20
 80a:	10 2f       	mov	r17, r16
 80c:	04 30       	cpi	r16, 0x04	; 4
 80e:	08 f0       	brcs	.+2      	; 0x812 <xTaskGenericCreate+0x9c>
 810:	13 e0       	ldi	r17, 0x03	; 3
 812:	f3 01       	movw	r30, r6
 814:	16 8b       	std	Z+22, r17	; 0x16
 816:	e3 01       	movw	r28, r6
 818:	22 96       	adiw	r28, 0x02	; 2
 81a:	ce 01       	movw	r24, r28
 81c:	0e 94 b4 00 	call	0x168	; 0x168 <vListInitialiseItem>
 820:	c3 01       	movw	r24, r6
 822:	0c 96       	adiw	r24, 0x0c	; 12
 824:	0e 94 b4 00 	call	0x168	; 0x168 <vListInitialiseItem>
 828:	f3 01       	movw	r30, r6
 82a:	71 86       	std	Z+9, r7	; 0x09
 82c:	60 86       	std	Z+8, r6	; 0x08
 82e:	84 e0       	ldi	r24, 0x04	; 4
 830:	90 e0       	ldi	r25, 0x00	; 0
 832:	81 1b       	sub	r24, r17
 834:	91 09       	sbc	r25, r1
 836:	95 87       	std	Z+13, r25	; 0x0d
 838:	84 87       	std	Z+12, r24	; 0x0c
 83a:	73 8a       	std	Z+19, r7	; 0x13
 83c:	62 8a       	std	Z+18, r6	; 0x12
 83e:	11 a2       	std	Z+33, r1	; 0x21
 840:	12 a2       	std	Z+34, r1	; 0x22
 842:	13 a2       	std	Z+35, r1	; 0x23
 844:	14 a2       	std	Z+36, r1	; 0x24
 846:	15 a2       	std	Z+37, r1	; 0x25
 848:	a2 01       	movw	r20, r4
 84a:	b4 01       	movw	r22, r8
 84c:	c6 01       	movw	r24, r12
 84e:	0e 94 30 01 	call	0x260	; 0x260 <pxPortInitialiseStack>
 852:	f3 01       	movw	r30, r6
 854:	91 83       	std	Z+1, r25	; 0x01
 856:	80 83       	st	Z, r24
 858:	e1 14       	cp	r14, r1
 85a:	f1 04       	cpc	r15, r1
 85c:	19 f0       	breq	.+6      	; 0x864 <xTaskGenericCreate+0xee>
 85e:	f7 01       	movw	r30, r14
 860:	71 82       	std	Z+1, r7	; 0x01
 862:	60 82       	st	Z, r6
 864:	0f b6       	in	r0, 0x3f	; 63
 866:	f8 94       	cli
 868:	0f 92       	push	r0
 86a:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <uxCurrentNumberOfTasks>
 86e:	8f 5f       	subi	r24, 0xFF	; 255
 870:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <uxCurrentNumberOfTasks>
 874:	80 91 e9 07 	lds	r24, 0x07E9	; 0x8007e9 <pxCurrentTCB>
 878:	90 91 ea 07 	lds	r25, 0x07EA	; 0x8007ea <pxCurrentTCB+0x1>
 87c:	89 2b       	or	r24, r25
 87e:	d1 f5       	brne	.+116    	; 0x8f4 <xTaskGenericCreate+0x17e>
 880:	70 92 ea 07 	sts	0x07EA, r7	; 0x8007ea <pxCurrentTCB+0x1>
 884:	60 92 e9 07 	sts	0x07E9, r6	; 0x8007e9 <pxCurrentTCB>
 888:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <uxCurrentNumberOfTasks>
 88c:	81 30       	cpi	r24, 0x01	; 1
 88e:	09 f0       	breq	.+2      	; 0x892 <xTaskGenericCreate+0x11c>
 890:	40 c0       	rjmp	.+128    	; 0x912 <__stack+0x13>
 892:	85 ec       	ldi	r24, 0xC5	; 197
 894:	97 e0       	ldi	r25, 0x07	; 7
 896:	0e 94 a6 00 	call	0x14c	; 0x14c <vListInitialise>
 89a:	8e ec       	ldi	r24, 0xCE	; 206
 89c:	97 e0       	ldi	r25, 0x07	; 7
 89e:	0e 94 a6 00 	call	0x14c	; 0x14c <vListInitialise>
 8a2:	87 ed       	ldi	r24, 0xD7	; 215
 8a4:	97 e0       	ldi	r25, 0x07	; 7
 8a6:	0e 94 a6 00 	call	0x14c	; 0x14c <vListInitialise>
 8aa:	80 ee       	ldi	r24, 0xE0	; 224
 8ac:	97 e0       	ldi	r25, 0x07	; 7
 8ae:	0e 94 a6 00 	call	0x14c	; 0x14c <vListInitialise>
 8b2:	8c eb       	ldi	r24, 0xBC	; 188
 8b4:	97 e0       	ldi	r25, 0x07	; 7
 8b6:	0e 94 a6 00 	call	0x14c	; 0x14c <vListInitialise>
 8ba:	83 eb       	ldi	r24, 0xB3	; 179
 8bc:	97 e0       	ldi	r25, 0x07	; 7
 8be:	0e 94 a6 00 	call	0x14c	; 0x14c <vListInitialise>
 8c2:	86 ea       	ldi	r24, 0xA6	; 166
 8c4:	97 e0       	ldi	r25, 0x07	; 7
 8c6:	0e 94 a6 00 	call	0x14c	; 0x14c <vListInitialise>
 8ca:	8d e9       	ldi	r24, 0x9D	; 157
 8cc:	97 e0       	ldi	r25, 0x07	; 7
 8ce:	0e 94 a6 00 	call	0x14c	; 0x14c <vListInitialise>
 8d2:	83 e9       	ldi	r24, 0x93	; 147
 8d4:	97 e0       	ldi	r25, 0x07	; 7
 8d6:	0e 94 a6 00 	call	0x14c	; 0x14c <vListInitialise>
 8da:	8c eb       	ldi	r24, 0xBC	; 188
 8dc:	97 e0       	ldi	r25, 0x07	; 7
 8de:	90 93 b2 07 	sts	0x07B2, r25	; 0x8007b2 <pxDelayedTaskList+0x1>
 8e2:	80 93 b1 07 	sts	0x07B1, r24	; 0x8007b1 <pxDelayedTaskList>
 8e6:	83 eb       	ldi	r24, 0xB3	; 179
 8e8:	97 e0       	ldi	r25, 0x07	; 7
 8ea:	90 93 b0 07 	sts	0x07B0, r25	; 0x8007b0 <pxOverflowDelayedTaskList+0x1>
 8ee:	80 93 af 07 	sts	0x07AF, r24	; 0x8007af <pxOverflowDelayedTaskList>
 8f2:	0f c0       	rjmp	.+30     	; 0x912 <__stack+0x13>
 8f4:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <xSchedulerRunning>
 8f8:	81 11       	cpse	r24, r1
 8fa:	0b c0       	rjmp	.+22     	; 0x912 <__stack+0x13>
 8fc:	e0 91 e9 07 	lds	r30, 0x07E9	; 0x8007e9 <pxCurrentTCB>
 900:	f0 91 ea 07 	lds	r31, 0x07EA	; 0x8007ea <pxCurrentTCB+0x1>
 904:	86 89       	ldd	r24, Z+22	; 0x16
 906:	08 17       	cp	r16, r24
 908:	20 f0       	brcs	.+8      	; 0x912 <__stack+0x13>
 90a:	70 92 ea 07 	sts	0x07EA, r7	; 0x8007ea <pxCurrentTCB+0x1>
 90e:	60 92 e9 07 	sts	0x07E9, r6	; 0x8007e9 <pxCurrentTCB>
 912:	80 91 8a 07 	lds	r24, 0x078A	; 0x80078a <uxTaskNumber>
 916:	8f 5f       	subi	r24, 0xFF	; 255
 918:	80 93 8a 07 	sts	0x078A, r24	; 0x80078a <uxTaskNumber>
 91c:	f3 01       	movw	r30, r6
 91e:	86 89       	ldd	r24, Z+22	; 0x16
 920:	90 91 8f 07 	lds	r25, 0x078F	; 0x80078f <uxTopReadyPriority>
 924:	98 17       	cp	r25, r24
 926:	10 f4       	brcc	.+4      	; 0x92c <__stack+0x2d>
 928:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <uxTopReadyPriority>
 92c:	90 e0       	ldi	r25, 0x00	; 0
 92e:	9c 01       	movw	r18, r24
 930:	22 0f       	add	r18, r18
 932:	33 1f       	adc	r19, r19
 934:	22 0f       	add	r18, r18
 936:	33 1f       	adc	r19, r19
 938:	22 0f       	add	r18, r18
 93a:	33 1f       	adc	r19, r19
 93c:	82 0f       	add	r24, r18
 93e:	93 1f       	adc	r25, r19
 940:	be 01       	movw	r22, r28
 942:	8b 53       	subi	r24, 0x3B	; 59
 944:	98 4f       	sbci	r25, 0xF8	; 248
 946:	0e 94 b8 00 	call	0x170	; 0x170 <vListInsertEnd>
 94a:	0f 90       	pop	r0
 94c:	0f be       	out	0x3f, r0	; 63
 94e:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <xSchedulerRunning>
 952:	88 23       	and	r24, r24
 954:	59 f0       	breq	.+22     	; 0x96c <__stack+0x6d>
 956:	e0 91 e9 07 	lds	r30, 0x07E9	; 0x8007e9 <pxCurrentTCB>
 95a:	f0 91 ea 07 	lds	r31, 0x07EA	; 0x8007ea <pxCurrentTCB+0x1>
 95e:	86 89       	ldd	r24, Z+22	; 0x16
 960:	80 17       	cp	r24, r16
 962:	30 f4       	brcc	.+12     	; 0x970 <__stack+0x71>
 964:	0e 94 d6 01 	call	0x3ac	; 0x3ac <vPortYield>
 968:	81 e0       	ldi	r24, 0x01	; 1
 96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x77>
 96c:	81 e0       	ldi	r24, 0x01	; 1
 96e:	03 c0       	rjmp	.+6      	; 0x976 <__stack+0x77>
 970:	81 e0       	ldi	r24, 0x01	; 1
 972:	01 c0       	rjmp	.+2      	; 0x976 <__stack+0x77>
 974:	8f ef       	ldi	r24, 0xFF	; 255
 976:	df 91       	pop	r29
 978:	cf 91       	pop	r28
 97a:	1f 91       	pop	r17
 97c:	0f 91       	pop	r16
 97e:	ff 90       	pop	r15
 980:	ef 90       	pop	r14
 982:	df 90       	pop	r13
 984:	cf 90       	pop	r12
 986:	bf 90       	pop	r11
 988:	af 90       	pop	r10
 98a:	9f 90       	pop	r9
 98c:	8f 90       	pop	r8
 98e:	7f 90       	pop	r7
 990:	6f 90       	pop	r6
 992:	5f 90       	pop	r5
 994:	4f 90       	pop	r4
 996:	08 95       	ret

00000998 <vTaskStartScheduler>:
 998:	af 92       	push	r10
 99a:	bf 92       	push	r11
 99c:	cf 92       	push	r12
 99e:	df 92       	push	r13
 9a0:	ef 92       	push	r14
 9a2:	ff 92       	push	r15
 9a4:	0f 93       	push	r16
 9a6:	a1 2c       	mov	r10, r1
 9a8:	b1 2c       	mov	r11, r1
 9aa:	c1 2c       	mov	r12, r1
 9ac:	d1 2c       	mov	r13, r1
 9ae:	e1 2c       	mov	r14, r1
 9b0:	f1 2c       	mov	r15, r1
 9b2:	00 e0       	ldi	r16, 0x00	; 0
 9b4:	20 e0       	ldi	r18, 0x00	; 0
 9b6:	30 e0       	ldi	r19, 0x00	; 0
 9b8:	45 e5       	ldi	r20, 0x55	; 85
 9ba:	50 e0       	ldi	r21, 0x00	; 0
 9bc:	6e e9       	ldi	r22, 0x9E	; 158
 9be:	71 e0       	ldi	r23, 0x01	; 1
 9c0:	88 e8       	ldi	r24, 0x88	; 136
 9c2:	96 e0       	ldi	r25, 0x06	; 6
 9c4:	0e 94 bb 03 	call	0x776	; 0x776 <xTaskGenericCreate>
 9c8:	81 30       	cpi	r24, 0x01	; 1
 9ca:	49 f4       	brne	.+18     	; 0x9de <vTaskStartScheduler+0x46>
 9cc:	f8 94       	cli
 9ce:	80 93 8e 07 	sts	0x078E, r24	; 0x80078e <xSchedulerRunning>
 9d2:	10 92 91 07 	sts	0x0791, r1	; 0x800791 <xTickCount+0x1>
 9d6:	10 92 90 07 	sts	0x0790, r1	; 0x800790 <xTickCount>
 9da:	0e 94 9c 01 	call	0x338	; 0x338 <xPortStartScheduler>
 9de:	0f 91       	pop	r16
 9e0:	ff 90       	pop	r15
 9e2:	ef 90       	pop	r14
 9e4:	df 90       	pop	r13
 9e6:	cf 90       	pop	r12
 9e8:	bf 90       	pop	r11
 9ea:	af 90       	pop	r10
 9ec:	08 95       	ret

000009ee <vTaskSuspendAll>:
 9ee:	80 91 89 07 	lds	r24, 0x0789	; 0x800789 <uxSchedulerSuspended>
 9f2:	8f 5f       	subi	r24, 0xFF	; 255
 9f4:	80 93 89 07 	sts	0x0789, r24	; 0x800789 <uxSchedulerSuspended>
 9f8:	08 95       	ret

000009fa <xTaskGetTickCount>:
 9fa:	0f b6       	in	r0, 0x3f	; 63
 9fc:	f8 94       	cli
 9fe:	0f 92       	push	r0
 a00:	80 91 90 07 	lds	r24, 0x0790	; 0x800790 <xTickCount>
 a04:	90 91 91 07 	lds	r25, 0x0791	; 0x800791 <xTickCount+0x1>
 a08:	0f 90       	pop	r0
 a0a:	0f be       	out	0x3f, r0	; 63
 a0c:	08 95       	ret

00000a0e <xTaskIncrementTick>:
 a0e:	cf 92       	push	r12
 a10:	df 92       	push	r13
 a12:	ef 92       	push	r14
 a14:	ff 92       	push	r15
 a16:	0f 93       	push	r16
 a18:	1f 93       	push	r17
 a1a:	cf 93       	push	r28
 a1c:	df 93       	push	r29
 a1e:	80 91 89 07 	lds	r24, 0x0789	; 0x800789 <uxSchedulerSuspended>
 a22:	81 11       	cpse	r24, r1
 a24:	9b c0       	rjmp	.+310    	; 0xb5c <xTaskIncrementTick+0x14e>
 a26:	80 91 90 07 	lds	r24, 0x0790	; 0x800790 <xTickCount>
 a2a:	90 91 91 07 	lds	r25, 0x0791	; 0x800791 <xTickCount+0x1>
 a2e:	01 96       	adiw	r24, 0x01	; 1
 a30:	90 93 91 07 	sts	0x0791, r25	; 0x800791 <xTickCount+0x1>
 a34:	80 93 90 07 	sts	0x0790, r24	; 0x800790 <xTickCount>
 a38:	e0 90 90 07 	lds	r14, 0x0790	; 0x800790 <xTickCount>
 a3c:	f0 90 91 07 	lds	r15, 0x0791	; 0x800791 <xTickCount+0x1>
 a40:	e1 14       	cp	r14, r1
 a42:	f1 04       	cpc	r15, r1
 a44:	b9 f4       	brne	.+46     	; 0xa74 <xTaskIncrementTick+0x66>
 a46:	80 91 b1 07 	lds	r24, 0x07B1	; 0x8007b1 <pxDelayedTaskList>
 a4a:	90 91 b2 07 	lds	r25, 0x07B2	; 0x8007b2 <pxDelayedTaskList+0x1>
 a4e:	20 91 af 07 	lds	r18, 0x07AF	; 0x8007af <pxOverflowDelayedTaskList>
 a52:	30 91 b0 07 	lds	r19, 0x07B0	; 0x8007b0 <pxOverflowDelayedTaskList+0x1>
 a56:	30 93 b2 07 	sts	0x07B2, r19	; 0x8007b2 <pxDelayedTaskList+0x1>
 a5a:	20 93 b1 07 	sts	0x07B1, r18	; 0x8007b1 <pxDelayedTaskList>
 a5e:	90 93 b0 07 	sts	0x07B0, r25	; 0x8007b0 <pxOverflowDelayedTaskList+0x1>
 a62:	80 93 af 07 	sts	0x07AF, r24	; 0x8007af <pxOverflowDelayedTaskList>
 a66:	80 91 8b 07 	lds	r24, 0x078B	; 0x80078b <xNumOfOverflows>
 a6a:	8f 5f       	subi	r24, 0xFF	; 255
 a6c:	80 93 8b 07 	sts	0x078B, r24	; 0x80078b <xNumOfOverflows>
 a70:	0e 94 65 03 	call	0x6ca	; 0x6ca <prvResetNextTaskUnblockTime>
 a74:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xNextTaskUnblockTime>
 a78:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <xNextTaskUnblockTime+0x1>
 a7c:	e8 16       	cp	r14, r24
 a7e:	f9 06       	cpc	r15, r25
 a80:	10 f4       	brcc	.+4      	; 0xa86 <xTaskIncrementTick+0x78>
 a82:	d1 2c       	mov	r13, r1
 a84:	53 c0       	rjmp	.+166    	; 0xb2c <xTaskIncrementTick+0x11e>
 a86:	d1 2c       	mov	r13, r1
 a88:	cc 24       	eor	r12, r12
 a8a:	c3 94       	inc	r12
 a8c:	e0 91 b1 07 	lds	r30, 0x07B1	; 0x8007b1 <pxDelayedTaskList>
 a90:	f0 91 b2 07 	lds	r31, 0x07B2	; 0x8007b2 <pxDelayedTaskList+0x1>
 a94:	80 81       	ld	r24, Z
 a96:	81 11       	cpse	r24, r1
 a98:	07 c0       	rjmp	.+14     	; 0xaa8 <xTaskIncrementTick+0x9a>
 a9a:	8f ef       	ldi	r24, 0xFF	; 255
 a9c:	9f ef       	ldi	r25, 0xFF	; 255
 a9e:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
 aa2:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
 aa6:	42 c0       	rjmp	.+132    	; 0xb2c <xTaskIncrementTick+0x11e>
 aa8:	e0 91 b1 07 	lds	r30, 0x07B1	; 0x8007b1 <pxDelayedTaskList>
 aac:	f0 91 b2 07 	lds	r31, 0x07B2	; 0x8007b2 <pxDelayedTaskList+0x1>
 ab0:	05 80       	ldd	r0, Z+5	; 0x05
 ab2:	f6 81       	ldd	r31, Z+6	; 0x06
 ab4:	e0 2d       	mov	r30, r0
 ab6:	c6 81       	ldd	r28, Z+6	; 0x06
 ab8:	d7 81       	ldd	r29, Z+7	; 0x07
 aba:	8a 81       	ldd	r24, Y+2	; 0x02
 abc:	9b 81       	ldd	r25, Y+3	; 0x03
 abe:	e8 16       	cp	r14, r24
 ac0:	f9 06       	cpc	r15, r25
 ac2:	28 f4       	brcc	.+10     	; 0xace <xTaskIncrementTick+0xc0>
 ac4:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
 ac8:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
 acc:	2f c0       	rjmp	.+94     	; 0xb2c <xTaskIncrementTick+0x11e>
 ace:	8e 01       	movw	r16, r28
 ad0:	0e 5f       	subi	r16, 0xFE	; 254
 ad2:	1f 4f       	sbci	r17, 0xFF	; 255
 ad4:	c8 01       	movw	r24, r16
 ad6:	0e 94 0a 01 	call	0x214	; 0x214 <uxListRemove>
 ada:	8c 89       	ldd	r24, Y+20	; 0x14
 adc:	9d 89       	ldd	r25, Y+21	; 0x15
 ade:	89 2b       	or	r24, r25
 ae0:	21 f0       	breq	.+8      	; 0xaea <xTaskIncrementTick+0xdc>
 ae2:	ce 01       	movw	r24, r28
 ae4:	0c 96       	adiw	r24, 0x0c	; 12
 ae6:	0e 94 0a 01 	call	0x214	; 0x214 <uxListRemove>
 aea:	8e 89       	ldd	r24, Y+22	; 0x16
 aec:	90 91 8f 07 	lds	r25, 0x078F	; 0x80078f <uxTopReadyPriority>
 af0:	98 17       	cp	r25, r24
 af2:	10 f4       	brcc	.+4      	; 0xaf8 <xTaskIncrementTick+0xea>
 af4:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <uxTopReadyPriority>
 af8:	90 e0       	ldi	r25, 0x00	; 0
 afa:	9c 01       	movw	r18, r24
 afc:	22 0f       	add	r18, r18
 afe:	33 1f       	adc	r19, r19
 b00:	22 0f       	add	r18, r18
 b02:	33 1f       	adc	r19, r19
 b04:	22 0f       	add	r18, r18
 b06:	33 1f       	adc	r19, r19
 b08:	82 0f       	add	r24, r18
 b0a:	93 1f       	adc	r25, r19
 b0c:	b8 01       	movw	r22, r16
 b0e:	8b 53       	subi	r24, 0x3B	; 59
 b10:	98 4f       	sbci	r25, 0xF8	; 248
 b12:	0e 94 b8 00 	call	0x170	; 0x170 <vListInsertEnd>
 b16:	e0 91 e9 07 	lds	r30, 0x07E9	; 0x8007e9 <pxCurrentTCB>
 b1a:	f0 91 ea 07 	lds	r31, 0x07EA	; 0x8007ea <pxCurrentTCB+0x1>
 b1e:	9e 89       	ldd	r25, Y+22	; 0x16
 b20:	86 89       	ldd	r24, Z+22	; 0x16
 b22:	98 17       	cp	r25, r24
 b24:	08 f4       	brcc	.+2      	; 0xb28 <xTaskIncrementTick+0x11a>
 b26:	b2 cf       	rjmp	.-156    	; 0xa8c <xTaskIncrementTick+0x7e>
 b28:	dc 2c       	mov	r13, r12
 b2a:	b0 cf       	rjmp	.-160    	; 0xa8c <xTaskIncrementTick+0x7e>
 b2c:	e0 91 e9 07 	lds	r30, 0x07E9	; 0x8007e9 <pxCurrentTCB>
 b30:	f0 91 ea 07 	lds	r31, 0x07EA	; 0x8007ea <pxCurrentTCB+0x1>
 b34:	86 89       	ldd	r24, Z+22	; 0x16
 b36:	90 e0       	ldi	r25, 0x00	; 0
 b38:	fc 01       	movw	r30, r24
 b3a:	ee 0f       	add	r30, r30
 b3c:	ff 1f       	adc	r31, r31
 b3e:	ee 0f       	add	r30, r30
 b40:	ff 1f       	adc	r31, r31
 b42:	ee 0f       	add	r30, r30
 b44:	ff 1f       	adc	r31, r31
 b46:	8e 0f       	add	r24, r30
 b48:	9f 1f       	adc	r25, r31
 b4a:	fc 01       	movw	r30, r24
 b4c:	eb 53       	subi	r30, 0x3B	; 59
 b4e:	f8 4f       	sbci	r31, 0xF8	; 248
 b50:	80 81       	ld	r24, Z
 b52:	82 30       	cpi	r24, 0x02	; 2
 b54:	48 f0       	brcs	.+18     	; 0xb68 <xTaskIncrementTick+0x15a>
 b56:	dd 24       	eor	r13, r13
 b58:	d3 94       	inc	r13
 b5a:	06 c0       	rjmp	.+12     	; 0xb68 <xTaskIncrementTick+0x15a>
 b5c:	80 91 8d 07 	lds	r24, 0x078D	; 0x80078d <uxPendedTicks>
 b60:	8f 5f       	subi	r24, 0xFF	; 255
 b62:	80 93 8d 07 	sts	0x078D, r24	; 0x80078d <uxPendedTicks>
 b66:	d1 2c       	mov	r13, r1
 b68:	80 91 8c 07 	lds	r24, 0x078C	; 0x80078c <xYieldPending>
 b6c:	88 23       	and	r24, r24
 b6e:	11 f0       	breq	.+4      	; 0xb74 <xTaskIncrementTick+0x166>
 b70:	dd 24       	eor	r13, r13
 b72:	d3 94       	inc	r13
 b74:	8d 2d       	mov	r24, r13
 b76:	df 91       	pop	r29
 b78:	cf 91       	pop	r28
 b7a:	1f 91       	pop	r17
 b7c:	0f 91       	pop	r16
 b7e:	ff 90       	pop	r15
 b80:	ef 90       	pop	r14
 b82:	df 90       	pop	r13
 b84:	cf 90       	pop	r12
 b86:	08 95       	ret

00000b88 <xTaskResumeAll>:
 b88:	df 92       	push	r13
 b8a:	ef 92       	push	r14
 b8c:	ff 92       	push	r15
 b8e:	0f 93       	push	r16
 b90:	1f 93       	push	r17
 b92:	cf 93       	push	r28
 b94:	df 93       	push	r29
 b96:	0f b6       	in	r0, 0x3f	; 63
 b98:	f8 94       	cli
 b9a:	0f 92       	push	r0
 b9c:	80 91 89 07 	lds	r24, 0x0789	; 0x800789 <uxSchedulerSuspended>
 ba0:	81 50       	subi	r24, 0x01	; 1
 ba2:	80 93 89 07 	sts	0x0789, r24	; 0x800789 <uxSchedulerSuspended>
 ba6:	80 91 89 07 	lds	r24, 0x0789	; 0x800789 <uxSchedulerSuspended>
 baa:	81 11       	cpse	r24, r1
 bac:	62 c0       	rjmp	.+196    	; 0xc72 <xTaskResumeAll+0xea>
 bae:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <uxCurrentNumberOfTasks>
 bb2:	81 11       	cpse	r24, r1
 bb4:	33 c0       	rjmp	.+102    	; 0xc1c <xTaskResumeAll+0x94>
 bb6:	60 c0       	rjmp	.+192    	; 0xc78 <xTaskResumeAll+0xf0>
 bb8:	d7 01       	movw	r26, r14
 bba:	15 96       	adiw	r26, 0x05	; 5
 bbc:	ed 91       	ld	r30, X+
 bbe:	fc 91       	ld	r31, X
 bc0:	16 97       	sbiw	r26, 0x06	; 6
 bc2:	c6 81       	ldd	r28, Z+6	; 0x06
 bc4:	d7 81       	ldd	r29, Z+7	; 0x07
 bc6:	ce 01       	movw	r24, r28
 bc8:	0c 96       	adiw	r24, 0x0c	; 12
 bca:	0e 94 0a 01 	call	0x214	; 0x214 <uxListRemove>
 bce:	8e 01       	movw	r16, r28
 bd0:	0e 5f       	subi	r16, 0xFE	; 254
 bd2:	1f 4f       	sbci	r17, 0xFF	; 255
 bd4:	c8 01       	movw	r24, r16
 bd6:	0e 94 0a 01 	call	0x214	; 0x214 <uxListRemove>
 bda:	8e 89       	ldd	r24, Y+22	; 0x16
 bdc:	90 91 8f 07 	lds	r25, 0x078F	; 0x80078f <uxTopReadyPriority>
 be0:	98 17       	cp	r25, r24
 be2:	10 f4       	brcc	.+4      	; 0xbe8 <xTaskResumeAll+0x60>
 be4:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <uxTopReadyPriority>
 be8:	90 e0       	ldi	r25, 0x00	; 0
 bea:	9c 01       	movw	r18, r24
 bec:	22 0f       	add	r18, r18
 bee:	33 1f       	adc	r19, r19
 bf0:	22 0f       	add	r18, r18
 bf2:	33 1f       	adc	r19, r19
 bf4:	22 0f       	add	r18, r18
 bf6:	33 1f       	adc	r19, r19
 bf8:	82 0f       	add	r24, r18
 bfa:	93 1f       	adc	r25, r19
 bfc:	b8 01       	movw	r22, r16
 bfe:	8b 53       	subi	r24, 0x3B	; 59
 c00:	98 4f       	sbci	r25, 0xF8	; 248
 c02:	0e 94 b8 00 	call	0x170	; 0x170 <vListInsertEnd>
 c06:	e0 91 e9 07 	lds	r30, 0x07E9	; 0x8007e9 <pxCurrentTCB>
 c0a:	f0 91 ea 07 	lds	r31, 0x07EA	; 0x8007ea <pxCurrentTCB+0x1>
 c0e:	9e 89       	ldd	r25, Y+22	; 0x16
 c10:	86 89       	ldd	r24, Z+22	; 0x16
 c12:	98 17       	cp	r25, r24
 c14:	58 f0       	brcs	.+22     	; 0xc2c <xTaskResumeAll+0xa4>
 c16:	d0 92 8c 07 	sts	0x078C, r13	; 0x80078c <xYieldPending>
 c1a:	08 c0       	rjmp	.+16     	; 0xc2c <xTaskResumeAll+0xa4>
 c1c:	0f 2e       	mov	r0, r31
 c1e:	f6 ea       	ldi	r31, 0xA6	; 166
 c20:	ef 2e       	mov	r14, r31
 c22:	f7 e0       	ldi	r31, 0x07	; 7
 c24:	ff 2e       	mov	r15, r31
 c26:	f0 2d       	mov	r31, r0
 c28:	dd 24       	eor	r13, r13
 c2a:	d3 94       	inc	r13
 c2c:	f7 01       	movw	r30, r14
 c2e:	80 81       	ld	r24, Z
 c30:	81 11       	cpse	r24, r1
 c32:	c2 cf       	rjmp	.-124    	; 0xbb8 <xTaskResumeAll+0x30>
 c34:	80 91 8d 07 	lds	r24, 0x078D	; 0x80078d <uxPendedTicks>
 c38:	88 23       	and	r24, r24
 c3a:	99 f0       	breq	.+38     	; 0xc62 <xTaskResumeAll+0xda>
 c3c:	80 91 8d 07 	lds	r24, 0x078D	; 0x80078d <uxPendedTicks>
 c40:	88 23       	and	r24, r24
 c42:	79 f0       	breq	.+30     	; 0xc62 <xTaskResumeAll+0xda>
 c44:	c1 e0       	ldi	r28, 0x01	; 1
 c46:	0e 94 07 05 	call	0xa0e	; 0xa0e <xTaskIncrementTick>
 c4a:	81 11       	cpse	r24, r1
 c4c:	c0 93 8c 07 	sts	0x078C, r28	; 0x80078c <xYieldPending>
 c50:	80 91 8d 07 	lds	r24, 0x078D	; 0x80078d <uxPendedTicks>
 c54:	81 50       	subi	r24, 0x01	; 1
 c56:	80 93 8d 07 	sts	0x078D, r24	; 0x80078d <uxPendedTicks>
 c5a:	80 91 8d 07 	lds	r24, 0x078D	; 0x80078d <uxPendedTicks>
 c5e:	81 11       	cpse	r24, r1
 c60:	f2 cf       	rjmp	.-28     	; 0xc46 <xTaskResumeAll+0xbe>
 c62:	80 91 8c 07 	lds	r24, 0x078C	; 0x80078c <xYieldPending>
 c66:	81 30       	cpi	r24, 0x01	; 1
 c68:	31 f4       	brne	.+12     	; 0xc76 <xTaskResumeAll+0xee>
 c6a:	0e 94 d6 01 	call	0x3ac	; 0x3ac <vPortYield>
 c6e:	81 e0       	ldi	r24, 0x01	; 1
 c70:	03 c0       	rjmp	.+6      	; 0xc78 <xTaskResumeAll+0xf0>
 c72:	80 e0       	ldi	r24, 0x00	; 0
 c74:	01 c0       	rjmp	.+2      	; 0xc78 <xTaskResumeAll+0xf0>
 c76:	80 e0       	ldi	r24, 0x00	; 0
 c78:	0f 90       	pop	r0
 c7a:	0f be       	out	0x3f, r0	; 63
 c7c:	df 91       	pop	r29
 c7e:	cf 91       	pop	r28
 c80:	1f 91       	pop	r17
 c82:	0f 91       	pop	r16
 c84:	ff 90       	pop	r15
 c86:	ef 90       	pop	r14
 c88:	df 90       	pop	r13
 c8a:	08 95       	ret

00000c8c <vTaskDelayUntil>:
 c8c:	0f 93       	push	r16
 c8e:	1f 93       	push	r17
 c90:	cf 93       	push	r28
 c92:	df 93       	push	r29
 c94:	8c 01       	movw	r16, r24
 c96:	eb 01       	movw	r28, r22
 c98:	0e 94 f7 04 	call	0x9ee	; 0x9ee <vTaskSuspendAll>
 c9c:	20 91 90 07 	lds	r18, 0x0790	; 0x800790 <xTickCount>
 ca0:	30 91 91 07 	lds	r19, 0x0791	; 0x800791 <xTickCount+0x1>
 ca4:	f8 01       	movw	r30, r16
 ca6:	80 81       	ld	r24, Z
 ca8:	91 81       	ldd	r25, Z+1	; 0x01
 caa:	c8 0f       	add	r28, r24
 cac:	d9 1f       	adc	r29, r25
 cae:	28 17       	cp	r18, r24
 cb0:	39 07       	cpc	r19, r25
 cb2:	48 f4       	brcc	.+18     	; 0xcc6 <vTaskDelayUntil+0x3a>
 cb4:	c8 17       	cp	r28, r24
 cb6:	d9 07       	cpc	r29, r25
 cb8:	10 f5       	brcc	.+68     	; 0xcfe <vTaskDelayUntil+0x72>
 cba:	d1 83       	std	Z+1, r29	; 0x01
 cbc:	c0 83       	st	Z, r28
 cbe:	2c 17       	cp	r18, r28
 cc0:	3d 07       	cpc	r19, r29
 cc2:	90 f4       	brcc	.+36     	; 0xce8 <vTaskDelayUntil+0x5c>
 cc4:	07 c0       	rjmp	.+14     	; 0xcd4 <vTaskDelayUntil+0x48>
 cc6:	c8 17       	cp	r28, r24
 cc8:	d9 07       	cpc	r29, r25
 cca:	a8 f0       	brcs	.+42     	; 0xcf6 <vTaskDelayUntil+0x6a>
 ccc:	2c 17       	cp	r18, r28
 cce:	3d 07       	cpc	r19, r29
 cd0:	90 f0       	brcs	.+36     	; 0xcf6 <vTaskDelayUntil+0x6a>
 cd2:	15 c0       	rjmp	.+42     	; 0xcfe <vTaskDelayUntil+0x72>
 cd4:	80 91 e9 07 	lds	r24, 0x07E9	; 0x8007e9 <pxCurrentTCB>
 cd8:	90 91 ea 07 	lds	r25, 0x07EA	; 0x8007ea <pxCurrentTCB+0x1>
 cdc:	02 96       	adiw	r24, 0x02	; 2
 cde:	0e 94 0a 01 	call	0x214	; 0x214 <uxListRemove>
 ce2:	ce 01       	movw	r24, r28
 ce4:	0e 94 84 03 	call	0x708	; 0x708 <prvAddCurrentTaskToDelayedList>
 ce8:	0e 94 c4 05 	call	0xb88	; 0xb88 <xTaskResumeAll>
 cec:	81 11       	cpse	r24, r1
 cee:	0b c0       	rjmp	.+22     	; 0xd06 <vTaskDelayUntil+0x7a>
 cf0:	0e 94 d6 01 	call	0x3ac	; 0x3ac <vPortYield>
 cf4:	08 c0       	rjmp	.+16     	; 0xd06 <vTaskDelayUntil+0x7a>
 cf6:	f8 01       	movw	r30, r16
 cf8:	d1 83       	std	Z+1, r29	; 0x01
 cfa:	c0 83       	st	Z, r28
 cfc:	eb cf       	rjmp	.-42     	; 0xcd4 <vTaskDelayUntil+0x48>
 cfe:	f8 01       	movw	r30, r16
 d00:	d1 83       	std	Z+1, r29	; 0x01
 d02:	c0 83       	st	Z, r28
 d04:	f1 cf       	rjmp	.-30     	; 0xce8 <vTaskDelayUntil+0x5c>
 d06:	df 91       	pop	r29
 d08:	cf 91       	pop	r28
 d0a:	1f 91       	pop	r17
 d0c:	0f 91       	pop	r16
 d0e:	08 95       	ret

00000d10 <prvIdleTask>:
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 d10:	0d e9       	ldi	r16, 0x9D	; 157
 d12:	17 e0       	ldi	r17, 0x07	; 7

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 d14:	0f 2e       	mov	r0, r31
 d16:	f5 ec       	ldi	r31, 0xC5	; 197
 d18:	ef 2e       	mov	r14, r31
 d1a:	f7 e0       	ldi	r31, 0x07	; 7
 d1c:	ff 2e       	mov	r15, r31
 d1e:	f0 2d       	mov	r31, r0
 d20:	29 c0       	rjmp	.+82     	; 0xd74 <prvIdleTask+0x64>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
 d22:	0e 94 f7 04 	call	0x9ee	; 0x9ee <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 d26:	d8 01       	movw	r26, r16
 d28:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
 d2a:	0e 94 c4 05 	call	0xb88	; 0xb88 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 d2e:	cc 23       	and	r28, r28
 d30:	09 f1       	breq	.+66     	; 0xd74 <prvIdleTask+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 d32:	0f b6       	in	r0, 0x3f	; 63
 d34:	f8 94       	cli
 d36:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 d38:	d8 01       	movw	r26, r16
 d3a:	15 96       	adiw	r26, 0x05	; 5
 d3c:	ed 91       	ld	r30, X+
 d3e:	fc 91       	ld	r31, X
 d40:	16 97       	sbiw	r26, 0x06	; 6
 d42:	c6 81       	ldd	r28, Z+6	; 0x06
 d44:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 d46:	ce 01       	movw	r24, r28
 d48:	02 96       	adiw	r24, 0x02	; 2
 d4a:	0e 94 0a 01 	call	0x214	; 0x214 <uxListRemove>
					--uxCurrentNumberOfTasks;
 d4e:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <uxCurrentNumberOfTasks>
 d52:	81 50       	subi	r24, 0x01	; 1
 d54:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
 d58:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxTasksDeleted>
 d5c:	81 50       	subi	r24, 0x01	; 1
 d5e:	80 93 9c 07 	sts	0x079C, r24	; 0x80079c <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
 d62:	0f 90       	pop	r0
 d64:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
 d66:	8f 89       	ldd	r24, Y+23	; 0x17
 d68:	98 8d       	ldd	r25, Y+24	; 0x18
 d6a:	0e 94 32 03 	call	0x664	; 0x664 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
 d6e:	ce 01       	movw	r24, r28
 d70:	0e 94 32 03 	call	0x664	; 0x664 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 d74:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxTasksDeleted>
 d78:	81 11       	cpse	r24, r1
 d7a:	d3 cf       	rjmp	.-90     	; 0xd22 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 d7c:	f7 01       	movw	r30, r14
 d7e:	80 81       	ld	r24, Z
 d80:	82 30       	cpi	r24, 0x02	; 2
 d82:	c0 f3       	brcs	.-16     	; 0xd74 <prvIdleTask+0x64>
			{
				taskYIELD();
 d84:	0e 94 d6 01 	call	0x3ac	; 0x3ac <vPortYield>
 d88:	f5 cf       	rjmp	.-22     	; 0xd74 <prvIdleTask+0x64>

00000d8a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 d8a:	80 91 89 07 	lds	r24, 0x0789	; 0x800789 <uxSchedulerSuspended>
 d8e:	88 23       	and	r24, r24
 d90:	21 f0       	breq	.+8      	; 0xd9a <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 d92:	81 e0       	ldi	r24, 0x01	; 1
 d94:	80 93 8c 07 	sts	0x078C, r24	; 0x80078c <xYieldPending>
 d98:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 d9a:	10 92 8c 07 	sts	0x078C, r1	; 0x80078c <xYieldPending>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 d9e:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxTopReadyPriority>
 da2:	90 e0       	ldi	r25, 0x00	; 0
 da4:	fc 01       	movw	r30, r24
 da6:	ee 0f       	add	r30, r30
 da8:	ff 1f       	adc	r31, r31
 daa:	ee 0f       	add	r30, r30
 dac:	ff 1f       	adc	r31, r31
 dae:	ee 0f       	add	r30, r30
 db0:	ff 1f       	adc	r31, r31
 db2:	8e 0f       	add	r24, r30
 db4:	9f 1f       	adc	r25, r31
 db6:	fc 01       	movw	r30, r24
 db8:	eb 53       	subi	r30, 0x3B	; 59
 dba:	f8 4f       	sbci	r31, 0xF8	; 248
 dbc:	80 81       	ld	r24, Z
 dbe:	81 11       	cpse	r24, r1
 dc0:	17 c0       	rjmp	.+46     	; 0xdf0 <vTaskSwitchContext+0x66>
 dc2:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxTopReadyPriority>
 dc6:	81 50       	subi	r24, 0x01	; 1
 dc8:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <uxTopReadyPriority>
 dcc:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxTopReadyPriority>
 dd0:	90 e0       	ldi	r25, 0x00	; 0
 dd2:	fc 01       	movw	r30, r24
 dd4:	ee 0f       	add	r30, r30
 dd6:	ff 1f       	adc	r31, r31
 dd8:	ee 0f       	add	r30, r30
 dda:	ff 1f       	adc	r31, r31
 ddc:	ee 0f       	add	r30, r30
 dde:	ff 1f       	adc	r31, r31
 de0:	8e 0f       	add	r24, r30
 de2:	9f 1f       	adc	r25, r31
 de4:	fc 01       	movw	r30, r24
 de6:	eb 53       	subi	r30, 0x3B	; 59
 de8:	f8 4f       	sbci	r31, 0xF8	; 248
 dea:	80 81       	ld	r24, Z
 dec:	88 23       	and	r24, r24
 dee:	49 f3       	breq	.-46     	; 0xdc2 <vTaskSwitchContext+0x38>
 df0:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxTopReadyPriority>
 df4:	90 e0       	ldi	r25, 0x00	; 0
 df6:	9c 01       	movw	r18, r24
 df8:	22 0f       	add	r18, r18
 dfa:	33 1f       	adc	r19, r19
 dfc:	22 0f       	add	r18, r18
 dfe:	33 1f       	adc	r19, r19
 e00:	22 0f       	add	r18, r18
 e02:	33 1f       	adc	r19, r19
 e04:	28 0f       	add	r18, r24
 e06:	39 1f       	adc	r19, r25
 e08:	d9 01       	movw	r26, r18
 e0a:	ab 53       	subi	r26, 0x3B	; 59
 e0c:	b8 4f       	sbci	r27, 0xF8	; 248
 e0e:	11 96       	adiw	r26, 0x01	; 1
 e10:	ed 91       	ld	r30, X+
 e12:	fc 91       	ld	r31, X
 e14:	12 97       	sbiw	r26, 0x02	; 2
 e16:	02 80       	ldd	r0, Z+2	; 0x02
 e18:	f3 81       	ldd	r31, Z+3	; 0x03
 e1a:	e0 2d       	mov	r30, r0
 e1c:	12 96       	adiw	r26, 0x02	; 2
 e1e:	fc 93       	st	X, r31
 e20:	ee 93       	st	-X, r30
 e22:	11 97       	sbiw	r26, 0x01	; 1
 e24:	28 53       	subi	r18, 0x38	; 56
 e26:	38 4f       	sbci	r19, 0xF8	; 248
 e28:	e2 17       	cp	r30, r18
 e2a:	f3 07       	cpc	r31, r19
 e2c:	29 f4       	brne	.+10     	; 0xe38 <vTaskSwitchContext+0xae>
 e2e:	22 81       	ldd	r18, Z+2	; 0x02
 e30:	33 81       	ldd	r19, Z+3	; 0x03
 e32:	fd 01       	movw	r30, r26
 e34:	32 83       	std	Z+2, r19	; 0x02
 e36:	21 83       	std	Z+1, r18	; 0x01
 e38:	fc 01       	movw	r30, r24
 e3a:	ee 0f       	add	r30, r30
 e3c:	ff 1f       	adc	r31, r31
 e3e:	ee 0f       	add	r30, r30
 e40:	ff 1f       	adc	r31, r31
 e42:	ee 0f       	add	r30, r30
 e44:	ff 1f       	adc	r31, r31
 e46:	8e 0f       	add	r24, r30
 e48:	9f 1f       	adc	r25, r31
 e4a:	fc 01       	movw	r30, r24
 e4c:	eb 53       	subi	r30, 0x3B	; 59
 e4e:	f8 4f       	sbci	r31, 0xF8	; 248
 e50:	01 80       	ldd	r0, Z+1	; 0x01
 e52:	f2 81       	ldd	r31, Z+2	; 0x02
 e54:	e0 2d       	mov	r30, r0
 e56:	86 81       	ldd	r24, Z+6	; 0x06
 e58:	97 81       	ldd	r25, Z+7	; 0x07
 e5a:	90 93 ea 07 	sts	0x07EA, r25	; 0x8007ea <pxCurrentTCB+0x1>
 e5e:	80 93 e9 07 	sts	0x07E9, r24	; 0x8007e9 <pxCurrentTCB>
 e62:	08 95       	ret

00000e64 <USART_init>:



void USART_init(void){
	
	UBRR0H = (uint8_t)(BAUD_PRESCALLER>>8);
 e64:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
	UBRR0L = (uint8_t)(BAUD_PRESCALLER);
 e68:	87 e6       	ldi	r24, 0x67	; 103
 e6a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	UCSR0B = (1<<RXEN0)|(1<<TXEN0)|(1<<UCSZ02);
 e6e:	8c e1       	ldi	r24, 0x1C	; 28
 e70:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));
 e74:	86 e0       	ldi	r24, 0x06	; 6
 e76:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 e7a:	08 95       	ret

00000e7c <USART_send>:
	}
}

void USART_send( unsigned char data){
	
	while(!(UCSR0A & (1<<UDRE0)));
 e7c:	e0 ec       	ldi	r30, 0xC0	; 192
 e7e:	f0 e0       	ldi	r31, 0x00	; 0
 e80:	90 81       	ld	r25, Z
 e82:	95 ff       	sbrs	r25, 5
 e84:	fd cf       	rjmp	.-6      	; 0xe80 <USART_send+0x4>
	UDR0 = data;
 e86:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
 e8a:	08 95       	ret

00000e8c <USART_sendstr>:
	UCSR0B = (1<<RXEN0)|(1<<TXEN0)|(1<<UCSZ02);
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));
}


void USART_sendstr( unsigned char* str){
 e8c:	cf 93       	push	r28
 e8e:	df 93       	push	r29
 e90:	ec 01       	movw	r28, r24
	int i =0;
	
	while (str[i] != 0x00)
 e92:	88 81       	ld	r24, Y
 e94:	88 23       	and	r24, r24
 e96:	31 f0       	breq	.+12     	; 0xea4 <USART_sendstr+0x18>
 e98:	21 96       	adiw	r28, 0x01	; 1
	{
		USART_send(str[i]);
 e9a:	0e 94 3e 07 	call	0xe7c	; 0xe7c <USART_send>


void USART_sendstr( unsigned char* str){
	int i =0;
	
	while (str[i] != 0x00)
 e9e:	89 91       	ld	r24, Y+
 ea0:	81 11       	cpse	r24, r1
 ea2:	fb cf       	rjmp	.-10     	; 0xe9a <USART_sendstr+0xe>
	{
		USART_send(str[i]);
		i++;
	}
}
 ea4:	df 91       	pop	r29
 ea6:	cf 91       	pop	r28
 ea8:	08 95       	ret

00000eaa <_exit>:
 eaa:	f8 94       	cli

00000eac <__stop_program>:
 eac:	ff cf       	rjmp	.-2      	; 0xeac <__stop_program>

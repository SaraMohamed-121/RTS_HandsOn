
ArduinoUnoFreertos_6_1(2).elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000144  00800100  00001966  000019fa  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001966  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000658  00800244  00800244  00001b3e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001b3e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001b70  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003b0  00000000  00000000  00001bb0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004937  00000000  00000000  00001f60  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000011ea  00000000  00000000  00006897  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000028fe  00000000  00000000  00007a81  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b50  00000000  00000000  0000a380  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000016af  00000000  00000000  0000aed0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004650  00000000  00000000  0000c57f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003c0  00000000  00000000  00010bcf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 2b 0c 	jmp	0x1856	; 0x1856 <__vector_1>
       8:	0c 94 58 0c 	jmp	0x18b0	; 0x18b0 <__vector_2>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 37 03 	jmp	0x66e	; 0x66e <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	12 e0       	ldi	r17, 0x02	; 2
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e6 e6       	ldi	r30, 0x66	; 102
      7c:	f9 e1       	ldi	r31, 0x19	; 25
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a4 34       	cpi	r26, 0x44	; 68
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	28 e0       	ldi	r18, 0x08	; 8
      8c:	a4 e4       	ldi	r26, 0x44	; 68
      8e:	b2 e0       	ldi	r27, 0x02	; 2
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	ac 39       	cpi	r26, 0x9C	; 156
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 0c 01 	call	0x218	; 0x218 <main>
      9e:	0c 94 b1 0c 	jmp	0x1962	; 0x1962 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vEvenTask>:
    }
}


static void vEvenTask( void *pvParameters )
{
      a6:	cf 93       	push	r28
      a8:	df 93       	push	r29
      aa:	00 d0       	rcall	.+0      	; 0xac <vEvenTask+0x6>
      ac:	cd b7       	in	r28, 0x3d	; 61
      ae:	de b7       	in	r29, 0x3e	; 62
	USART_sendstr("Start Even Task \r\n");
      b0:	84 e0       	ldi	r24, 0x04	; 4
      b2:	91 e0       	ldi	r25, 0x01	; 1
      b4:	0e 94 99 0c 	call	0x1932	; 0x1932 <USART_sendstr>
	TickType_t xLastWakeTime = xTaskGetTickCount();
      b8:	0e 94 63 08 	call	0x10c6	; 0x10c6 <xTaskGetTickCount>
      bc:	9a 83       	std	Y+2, r25	; 0x02
      be:	89 83       	std	Y+1, r24	; 0x01
	
	if( xSemaphoreGive(sem))
      c0:	20 e0       	ldi	r18, 0x00	; 0
      c2:	40 e0       	ldi	r20, 0x00	; 0
      c4:	50 e0       	ldi	r21, 0x00	; 0
      c6:	60 e0       	ldi	r22, 0x00	; 0
      c8:	70 e0       	ldi	r23, 0x00	; 0
      ca:	80 91 92 08 	lds	r24, 0x0892	; 0x800892 <sem>
      ce:	90 91 93 08 	lds	r25, 0x0893	; 0x800893 <sem+0x1>
      d2:	0e 94 36 05 	call	0xa6c	; 0xa6c <xQueueGenericSend>
      d6:	88 23       	and	r24, r24
      d8:	31 f0       	breq	.+12     	; 0xe6 <vEvenTask+0x40>
	   USART_sendstr("Semaphore is released by Even Task \r\n");
      da:	87 e1       	ldi	r24, 0x17	; 23
      dc:	91 e0       	ldi	r25, 0x01	; 1
      de:	0e 94 99 0c 	call	0x1932	; 0x1932 <USART_sendstr>
	{
		 USART_sendstr("Even \r\n");
		/* Block waiting for the semaphore to become available. */
		if( xSemaphoreTake(sem, LONG_TIME ) == pdTRUE )
		{
			PORTC = 0xAA;
      e2:	1a ea       	ldi	r17, 0xAA	; 170
      e4:	05 c0       	rjmp	.+10     	; 0xf0 <vEvenTask+0x4a>
	TickType_t xLastWakeTime = xTaskGetTickCount();
	
	if( xSemaphoreGive(sem))
	   USART_sendstr("Semaphore is released by Even Task \r\n");
	else
	   USART_sendstr("Semaphore can not release by Even Task \r\n");
      e6:	8d e3       	ldi	r24, 0x3D	; 61
      e8:	91 e0       	ldi	r25, 0x01	; 1
      ea:	0e 94 99 0c 	call	0x1932	; 0x1932 <USART_sendstr>
      ee:	f9 cf       	rjmp	.-14     	; 0xe2 <vEvenTask+0x3c>
	   
	
	for( ;; )
	{
		 USART_sendstr("Even \r\n");
      f0:	87 e6       	ldi	r24, 0x67	; 103
      f2:	91 e0       	ldi	r25, 0x01	; 1
      f4:	0e 94 99 0c 	call	0x1932	; 0x1932 <USART_sendstr>
		/* Block waiting for the semaphore to become available. */
		if( xSemaphoreTake(sem, LONG_TIME ) == pdTRUE )
      f8:	20 e0       	ldi	r18, 0x00	; 0
      fa:	4f ef       	ldi	r20, 0xFF	; 255
      fc:	5f ef       	ldi	r21, 0xFF	; 255
      fe:	60 e0       	ldi	r22, 0x00	; 0
     100:	70 e0       	ldi	r23, 0x00	; 0
     102:	80 91 92 08 	lds	r24, 0x0892	; 0x800892 <sem>
     106:	90 91 93 08 	lds	r25, 0x0893	; 0x800893 <sem+0x1>
     10a:	0e 94 02 06 	call	0xc04	; 0xc04 <xQueueGenericReceive>
     10e:	81 30       	cpi	r24, 0x01	; 1
     110:	79 f7       	brne	.-34     	; 0xf0 <vEvenTask+0x4a>
		{
			PORTC = 0xAA;
     112:	18 b9       	out	0x08, r17	; 8
			USART_sendstr("Semaphore is given to Even Task \r\n");
     114:	8f e6       	ldi	r24, 0x6F	; 111
     116:	91 e0       	ldi	r25, 0x01	; 1
     118:	0e 94 99 0c 	call	0x1932	; 0x1932 <USART_sendstr>
			
			if( xSemaphoreGive( sem ) != pdTRUE )
     11c:	20 e0       	ldi	r18, 0x00	; 0
     11e:	40 e0       	ldi	r20, 0x00	; 0
     120:	50 e0       	ldi	r21, 0x00	; 0
     122:	60 e0       	ldi	r22, 0x00	; 0
     124:	70 e0       	ldi	r23, 0x00	; 0
     126:	80 91 92 08 	lds	r24, 0x0892	; 0x800892 <sem>
     12a:	90 91 93 08 	lds	r25, 0x0893	; 0x800893 <sem+0x1>
     12e:	0e 94 36 05 	call	0xa6c	; 0xa6c <xQueueGenericSend>
     132:	81 30       	cpi	r24, 0x01	; 1
     134:	21 f0       	breq	.+8      	; 0x13e <vEvenTask+0x98>
				USART_sendstr("Semaphore can not release by Even Task \r\n");
     136:	8d e3       	ldi	r24, 0x3D	; 61
     138:	91 e0       	ldi	r25, 0x01	; 1
     13a:	0e 94 99 0c 	call	0x1932	; 0x1932 <USART_sendstr>
				
			vTaskDelayUntil(&xLastWakeTime, (100 / portTICK_PERIOD_MS));
     13e:	64 e6       	ldi	r22, 0x64	; 100
     140:	70 e0       	ldi	r23, 0x00	; 0
     142:	ce 01       	movw	r24, r28
     144:	01 96       	adiw	r24, 0x01	; 1
     146:	0e 94 ac 09 	call	0x1358	; 0x1358 <vTaskDelayUntil>
     14a:	d2 cf       	rjmp	.-92     	; 0xf0 <vEvenTask+0x4a>

0000014c <vOddTask>:




static void vOddTask( void *pvParameters )
{
     14c:	cf 93       	push	r28
     14e:	df 93       	push	r29
     150:	00 d0       	rcall	.+0      	; 0x152 <vOddTask+0x6>
     152:	cd b7       	in	r28, 0x3d	; 61
     154:	de b7       	in	r29, 0x3e	; 62
  USART_sendstr("Start Odd Task \r\n");
     156:	82 e9       	ldi	r24, 0x92	; 146
     158:	91 e0       	ldi	r25, 0x01	; 1
     15a:	0e 94 99 0c 	call	0x1932	; 0x1932 <USART_sendstr>
  TickType_t xLastWakeTime = xTaskGetTickCount();
     15e:	0e 94 63 08 	call	0x10c6	; 0x10c6 <xTaskGetTickCount>
     162:	9a 83       	std	Y+2, r25	; 0x02
     164:	89 83       	std	Y+1, r24	; 0x01
    {
       /* Block waiting for the semaphore to become available. */
	   USART_sendstr("Odd \r\n");
        if( xSemaphoreTake(sem, LONG_TIME ) == pdTRUE )
        {
			PORTC = 0x55;
     166:	15 e5       	ldi	r17, 0x55	; 85
  TickType_t xLastWakeTime = xTaskGetTickCount();
	 
  for( ;; )
    {
       /* Block waiting for the semaphore to become available. */
	   USART_sendstr("Odd \r\n");
     168:	84 ea       	ldi	r24, 0xA4	; 164
     16a:	91 e0       	ldi	r25, 0x01	; 1
     16c:	0e 94 99 0c 	call	0x1932	; 0x1932 <USART_sendstr>
        if( xSemaphoreTake(sem, LONG_TIME ) == pdTRUE )
     170:	20 e0       	ldi	r18, 0x00	; 0
     172:	4f ef       	ldi	r20, 0xFF	; 255
     174:	5f ef       	ldi	r21, 0xFF	; 255
     176:	60 e0       	ldi	r22, 0x00	; 0
     178:	70 e0       	ldi	r23, 0x00	; 0
     17a:	80 91 92 08 	lds	r24, 0x0892	; 0x800892 <sem>
     17e:	90 91 93 08 	lds	r25, 0x0893	; 0x800893 <sem+0x1>
     182:	0e 94 02 06 	call	0xc04	; 0xc04 <xQueueGenericReceive>
     186:	81 30       	cpi	r24, 0x01	; 1
     188:	79 f7       	brne	.-34     	; 0x168 <vOddTask+0x1c>
        {
			PORTC = 0x55;
     18a:	18 b9       	out	0x08, r17	; 8
            USART_sendstr("Semaphore is given to Odd Task \r\n");
     18c:	8b ea       	ldi	r24, 0xAB	; 171
     18e:	91 e0       	ldi	r25, 0x01	; 1
     190:	0e 94 99 0c 	call	0x1932	; 0x1932 <USART_sendstr>
		    vTaskDelayUntil(&xLastWakeTime, (2000 / portTICK_PERIOD_MS));
     194:	60 ed       	ldi	r22, 0xD0	; 208
     196:	77 e0       	ldi	r23, 0x07	; 7
     198:	ce 01       	movw	r24, r28
     19a:	01 96       	adiw	r24, 0x01	; 1
     19c:	0e 94 ac 09 	call	0x1358	; 0x1358 <vTaskDelayUntil>
     1a0:	e3 cf       	rjmp	.-58     	; 0x168 <vOddTask+0x1c>

000001a2 <vTimerISR>:
unsigned long lastInterrupt;


static void vTimerISR()
{
	if(xTaskGetTickCount() - lastInterrupt > 500) // we set a 10ms no-interrupts window
     1a2:	0e 94 63 08 	call	0x10c6	; 0x10c6 <xTaskGetTickCount>
     1a6:	a0 e0       	ldi	r26, 0x00	; 0
     1a8:	b0 e0       	ldi	r27, 0x00	; 0
     1aa:	40 91 96 08 	lds	r20, 0x0896	; 0x800896 <lastInterrupt>
     1ae:	50 91 97 08 	lds	r21, 0x0897	; 0x800897 <lastInterrupt+0x1>
     1b2:	60 91 98 08 	lds	r22, 0x0898	; 0x800898 <lastInterrupt+0x2>
     1b6:	70 91 99 08 	lds	r23, 0x0899	; 0x800899 <lastInterrupt+0x3>
     1ba:	84 1b       	sub	r24, r20
     1bc:	95 0b       	sbc	r25, r21
     1be:	a6 0b       	sbc	r26, r22
     1c0:	b7 0b       	sbc	r27, r23
     1c2:	85 3f       	cpi	r24, 0xF5	; 245
     1c4:	91 40       	sbci	r25, 0x01	; 1
     1c6:	a1 05       	cpc	r26, r1
     1c8:	b1 05       	cpc	r27, r1
     1ca:	28 f1       	brcs	.+74     	; 0x216 <vTimerISR+0x74>
	{
    USART_sendstr("interrupt Happened \r\n");
     1cc:	8d ec       	ldi	r24, 0xCD	; 205
     1ce:	91 e0       	ldi	r25, 0x01	; 1
     1d0:	0e 94 99 0c 	call	0x1932	; 0x1932 <USART_sendstr>
    /* A timer tick has occurred. */

    /*..Do other time functions..*/ 

    /* Is it time for vATask() to run? */
    xHigherPriorityTaskWoken = pdFALSE;
     1d4:	10 92 44 02 	sts	0x0244, r1	; 0x800244 <__data_end>
  
        /* Unblock the task by releasing the semaphore. */
        xSemaphoreGiveFromISR( sem, &xHigherPriorityTaskWoken );
     1d8:	64 e4       	ldi	r22, 0x44	; 68
     1da:	72 e0       	ldi	r23, 0x02	; 2
     1dc:	80 91 92 08 	lds	r24, 0x0892	; 0x800892 <sem>
     1e0:	90 91 93 08 	lds	r25, 0x0893	; 0x800893 <sem+0x1>
     1e4:	0e 94 d7 05 	call	0xbae	; 0xbae <xQueueGiveFromISR>

    /* If xHigherPriorityTaskWoken was set to true you
    we should yield.  The actual macro used here is
    port specific. */
	
	lastInterrupt = xTaskGetTickCount();
     1e8:	0e 94 63 08 	call	0x10c6	; 0x10c6 <xTaskGetTickCount>
     1ec:	a0 e0       	ldi	r26, 0x00	; 0
     1ee:	b0 e0       	ldi	r27, 0x00	; 0
     1f0:	80 93 96 08 	sts	0x0896, r24	; 0x800896 <lastInterrupt>
     1f4:	90 93 97 08 	sts	0x0897, r25	; 0x800897 <lastInterrupt+0x1>
     1f8:	a0 93 98 08 	sts	0x0898, r26	; 0x800898 <lastInterrupt+0x2>
     1fc:	b0 93 99 08 	sts	0x0899, r27	; 0x800899 <lastInterrupt+0x3>
	if(xHigherPriorityTaskWoken)
     200:	80 91 44 02 	lds	r24, 0x0244	; 0x800244 <__data_end>
     204:	88 23       	and	r24, r24
     206:	19 f0       	breq	.+6      	; 0x20e <vTimerISR+0x6c>
       vPortYield();
     208:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
     20c:	08 95       	ret
	else
	   USART_sendstr("No Higher Priority Task is Woken \r\n");
     20e:	83 ee       	ldi	r24, 0xE3	; 227
     210:	91 e0       	ldi	r25, 0x01	; 1
     212:	0e 94 99 0c 	call	0x1932	; 0x1932 <USART_sendstr>
     216:	08 95       	ret

00000218 <main>:
TaskHandle_t TaskHandle_2;

SemaphoreHandle_t sem;
int main(void)
{ 
  cli();
     218:	f8 94       	cli
  attachInterrupt(0, vTimerISR, 1); 
     21a:	41 e0       	ldi	r20, 0x01	; 1
     21c:	50 e0       	ldi	r21, 0x00	; 0
     21e:	61 ed       	ldi	r22, 0xD1	; 209
     220:	70 e0       	ldi	r23, 0x00	; 0
     222:	80 e0       	ldi	r24, 0x00	; 0
     224:	0e 94 08 0c 	call	0x1810	; 0x1810 <attachInterrupt>
  USART_init();
     228:	0e 94 85 0c 	call	0x190a	; 0x190a <USART_init>
  sem =  xSemaphoreCreateBinary();
     22c:	43 e0       	ldi	r20, 0x03	; 3
     22e:	60 e0       	ldi	r22, 0x00	; 0
     230:	81 e0       	ldi	r24, 0x01	; 1
     232:	0e 94 0a 05 	call	0xa14	; 0xa14 <xQueueGenericCreate>
     236:	90 93 93 08 	sts	0x0893, r25	; 0x800893 <sem+0x1>
     23a:	80 93 92 08 	sts	0x0892, r24	; 0x800892 <sem>
  if(sem != NULL){
     23e:	89 2b       	or	r24, r25
     240:	61 f1       	breq	.+88     	; 0x29a <main+0x82>
    DDRC = 0xff;
     242:	8f ef       	ldi	r24, 0xFF	; 255
     244:	87 b9       	out	0x07, r24	; 7
	xTaskCreate( vOddTask, "Odd", 256, NULL, 1, &TaskHandle_1 );
     246:	a1 2c       	mov	r10, r1
     248:	b1 2c       	mov	r11, r1
     24a:	c1 2c       	mov	r12, r1
     24c:	d1 2c       	mov	r13, r1
     24e:	0f 2e       	mov	r0, r31
     250:	fa e9       	ldi	r31, 0x9A	; 154
     252:	ef 2e       	mov	r14, r31
     254:	f8 e0       	ldi	r31, 0x08	; 8
     256:	ff 2e       	mov	r15, r31
     258:	f0 2d       	mov	r31, r0
     25a:	01 e0       	ldi	r16, 0x01	; 1
     25c:	20 e0       	ldi	r18, 0x00	; 0
     25e:	30 e0       	ldi	r19, 0x00	; 0
     260:	40 e0       	ldi	r20, 0x00	; 0
     262:	51 e0       	ldi	r21, 0x01	; 1
     264:	67 e0       	ldi	r22, 0x07	; 7
     266:	72 e0       	ldi	r23, 0x02	; 2
     268:	86 ea       	ldi	r24, 0xA6	; 166
     26a:	90 e0       	ldi	r25, 0x00	; 0
     26c:	0e 94 1b 07 	call	0xe36	; 0xe36 <xTaskGenericCreate>
	xTaskCreate( vEvenTask, "Even", 256, NULL, 3, &TaskHandle_2 );
     270:	0f 2e       	mov	r0, r31
     272:	f4 e9       	ldi	r31, 0x94	; 148
     274:	ef 2e       	mov	r14, r31
     276:	f8 e0       	ldi	r31, 0x08	; 8
     278:	ff 2e       	mov	r15, r31
     27a:	f0 2d       	mov	r31, r0
     27c:	03 e0       	ldi	r16, 0x03	; 3
     27e:	20 e0       	ldi	r18, 0x00	; 0
     280:	30 e0       	ldi	r19, 0x00	; 0
     282:	40 e0       	ldi	r20, 0x00	; 0
     284:	51 e0       	ldi	r21, 0x01	; 1
     286:	6b e0       	ldi	r22, 0x0B	; 11
     288:	72 e0       	ldi	r23, 0x02	; 2
     28a:	83 e5       	ldi	r24, 0x53	; 83
     28c:	90 e0       	ldi	r25, 0x00	; 0
     28e:	0e 94 1b 07 	call	0xe36	; 0xe36 <xTaskGenericCreate>
	sei();
     292:	78 94       	sei
	vTaskStartScheduler();
     294:	0e 94 2e 08 	call	0x105c	; 0x105c <vTaskStartScheduler>
     298:	04 c0       	rjmp	.+8      	; 0x2a2 <main+0x8a>
	 }
  else
	   USART_sendstr("Semaphore not Created Correctly !!");
     29a:	80 e1       	ldi	r24, 0x10	; 16
     29c:	92 e0       	ldi	r25, 0x02	; 2
     29e:	0e 94 99 0c 	call	0x1932	; 0x1932 <USART_sendstr>
     2a2:	ff cf       	rjmp	.-2      	; 0x2a2 <main+0x8a>

000002a4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     2a4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2a6:	03 96       	adiw	r24, 0x03	; 3
     2a8:	92 83       	std	Z+2, r25	; 0x02
     2aa:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     2ac:	2f ef       	ldi	r18, 0xFF	; 255
     2ae:	3f ef       	ldi	r19, 0xFF	; 255
     2b0:	34 83       	std	Z+4, r19	; 0x04
     2b2:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2b4:	96 83       	std	Z+6, r25	; 0x06
     2b6:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2b8:	90 87       	std	Z+8, r25	; 0x08
     2ba:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     2bc:	10 82       	st	Z, r1
     2be:	08 95       	ret

000002c0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     2c0:	fc 01       	movw	r30, r24
     2c2:	11 86       	std	Z+9, r1	; 0x09
     2c4:	10 86       	std	Z+8, r1	; 0x08
     2c6:	08 95       	ret

000002c8 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     2c8:	cf 93       	push	r28
     2ca:	df 93       	push	r29
     2cc:	9c 01       	movw	r18, r24
     2ce:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     2d0:	dc 01       	movw	r26, r24
     2d2:	11 96       	adiw	r26, 0x01	; 1
     2d4:	cd 91       	ld	r28, X+
     2d6:	dc 91       	ld	r29, X
     2d8:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     2da:	d3 83       	std	Z+3, r29	; 0x03
     2dc:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     2de:	8c 81       	ldd	r24, Y+4	; 0x04
     2e0:	9d 81       	ldd	r25, Y+5	; 0x05
     2e2:	95 83       	std	Z+5, r25	; 0x05
     2e4:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     2e6:	8c 81       	ldd	r24, Y+4	; 0x04
     2e8:	9d 81       	ldd	r25, Y+5	; 0x05
     2ea:	dc 01       	movw	r26, r24
     2ec:	13 96       	adiw	r26, 0x03	; 3
     2ee:	7c 93       	st	X, r23
     2f0:	6e 93       	st	-X, r22
     2f2:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     2f4:	7d 83       	std	Y+5, r23	; 0x05
     2f6:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2f8:	31 87       	std	Z+9, r19	; 0x09
     2fa:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     2fc:	f9 01       	movw	r30, r18
     2fe:	80 81       	ld	r24, Z
     300:	8f 5f       	subi	r24, 0xFF	; 255
     302:	80 83       	st	Z, r24
}
     304:	df 91       	pop	r29
     306:	cf 91       	pop	r28
     308:	08 95       	ret

0000030a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     30a:	cf 93       	push	r28
     30c:	df 93       	push	r29
     30e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     310:	48 81       	ld	r20, Y
     312:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     314:	4f 3f       	cpi	r20, 0xFF	; 255
     316:	2f ef       	ldi	r18, 0xFF	; 255
     318:	52 07       	cpc	r21, r18
     31a:	21 f4       	brne	.+8      	; 0x324 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     31c:	fc 01       	movw	r30, r24
     31e:	a7 81       	ldd	r26, Z+7	; 0x07
     320:	b0 85       	ldd	r27, Z+8	; 0x08
     322:	0d c0       	rjmp	.+26     	; 0x33e <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     324:	dc 01       	movw	r26, r24
     326:	13 96       	adiw	r26, 0x03	; 3
     328:	01 c0       	rjmp	.+2      	; 0x32c <vListInsert+0x22>
     32a:	df 01       	movw	r26, r30
     32c:	12 96       	adiw	r26, 0x02	; 2
     32e:	ed 91       	ld	r30, X+
     330:	fc 91       	ld	r31, X
     332:	13 97       	sbiw	r26, 0x03	; 3
     334:	20 81       	ld	r18, Z
     336:	31 81       	ldd	r19, Z+1	; 0x01
     338:	42 17       	cp	r20, r18
     33a:	53 07       	cpc	r21, r19
     33c:	b0 f7       	brcc	.-20     	; 0x32a <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     33e:	12 96       	adiw	r26, 0x02	; 2
     340:	ed 91       	ld	r30, X+
     342:	fc 91       	ld	r31, X
     344:	13 97       	sbiw	r26, 0x03	; 3
     346:	fb 83       	std	Y+3, r31	; 0x03
     348:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     34a:	d5 83       	std	Z+5, r29	; 0x05
     34c:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     34e:	bd 83       	std	Y+5, r27	; 0x05
     350:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     352:	13 96       	adiw	r26, 0x03	; 3
     354:	dc 93       	st	X, r29
     356:	ce 93       	st	-X, r28
     358:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     35a:	99 87       	std	Y+9, r25	; 0x09
     35c:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     35e:	fc 01       	movw	r30, r24
     360:	20 81       	ld	r18, Z
     362:	2f 5f       	subi	r18, 0xFF	; 255
     364:	20 83       	st	Z, r18
}
     366:	df 91       	pop	r29
     368:	cf 91       	pop	r28
     36a:	08 95       	ret

0000036c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     36c:	cf 93       	push	r28
     36e:	df 93       	push	r29
     370:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     372:	a0 85       	ldd	r26, Z+8	; 0x08
     374:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     376:	c2 81       	ldd	r28, Z+2	; 0x02
     378:	d3 81       	ldd	r29, Z+3	; 0x03
     37a:	84 81       	ldd	r24, Z+4	; 0x04
     37c:	95 81       	ldd	r25, Z+5	; 0x05
     37e:	9d 83       	std	Y+5, r25	; 0x05
     380:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     382:	c4 81       	ldd	r28, Z+4	; 0x04
     384:	d5 81       	ldd	r29, Z+5	; 0x05
     386:	82 81       	ldd	r24, Z+2	; 0x02
     388:	93 81       	ldd	r25, Z+3	; 0x03
     38a:	9b 83       	std	Y+3, r25	; 0x03
     38c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     38e:	11 96       	adiw	r26, 0x01	; 1
     390:	8d 91       	ld	r24, X+
     392:	9c 91       	ld	r25, X
     394:	12 97       	sbiw	r26, 0x02	; 2
     396:	e8 17       	cp	r30, r24
     398:	f9 07       	cpc	r31, r25
     39a:	31 f4       	brne	.+12     	; 0x3a8 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     39c:	84 81       	ldd	r24, Z+4	; 0x04
     39e:	95 81       	ldd	r25, Z+5	; 0x05
     3a0:	12 96       	adiw	r26, 0x02	; 2
     3a2:	9c 93       	st	X, r25
     3a4:	8e 93       	st	-X, r24
     3a6:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     3a8:	11 86       	std	Z+9, r1	; 0x09
     3aa:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     3ac:	8c 91       	ld	r24, X
     3ae:	81 50       	subi	r24, 0x01	; 1
     3b0:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     3b2:	df 91       	pop	r29
     3b4:	cf 91       	pop	r28
     3b6:	08 95       	ret

000003b8 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     3b8:	31 e1       	ldi	r19, 0x11	; 17
     3ba:	fc 01       	movw	r30, r24
     3bc:	30 83       	st	Z, r19
     3be:	31 97       	sbiw	r30, 0x01	; 1
     3c0:	22 e2       	ldi	r18, 0x22	; 34
     3c2:	20 83       	st	Z, r18
     3c4:	31 97       	sbiw	r30, 0x01	; 1
     3c6:	a3 e3       	ldi	r26, 0x33	; 51
     3c8:	a0 83       	st	Z, r26
     3ca:	31 97       	sbiw	r30, 0x01	; 1
     3cc:	60 83       	st	Z, r22
     3ce:	31 97       	sbiw	r30, 0x01	; 1
     3d0:	70 83       	st	Z, r23
     3d2:	31 97       	sbiw	r30, 0x01	; 1
     3d4:	10 82       	st	Z, r1
     3d6:	31 97       	sbiw	r30, 0x01	; 1
     3d8:	60 e8       	ldi	r22, 0x80	; 128
     3da:	60 83       	st	Z, r22
     3dc:	31 97       	sbiw	r30, 0x01	; 1
     3de:	10 82       	st	Z, r1
     3e0:	31 97       	sbiw	r30, 0x01	; 1
     3e2:	62 e0       	ldi	r22, 0x02	; 2
     3e4:	60 83       	st	Z, r22
     3e6:	31 97       	sbiw	r30, 0x01	; 1
     3e8:	63 e0       	ldi	r22, 0x03	; 3
     3ea:	60 83       	st	Z, r22
     3ec:	31 97       	sbiw	r30, 0x01	; 1
     3ee:	64 e0       	ldi	r22, 0x04	; 4
     3f0:	60 83       	st	Z, r22
     3f2:	31 97       	sbiw	r30, 0x01	; 1
     3f4:	65 e0       	ldi	r22, 0x05	; 5
     3f6:	60 83       	st	Z, r22
     3f8:	31 97       	sbiw	r30, 0x01	; 1
     3fa:	66 e0       	ldi	r22, 0x06	; 6
     3fc:	60 83       	st	Z, r22
     3fe:	31 97       	sbiw	r30, 0x01	; 1
     400:	67 e0       	ldi	r22, 0x07	; 7
     402:	60 83       	st	Z, r22
     404:	31 97       	sbiw	r30, 0x01	; 1
     406:	68 e0       	ldi	r22, 0x08	; 8
     408:	60 83       	st	Z, r22
     40a:	31 97       	sbiw	r30, 0x01	; 1
     40c:	69 e0       	ldi	r22, 0x09	; 9
     40e:	60 83       	st	Z, r22
     410:	31 97       	sbiw	r30, 0x01	; 1
     412:	60 e1       	ldi	r22, 0x10	; 16
     414:	60 83       	st	Z, r22
     416:	31 97       	sbiw	r30, 0x01	; 1
     418:	30 83       	st	Z, r19
     41a:	31 97       	sbiw	r30, 0x01	; 1
     41c:	32 e1       	ldi	r19, 0x12	; 18
     41e:	30 83       	st	Z, r19
     420:	31 97       	sbiw	r30, 0x01	; 1
     422:	33 e1       	ldi	r19, 0x13	; 19
     424:	30 83       	st	Z, r19
     426:	31 97       	sbiw	r30, 0x01	; 1
     428:	34 e1       	ldi	r19, 0x14	; 20
     42a:	30 83       	st	Z, r19
     42c:	31 97       	sbiw	r30, 0x01	; 1
     42e:	35 e1       	ldi	r19, 0x15	; 21
     430:	30 83       	st	Z, r19
     432:	31 97       	sbiw	r30, 0x01	; 1
     434:	36 e1       	ldi	r19, 0x16	; 22
     436:	30 83       	st	Z, r19
     438:	31 97       	sbiw	r30, 0x01	; 1
     43a:	37 e1       	ldi	r19, 0x17	; 23
     43c:	30 83       	st	Z, r19
     43e:	31 97       	sbiw	r30, 0x01	; 1
     440:	38 e1       	ldi	r19, 0x18	; 24
     442:	30 83       	st	Z, r19
     444:	31 97       	sbiw	r30, 0x01	; 1
     446:	39 e1       	ldi	r19, 0x19	; 25
     448:	30 83       	st	Z, r19
     44a:	31 97       	sbiw	r30, 0x01	; 1
     44c:	30 e2       	ldi	r19, 0x20	; 32
     44e:	30 83       	st	Z, r19
     450:	31 97       	sbiw	r30, 0x01	; 1
     452:	31 e2       	ldi	r19, 0x21	; 33
     454:	30 83       	st	Z, r19
     456:	31 97       	sbiw	r30, 0x01	; 1
     458:	20 83       	st	Z, r18
     45a:	31 97       	sbiw	r30, 0x01	; 1
     45c:	23 e2       	ldi	r18, 0x23	; 35
     45e:	20 83       	st	Z, r18
     460:	31 97       	sbiw	r30, 0x01	; 1
     462:	40 83       	st	Z, r20
     464:	31 97       	sbiw	r30, 0x01	; 1
     466:	50 83       	st	Z, r21
     468:	31 97       	sbiw	r30, 0x01	; 1
     46a:	26 e2       	ldi	r18, 0x26	; 38
     46c:	20 83       	st	Z, r18
     46e:	31 97       	sbiw	r30, 0x01	; 1
     470:	27 e2       	ldi	r18, 0x27	; 39
     472:	20 83       	st	Z, r18
     474:	31 97       	sbiw	r30, 0x01	; 1
     476:	28 e2       	ldi	r18, 0x28	; 40
     478:	20 83       	st	Z, r18
     47a:	31 97       	sbiw	r30, 0x01	; 1
     47c:	29 e2       	ldi	r18, 0x29	; 41
     47e:	20 83       	st	Z, r18
     480:	31 97       	sbiw	r30, 0x01	; 1
     482:	20 e3       	ldi	r18, 0x30	; 48
     484:	20 83       	st	Z, r18
     486:	31 97       	sbiw	r30, 0x01	; 1
     488:	21 e3       	ldi	r18, 0x31	; 49
     48a:	20 83       	st	Z, r18
     48c:	86 97       	sbiw	r24, 0x26	; 38
     48e:	08 95       	ret

00000490 <xPortStartScheduler>:
     490:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     494:	8c e7       	ldi	r24, 0x7C	; 124
     496:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     49a:	8b e0       	ldi	r24, 0x0B	; 11
     49c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     4a0:	ef e6       	ldi	r30, 0x6F	; 111
     4a2:	f0 e0       	ldi	r31, 0x00	; 0
     4a4:	80 81       	ld	r24, Z
     4a6:	82 60       	ori	r24, 0x02	; 2
     4a8:	80 83       	st	Z, r24
     4aa:	a0 91 8c 08 	lds	r26, 0x088C	; 0x80088c <pxCurrentTCB>
     4ae:	b0 91 8d 08 	lds	r27, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
     4b2:	cd 91       	ld	r28, X+
     4b4:	cd bf       	out	0x3d, r28	; 61
     4b6:	dd 91       	ld	r29, X+
     4b8:	de bf       	out	0x3e, r29	; 62
     4ba:	ff 91       	pop	r31
     4bc:	ef 91       	pop	r30
     4be:	df 91       	pop	r29
     4c0:	cf 91       	pop	r28
     4c2:	bf 91       	pop	r27
     4c4:	af 91       	pop	r26
     4c6:	9f 91       	pop	r25
     4c8:	8f 91       	pop	r24
     4ca:	7f 91       	pop	r23
     4cc:	6f 91       	pop	r22
     4ce:	5f 91       	pop	r21
     4d0:	4f 91       	pop	r20
     4d2:	3f 91       	pop	r19
     4d4:	2f 91       	pop	r18
     4d6:	1f 91       	pop	r17
     4d8:	0f 91       	pop	r16
     4da:	ff 90       	pop	r15
     4dc:	ef 90       	pop	r14
     4de:	df 90       	pop	r13
     4e0:	cf 90       	pop	r12
     4e2:	bf 90       	pop	r11
     4e4:	af 90       	pop	r10
     4e6:	9f 90       	pop	r9
     4e8:	8f 90       	pop	r8
     4ea:	7f 90       	pop	r7
     4ec:	6f 90       	pop	r6
     4ee:	5f 90       	pop	r5
     4f0:	4f 90       	pop	r4
     4f2:	3f 90       	pop	r3
     4f4:	2f 90       	pop	r2
     4f6:	1f 90       	pop	r1
     4f8:	0f 90       	pop	r0
     4fa:	0f be       	out	0x3f, r0	; 63
     4fc:	0f 90       	pop	r0
     4fe:	08 95       	ret
     500:	81 e0       	ldi	r24, 0x01	; 1
     502:	08 95       	ret

00000504 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     504:	0f 92       	push	r0
     506:	0f b6       	in	r0, 0x3f	; 63
     508:	f8 94       	cli
     50a:	0f 92       	push	r0
     50c:	1f 92       	push	r1
     50e:	11 24       	eor	r1, r1
     510:	2f 92       	push	r2
     512:	3f 92       	push	r3
     514:	4f 92       	push	r4
     516:	5f 92       	push	r5
     518:	6f 92       	push	r6
     51a:	7f 92       	push	r7
     51c:	8f 92       	push	r8
     51e:	9f 92       	push	r9
     520:	af 92       	push	r10
     522:	bf 92       	push	r11
     524:	cf 92       	push	r12
     526:	df 92       	push	r13
     528:	ef 92       	push	r14
     52a:	ff 92       	push	r15
     52c:	0f 93       	push	r16
     52e:	1f 93       	push	r17
     530:	2f 93       	push	r18
     532:	3f 93       	push	r19
     534:	4f 93       	push	r20
     536:	5f 93       	push	r21
     538:	6f 93       	push	r22
     53a:	7f 93       	push	r23
     53c:	8f 93       	push	r24
     53e:	9f 93       	push	r25
     540:	af 93       	push	r26
     542:	bf 93       	push	r27
     544:	cf 93       	push	r28
     546:	df 93       	push	r29
     548:	ef 93       	push	r30
     54a:	ff 93       	push	r31
     54c:	a0 91 8c 08 	lds	r26, 0x088C	; 0x80088c <pxCurrentTCB>
     550:	b0 91 8d 08 	lds	r27, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
     554:	0d b6       	in	r0, 0x3d	; 61
     556:	0d 92       	st	X+, r0
     558:	0e b6       	in	r0, 0x3e	; 62
     55a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     55c:	0e 94 2b 0a 	call	0x1456	; 0x1456 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     560:	a0 91 8c 08 	lds	r26, 0x088C	; 0x80088c <pxCurrentTCB>
     564:	b0 91 8d 08 	lds	r27, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
     568:	cd 91       	ld	r28, X+
     56a:	cd bf       	out	0x3d, r28	; 61
     56c:	dd 91       	ld	r29, X+
     56e:	de bf       	out	0x3e, r29	; 62
     570:	ff 91       	pop	r31
     572:	ef 91       	pop	r30
     574:	df 91       	pop	r29
     576:	cf 91       	pop	r28
     578:	bf 91       	pop	r27
     57a:	af 91       	pop	r26
     57c:	9f 91       	pop	r25
     57e:	8f 91       	pop	r24
     580:	7f 91       	pop	r23
     582:	6f 91       	pop	r22
     584:	5f 91       	pop	r21
     586:	4f 91       	pop	r20
     588:	3f 91       	pop	r19
     58a:	2f 91       	pop	r18
     58c:	1f 91       	pop	r17
     58e:	0f 91       	pop	r16
     590:	ff 90       	pop	r15
     592:	ef 90       	pop	r14
     594:	df 90       	pop	r13
     596:	cf 90       	pop	r12
     598:	bf 90       	pop	r11
     59a:	af 90       	pop	r10
     59c:	9f 90       	pop	r9
     59e:	8f 90       	pop	r8
     5a0:	7f 90       	pop	r7
     5a2:	6f 90       	pop	r6
     5a4:	5f 90       	pop	r5
     5a6:	4f 90       	pop	r4
     5a8:	3f 90       	pop	r3
     5aa:	2f 90       	pop	r2
     5ac:	1f 90       	pop	r1
     5ae:	0f 90       	pop	r0
     5b0:	0f be       	out	0x3f, r0	; 63
     5b2:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5b4:	08 95       	ret

000005b6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     5b6:	0f 92       	push	r0
     5b8:	0f b6       	in	r0, 0x3f	; 63
     5ba:	f8 94       	cli
     5bc:	0f 92       	push	r0
     5be:	1f 92       	push	r1
     5c0:	11 24       	eor	r1, r1
     5c2:	2f 92       	push	r2
     5c4:	3f 92       	push	r3
     5c6:	4f 92       	push	r4
     5c8:	5f 92       	push	r5
     5ca:	6f 92       	push	r6
     5cc:	7f 92       	push	r7
     5ce:	8f 92       	push	r8
     5d0:	9f 92       	push	r9
     5d2:	af 92       	push	r10
     5d4:	bf 92       	push	r11
     5d6:	cf 92       	push	r12
     5d8:	df 92       	push	r13
     5da:	ef 92       	push	r14
     5dc:	ff 92       	push	r15
     5de:	0f 93       	push	r16
     5e0:	1f 93       	push	r17
     5e2:	2f 93       	push	r18
     5e4:	3f 93       	push	r19
     5e6:	4f 93       	push	r20
     5e8:	5f 93       	push	r21
     5ea:	6f 93       	push	r22
     5ec:	7f 93       	push	r23
     5ee:	8f 93       	push	r24
     5f0:	9f 93       	push	r25
     5f2:	af 93       	push	r26
     5f4:	bf 93       	push	r27
     5f6:	cf 93       	push	r28
     5f8:	df 93       	push	r29
     5fa:	ef 93       	push	r30
     5fc:	ff 93       	push	r31
     5fe:	a0 91 8c 08 	lds	r26, 0x088C	; 0x80088c <pxCurrentTCB>
     602:	b0 91 8d 08 	lds	r27, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
     606:	0d b6       	in	r0, 0x3d	; 61
     608:	0d 92       	st	X+, r0
     60a:	0e b6       	in	r0, 0x3e	; 62
     60c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     60e:	0e 94 6d 08 	call	0x10da	; 0x10da <xTaskIncrementTick>
     612:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     614:	0e 94 2b 0a 	call	0x1456	; 0x1456 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     618:	a0 91 8c 08 	lds	r26, 0x088C	; 0x80088c <pxCurrentTCB>
     61c:	b0 91 8d 08 	lds	r27, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
     620:	cd 91       	ld	r28, X+
     622:	cd bf       	out	0x3d, r28	; 61
     624:	dd 91       	ld	r29, X+
     626:	de bf       	out	0x3e, r29	; 62
     628:	ff 91       	pop	r31
     62a:	ef 91       	pop	r30
     62c:	df 91       	pop	r29
     62e:	cf 91       	pop	r28
     630:	bf 91       	pop	r27
     632:	af 91       	pop	r26
     634:	9f 91       	pop	r25
     636:	8f 91       	pop	r24
     638:	7f 91       	pop	r23
     63a:	6f 91       	pop	r22
     63c:	5f 91       	pop	r21
     63e:	4f 91       	pop	r20
     640:	3f 91       	pop	r19
     642:	2f 91       	pop	r18
     644:	1f 91       	pop	r17
     646:	0f 91       	pop	r16
     648:	ff 90       	pop	r15
     64a:	ef 90       	pop	r14
     64c:	df 90       	pop	r13
     64e:	cf 90       	pop	r12
     650:	bf 90       	pop	r11
     652:	af 90       	pop	r10
     654:	9f 90       	pop	r9
     656:	8f 90       	pop	r8
     658:	7f 90       	pop	r7
     65a:	6f 90       	pop	r6
     65c:	5f 90       	pop	r5
     65e:	4f 90       	pop	r4
     660:	3f 90       	pop	r3
     662:	2f 90       	pop	r2
     664:	1f 90       	pop	r1
     666:	0f 90       	pop	r0
     668:	0f be       	out	0x3f, r0	; 63
     66a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     66c:	08 95       	ret

0000066e <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect(void) __attribute__ ((signal, naked));
	void TIMER1_COMPA_vect(void)
	{
		vPortYieldFromTick();
     66e:	0e 94 db 02 	call	0x5b6	; 0x5b6 <vPortYieldFromTick>
		asm volatile ( "reti" );
     672:	18 95       	reti

00000674 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     674:	0f 93       	push	r16
     676:	1f 93       	push	r17
     678:	cf 93       	push	r28
     67a:	df 93       	push	r29
     67c:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     67e:	0e 94 5d 08 	call	0x10ba	; 0x10ba <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     682:	80 91 45 02 	lds	r24, 0x0245	; 0x800245 <xHeapHasBeenInitialised.2023>
     686:	81 11       	cpse	r24, r1
     688:	1d c0       	rjmp	.+58     	; 0x6c4 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     68a:	ea e4       	ldi	r30, 0x4A	; 74
     68c:	f2 e0       	ldi	r31, 0x02	; 2
     68e:	8f e4       	ldi	r24, 0x4F	; 79
     690:	92 e0       	ldi	r25, 0x02	; 2
     692:	91 83       	std	Z+1, r25	; 0x01
     694:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     696:	13 82       	std	Z+3, r1	; 0x03
     698:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     69a:	e6 e4       	ldi	r30, 0x46	; 70
     69c:	f2 e0       	ldi	r31, 0x02	; 2
     69e:	8b ed       	ldi	r24, 0xDB	; 219
     6a0:	95 e0       	ldi	r25, 0x05	; 5
     6a2:	93 83       	std	Z+3, r25	; 0x03
     6a4:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     6a6:	11 82       	std	Z+1, r1	; 0x01
     6a8:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     6aa:	ae e4       	ldi	r26, 0x4E	; 78
     6ac:	b2 e0       	ldi	r27, 0x02	; 2
     6ae:	14 96       	adiw	r26, 0x04	; 4
     6b0:	9c 93       	st	X, r25
     6b2:	8e 93       	st	-X, r24
     6b4:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     6b6:	12 96       	adiw	r26, 0x02	; 2
     6b8:	fc 93       	st	X, r31
     6ba:	ee 93       	st	-X, r30
     6bc:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     6be:	81 e0       	ldi	r24, 0x01	; 1
     6c0:	80 93 45 02 	sts	0x0245, r24	; 0x800245 <xHeapHasBeenInitialised.2023>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     6c4:	20 97       	sbiw	r28, 0x00	; 0
     6c6:	09 f4       	brne	.+2      	; 0x6ca <pvPortMalloc+0x56>
     6c8:	5f c0       	rjmp	.+190    	; 0x788 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
     6ca:	9e 01       	movw	r18, r28
     6cc:	2c 5f       	subi	r18, 0xFC	; 252
     6ce:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     6d0:	23 96       	adiw	r28, 0x03	; 3
     6d2:	ca 3d       	cpi	r28, 0xDA	; 218
     6d4:	d5 40       	sbci	r29, 0x05	; 5
     6d6:	08 f0       	brcs	.+2      	; 0x6da <pvPortMalloc+0x66>
     6d8:	5a c0       	rjmp	.+180    	; 0x78e <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     6da:	e0 91 4a 02 	lds	r30, 0x024A	; 0x80024a <xStart>
     6de:	f0 91 4b 02 	lds	r31, 0x024B	; 0x80024b <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     6e2:	aa e4       	ldi	r26, 0x4A	; 74
     6e4:	b2 e0       	ldi	r27, 0x02	; 2
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     6e6:	02 c0       	rjmp	.+4      	; 0x6ec <pvPortMalloc+0x78>
     6e8:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     6ea:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     6ec:	82 81       	ldd	r24, Z+2	; 0x02
     6ee:	93 81       	ldd	r25, Z+3	; 0x03
     6f0:	82 17       	cp	r24, r18
     6f2:	93 07       	cpc	r25, r19
     6f4:	20 f4       	brcc	.+8      	; 0x6fe <pvPortMalloc+0x8a>
     6f6:	80 81       	ld	r24, Z
     6f8:	91 81       	ldd	r25, Z+1	; 0x01
     6fa:	00 97       	sbiw	r24, 0x00	; 0
     6fc:	a9 f7       	brne	.-22     	; 0x6e8 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     6fe:	c2 e0       	ldi	r28, 0x02	; 2
     700:	e6 34       	cpi	r30, 0x46	; 70
     702:	fc 07       	cpc	r31, r28
     704:	09 f4       	brne	.+2      	; 0x708 <pvPortMalloc+0x94>
     706:	46 c0       	rjmp	.+140    	; 0x794 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     708:	cd 91       	ld	r28, X+
     70a:	dc 91       	ld	r29, X
     70c:	11 97       	sbiw	r26, 0x01	; 1
     70e:	8e 01       	movw	r16, r28
     710:	0c 5f       	subi	r16, 0xFC	; 252
     712:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     714:	80 81       	ld	r24, Z
     716:	91 81       	ldd	r25, Z+1	; 0x01
     718:	8d 93       	st	X+, r24
     71a:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     71c:	82 81       	ldd	r24, Z+2	; 0x02
     71e:	93 81       	ldd	r25, Z+3	; 0x03
     720:	82 1b       	sub	r24, r18
     722:	93 0b       	sbc	r25, r19
     724:	89 30       	cpi	r24, 0x09	; 9
     726:	91 05       	cpc	r25, r1
     728:	10 f1       	brcs	.+68     	; 0x76e <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     72a:	bf 01       	movw	r22, r30
     72c:	62 0f       	add	r22, r18
     72e:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     730:	db 01       	movw	r26, r22
     732:	13 96       	adiw	r26, 0x03	; 3
     734:	9c 93       	st	X, r25
     736:	8e 93       	st	-X, r24
     738:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     73a:	33 83       	std	Z+3, r19	; 0x03
     73c:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     73e:	12 96       	adiw	r26, 0x02	; 2
     740:	4d 91       	ld	r20, X+
     742:	5c 91       	ld	r21, X
     744:	13 97       	sbiw	r26, 0x03	; 3
     746:	8a e4       	ldi	r24, 0x4A	; 74
     748:	92 e0       	ldi	r25, 0x02	; 2
     74a:	01 c0       	rjmp	.+2      	; 0x74e <pvPortMalloc+0xda>
     74c:	cd 01       	movw	r24, r26
     74e:	ec 01       	movw	r28, r24
     750:	a8 81       	ld	r26, Y
     752:	b9 81       	ldd	r27, Y+1	; 0x01
     754:	12 96       	adiw	r26, 0x02	; 2
     756:	2d 91       	ld	r18, X+
     758:	3c 91       	ld	r19, X
     75a:	13 97       	sbiw	r26, 0x03	; 3
     75c:	24 17       	cp	r18, r20
     75e:	35 07       	cpc	r19, r21
     760:	a8 f3       	brcs	.-22     	; 0x74c <pvPortMalloc+0xd8>
     762:	eb 01       	movw	r28, r22
     764:	b9 83       	std	Y+1, r27	; 0x01
     766:	a8 83       	st	Y, r26
     768:	dc 01       	movw	r26, r24
     76a:	6d 93       	st	X+, r22
     76c:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     76e:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     772:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
     776:	22 81       	ldd	r18, Z+2	; 0x02
     778:	33 81       	ldd	r19, Z+3	; 0x03
     77a:	82 1b       	sub	r24, r18
     77c:	93 0b       	sbc	r25, r19
     77e:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     782:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
     786:	08 c0       	rjmp	.+16     	; 0x798 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     788:	00 e0       	ldi	r16, 0x00	; 0
     78a:	10 e0       	ldi	r17, 0x00	; 0
     78c:	05 c0       	rjmp	.+10     	; 0x798 <pvPortMalloc+0x124>
     78e:	00 e0       	ldi	r16, 0x00	; 0
     790:	10 e0       	ldi	r17, 0x00	; 0
     792:	02 c0       	rjmp	.+4      	; 0x798 <pvPortMalloc+0x124>
     794:	00 e0       	ldi	r16, 0x00	; 0
     796:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     798:	0e 94 2a 09 	call	0x1254	; 0x1254 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     79c:	c8 01       	movw	r24, r16
     79e:	df 91       	pop	r29
     7a0:	cf 91       	pop	r28
     7a2:	1f 91       	pop	r17
     7a4:	0f 91       	pop	r16
     7a6:	08 95       	ret

000007a8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     7a8:	0f 93       	push	r16
     7aa:	1f 93       	push	r17
     7ac:	cf 93       	push	r28
     7ae:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     7b0:	00 97       	sbiw	r24, 0x00	; 0
     7b2:	41 f1       	breq	.+80     	; 0x804 <vPortFree+0x5c>
     7b4:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     7b6:	8c 01       	movw	r16, r24
     7b8:	04 50       	subi	r16, 0x04	; 4
     7ba:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     7bc:	0e 94 5d 08 	call	0x10ba	; 0x10ba <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     7c0:	f8 01       	movw	r30, r16
     7c2:	42 81       	ldd	r20, Z+2	; 0x02
     7c4:	53 81       	ldd	r21, Z+3	; 0x03
     7c6:	aa e4       	ldi	r26, 0x4A	; 74
     7c8:	b2 e0       	ldi	r27, 0x02	; 2
     7ca:	01 c0       	rjmp	.+2      	; 0x7ce <vPortFree+0x26>
     7cc:	df 01       	movw	r26, r30
     7ce:	ed 91       	ld	r30, X+
     7d0:	fc 91       	ld	r31, X
     7d2:	11 97       	sbiw	r26, 0x01	; 1
     7d4:	22 81       	ldd	r18, Z+2	; 0x02
     7d6:	33 81       	ldd	r19, Z+3	; 0x03
     7d8:	24 17       	cp	r18, r20
     7da:	35 07       	cpc	r19, r21
     7dc:	b8 f3       	brcs	.-18     	; 0x7cc <vPortFree+0x24>
     7de:	24 97       	sbiw	r28, 0x04	; 4
     7e0:	f9 83       	std	Y+1, r31	; 0x01
     7e2:	e8 83       	st	Y, r30
     7e4:	0d 93       	st	X+, r16
     7e6:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     7e8:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
     7ec:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
     7f0:	8a 81       	ldd	r24, Y+2	; 0x02
     7f2:	9b 81       	ldd	r25, Y+3	; 0x03
     7f4:	82 0f       	add	r24, r18
     7f6:	93 1f       	adc	r25, r19
     7f8:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     7fc:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     800:	0e 94 2a 09 	call	0x1254	; 0x1254 <xTaskResumeAll>
	}
}
     804:	df 91       	pop	r29
     806:	cf 91       	pop	r28
     808:	1f 91       	pop	r17
     80a:	0f 91       	pop	r16
     80c:	08 95       	ret

0000080e <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     80e:	1f 93       	push	r17
     810:	cf 93       	push	r28
     812:	df 93       	push	r29
     814:	ec 01       	movw	r28, r24
     816:	14 2f       	mov	r17, r20
     818:	4c 8d       	ldd	r20, Y+28	; 0x1c
     81a:	41 11       	cpse	r20, r1
     81c:	0c c0       	rjmp	.+24     	; 0x836 <prvCopyDataToQueue+0x28>
     81e:	88 81       	ld	r24, Y
     820:	99 81       	ldd	r25, Y+1	; 0x01
     822:	89 2b       	or	r24, r25
     824:	09 f0       	breq	.+2      	; 0x828 <prvCopyDataToQueue+0x1a>
     826:	45 c0       	rjmp	.+138    	; 0x8b2 <prvCopyDataToQueue+0xa4>
     828:	8a 81       	ldd	r24, Y+2	; 0x02
     82a:	9b 81       	ldd	r25, Y+3	; 0x03
     82c:	0e 94 b6 0b 	call	0x176c	; 0x176c <xTaskPriorityDisinherit>
     830:	1b 82       	std	Y+3, r1	; 0x03
     832:	1a 82       	std	Y+2, r1	; 0x02
     834:	45 c0       	rjmp	.+138    	; 0x8c0 <prvCopyDataToQueue+0xb2>
     836:	11 11       	cpse	r17, r1
     838:	17 c0       	rjmp	.+46     	; 0x868 <prvCopyDataToQueue+0x5a>
     83a:	50 e0       	ldi	r21, 0x00	; 0
     83c:	8c 81       	ldd	r24, Y+4	; 0x04
     83e:	9d 81       	ldd	r25, Y+5	; 0x05
     840:	0e 94 a8 0c 	call	0x1950	; 0x1950 <memcpy>
     844:	2c 8d       	ldd	r18, Y+28	; 0x1c
     846:	8c 81       	ldd	r24, Y+4	; 0x04
     848:	9d 81       	ldd	r25, Y+5	; 0x05
     84a:	82 0f       	add	r24, r18
     84c:	91 1d       	adc	r25, r1
     84e:	9d 83       	std	Y+5, r25	; 0x05
     850:	8c 83       	std	Y+4, r24	; 0x04
     852:	2a 81       	ldd	r18, Y+2	; 0x02
     854:	3b 81       	ldd	r19, Y+3	; 0x03
     856:	82 17       	cp	r24, r18
     858:	93 07       	cpc	r25, r19
     85a:	68 f1       	brcs	.+90     	; 0x8b6 <prvCopyDataToQueue+0xa8>
     85c:	88 81       	ld	r24, Y
     85e:	99 81       	ldd	r25, Y+1	; 0x01
     860:	9d 83       	std	Y+5, r25	; 0x05
     862:	8c 83       	std	Y+4, r24	; 0x04
     864:	80 e0       	ldi	r24, 0x00	; 0
     866:	2c c0       	rjmp	.+88     	; 0x8c0 <prvCopyDataToQueue+0xb2>
     868:	50 e0       	ldi	r21, 0x00	; 0
     86a:	8e 81       	ldd	r24, Y+6	; 0x06
     86c:	9f 81       	ldd	r25, Y+7	; 0x07
     86e:	0e 94 a8 0c 	call	0x1950	; 0x1950 <memcpy>
     872:	8c 8d       	ldd	r24, Y+28	; 0x1c
     874:	90 e0       	ldi	r25, 0x00	; 0
     876:	91 95       	neg	r25
     878:	81 95       	neg	r24
     87a:	91 09       	sbc	r25, r1
     87c:	2e 81       	ldd	r18, Y+6	; 0x06
     87e:	3f 81       	ldd	r19, Y+7	; 0x07
     880:	28 0f       	add	r18, r24
     882:	39 1f       	adc	r19, r25
     884:	3f 83       	std	Y+7, r19	; 0x07
     886:	2e 83       	std	Y+6, r18	; 0x06
     888:	48 81       	ld	r20, Y
     88a:	59 81       	ldd	r21, Y+1	; 0x01
     88c:	24 17       	cp	r18, r20
     88e:	35 07       	cpc	r19, r21
     890:	30 f4       	brcc	.+12     	; 0x89e <prvCopyDataToQueue+0x90>
     892:	2a 81       	ldd	r18, Y+2	; 0x02
     894:	3b 81       	ldd	r19, Y+3	; 0x03
     896:	82 0f       	add	r24, r18
     898:	93 1f       	adc	r25, r19
     89a:	9f 83       	std	Y+7, r25	; 0x07
     89c:	8e 83       	std	Y+6, r24	; 0x06
     89e:	12 30       	cpi	r17, 0x02	; 2
     8a0:	61 f4       	brne	.+24     	; 0x8ba <prvCopyDataToQueue+0xac>
     8a2:	8a 8d       	ldd	r24, Y+26	; 0x1a
     8a4:	88 23       	and	r24, r24
     8a6:	59 f0       	breq	.+22     	; 0x8be <prvCopyDataToQueue+0xb0>
     8a8:	8a 8d       	ldd	r24, Y+26	; 0x1a
     8aa:	81 50       	subi	r24, 0x01	; 1
     8ac:	8a 8f       	std	Y+26, r24	; 0x1a
     8ae:	80 e0       	ldi	r24, 0x00	; 0
     8b0:	07 c0       	rjmp	.+14     	; 0x8c0 <prvCopyDataToQueue+0xb2>
     8b2:	80 e0       	ldi	r24, 0x00	; 0
     8b4:	05 c0       	rjmp	.+10     	; 0x8c0 <prvCopyDataToQueue+0xb2>
     8b6:	80 e0       	ldi	r24, 0x00	; 0
     8b8:	03 c0       	rjmp	.+6      	; 0x8c0 <prvCopyDataToQueue+0xb2>
     8ba:	80 e0       	ldi	r24, 0x00	; 0
     8bc:	01 c0       	rjmp	.+2      	; 0x8c0 <prvCopyDataToQueue+0xb2>
     8be:	80 e0       	ldi	r24, 0x00	; 0
     8c0:	9a 8d       	ldd	r25, Y+26	; 0x1a
     8c2:	9f 5f       	subi	r25, 0xFF	; 255
     8c4:	9a 8f       	std	Y+26, r25	; 0x1a
     8c6:	df 91       	pop	r29
     8c8:	cf 91       	pop	r28
     8ca:	1f 91       	pop	r17
     8cc:	08 95       	ret

000008ce <prvCopyDataFromQueue>:
     8ce:	fc 01       	movw	r30, r24
     8d0:	44 8d       	ldd	r20, Z+28	; 0x1c
     8d2:	44 23       	and	r20, r20
     8d4:	a9 f0       	breq	.+42     	; 0x900 <__stack+0x1>
     8d6:	50 e0       	ldi	r21, 0x00	; 0
     8d8:	26 81       	ldd	r18, Z+6	; 0x06
     8da:	37 81       	ldd	r19, Z+7	; 0x07
     8dc:	24 0f       	add	r18, r20
     8de:	35 1f       	adc	r19, r21
     8e0:	37 83       	std	Z+7, r19	; 0x07
     8e2:	26 83       	std	Z+6, r18	; 0x06
     8e4:	82 81       	ldd	r24, Z+2	; 0x02
     8e6:	93 81       	ldd	r25, Z+3	; 0x03
     8e8:	28 17       	cp	r18, r24
     8ea:	39 07       	cpc	r19, r25
     8ec:	20 f0       	brcs	.+8      	; 0x8f6 <prvCopyDataFromQueue+0x28>
     8ee:	80 81       	ld	r24, Z
     8f0:	91 81       	ldd	r25, Z+1	; 0x01
     8f2:	97 83       	std	Z+7, r25	; 0x07
     8f4:	86 83       	std	Z+6, r24	; 0x06
     8f6:	cb 01       	movw	r24, r22
     8f8:	66 81       	ldd	r22, Z+6	; 0x06
     8fa:	77 81       	ldd	r23, Z+7	; 0x07
     8fc:	0e 94 a8 0c 	call	0x1950	; 0x1950 <memcpy>
     900:	08 95       	ret

00000902 <prvUnlockQueue>:
     902:	0f 93       	push	r16
     904:	1f 93       	push	r17
     906:	cf 93       	push	r28
     908:	df 93       	push	r29
     90a:	ec 01       	movw	r28, r24
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	0f 92       	push	r0
     912:	8e 8d       	ldd	r24, Y+30	; 0x1e
     914:	18 16       	cp	r1, r24
     916:	bc f4       	brge	.+46     	; 0x946 <prvUnlockQueue+0x44>
     918:	89 89       	ldd	r24, Y+17	; 0x11
     91a:	81 11       	cpse	r24, r1
     91c:	05 c0       	rjmp	.+10     	; 0x928 <prvUnlockQueue+0x26>
     91e:	13 c0       	rjmp	.+38     	; 0x946 <prvUnlockQueue+0x44>
     920:	89 89       	ldd	r24, Y+17	; 0x11
     922:	81 11       	cpse	r24, r1
     924:	04 c0       	rjmp	.+8      	; 0x92e <prvUnlockQueue+0x2c>
     926:	0f c0       	rjmp	.+30     	; 0x946 <prvUnlockQueue+0x44>
     928:	8e 01       	movw	r16, r28
     92a:	0f 5e       	subi	r16, 0xEF	; 239
     92c:	1f 4f       	sbci	r17, 0xFF	; 255
     92e:	c8 01       	movw	r24, r16
     930:	0e 94 c4 0a 	call	0x1588	; 0x1588 <xTaskRemoveFromEventList>
     934:	81 11       	cpse	r24, r1
     936:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <vTaskMissedYield>
     93a:	8e 8d       	ldd	r24, Y+30	; 0x1e
     93c:	81 50       	subi	r24, 0x01	; 1
     93e:	8e 8f       	std	Y+30, r24	; 0x1e
     940:	8e 8d       	ldd	r24, Y+30	; 0x1e
     942:	18 16       	cp	r1, r24
     944:	6c f3       	brlt	.-38     	; 0x920 <prvUnlockQueue+0x1e>
     946:	8f ef       	ldi	r24, 0xFF	; 255
     948:	8e 8f       	std	Y+30, r24	; 0x1e
     94a:	0f 90       	pop	r0
     94c:	0f be       	out	0x3f, r0	; 63
     94e:	0f b6       	in	r0, 0x3f	; 63
     950:	f8 94       	cli
     952:	0f 92       	push	r0
     954:	8d 8d       	ldd	r24, Y+29	; 0x1d
     956:	18 16       	cp	r1, r24
     958:	bc f4       	brge	.+46     	; 0x988 <prvUnlockQueue+0x86>
     95a:	88 85       	ldd	r24, Y+8	; 0x08
     95c:	81 11       	cpse	r24, r1
     95e:	05 c0       	rjmp	.+10     	; 0x96a <prvUnlockQueue+0x68>
     960:	13 c0       	rjmp	.+38     	; 0x988 <prvUnlockQueue+0x86>
     962:	88 85       	ldd	r24, Y+8	; 0x08
     964:	81 11       	cpse	r24, r1
     966:	04 c0       	rjmp	.+8      	; 0x970 <prvUnlockQueue+0x6e>
     968:	0f c0       	rjmp	.+30     	; 0x988 <prvUnlockQueue+0x86>
     96a:	8e 01       	movw	r16, r28
     96c:	08 5f       	subi	r16, 0xF8	; 248
     96e:	1f 4f       	sbci	r17, 0xFF	; 255
     970:	c8 01       	movw	r24, r16
     972:	0e 94 c4 0a 	call	0x1588	; 0x1588 <xTaskRemoveFromEventList>
     976:	81 11       	cpse	r24, r1
     978:	0e 94 50 0b 	call	0x16a0	; 0x16a0 <vTaskMissedYield>
     97c:	8d 8d       	ldd	r24, Y+29	; 0x1d
     97e:	81 50       	subi	r24, 0x01	; 1
     980:	8d 8f       	std	Y+29, r24	; 0x1d
     982:	8d 8d       	ldd	r24, Y+29	; 0x1d
     984:	18 16       	cp	r1, r24
     986:	6c f3       	brlt	.-38     	; 0x962 <prvUnlockQueue+0x60>
     988:	8f ef       	ldi	r24, 0xFF	; 255
     98a:	8d 8f       	std	Y+29, r24	; 0x1d
     98c:	0f 90       	pop	r0
     98e:	0f be       	out	0x3f, r0	; 63
     990:	df 91       	pop	r29
     992:	cf 91       	pop	r28
     994:	1f 91       	pop	r17
     996:	0f 91       	pop	r16
     998:	08 95       	ret

0000099a <xQueueGenericReset>:
     99a:	cf 93       	push	r28
     99c:	df 93       	push	r29
     99e:	ec 01       	movw	r28, r24
     9a0:	0f b6       	in	r0, 0x3f	; 63
     9a2:	f8 94       	cli
     9a4:	0f 92       	push	r0
     9a6:	48 81       	ld	r20, Y
     9a8:	59 81       	ldd	r21, Y+1	; 0x01
     9aa:	2c 8d       	ldd	r18, Y+28	; 0x1c
     9ac:	30 e0       	ldi	r19, 0x00	; 0
     9ae:	7b 8d       	ldd	r23, Y+27	; 0x1b
     9b0:	72 9f       	mul	r23, r18
     9b2:	c0 01       	movw	r24, r0
     9b4:	73 9f       	mul	r23, r19
     9b6:	90 0d       	add	r25, r0
     9b8:	11 24       	eor	r1, r1
     9ba:	fa 01       	movw	r30, r20
     9bc:	e8 0f       	add	r30, r24
     9be:	f9 1f       	adc	r31, r25
     9c0:	fb 83       	std	Y+3, r31	; 0x03
     9c2:	ea 83       	std	Y+2, r30	; 0x02
     9c4:	1a 8e       	std	Y+26, r1	; 0x1a
     9c6:	5d 83       	std	Y+5, r21	; 0x05
     9c8:	4c 83       	std	Y+4, r20	; 0x04
     9ca:	82 1b       	sub	r24, r18
     9cc:	93 0b       	sbc	r25, r19
     9ce:	84 0f       	add	r24, r20
     9d0:	95 1f       	adc	r25, r21
     9d2:	9f 83       	std	Y+7, r25	; 0x07
     9d4:	8e 83       	std	Y+6, r24	; 0x06
     9d6:	8f ef       	ldi	r24, 0xFF	; 255
     9d8:	8d 8f       	std	Y+29, r24	; 0x1d
     9da:	8e 8f       	std	Y+30, r24	; 0x1e
     9dc:	61 11       	cpse	r22, r1
     9de:	0c c0       	rjmp	.+24     	; 0x9f8 <xQueueGenericReset+0x5e>
     9e0:	88 85       	ldd	r24, Y+8	; 0x08
     9e2:	88 23       	and	r24, r24
     9e4:	89 f0       	breq	.+34     	; 0xa08 <xQueueGenericReset+0x6e>
     9e6:	ce 01       	movw	r24, r28
     9e8:	08 96       	adiw	r24, 0x08	; 8
     9ea:	0e 94 c4 0a 	call	0x1588	; 0x1588 <xTaskRemoveFromEventList>
     9ee:	81 30       	cpi	r24, 0x01	; 1
     9f0:	59 f4       	brne	.+22     	; 0xa08 <xQueueGenericReset+0x6e>
     9f2:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
     9f6:	08 c0       	rjmp	.+16     	; 0xa08 <xQueueGenericReset+0x6e>
     9f8:	ce 01       	movw	r24, r28
     9fa:	08 96       	adiw	r24, 0x08	; 8
     9fc:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
     a00:	ce 01       	movw	r24, r28
     a02:	41 96       	adiw	r24, 0x11	; 17
     a04:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
     a08:	0f 90       	pop	r0
     a0a:	0f be       	out	0x3f, r0	; 63
     a0c:	81 e0       	ldi	r24, 0x01	; 1
     a0e:	df 91       	pop	r29
     a10:	cf 91       	pop	r28
     a12:	08 95       	ret

00000a14 <xQueueGenericCreate>:
     a14:	0f 93       	push	r16
     a16:	1f 93       	push	r17
     a18:	cf 93       	push	r28
     a1a:	df 93       	push	r29
     a1c:	08 2f       	mov	r16, r24
     a1e:	16 2f       	mov	r17, r22
     a20:	66 23       	and	r22, r22
     a22:	b9 f0       	breq	.+46     	; 0xa52 <xQueueGenericCreate+0x3e>
     a24:	86 9f       	mul	r24, r22
     a26:	c0 01       	movw	r24, r0
     a28:	11 24       	eor	r1, r1
     a2a:	80 96       	adiw	r24, 0x20	; 32
     a2c:	0e 94 3a 03 	call	0x674	; 0x674 <pvPortMalloc>
     a30:	ec 01       	movw	r28, r24
     a32:	00 97       	sbiw	r24, 0x00	; 0
     a34:	21 f4       	brne	.+8      	; 0xa3e <xQueueGenericCreate+0x2a>
     a36:	14 c0       	rjmp	.+40     	; 0xa60 <xQueueGenericCreate+0x4c>
     a38:	d9 83       	std	Y+1, r29	; 0x01
     a3a:	c8 83       	st	Y, r28
     a3c:	03 c0       	rjmp	.+6      	; 0xa44 <xQueueGenericCreate+0x30>
     a3e:	4f 96       	adiw	r24, 0x1f	; 31
     a40:	99 83       	std	Y+1, r25	; 0x01
     a42:	88 83       	st	Y, r24
     a44:	0b 8f       	std	Y+27, r16	; 0x1b
     a46:	1c 8f       	std	Y+28, r17	; 0x1c
     a48:	61 e0       	ldi	r22, 0x01	; 1
     a4a:	ce 01       	movw	r24, r28
     a4c:	0e 94 cd 04 	call	0x99a	; 0x99a <xQueueGenericReset>
     a50:	07 c0       	rjmp	.+14     	; 0xa60 <xQueueGenericCreate+0x4c>
     a52:	8f e1       	ldi	r24, 0x1F	; 31
     a54:	90 e0       	ldi	r25, 0x00	; 0
     a56:	0e 94 3a 03 	call	0x674	; 0x674 <pvPortMalloc>
     a5a:	ec 01       	movw	r28, r24
     a5c:	89 2b       	or	r24, r25
     a5e:	61 f7       	brne	.-40     	; 0xa38 <xQueueGenericCreate+0x24>
     a60:	ce 01       	movw	r24, r28
     a62:	df 91       	pop	r29
     a64:	cf 91       	pop	r28
     a66:	1f 91       	pop	r17
     a68:	0f 91       	pop	r16
     a6a:	08 95       	ret

00000a6c <xQueueGenericSend>:
     a6c:	9f 92       	push	r9
     a6e:	af 92       	push	r10
     a70:	bf 92       	push	r11
     a72:	cf 92       	push	r12
     a74:	df 92       	push	r13
     a76:	ef 92       	push	r14
     a78:	ff 92       	push	r15
     a7a:	0f 93       	push	r16
     a7c:	1f 93       	push	r17
     a7e:	cf 93       	push	r28
     a80:	df 93       	push	r29
     a82:	00 d0       	rcall	.+0      	; 0xa84 <xQueueGenericSend+0x18>
     a84:	00 d0       	rcall	.+0      	; 0xa86 <xQueueGenericSend+0x1a>
     a86:	1f 92       	push	r1
     a88:	cd b7       	in	r28, 0x3d	; 61
     a8a:	de b7       	in	r29, 0x3e	; 62
     a8c:	8c 01       	movw	r16, r24
     a8e:	6b 01       	movw	r12, r22
     a90:	5d 83       	std	Y+5, r21	; 0x05
     a92:	4c 83       	std	Y+4, r20	; 0x04
     a94:	a2 2e       	mov	r10, r18
     a96:	b1 2c       	mov	r11, r1
     a98:	99 24       	eor	r9, r9
     a9a:	93 94       	inc	r9
     a9c:	7c 01       	movw	r14, r24
     a9e:	88 e0       	ldi	r24, 0x08	; 8
     aa0:	e8 0e       	add	r14, r24
     aa2:	f1 1c       	adc	r15, r1
     aa4:	0f b6       	in	r0, 0x3f	; 63
     aa6:	f8 94       	cli
     aa8:	0f 92       	push	r0
     aaa:	f8 01       	movw	r30, r16
     aac:	92 8d       	ldd	r25, Z+26	; 0x1a
     aae:	83 8d       	ldd	r24, Z+27	; 0x1b
     ab0:	98 17       	cp	r25, r24
     ab2:	18 f0       	brcs	.+6      	; 0xaba <xQueueGenericSend+0x4e>
     ab4:	f2 e0       	ldi	r31, 0x02	; 2
     ab6:	af 12       	cpse	r10, r31
     ab8:	19 c0       	rjmp	.+50     	; 0xaec <xQueueGenericSend+0x80>
     aba:	4a 2d       	mov	r20, r10
     abc:	b6 01       	movw	r22, r12
     abe:	c8 01       	movw	r24, r16
     ac0:	0e 94 07 04 	call	0x80e	; 0x80e <prvCopyDataToQueue>
     ac4:	f8 01       	movw	r30, r16
     ac6:	91 89       	ldd	r25, Z+17	; 0x11
     ac8:	99 23       	and	r25, r25
     aca:	49 f0       	breq	.+18     	; 0xade <xQueueGenericSend+0x72>
     acc:	c8 01       	movw	r24, r16
     ace:	41 96       	adiw	r24, 0x11	; 17
     ad0:	0e 94 c4 0a 	call	0x1588	; 0x1588 <xTaskRemoveFromEventList>
     ad4:	81 30       	cpi	r24, 0x01	; 1
     ad6:	31 f4       	brne	.+12     	; 0xae4 <xQueueGenericSend+0x78>
     ad8:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
     adc:	03 c0       	rjmp	.+6      	; 0xae4 <xQueueGenericSend+0x78>
     ade:	81 11       	cpse	r24, r1
     ae0:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
     ae4:	0f 90       	pop	r0
     ae6:	0f be       	out	0x3f, r0	; 63
     ae8:	81 e0       	ldi	r24, 0x01	; 1
     aea:	50 c0       	rjmp	.+160    	; 0xb8c <xQueueGenericSend+0x120>
     aec:	8c 81       	ldd	r24, Y+4	; 0x04
     aee:	9d 81       	ldd	r25, Y+5	; 0x05
     af0:	89 2b       	or	r24, r25
     af2:	21 f4       	brne	.+8      	; 0xafc <xQueueGenericSend+0x90>
     af4:	0f 90       	pop	r0
     af6:	0f be       	out	0x3f, r0	; 63
     af8:	80 e0       	ldi	r24, 0x00	; 0
     afa:	48 c0       	rjmp	.+144    	; 0xb8c <xQueueGenericSend+0x120>
     afc:	b1 10       	cpse	r11, r1
     afe:	05 c0       	rjmp	.+10     	; 0xb0a <xQueueGenericSend+0x9e>
     b00:	ce 01       	movw	r24, r28
     b02:	01 96       	adiw	r24, 0x01	; 1
     b04:	0e 94 0c 0b 	call	0x1618	; 0x1618 <vTaskSetTimeOutState>
     b08:	b9 2c       	mov	r11, r9
     b0a:	0f 90       	pop	r0
     b0c:	0f be       	out	0x3f, r0	; 63
     b0e:	0e 94 5d 08 	call	0x10ba	; 0x10ba <vTaskSuspendAll>
     b12:	0f b6       	in	r0, 0x3f	; 63
     b14:	f8 94       	cli
     b16:	0f 92       	push	r0
     b18:	f8 01       	movw	r30, r16
     b1a:	85 8d       	ldd	r24, Z+29	; 0x1d
     b1c:	8f 3f       	cpi	r24, 0xFF	; 255
     b1e:	09 f4       	brne	.+2      	; 0xb22 <xQueueGenericSend+0xb6>
     b20:	15 8e       	std	Z+29, r1	; 0x1d
     b22:	f8 01       	movw	r30, r16
     b24:	86 8d       	ldd	r24, Z+30	; 0x1e
     b26:	8f 3f       	cpi	r24, 0xFF	; 255
     b28:	09 f4       	brne	.+2      	; 0xb2c <xQueueGenericSend+0xc0>
     b2a:	16 8e       	std	Z+30, r1	; 0x1e
     b2c:	0f 90       	pop	r0
     b2e:	0f be       	out	0x3f, r0	; 63
     b30:	be 01       	movw	r22, r28
     b32:	6c 5f       	subi	r22, 0xFC	; 252
     b34:	7f 4f       	sbci	r23, 0xFF	; 255
     b36:	ce 01       	movw	r24, r28
     b38:	01 96       	adiw	r24, 0x01	; 1
     b3a:	0e 94 17 0b 	call	0x162e	; 0x162e <xTaskCheckForTimeOut>
     b3e:	81 11       	cpse	r24, r1
     b40:	1f c0       	rjmp	.+62     	; 0xb80 <xQueueGenericSend+0x114>
     b42:	0f b6       	in	r0, 0x3f	; 63
     b44:	f8 94       	cli
     b46:	0f 92       	push	r0
     b48:	f8 01       	movw	r30, r16
     b4a:	92 8d       	ldd	r25, Z+26	; 0x1a
     b4c:	0f 90       	pop	r0
     b4e:	0f be       	out	0x3f, r0	; 63
     b50:	83 8d       	ldd	r24, Z+27	; 0x1b
     b52:	98 13       	cpse	r25, r24
     b54:	0f c0       	rjmp	.+30     	; 0xb74 <xQueueGenericSend+0x108>
     b56:	6c 81       	ldd	r22, Y+4	; 0x04
     b58:	7d 81       	ldd	r23, Y+5	; 0x05
     b5a:	c7 01       	movw	r24, r14
     b5c:	0e 94 98 0a 	call	0x1530	; 0x1530 <vTaskPlaceOnEventList>
     b60:	c8 01       	movw	r24, r16
     b62:	0e 94 81 04 	call	0x902	; 0x902 <prvUnlockQueue>
     b66:	0e 94 2a 09 	call	0x1254	; 0x1254 <xTaskResumeAll>
     b6a:	81 11       	cpse	r24, r1
     b6c:	9b cf       	rjmp	.-202    	; 0xaa4 <xQueueGenericSend+0x38>
     b6e:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
     b72:	98 cf       	rjmp	.-208    	; 0xaa4 <xQueueGenericSend+0x38>
     b74:	c8 01       	movw	r24, r16
     b76:	0e 94 81 04 	call	0x902	; 0x902 <prvUnlockQueue>
     b7a:	0e 94 2a 09 	call	0x1254	; 0x1254 <xTaskResumeAll>
     b7e:	92 cf       	rjmp	.-220    	; 0xaa4 <xQueueGenericSend+0x38>
     b80:	c8 01       	movw	r24, r16
     b82:	0e 94 81 04 	call	0x902	; 0x902 <prvUnlockQueue>
     b86:	0e 94 2a 09 	call	0x1254	; 0x1254 <xTaskResumeAll>
     b8a:	80 e0       	ldi	r24, 0x00	; 0
     b8c:	0f 90       	pop	r0
     b8e:	0f 90       	pop	r0
     b90:	0f 90       	pop	r0
     b92:	0f 90       	pop	r0
     b94:	0f 90       	pop	r0
     b96:	df 91       	pop	r29
     b98:	cf 91       	pop	r28
     b9a:	1f 91       	pop	r17
     b9c:	0f 91       	pop	r16
     b9e:	ff 90       	pop	r15
     ba0:	ef 90       	pop	r14
     ba2:	df 90       	pop	r13
     ba4:	cf 90       	pop	r12
     ba6:	bf 90       	pop	r11
     ba8:	af 90       	pop	r10
     baa:	9f 90       	pop	r9
     bac:	08 95       	ret

00000bae <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
     bae:	cf 93       	push	r28
     bb0:	df 93       	push	r29
     bb2:	fc 01       	movw	r30, r24
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     bb4:	92 8d       	ldd	r25, Z+26	; 0x1a
     bb6:	83 8d       	ldd	r24, Z+27	; 0x1b
     bb8:	98 17       	cp	r25, r24
     bba:	d0 f4       	brcc	.+52     	; 0xbf0 <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
     bbc:	82 8d       	ldd	r24, Z+26	; 0x1a
     bbe:	8f 5f       	subi	r24, 0xFF	; 255
     bc0:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     bc2:	86 8d       	ldd	r24, Z+30	; 0x1e
     bc4:	8f 3f       	cpi	r24, 0xFF	; 255
     bc6:	79 f4       	brne	.+30     	; 0xbe6 <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     bc8:	81 89       	ldd	r24, Z+17	; 0x11
     bca:	88 23       	and	r24, r24
     bcc:	99 f0       	breq	.+38     	; 0xbf4 <xQueueGiveFromISR+0x46>
     bce:	eb 01       	movw	r28, r22
     bd0:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     bd2:	41 96       	adiw	r24, 0x11	; 17
     bd4:	0e 94 c4 0a 	call	0x1588	; 0x1588 <xTaskRemoveFromEventList>
     bd8:	88 23       	and	r24, r24
     bda:	71 f0       	breq	.+28     	; 0xbf8 <xQueueGiveFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     bdc:	20 97       	sbiw	r28, 0x00	; 0
     bde:	71 f0       	breq	.+28     	; 0xbfc <xQueueGiveFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     be0:	81 e0       	ldi	r24, 0x01	; 1
     be2:	88 83       	st	Y, r24
     be4:	0c c0       	rjmp	.+24     	; 0xbfe <xQueueGiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     be6:	86 8d       	ldd	r24, Z+30	; 0x1e
     be8:	8f 5f       	subi	r24, 0xFF	; 255
     bea:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     bec:	81 e0       	ldi	r24, 0x01	; 1
     bee:	07 c0       	rjmp	.+14     	; 0xbfe <xQueueGiveFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     bf0:	80 e0       	ldi	r24, 0x00	; 0
     bf2:	05 c0       	rjmp	.+10     	; 0xbfe <xQueueGiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
     bf4:	81 e0       	ldi	r24, 0x01	; 1
     bf6:	03 c0       	rjmp	.+6      	; 0xbfe <xQueueGiveFromISR+0x50>
     bf8:	81 e0       	ldi	r24, 0x01	; 1
     bfa:	01 c0       	rjmp	.+2      	; 0xbfe <xQueueGiveFromISR+0x50>
     bfc:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     bfe:	df 91       	pop	r29
     c00:	cf 91       	pop	r28
     c02:	08 95       	ret

00000c04 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     c04:	9f 92       	push	r9
     c06:	af 92       	push	r10
     c08:	bf 92       	push	r11
     c0a:	cf 92       	push	r12
     c0c:	df 92       	push	r13
     c0e:	ef 92       	push	r14
     c10:	ff 92       	push	r15
     c12:	0f 93       	push	r16
     c14:	1f 93       	push	r17
     c16:	cf 93       	push	r28
     c18:	df 93       	push	r29
     c1a:	00 d0       	rcall	.+0      	; 0xc1c <xQueueGenericReceive+0x18>
     c1c:	00 d0       	rcall	.+0      	; 0xc1e <xQueueGenericReceive+0x1a>
     c1e:	1f 92       	push	r1
     c20:	cd b7       	in	r28, 0x3d	; 61
     c22:	de b7       	in	r29, 0x3e	; 62
     c24:	8c 01       	movw	r16, r24
     c26:	6b 01       	movw	r12, r22
     c28:	5d 83       	std	Y+5, r21	; 0x05
     c2a:	4c 83       	std	Y+4, r20	; 0x04
     c2c:	92 2e       	mov	r9, r18
BaseType_t xEntryTimeSet = pdFALSE;
     c2e:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     c30:	aa 24       	eor	r10, r10
     c32:	a3 94       	inc	r10
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     c34:	7c 01       	movw	r14, r24
     c36:	81 e1       	ldi	r24, 0x11	; 17
     c38:	e8 0e       	add	r14, r24
     c3a:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     c3c:	0f b6       	in	r0, 0x3f	; 63
     c3e:	f8 94       	cli
     c40:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     c42:	f8 01       	movw	r30, r16
     c44:	82 8d       	ldd	r24, Z+26	; 0x1a
     c46:	88 23       	and	r24, r24
     c48:	99 f1       	breq	.+102    	; 0xcb0 <xQueueGenericReceive+0xac>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     c4a:	e6 80       	ldd	r14, Z+6	; 0x06
     c4c:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     c4e:	b6 01       	movw	r22, r12
     c50:	c8 01       	movw	r24, r16
     c52:	0e 94 67 04 	call	0x8ce	; 0x8ce <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     c56:	91 10       	cpse	r9, r1
     c58:	1a c0       	rjmp	.+52     	; 0xc8e <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     c5a:	f8 01       	movw	r30, r16
     c5c:	82 8d       	ldd	r24, Z+26	; 0x1a
     c5e:	81 50       	subi	r24, 0x01	; 1
     c60:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     c62:	80 81       	ld	r24, Z
     c64:	91 81       	ldd	r25, Z+1	; 0x01
     c66:	89 2b       	or	r24, r25
     c68:	29 f4       	brne	.+10     	; 0xc74 <xQueueGenericReceive+0x70>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     c6a:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <pvTaskIncrementMutexHeldCount>
     c6e:	f8 01       	movw	r30, r16
     c70:	93 83       	std	Z+3, r25	; 0x03
     c72:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     c74:	f8 01       	movw	r30, r16
     c76:	80 85       	ldd	r24, Z+8	; 0x08
     c78:	88 23       	and	r24, r24
     c7a:	b1 f0       	breq	.+44     	; 0xca8 <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     c7c:	c8 01       	movw	r24, r16
     c7e:	08 96       	adiw	r24, 0x08	; 8
     c80:	0e 94 c4 0a 	call	0x1588	; 0x1588 <xTaskRemoveFromEventList>
     c84:	81 30       	cpi	r24, 0x01	; 1
     c86:	81 f4       	brne	.+32     	; 0xca8 <xQueueGenericReceive+0xa4>
						{
							queueYIELD_IF_USING_PREEMPTION();
     c88:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
     c8c:	0d c0       	rjmp	.+26     	; 0xca8 <xQueueGenericReceive+0xa4>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     c8e:	f8 01       	movw	r30, r16
     c90:	f7 82       	std	Z+7, r15	; 0x07
     c92:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     c94:	81 89       	ldd	r24, Z+17	; 0x11
     c96:	88 23       	and	r24, r24
     c98:	39 f0       	breq	.+14     	; 0xca8 <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c9a:	c8 01       	movw	r24, r16
     c9c:	41 96       	adiw	r24, 0x11	; 17
     c9e:	0e 94 c4 0a 	call	0x1588	; 0x1588 <xTaskRemoveFromEventList>
     ca2:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     ca4:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     ca8:	0f 90       	pop	r0
     caa:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     cac:	81 e0       	ldi	r24, 0x01	; 1
     cae:	5c c0       	rjmp	.+184    	; 0xd68 <xQueueGenericReceive+0x164>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     cb0:	8c 81       	ldd	r24, Y+4	; 0x04
     cb2:	9d 81       	ldd	r25, Y+5	; 0x05
     cb4:	89 2b       	or	r24, r25
     cb6:	21 f4       	brne	.+8      	; 0xcc0 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     cb8:	0f 90       	pop	r0
     cba:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     cbc:	80 e0       	ldi	r24, 0x00	; 0
     cbe:	54 c0       	rjmp	.+168    	; 0xd68 <xQueueGenericReceive+0x164>
				}
				else if( xEntryTimeSet == pdFALSE )
     cc0:	b1 10       	cpse	r11, r1
     cc2:	05 c0       	rjmp	.+10     	; 0xcce <xQueueGenericReceive+0xca>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     cc4:	ce 01       	movw	r24, r28
     cc6:	01 96       	adiw	r24, 0x01	; 1
     cc8:	0e 94 0c 0b 	call	0x1618	; 0x1618 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     ccc:	ba 2c       	mov	r11, r10
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     cce:	0f 90       	pop	r0
     cd0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     cd2:	0e 94 5d 08 	call	0x10ba	; 0x10ba <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     cd6:	0f b6       	in	r0, 0x3f	; 63
     cd8:	f8 94       	cli
     cda:	0f 92       	push	r0
     cdc:	f8 01       	movw	r30, r16
     cde:	85 8d       	ldd	r24, Z+29	; 0x1d
     ce0:	8f 3f       	cpi	r24, 0xFF	; 255
     ce2:	09 f4       	brne	.+2      	; 0xce6 <xQueueGenericReceive+0xe2>
     ce4:	15 8e       	std	Z+29, r1	; 0x1d
     ce6:	f8 01       	movw	r30, r16
     ce8:	86 8d       	ldd	r24, Z+30	; 0x1e
     cea:	8f 3f       	cpi	r24, 0xFF	; 255
     cec:	09 f4       	brne	.+2      	; 0xcf0 <xQueueGenericReceive+0xec>
     cee:	16 8e       	std	Z+30, r1	; 0x1e
     cf0:	0f 90       	pop	r0
     cf2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     cf4:	be 01       	movw	r22, r28
     cf6:	6c 5f       	subi	r22, 0xFC	; 252
     cf8:	7f 4f       	sbci	r23, 0xFF	; 255
     cfa:	ce 01       	movw	r24, r28
     cfc:	01 96       	adiw	r24, 0x01	; 1
     cfe:	0e 94 17 0b 	call	0x162e	; 0x162e <xTaskCheckForTimeOut>
     d02:	81 11       	cpse	r24, r1
     d04:	2b c0       	rjmp	.+86     	; 0xd5c <xQueueGenericReceive+0x158>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     d06:	0f b6       	in	r0, 0x3f	; 63
     d08:	f8 94       	cli
     d0a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     d0c:	f8 01       	movw	r30, r16
     d0e:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     d10:	0f 90       	pop	r0
     d12:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     d14:	81 11       	cpse	r24, r1
     d16:	1c c0       	rjmp	.+56     	; 0xd50 <xQueueGenericReceive+0x14c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     d18:	80 81       	ld	r24, Z
     d1a:	91 81       	ldd	r25, Z+1	; 0x01
     d1c:	89 2b       	or	r24, r25
     d1e:	49 f4       	brne	.+18     	; 0xd32 <xQueueGenericReceive+0x12e>
					{
						taskENTER_CRITICAL();
     d20:	0f b6       	in	r0, 0x3f	; 63
     d22:	f8 94       	cli
     d24:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     d26:	82 81       	ldd	r24, Z+2	; 0x02
     d28:	93 81       	ldd	r25, Z+3	; 0x03
     d2a:	0e 94 54 0b 	call	0x16a8	; 0x16a8 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     d2e:	0f 90       	pop	r0
     d30:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     d32:	6c 81       	ldd	r22, Y+4	; 0x04
     d34:	7d 81       	ldd	r23, Y+5	; 0x05
     d36:	c7 01       	movw	r24, r14
     d38:	0e 94 98 0a 	call	0x1530	; 0x1530 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     d3c:	c8 01       	movw	r24, r16
     d3e:	0e 94 81 04 	call	0x902	; 0x902 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     d42:	0e 94 2a 09 	call	0x1254	; 0x1254 <xTaskResumeAll>
     d46:	81 11       	cpse	r24, r1
     d48:	79 cf       	rjmp	.-270    	; 0xc3c <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
     d4a:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
     d4e:	76 cf       	rjmp	.-276    	; 0xc3c <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     d50:	c8 01       	movw	r24, r16
     d52:	0e 94 81 04 	call	0x902	; 0x902 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     d56:	0e 94 2a 09 	call	0x1254	; 0x1254 <xTaskResumeAll>
     d5a:	70 cf       	rjmp	.-288    	; 0xc3c <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     d5c:	c8 01       	movw	r24, r16
     d5e:	0e 94 81 04 	call	0x902	; 0x902 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     d62:	0e 94 2a 09 	call	0x1254	; 0x1254 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     d66:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     d68:	0f 90       	pop	r0
     d6a:	0f 90       	pop	r0
     d6c:	0f 90       	pop	r0
     d6e:	0f 90       	pop	r0
     d70:	0f 90       	pop	r0
     d72:	df 91       	pop	r29
     d74:	cf 91       	pop	r28
     d76:	1f 91       	pop	r17
     d78:	0f 91       	pop	r16
     d7a:	ff 90       	pop	r15
     d7c:	ef 90       	pop	r14
     d7e:	df 90       	pop	r13
     d80:	cf 90       	pop	r12
     d82:	bf 90       	pop	r11
     d84:	af 90       	pop	r10
     d86:	9f 90       	pop	r9
     d88:	08 95       	ret

00000d8a <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     d8a:	e0 91 54 08 	lds	r30, 0x0854	; 0x800854 <pxDelayedTaskList>
     d8e:	f0 91 55 08 	lds	r31, 0x0855	; 0x800855 <pxDelayedTaskList+0x1>
     d92:	80 81       	ld	r24, Z
     d94:	81 11       	cpse	r24, r1
     d96:	07 c0       	rjmp	.+14     	; 0xda6 <prvResetNextTaskUnblockTime+0x1c>
     d98:	8f ef       	ldi	r24, 0xFF	; 255
     d9a:	9f ef       	ldi	r25, 0xFF	; 255
     d9c:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
     da0:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
     da4:	08 95       	ret
     da6:	e0 91 54 08 	lds	r30, 0x0854	; 0x800854 <pxDelayedTaskList>
     daa:	f0 91 55 08 	lds	r31, 0x0855	; 0x800855 <pxDelayedTaskList+0x1>
     dae:	05 80       	ldd	r0, Z+5	; 0x05
     db0:	f6 81       	ldd	r31, Z+6	; 0x06
     db2:	e0 2d       	mov	r30, r0
     db4:	06 80       	ldd	r0, Z+6	; 0x06
     db6:	f7 81       	ldd	r31, Z+7	; 0x07
     db8:	e0 2d       	mov	r30, r0
     dba:	82 81       	ldd	r24, Z+2	; 0x02
     dbc:	93 81       	ldd	r25, Z+3	; 0x03
     dbe:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
     dc2:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
     dc6:	08 95       	ret

00000dc8 <prvAddCurrentTaskToDelayedList>:
     dc8:	cf 93       	push	r28
     dca:	df 93       	push	r29
     dcc:	ec 01       	movw	r28, r24
     dce:	e0 91 8c 08 	lds	r30, 0x088C	; 0x80088c <pxCurrentTCB>
     dd2:	f0 91 8d 08 	lds	r31, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
     dd6:	93 83       	std	Z+3, r25	; 0x03
     dd8:	82 83       	std	Z+2, r24	; 0x02
     dda:	80 91 31 08 	lds	r24, 0x0831	; 0x800831 <xTickCount>
     dde:	90 91 32 08 	lds	r25, 0x0832	; 0x800832 <xTickCount+0x1>
     de2:	c8 17       	cp	r28, r24
     de4:	d9 07       	cpc	r29, r25
     de6:	68 f4       	brcc	.+26     	; 0xe02 <prvAddCurrentTaskToDelayedList+0x3a>
     de8:	60 91 8c 08 	lds	r22, 0x088C	; 0x80088c <pxCurrentTCB>
     dec:	70 91 8d 08 	lds	r23, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
     df0:	80 91 52 08 	lds	r24, 0x0852	; 0x800852 <pxOverflowDelayedTaskList>
     df4:	90 91 53 08 	lds	r25, 0x0853	; 0x800853 <pxOverflowDelayedTaskList+0x1>
     df8:	6e 5f       	subi	r22, 0xFE	; 254
     dfa:	7f 4f       	sbci	r23, 0xFF	; 255
     dfc:	0e 94 85 01 	call	0x30a	; 0x30a <vListInsert>
     e00:	17 c0       	rjmp	.+46     	; 0xe30 <prvAddCurrentTaskToDelayedList+0x68>
     e02:	60 91 8c 08 	lds	r22, 0x088C	; 0x80088c <pxCurrentTCB>
     e06:	70 91 8d 08 	lds	r23, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
     e0a:	80 91 54 08 	lds	r24, 0x0854	; 0x800854 <pxDelayedTaskList>
     e0e:	90 91 55 08 	lds	r25, 0x0855	; 0x800855 <pxDelayedTaskList+0x1>
     e12:	6e 5f       	subi	r22, 0xFE	; 254
     e14:	7f 4f       	sbci	r23, 0xFF	; 255
     e16:	0e 94 85 01 	call	0x30a	; 0x30a <vListInsert>
     e1a:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xNextTaskUnblockTime>
     e1e:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <xNextTaskUnblockTime+0x1>
     e22:	c8 17       	cp	r28, r24
     e24:	d9 07       	cpc	r29, r25
     e26:	20 f4       	brcc	.+8      	; 0xe30 <prvAddCurrentTaskToDelayedList+0x68>
     e28:	d0 93 03 01 	sts	0x0103, r29	; 0x800103 <xNextTaskUnblockTime+0x1>
     e2c:	c0 93 02 01 	sts	0x0102, r28	; 0x800102 <xNextTaskUnblockTime>
     e30:	df 91       	pop	r29
     e32:	cf 91       	pop	r28
     e34:	08 95       	ret

00000e36 <xTaskGenericCreate>:
     e36:	4f 92       	push	r4
     e38:	5f 92       	push	r5
     e3a:	6f 92       	push	r6
     e3c:	7f 92       	push	r7
     e3e:	8f 92       	push	r8
     e40:	9f 92       	push	r9
     e42:	af 92       	push	r10
     e44:	bf 92       	push	r11
     e46:	cf 92       	push	r12
     e48:	df 92       	push	r13
     e4a:	ef 92       	push	r14
     e4c:	ff 92       	push	r15
     e4e:	0f 93       	push	r16
     e50:	1f 93       	push	r17
     e52:	cf 93       	push	r28
     e54:	df 93       	push	r29
     e56:	4c 01       	movw	r8, r24
     e58:	eb 01       	movw	r28, r22
     e5a:	5a 01       	movw	r10, r20
     e5c:	29 01       	movw	r4, r18
     e5e:	c1 14       	cp	r12, r1
     e60:	d1 04       	cpc	r13, r1
     e62:	39 f4       	brne	.+14     	; 0xe72 <xTaskGenericCreate+0x3c>
     e64:	ca 01       	movw	r24, r20
     e66:	0e 94 3a 03 	call	0x674	; 0x674 <pvPortMalloc>
     e6a:	6c 01       	movw	r12, r24
     e6c:	89 2b       	or	r24, r25
     e6e:	09 f4       	brne	.+2      	; 0xe72 <xTaskGenericCreate+0x3c>
     e70:	e3 c0       	rjmp	.+454    	; 0x1038 <xTaskGenericCreate+0x202>
     e72:	88 e2       	ldi	r24, 0x28	; 40
     e74:	90 e0       	ldi	r25, 0x00	; 0
     e76:	0e 94 3a 03 	call	0x674	; 0x674 <pvPortMalloc>
     e7a:	3c 01       	movw	r6, r24
     e7c:	00 97       	sbiw	r24, 0x00	; 0
     e7e:	79 f0       	breq	.+30     	; 0xe9e <xTaskGenericCreate+0x68>
     e80:	fc 01       	movw	r30, r24
     e82:	d0 8e       	std	Z+24, r13	; 0x18
     e84:	c7 8a       	std	Z+23, r12	; 0x17
     e86:	f1 e0       	ldi	r31, 0x01	; 1
     e88:	af 1a       	sub	r10, r31
     e8a:	b1 08       	sbc	r11, r1
     e8c:	ca 0c       	add	r12, r10
     e8e:	db 1c       	adc	r13, r11
     e90:	88 81       	ld	r24, Y
     e92:	f3 01       	movw	r30, r6
     e94:	81 8f       	std	Z+25, r24	; 0x19
     e96:	88 81       	ld	r24, Y
     e98:	81 11       	cpse	r24, r1
     e9a:	05 c0       	rjmp	.+10     	; 0xea6 <xTaskGenericCreate+0x70>
     e9c:	14 c0       	rjmp	.+40     	; 0xec6 <xTaskGenericCreate+0x90>
     e9e:	c6 01       	movw	r24, r12
     ea0:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <vPortFree>
     ea4:	c9 c0       	rjmp	.+402    	; 0x1038 <xTaskGenericCreate+0x202>
     ea6:	d3 01       	movw	r26, r6
     ea8:	5a 96       	adiw	r26, 0x1a	; 26
     eaa:	fe 01       	movw	r30, r28
     eac:	31 96       	adiw	r30, 0x01	; 1
     eae:	9e 01       	movw	r18, r28
     eb0:	28 5f       	subi	r18, 0xF8	; 248
     eb2:	3f 4f       	sbci	r19, 0xFF	; 255
     eb4:	ef 01       	movw	r28, r30
     eb6:	81 91       	ld	r24, Z+
     eb8:	8d 93       	st	X+, r24
     eba:	88 81       	ld	r24, Y
     ebc:	88 23       	and	r24, r24
     ebe:	19 f0       	breq	.+6      	; 0xec6 <xTaskGenericCreate+0x90>
     ec0:	e2 17       	cp	r30, r18
     ec2:	f3 07       	cpc	r31, r19
     ec4:	b9 f7       	brne	.-18     	; 0xeb4 <xTaskGenericCreate+0x7e>
     ec6:	f3 01       	movw	r30, r6
     ec8:	10 a2       	std	Z+32, r1	; 0x20
     eca:	10 2f       	mov	r17, r16
     ecc:	04 30       	cpi	r16, 0x04	; 4
     ece:	08 f0       	brcs	.+2      	; 0xed2 <xTaskGenericCreate+0x9c>
     ed0:	13 e0       	ldi	r17, 0x03	; 3
     ed2:	f3 01       	movw	r30, r6
     ed4:	16 8b       	std	Z+22, r17	; 0x16
     ed6:	11 a3       	std	Z+33, r17	; 0x21
     ed8:	12 a2       	std	Z+34, r1	; 0x22
     eda:	e3 01       	movw	r28, r6
     edc:	22 96       	adiw	r28, 0x02	; 2
     ede:	ce 01       	movw	r24, r28
     ee0:	0e 94 60 01 	call	0x2c0	; 0x2c0 <vListInitialiseItem>
     ee4:	c3 01       	movw	r24, r6
     ee6:	0c 96       	adiw	r24, 0x0c	; 12
     ee8:	0e 94 60 01 	call	0x2c0	; 0x2c0 <vListInitialiseItem>
     eec:	f3 01       	movw	r30, r6
     eee:	71 86       	std	Z+9, r7	; 0x09
     ef0:	60 86       	std	Z+8, r6	; 0x08
     ef2:	84 e0       	ldi	r24, 0x04	; 4
     ef4:	90 e0       	ldi	r25, 0x00	; 0
     ef6:	81 1b       	sub	r24, r17
     ef8:	91 09       	sbc	r25, r1
     efa:	95 87       	std	Z+13, r25	; 0x0d
     efc:	84 87       	std	Z+12, r24	; 0x0c
     efe:	73 8a       	std	Z+19, r7	; 0x13
     f00:	62 8a       	std	Z+18, r6	; 0x12
     f02:	13 a2       	std	Z+35, r1	; 0x23
     f04:	14 a2       	std	Z+36, r1	; 0x24
     f06:	15 a2       	std	Z+37, r1	; 0x25
     f08:	16 a2       	std	Z+38, r1	; 0x26
     f0a:	17 a2       	std	Z+39, r1	; 0x27
     f0c:	a2 01       	movw	r20, r4
     f0e:	b4 01       	movw	r22, r8
     f10:	c6 01       	movw	r24, r12
     f12:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <pxPortInitialiseStack>
     f16:	f3 01       	movw	r30, r6
     f18:	91 83       	std	Z+1, r25	; 0x01
     f1a:	80 83       	st	Z, r24
     f1c:	e1 14       	cp	r14, r1
     f1e:	f1 04       	cpc	r15, r1
     f20:	19 f0       	breq	.+6      	; 0xf28 <xTaskGenericCreate+0xf2>
     f22:	f7 01       	movw	r30, r14
     f24:	71 82       	std	Z+1, r7	; 0x01
     f26:	60 82       	st	Z, r6
     f28:	0f b6       	in	r0, 0x3f	; 63
     f2a:	f8 94       	cli
     f2c:	0f 92       	push	r0
     f2e:	80 91 33 08 	lds	r24, 0x0833	; 0x800833 <uxCurrentNumberOfTasks>
     f32:	8f 5f       	subi	r24, 0xFF	; 255
     f34:	80 93 33 08 	sts	0x0833, r24	; 0x800833 <uxCurrentNumberOfTasks>
     f38:	80 91 8c 08 	lds	r24, 0x088C	; 0x80088c <pxCurrentTCB>
     f3c:	90 91 8d 08 	lds	r25, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
     f40:	89 2b       	or	r24, r25
     f42:	d1 f5       	brne	.+116    	; 0xfb8 <xTaskGenericCreate+0x182>
     f44:	70 92 8d 08 	sts	0x088D, r7	; 0x80088d <pxCurrentTCB+0x1>
     f48:	60 92 8c 08 	sts	0x088C, r6	; 0x80088c <pxCurrentTCB>
     f4c:	80 91 33 08 	lds	r24, 0x0833	; 0x800833 <uxCurrentNumberOfTasks>
     f50:	81 30       	cpi	r24, 0x01	; 1
     f52:	09 f0       	breq	.+2      	; 0xf56 <xTaskGenericCreate+0x120>
     f54:	40 c0       	rjmp	.+128    	; 0xfd6 <xTaskGenericCreate+0x1a0>
     f56:	88 e6       	ldi	r24, 0x68	; 104
     f58:	98 e0       	ldi	r25, 0x08	; 8
     f5a:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
     f5e:	81 e7       	ldi	r24, 0x71	; 113
     f60:	98 e0       	ldi	r25, 0x08	; 8
     f62:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
     f66:	8a e7       	ldi	r24, 0x7A	; 122
     f68:	98 e0       	ldi	r25, 0x08	; 8
     f6a:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
     f6e:	83 e8       	ldi	r24, 0x83	; 131
     f70:	98 e0       	ldi	r25, 0x08	; 8
     f72:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
     f76:	8f e5       	ldi	r24, 0x5F	; 95
     f78:	98 e0       	ldi	r25, 0x08	; 8
     f7a:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
     f7e:	86 e5       	ldi	r24, 0x56	; 86
     f80:	98 e0       	ldi	r25, 0x08	; 8
     f82:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
     f86:	89 e4       	ldi	r24, 0x49	; 73
     f88:	98 e0       	ldi	r25, 0x08	; 8
     f8a:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
     f8e:	80 e4       	ldi	r24, 0x40	; 64
     f90:	98 e0       	ldi	r25, 0x08	; 8
     f92:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
     f96:	86 e3       	ldi	r24, 0x36	; 54
     f98:	98 e0       	ldi	r25, 0x08	; 8
     f9a:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
     f9e:	8f e5       	ldi	r24, 0x5F	; 95
     fa0:	98 e0       	ldi	r25, 0x08	; 8
     fa2:	90 93 55 08 	sts	0x0855, r25	; 0x800855 <pxDelayedTaskList+0x1>
     fa6:	80 93 54 08 	sts	0x0854, r24	; 0x800854 <pxDelayedTaskList>
     faa:	86 e5       	ldi	r24, 0x56	; 86
     fac:	98 e0       	ldi	r25, 0x08	; 8
     fae:	90 93 53 08 	sts	0x0853, r25	; 0x800853 <pxOverflowDelayedTaskList+0x1>
     fb2:	80 93 52 08 	sts	0x0852, r24	; 0x800852 <pxOverflowDelayedTaskList>
     fb6:	0f c0       	rjmp	.+30     	; 0xfd6 <xTaskGenericCreate+0x1a0>
     fb8:	80 91 2f 08 	lds	r24, 0x082F	; 0x80082f <xSchedulerRunning>
     fbc:	81 11       	cpse	r24, r1
     fbe:	0b c0       	rjmp	.+22     	; 0xfd6 <xTaskGenericCreate+0x1a0>
     fc0:	e0 91 8c 08 	lds	r30, 0x088C	; 0x80088c <pxCurrentTCB>
     fc4:	f0 91 8d 08 	lds	r31, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
     fc8:	86 89       	ldd	r24, Z+22	; 0x16
     fca:	08 17       	cp	r16, r24
     fcc:	20 f0       	brcs	.+8      	; 0xfd6 <xTaskGenericCreate+0x1a0>
     fce:	70 92 8d 08 	sts	0x088D, r7	; 0x80088d <pxCurrentTCB+0x1>
     fd2:	60 92 8c 08 	sts	0x088C, r6	; 0x80088c <pxCurrentTCB>
     fd6:	80 91 2b 08 	lds	r24, 0x082B	; 0x80082b <uxTaskNumber>
     fda:	8f 5f       	subi	r24, 0xFF	; 255
     fdc:	80 93 2b 08 	sts	0x082B, r24	; 0x80082b <uxTaskNumber>
     fe0:	f3 01       	movw	r30, r6
     fe2:	86 89       	ldd	r24, Z+22	; 0x16
     fe4:	90 91 30 08 	lds	r25, 0x0830	; 0x800830 <uxTopReadyPriority>
     fe8:	98 17       	cp	r25, r24
     fea:	10 f4       	brcc	.+4      	; 0xff0 <xTaskGenericCreate+0x1ba>
     fec:	80 93 30 08 	sts	0x0830, r24	; 0x800830 <uxTopReadyPriority>
     ff0:	90 e0       	ldi	r25, 0x00	; 0
     ff2:	9c 01       	movw	r18, r24
     ff4:	22 0f       	add	r18, r18
     ff6:	33 1f       	adc	r19, r19
     ff8:	22 0f       	add	r18, r18
     ffa:	33 1f       	adc	r19, r19
     ffc:	22 0f       	add	r18, r18
     ffe:	33 1f       	adc	r19, r19
    1000:	82 0f       	add	r24, r18
    1002:	93 1f       	adc	r25, r19
    1004:	be 01       	movw	r22, r28
    1006:	88 59       	subi	r24, 0x98	; 152
    1008:	97 4f       	sbci	r25, 0xF7	; 247
    100a:	0e 94 64 01 	call	0x2c8	; 0x2c8 <vListInsertEnd>
    100e:	0f 90       	pop	r0
    1010:	0f be       	out	0x3f, r0	; 63
    1012:	80 91 2f 08 	lds	r24, 0x082F	; 0x80082f <xSchedulerRunning>
    1016:	88 23       	and	r24, r24
    1018:	59 f0       	breq	.+22     	; 0x1030 <xTaskGenericCreate+0x1fa>
    101a:	e0 91 8c 08 	lds	r30, 0x088C	; 0x80088c <pxCurrentTCB>
    101e:	f0 91 8d 08 	lds	r31, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
    1022:	86 89       	ldd	r24, Z+22	; 0x16
    1024:	80 17       	cp	r24, r16
    1026:	30 f4       	brcc	.+12     	; 0x1034 <xTaskGenericCreate+0x1fe>
    1028:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
    102c:	81 e0       	ldi	r24, 0x01	; 1
    102e:	05 c0       	rjmp	.+10     	; 0x103a <xTaskGenericCreate+0x204>
    1030:	81 e0       	ldi	r24, 0x01	; 1
    1032:	03 c0       	rjmp	.+6      	; 0x103a <xTaskGenericCreate+0x204>
    1034:	81 e0       	ldi	r24, 0x01	; 1
    1036:	01 c0       	rjmp	.+2      	; 0x103a <xTaskGenericCreate+0x204>
    1038:	8f ef       	ldi	r24, 0xFF	; 255
    103a:	df 91       	pop	r29
    103c:	cf 91       	pop	r28
    103e:	1f 91       	pop	r17
    1040:	0f 91       	pop	r16
    1042:	ff 90       	pop	r15
    1044:	ef 90       	pop	r14
    1046:	df 90       	pop	r13
    1048:	cf 90       	pop	r12
    104a:	bf 90       	pop	r11
    104c:	af 90       	pop	r10
    104e:	9f 90       	pop	r9
    1050:	8f 90       	pop	r8
    1052:	7f 90       	pop	r7
    1054:	6f 90       	pop	r6
    1056:	5f 90       	pop	r5
    1058:	4f 90       	pop	r4
    105a:	08 95       	ret

0000105c <vTaskStartScheduler>:
    105c:	af 92       	push	r10
    105e:	bf 92       	push	r11
    1060:	cf 92       	push	r12
    1062:	df 92       	push	r13
    1064:	ef 92       	push	r14
    1066:	ff 92       	push	r15
    1068:	0f 93       	push	r16
    106a:	a1 2c       	mov	r10, r1
    106c:	b1 2c       	mov	r11, r1
    106e:	c1 2c       	mov	r12, r1
    1070:	d1 2c       	mov	r13, r1
    1072:	0f 2e       	mov	r0, r31
    1074:	f4 e3       	ldi	r31, 0x34	; 52
    1076:	ef 2e       	mov	r14, r31
    1078:	f8 e0       	ldi	r31, 0x08	; 8
    107a:	ff 2e       	mov	r15, r31
    107c:	f0 2d       	mov	r31, r0
    107e:	00 e0       	ldi	r16, 0x00	; 0
    1080:	20 e0       	ldi	r18, 0x00	; 0
    1082:	30 e0       	ldi	r19, 0x00	; 0
    1084:	45 e5       	ldi	r20, 0x55	; 85
    1086:	50 e0       	ldi	r21, 0x00	; 0
    1088:	6e e3       	ldi	r22, 0x3E	; 62
    108a:	72 e0       	ldi	r23, 0x02	; 2
    108c:	8e ee       	ldi	r24, 0xEE	; 238
    108e:	99 e0       	ldi	r25, 0x09	; 9
    1090:	0e 94 1b 07 	call	0xe36	; 0xe36 <xTaskGenericCreate>
    1094:	81 30       	cpi	r24, 0x01	; 1
    1096:	49 f4       	brne	.+18     	; 0x10aa <vTaskStartScheduler+0x4e>
    1098:	f8 94       	cli
    109a:	80 93 2f 08 	sts	0x082F, r24	; 0x80082f <xSchedulerRunning>
    109e:	10 92 32 08 	sts	0x0832, r1	; 0x800832 <xTickCount+0x1>
    10a2:	10 92 31 08 	sts	0x0831, r1	; 0x800831 <xTickCount>
    10a6:	0e 94 48 02 	call	0x490	; 0x490 <xPortStartScheduler>
    10aa:	0f 91       	pop	r16
    10ac:	ff 90       	pop	r15
    10ae:	ef 90       	pop	r14
    10b0:	df 90       	pop	r13
    10b2:	cf 90       	pop	r12
    10b4:	bf 90       	pop	r11
    10b6:	af 90       	pop	r10
    10b8:	08 95       	ret

000010ba <vTaskSuspendAll>:
    10ba:	80 91 2a 08 	lds	r24, 0x082A	; 0x80082a <uxSchedulerSuspended>
    10be:	8f 5f       	subi	r24, 0xFF	; 255
    10c0:	80 93 2a 08 	sts	0x082A, r24	; 0x80082a <uxSchedulerSuspended>
    10c4:	08 95       	ret

000010c6 <xTaskGetTickCount>:
    10c6:	0f b6       	in	r0, 0x3f	; 63
    10c8:	f8 94       	cli
    10ca:	0f 92       	push	r0
    10cc:	80 91 31 08 	lds	r24, 0x0831	; 0x800831 <xTickCount>
    10d0:	90 91 32 08 	lds	r25, 0x0832	; 0x800832 <xTickCount+0x1>
    10d4:	0f 90       	pop	r0
    10d6:	0f be       	out	0x3f, r0	; 63
    10d8:	08 95       	ret

000010da <xTaskIncrementTick>:
    10da:	cf 92       	push	r12
    10dc:	df 92       	push	r13
    10de:	ef 92       	push	r14
    10e0:	ff 92       	push	r15
    10e2:	0f 93       	push	r16
    10e4:	1f 93       	push	r17
    10e6:	cf 93       	push	r28
    10e8:	df 93       	push	r29
    10ea:	80 91 2a 08 	lds	r24, 0x082A	; 0x80082a <uxSchedulerSuspended>
    10ee:	81 11       	cpse	r24, r1
    10f0:	9b c0       	rjmp	.+310    	; 0x1228 <xTaskIncrementTick+0x14e>
    10f2:	80 91 31 08 	lds	r24, 0x0831	; 0x800831 <xTickCount>
    10f6:	90 91 32 08 	lds	r25, 0x0832	; 0x800832 <xTickCount+0x1>
    10fa:	01 96       	adiw	r24, 0x01	; 1
    10fc:	90 93 32 08 	sts	0x0832, r25	; 0x800832 <xTickCount+0x1>
    1100:	80 93 31 08 	sts	0x0831, r24	; 0x800831 <xTickCount>
    1104:	e0 90 31 08 	lds	r14, 0x0831	; 0x800831 <xTickCount>
    1108:	f0 90 32 08 	lds	r15, 0x0832	; 0x800832 <xTickCount+0x1>
    110c:	e1 14       	cp	r14, r1
    110e:	f1 04       	cpc	r15, r1
    1110:	b9 f4       	brne	.+46     	; 0x1140 <xTaskIncrementTick+0x66>
    1112:	80 91 54 08 	lds	r24, 0x0854	; 0x800854 <pxDelayedTaskList>
    1116:	90 91 55 08 	lds	r25, 0x0855	; 0x800855 <pxDelayedTaskList+0x1>
    111a:	20 91 52 08 	lds	r18, 0x0852	; 0x800852 <pxOverflowDelayedTaskList>
    111e:	30 91 53 08 	lds	r19, 0x0853	; 0x800853 <pxOverflowDelayedTaskList+0x1>
    1122:	30 93 55 08 	sts	0x0855, r19	; 0x800855 <pxDelayedTaskList+0x1>
    1126:	20 93 54 08 	sts	0x0854, r18	; 0x800854 <pxDelayedTaskList>
    112a:	90 93 53 08 	sts	0x0853, r25	; 0x800853 <pxOverflowDelayedTaskList+0x1>
    112e:	80 93 52 08 	sts	0x0852, r24	; 0x800852 <pxOverflowDelayedTaskList>
    1132:	80 91 2c 08 	lds	r24, 0x082C	; 0x80082c <xNumOfOverflows>
    1136:	8f 5f       	subi	r24, 0xFF	; 255
    1138:	80 93 2c 08 	sts	0x082C, r24	; 0x80082c <xNumOfOverflows>
    113c:	0e 94 c5 06 	call	0xd8a	; 0xd8a <prvResetNextTaskUnblockTime>
    1140:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xNextTaskUnblockTime>
    1144:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <xNextTaskUnblockTime+0x1>
    1148:	e8 16       	cp	r14, r24
    114a:	f9 06       	cpc	r15, r25
    114c:	10 f4       	brcc	.+4      	; 0x1152 <xTaskIncrementTick+0x78>
    114e:	d1 2c       	mov	r13, r1
    1150:	53 c0       	rjmp	.+166    	; 0x11f8 <xTaskIncrementTick+0x11e>
    1152:	d1 2c       	mov	r13, r1
    1154:	cc 24       	eor	r12, r12
    1156:	c3 94       	inc	r12
    1158:	e0 91 54 08 	lds	r30, 0x0854	; 0x800854 <pxDelayedTaskList>
    115c:	f0 91 55 08 	lds	r31, 0x0855	; 0x800855 <pxDelayedTaskList+0x1>
    1160:	80 81       	ld	r24, Z
    1162:	81 11       	cpse	r24, r1
    1164:	07 c0       	rjmp	.+14     	; 0x1174 <xTaskIncrementTick+0x9a>
    1166:	8f ef       	ldi	r24, 0xFF	; 255
    1168:	9f ef       	ldi	r25, 0xFF	; 255
    116a:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
    116e:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
    1172:	42 c0       	rjmp	.+132    	; 0x11f8 <xTaskIncrementTick+0x11e>
    1174:	e0 91 54 08 	lds	r30, 0x0854	; 0x800854 <pxDelayedTaskList>
    1178:	f0 91 55 08 	lds	r31, 0x0855	; 0x800855 <pxDelayedTaskList+0x1>
    117c:	05 80       	ldd	r0, Z+5	; 0x05
    117e:	f6 81       	ldd	r31, Z+6	; 0x06
    1180:	e0 2d       	mov	r30, r0
    1182:	c6 81       	ldd	r28, Z+6	; 0x06
    1184:	d7 81       	ldd	r29, Z+7	; 0x07
    1186:	8a 81       	ldd	r24, Y+2	; 0x02
    1188:	9b 81       	ldd	r25, Y+3	; 0x03
    118a:	e8 16       	cp	r14, r24
    118c:	f9 06       	cpc	r15, r25
    118e:	28 f4       	brcc	.+10     	; 0x119a <xTaskIncrementTick+0xc0>
    1190:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
    1194:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
    1198:	2f c0       	rjmp	.+94     	; 0x11f8 <xTaskIncrementTick+0x11e>
    119a:	8e 01       	movw	r16, r28
    119c:	0e 5f       	subi	r16, 0xFE	; 254
    119e:	1f 4f       	sbci	r17, 0xFF	; 255
    11a0:	c8 01       	movw	r24, r16
    11a2:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
    11a6:	8c 89       	ldd	r24, Y+20	; 0x14
    11a8:	9d 89       	ldd	r25, Y+21	; 0x15
    11aa:	89 2b       	or	r24, r25
    11ac:	21 f0       	breq	.+8      	; 0x11b6 <xTaskIncrementTick+0xdc>
    11ae:	ce 01       	movw	r24, r28
    11b0:	0c 96       	adiw	r24, 0x0c	; 12
    11b2:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
    11b6:	8e 89       	ldd	r24, Y+22	; 0x16
    11b8:	90 91 30 08 	lds	r25, 0x0830	; 0x800830 <uxTopReadyPriority>
    11bc:	98 17       	cp	r25, r24
    11be:	10 f4       	brcc	.+4      	; 0x11c4 <xTaskIncrementTick+0xea>
    11c0:	80 93 30 08 	sts	0x0830, r24	; 0x800830 <uxTopReadyPriority>
    11c4:	90 e0       	ldi	r25, 0x00	; 0
    11c6:	9c 01       	movw	r18, r24
    11c8:	22 0f       	add	r18, r18
    11ca:	33 1f       	adc	r19, r19
    11cc:	22 0f       	add	r18, r18
    11ce:	33 1f       	adc	r19, r19
    11d0:	22 0f       	add	r18, r18
    11d2:	33 1f       	adc	r19, r19
    11d4:	82 0f       	add	r24, r18
    11d6:	93 1f       	adc	r25, r19
    11d8:	b8 01       	movw	r22, r16
    11da:	88 59       	subi	r24, 0x98	; 152
    11dc:	97 4f       	sbci	r25, 0xF7	; 247
    11de:	0e 94 64 01 	call	0x2c8	; 0x2c8 <vListInsertEnd>
    11e2:	e0 91 8c 08 	lds	r30, 0x088C	; 0x80088c <pxCurrentTCB>
    11e6:	f0 91 8d 08 	lds	r31, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
    11ea:	9e 89       	ldd	r25, Y+22	; 0x16
    11ec:	86 89       	ldd	r24, Z+22	; 0x16
    11ee:	98 17       	cp	r25, r24
    11f0:	08 f4       	brcc	.+2      	; 0x11f4 <xTaskIncrementTick+0x11a>
    11f2:	b2 cf       	rjmp	.-156    	; 0x1158 <xTaskIncrementTick+0x7e>
    11f4:	dc 2c       	mov	r13, r12
    11f6:	b0 cf       	rjmp	.-160    	; 0x1158 <xTaskIncrementTick+0x7e>
    11f8:	e0 91 8c 08 	lds	r30, 0x088C	; 0x80088c <pxCurrentTCB>
    11fc:	f0 91 8d 08 	lds	r31, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
    1200:	86 89       	ldd	r24, Z+22	; 0x16
    1202:	90 e0       	ldi	r25, 0x00	; 0
    1204:	fc 01       	movw	r30, r24
    1206:	ee 0f       	add	r30, r30
    1208:	ff 1f       	adc	r31, r31
    120a:	ee 0f       	add	r30, r30
    120c:	ff 1f       	adc	r31, r31
    120e:	ee 0f       	add	r30, r30
    1210:	ff 1f       	adc	r31, r31
    1212:	8e 0f       	add	r24, r30
    1214:	9f 1f       	adc	r25, r31
    1216:	fc 01       	movw	r30, r24
    1218:	e8 59       	subi	r30, 0x98	; 152
    121a:	f7 4f       	sbci	r31, 0xF7	; 247
    121c:	80 81       	ld	r24, Z
    121e:	82 30       	cpi	r24, 0x02	; 2
    1220:	48 f0       	brcs	.+18     	; 0x1234 <xTaskIncrementTick+0x15a>
    1222:	dd 24       	eor	r13, r13
    1224:	d3 94       	inc	r13
    1226:	06 c0       	rjmp	.+12     	; 0x1234 <xTaskIncrementTick+0x15a>
    1228:	80 91 2e 08 	lds	r24, 0x082E	; 0x80082e <uxPendedTicks>
    122c:	8f 5f       	subi	r24, 0xFF	; 255
    122e:	80 93 2e 08 	sts	0x082E, r24	; 0x80082e <uxPendedTicks>
    1232:	d1 2c       	mov	r13, r1
    1234:	80 91 2d 08 	lds	r24, 0x082D	; 0x80082d <xYieldPending>
    1238:	88 23       	and	r24, r24
    123a:	11 f0       	breq	.+4      	; 0x1240 <xTaskIncrementTick+0x166>
    123c:	dd 24       	eor	r13, r13
    123e:	d3 94       	inc	r13
    1240:	8d 2d       	mov	r24, r13
    1242:	df 91       	pop	r29
    1244:	cf 91       	pop	r28
    1246:	1f 91       	pop	r17
    1248:	0f 91       	pop	r16
    124a:	ff 90       	pop	r15
    124c:	ef 90       	pop	r14
    124e:	df 90       	pop	r13
    1250:	cf 90       	pop	r12
    1252:	08 95       	ret

00001254 <xTaskResumeAll>:
    1254:	df 92       	push	r13
    1256:	ef 92       	push	r14
    1258:	ff 92       	push	r15
    125a:	0f 93       	push	r16
    125c:	1f 93       	push	r17
    125e:	cf 93       	push	r28
    1260:	df 93       	push	r29
    1262:	0f b6       	in	r0, 0x3f	; 63
    1264:	f8 94       	cli
    1266:	0f 92       	push	r0
    1268:	80 91 2a 08 	lds	r24, 0x082A	; 0x80082a <uxSchedulerSuspended>
    126c:	81 50       	subi	r24, 0x01	; 1
    126e:	80 93 2a 08 	sts	0x082A, r24	; 0x80082a <uxSchedulerSuspended>
    1272:	80 91 2a 08 	lds	r24, 0x082A	; 0x80082a <uxSchedulerSuspended>
    1276:	81 11       	cpse	r24, r1
    1278:	62 c0       	rjmp	.+196    	; 0x133e <xTaskResumeAll+0xea>
    127a:	80 91 33 08 	lds	r24, 0x0833	; 0x800833 <uxCurrentNumberOfTasks>
    127e:	81 11       	cpse	r24, r1
    1280:	33 c0       	rjmp	.+102    	; 0x12e8 <xTaskResumeAll+0x94>
    1282:	60 c0       	rjmp	.+192    	; 0x1344 <xTaskResumeAll+0xf0>
    1284:	d7 01       	movw	r26, r14
    1286:	15 96       	adiw	r26, 0x05	; 5
    1288:	ed 91       	ld	r30, X+
    128a:	fc 91       	ld	r31, X
    128c:	16 97       	sbiw	r26, 0x06	; 6
    128e:	c6 81       	ldd	r28, Z+6	; 0x06
    1290:	d7 81       	ldd	r29, Z+7	; 0x07
    1292:	ce 01       	movw	r24, r28
    1294:	0c 96       	adiw	r24, 0x0c	; 12
    1296:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
    129a:	8e 01       	movw	r16, r28
    129c:	0e 5f       	subi	r16, 0xFE	; 254
    129e:	1f 4f       	sbci	r17, 0xFF	; 255
    12a0:	c8 01       	movw	r24, r16
    12a2:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
    12a6:	8e 89       	ldd	r24, Y+22	; 0x16
    12a8:	90 91 30 08 	lds	r25, 0x0830	; 0x800830 <uxTopReadyPriority>
    12ac:	98 17       	cp	r25, r24
    12ae:	10 f4       	brcc	.+4      	; 0x12b4 <xTaskResumeAll+0x60>
    12b0:	80 93 30 08 	sts	0x0830, r24	; 0x800830 <uxTopReadyPriority>
    12b4:	90 e0       	ldi	r25, 0x00	; 0
    12b6:	9c 01       	movw	r18, r24
    12b8:	22 0f       	add	r18, r18
    12ba:	33 1f       	adc	r19, r19
    12bc:	22 0f       	add	r18, r18
    12be:	33 1f       	adc	r19, r19
    12c0:	22 0f       	add	r18, r18
    12c2:	33 1f       	adc	r19, r19
    12c4:	82 0f       	add	r24, r18
    12c6:	93 1f       	adc	r25, r19
    12c8:	b8 01       	movw	r22, r16
    12ca:	88 59       	subi	r24, 0x98	; 152
    12cc:	97 4f       	sbci	r25, 0xF7	; 247
    12ce:	0e 94 64 01 	call	0x2c8	; 0x2c8 <vListInsertEnd>
    12d2:	e0 91 8c 08 	lds	r30, 0x088C	; 0x80088c <pxCurrentTCB>
    12d6:	f0 91 8d 08 	lds	r31, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
    12da:	9e 89       	ldd	r25, Y+22	; 0x16
    12dc:	86 89       	ldd	r24, Z+22	; 0x16
    12de:	98 17       	cp	r25, r24
    12e0:	58 f0       	brcs	.+22     	; 0x12f8 <xTaskResumeAll+0xa4>
    12e2:	d0 92 2d 08 	sts	0x082D, r13	; 0x80082d <xYieldPending>
    12e6:	08 c0       	rjmp	.+16     	; 0x12f8 <xTaskResumeAll+0xa4>
    12e8:	0f 2e       	mov	r0, r31
    12ea:	f9 e4       	ldi	r31, 0x49	; 73
    12ec:	ef 2e       	mov	r14, r31
    12ee:	f8 e0       	ldi	r31, 0x08	; 8
    12f0:	ff 2e       	mov	r15, r31
    12f2:	f0 2d       	mov	r31, r0
    12f4:	dd 24       	eor	r13, r13
    12f6:	d3 94       	inc	r13
    12f8:	f7 01       	movw	r30, r14
    12fa:	80 81       	ld	r24, Z
    12fc:	81 11       	cpse	r24, r1
    12fe:	c2 cf       	rjmp	.-124    	; 0x1284 <xTaskResumeAll+0x30>
    1300:	80 91 2e 08 	lds	r24, 0x082E	; 0x80082e <uxPendedTicks>
    1304:	88 23       	and	r24, r24
    1306:	99 f0       	breq	.+38     	; 0x132e <xTaskResumeAll+0xda>
    1308:	80 91 2e 08 	lds	r24, 0x082E	; 0x80082e <uxPendedTicks>
    130c:	88 23       	and	r24, r24
    130e:	79 f0       	breq	.+30     	; 0x132e <xTaskResumeAll+0xda>
    1310:	c1 e0       	ldi	r28, 0x01	; 1
    1312:	0e 94 6d 08 	call	0x10da	; 0x10da <xTaskIncrementTick>
    1316:	81 11       	cpse	r24, r1
    1318:	c0 93 2d 08 	sts	0x082D, r28	; 0x80082d <xYieldPending>
    131c:	80 91 2e 08 	lds	r24, 0x082E	; 0x80082e <uxPendedTicks>
    1320:	81 50       	subi	r24, 0x01	; 1
    1322:	80 93 2e 08 	sts	0x082E, r24	; 0x80082e <uxPendedTicks>
    1326:	80 91 2e 08 	lds	r24, 0x082E	; 0x80082e <uxPendedTicks>
    132a:	81 11       	cpse	r24, r1
    132c:	f2 cf       	rjmp	.-28     	; 0x1312 <xTaskResumeAll+0xbe>
    132e:	80 91 2d 08 	lds	r24, 0x082D	; 0x80082d <xYieldPending>
    1332:	81 30       	cpi	r24, 0x01	; 1
    1334:	31 f4       	brne	.+12     	; 0x1342 <xTaskResumeAll+0xee>
    1336:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
    133a:	81 e0       	ldi	r24, 0x01	; 1
    133c:	03 c0       	rjmp	.+6      	; 0x1344 <xTaskResumeAll+0xf0>
    133e:	80 e0       	ldi	r24, 0x00	; 0
    1340:	01 c0       	rjmp	.+2      	; 0x1344 <xTaskResumeAll+0xf0>
    1342:	80 e0       	ldi	r24, 0x00	; 0
    1344:	0f 90       	pop	r0
    1346:	0f be       	out	0x3f, r0	; 63
    1348:	df 91       	pop	r29
    134a:	cf 91       	pop	r28
    134c:	1f 91       	pop	r17
    134e:	0f 91       	pop	r16
    1350:	ff 90       	pop	r15
    1352:	ef 90       	pop	r14
    1354:	df 90       	pop	r13
    1356:	08 95       	ret

00001358 <vTaskDelayUntil>:
    1358:	0f 93       	push	r16
    135a:	1f 93       	push	r17
    135c:	cf 93       	push	r28
    135e:	df 93       	push	r29
    1360:	8c 01       	movw	r16, r24
    1362:	eb 01       	movw	r28, r22
    1364:	0e 94 5d 08 	call	0x10ba	; 0x10ba <vTaskSuspendAll>
    1368:	20 91 31 08 	lds	r18, 0x0831	; 0x800831 <xTickCount>
    136c:	30 91 32 08 	lds	r19, 0x0832	; 0x800832 <xTickCount+0x1>
    1370:	f8 01       	movw	r30, r16
    1372:	80 81       	ld	r24, Z
    1374:	91 81       	ldd	r25, Z+1	; 0x01
    1376:	c8 0f       	add	r28, r24
    1378:	d9 1f       	adc	r29, r25
    137a:	28 17       	cp	r18, r24
    137c:	39 07       	cpc	r19, r25
    137e:	48 f4       	brcc	.+18     	; 0x1392 <vTaskDelayUntil+0x3a>
    1380:	c8 17       	cp	r28, r24
    1382:	d9 07       	cpc	r29, r25
    1384:	10 f5       	brcc	.+68     	; 0x13ca <vTaskDelayUntil+0x72>
    1386:	d1 83       	std	Z+1, r29	; 0x01
    1388:	c0 83       	st	Z, r28
    138a:	2c 17       	cp	r18, r28
    138c:	3d 07       	cpc	r19, r29
    138e:	90 f4       	brcc	.+36     	; 0x13b4 <vTaskDelayUntil+0x5c>
    1390:	07 c0       	rjmp	.+14     	; 0x13a0 <vTaskDelayUntil+0x48>
    1392:	c8 17       	cp	r28, r24
    1394:	d9 07       	cpc	r29, r25
    1396:	a8 f0       	brcs	.+42     	; 0x13c2 <vTaskDelayUntil+0x6a>
    1398:	2c 17       	cp	r18, r28
    139a:	3d 07       	cpc	r19, r29
    139c:	90 f0       	brcs	.+36     	; 0x13c2 <vTaskDelayUntil+0x6a>
    139e:	15 c0       	rjmp	.+42     	; 0x13ca <vTaskDelayUntil+0x72>
    13a0:	80 91 8c 08 	lds	r24, 0x088C	; 0x80088c <pxCurrentTCB>
    13a4:	90 91 8d 08 	lds	r25, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
    13a8:	02 96       	adiw	r24, 0x02	; 2
    13aa:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
    13ae:	ce 01       	movw	r24, r28
    13b0:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <prvAddCurrentTaskToDelayedList>
    13b4:	0e 94 2a 09 	call	0x1254	; 0x1254 <xTaskResumeAll>
    13b8:	81 11       	cpse	r24, r1
    13ba:	0b c0       	rjmp	.+22     	; 0x13d2 <vTaskDelayUntil+0x7a>
    13bc:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
    13c0:	08 c0       	rjmp	.+16     	; 0x13d2 <vTaskDelayUntil+0x7a>
    13c2:	f8 01       	movw	r30, r16
    13c4:	d1 83       	std	Z+1, r29	; 0x01
    13c6:	c0 83       	st	Z, r28
    13c8:	eb cf       	rjmp	.-42     	; 0x13a0 <vTaskDelayUntil+0x48>
    13ca:	f8 01       	movw	r30, r16
    13cc:	d1 83       	std	Z+1, r29	; 0x01
    13ce:	c0 83       	st	Z, r28
    13d0:	f1 cf       	rjmp	.-30     	; 0x13b4 <vTaskDelayUntil+0x5c>
    13d2:	df 91       	pop	r29
    13d4:	cf 91       	pop	r28
    13d6:	1f 91       	pop	r17
    13d8:	0f 91       	pop	r16
    13da:	08 95       	ret

000013dc <prvIdleTask>:
    13dc:	00 e4       	ldi	r16, 0x40	; 64
    13de:	18 e0       	ldi	r17, 0x08	; 8
    13e0:	0f 2e       	mov	r0, r31
    13e2:	f8 e6       	ldi	r31, 0x68	; 104
    13e4:	ef 2e       	mov	r14, r31
    13e6:	f8 e0       	ldi	r31, 0x08	; 8
    13e8:	ff 2e       	mov	r15, r31
    13ea:	f0 2d       	mov	r31, r0
    13ec:	29 c0       	rjmp	.+82     	; 0x1440 <prvIdleTask+0x64>
    13ee:	0e 94 5d 08 	call	0x10ba	; 0x10ba <vTaskSuspendAll>
    13f2:	d8 01       	movw	r26, r16
    13f4:	cc 91       	ld	r28, X
    13f6:	0e 94 2a 09 	call	0x1254	; 0x1254 <xTaskResumeAll>
    13fa:	cc 23       	and	r28, r28
    13fc:	09 f1       	breq	.+66     	; 0x1440 <prvIdleTask+0x64>
    13fe:	0f b6       	in	r0, 0x3f	; 63
    1400:	f8 94       	cli
    1402:	0f 92       	push	r0
    1404:	d8 01       	movw	r26, r16
    1406:	15 96       	adiw	r26, 0x05	; 5
    1408:	ed 91       	ld	r30, X+
    140a:	fc 91       	ld	r31, X
    140c:	16 97       	sbiw	r26, 0x06	; 6
    140e:	c6 81       	ldd	r28, Z+6	; 0x06
    1410:	d7 81       	ldd	r29, Z+7	; 0x07
    1412:	ce 01       	movw	r24, r28
    1414:	02 96       	adiw	r24, 0x02	; 2
    1416:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
    141a:	80 91 33 08 	lds	r24, 0x0833	; 0x800833 <uxCurrentNumberOfTasks>
    141e:	81 50       	subi	r24, 0x01	; 1
    1420:	80 93 33 08 	sts	0x0833, r24	; 0x800833 <uxCurrentNumberOfTasks>
    1424:	80 91 3f 08 	lds	r24, 0x083F	; 0x80083f <uxTasksDeleted>
    1428:	81 50       	subi	r24, 0x01	; 1
    142a:	80 93 3f 08 	sts	0x083F, r24	; 0x80083f <uxTasksDeleted>
    142e:	0f 90       	pop	r0
    1430:	0f be       	out	0x3f, r0	; 63
    1432:	8f 89       	ldd	r24, Y+23	; 0x17
    1434:	98 8d       	ldd	r25, Y+24	; 0x18
    1436:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <vPortFree>
    143a:	ce 01       	movw	r24, r28
    143c:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <vPortFree>
    1440:	80 91 3f 08 	lds	r24, 0x083F	; 0x80083f <uxTasksDeleted>
    1444:	81 11       	cpse	r24, r1
    1446:	d3 cf       	rjmp	.-90     	; 0x13ee <prvIdleTask+0x12>
    1448:	f7 01       	movw	r30, r14
    144a:	80 81       	ld	r24, Z
    144c:	82 30       	cpi	r24, 0x02	; 2
    144e:	c0 f3       	brcs	.-16     	; 0x1440 <prvIdleTask+0x64>
    1450:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
    1454:	f5 cf       	rjmp	.-22     	; 0x1440 <prvIdleTask+0x64>

00001456 <vTaskSwitchContext>:
    1456:	80 91 2a 08 	lds	r24, 0x082A	; 0x80082a <uxSchedulerSuspended>
    145a:	88 23       	and	r24, r24
    145c:	21 f0       	breq	.+8      	; 0x1466 <vTaskSwitchContext+0x10>
    145e:	81 e0       	ldi	r24, 0x01	; 1
    1460:	80 93 2d 08 	sts	0x082D, r24	; 0x80082d <xYieldPending>
    1464:	08 95       	ret
    1466:	10 92 2d 08 	sts	0x082D, r1	; 0x80082d <xYieldPending>
    146a:	80 91 30 08 	lds	r24, 0x0830	; 0x800830 <uxTopReadyPriority>
    146e:	90 e0       	ldi	r25, 0x00	; 0
    1470:	fc 01       	movw	r30, r24
    1472:	ee 0f       	add	r30, r30
    1474:	ff 1f       	adc	r31, r31
    1476:	ee 0f       	add	r30, r30
    1478:	ff 1f       	adc	r31, r31
    147a:	ee 0f       	add	r30, r30
    147c:	ff 1f       	adc	r31, r31
    147e:	8e 0f       	add	r24, r30
    1480:	9f 1f       	adc	r25, r31
    1482:	fc 01       	movw	r30, r24
    1484:	e8 59       	subi	r30, 0x98	; 152
    1486:	f7 4f       	sbci	r31, 0xF7	; 247
    1488:	80 81       	ld	r24, Z
    148a:	81 11       	cpse	r24, r1
    148c:	17 c0       	rjmp	.+46     	; 0x14bc <vTaskSwitchContext+0x66>
    148e:	80 91 30 08 	lds	r24, 0x0830	; 0x800830 <uxTopReadyPriority>
    1492:	81 50       	subi	r24, 0x01	; 1
    1494:	80 93 30 08 	sts	0x0830, r24	; 0x800830 <uxTopReadyPriority>
    1498:	80 91 30 08 	lds	r24, 0x0830	; 0x800830 <uxTopReadyPriority>
    149c:	90 e0       	ldi	r25, 0x00	; 0
    149e:	fc 01       	movw	r30, r24
    14a0:	ee 0f       	add	r30, r30
    14a2:	ff 1f       	adc	r31, r31
    14a4:	ee 0f       	add	r30, r30
    14a6:	ff 1f       	adc	r31, r31
    14a8:	ee 0f       	add	r30, r30
    14aa:	ff 1f       	adc	r31, r31
    14ac:	8e 0f       	add	r24, r30
    14ae:	9f 1f       	adc	r25, r31
    14b0:	fc 01       	movw	r30, r24
    14b2:	e8 59       	subi	r30, 0x98	; 152
    14b4:	f7 4f       	sbci	r31, 0xF7	; 247
    14b6:	80 81       	ld	r24, Z
    14b8:	88 23       	and	r24, r24
    14ba:	49 f3       	breq	.-46     	; 0x148e <vTaskSwitchContext+0x38>
    14bc:	80 91 30 08 	lds	r24, 0x0830	; 0x800830 <uxTopReadyPriority>
    14c0:	90 e0       	ldi	r25, 0x00	; 0
    14c2:	9c 01       	movw	r18, r24
    14c4:	22 0f       	add	r18, r18
    14c6:	33 1f       	adc	r19, r19
    14c8:	22 0f       	add	r18, r18
    14ca:	33 1f       	adc	r19, r19
    14cc:	22 0f       	add	r18, r18
    14ce:	33 1f       	adc	r19, r19
    14d0:	28 0f       	add	r18, r24
    14d2:	39 1f       	adc	r19, r25
    14d4:	d9 01       	movw	r26, r18
    14d6:	a8 59       	subi	r26, 0x98	; 152
    14d8:	b7 4f       	sbci	r27, 0xF7	; 247
    14da:	11 96       	adiw	r26, 0x01	; 1
    14dc:	ed 91       	ld	r30, X+
    14de:	fc 91       	ld	r31, X
    14e0:	12 97       	sbiw	r26, 0x02	; 2
    14e2:	02 80       	ldd	r0, Z+2	; 0x02
    14e4:	f3 81       	ldd	r31, Z+3	; 0x03
    14e6:	e0 2d       	mov	r30, r0
    14e8:	12 96       	adiw	r26, 0x02	; 2
    14ea:	fc 93       	st	X, r31
    14ec:	ee 93       	st	-X, r30
    14ee:	11 97       	sbiw	r26, 0x01	; 1
    14f0:	25 59       	subi	r18, 0x95	; 149
    14f2:	37 4f       	sbci	r19, 0xF7	; 247
    14f4:	e2 17       	cp	r30, r18
    14f6:	f3 07       	cpc	r31, r19
    14f8:	29 f4       	brne	.+10     	; 0x1504 <vTaskSwitchContext+0xae>
    14fa:	22 81       	ldd	r18, Z+2	; 0x02
    14fc:	33 81       	ldd	r19, Z+3	; 0x03
    14fe:	fd 01       	movw	r30, r26
    1500:	32 83       	std	Z+2, r19	; 0x02
    1502:	21 83       	std	Z+1, r18	; 0x01
    1504:	fc 01       	movw	r30, r24
    1506:	ee 0f       	add	r30, r30
    1508:	ff 1f       	adc	r31, r31
    150a:	ee 0f       	add	r30, r30
    150c:	ff 1f       	adc	r31, r31
    150e:	ee 0f       	add	r30, r30
    1510:	ff 1f       	adc	r31, r31
    1512:	8e 0f       	add	r24, r30
    1514:	9f 1f       	adc	r25, r31
    1516:	fc 01       	movw	r30, r24
    1518:	e8 59       	subi	r30, 0x98	; 152
    151a:	f7 4f       	sbci	r31, 0xF7	; 247
    151c:	01 80       	ldd	r0, Z+1	; 0x01
    151e:	f2 81       	ldd	r31, Z+2	; 0x02
    1520:	e0 2d       	mov	r30, r0
    1522:	86 81       	ldd	r24, Z+6	; 0x06
    1524:	97 81       	ldd	r25, Z+7	; 0x07
    1526:	90 93 8d 08 	sts	0x088D, r25	; 0x80088d <pxCurrentTCB+0x1>
    152a:	80 93 8c 08 	sts	0x088C, r24	; 0x80088c <pxCurrentTCB>
    152e:	08 95       	ret

00001530 <vTaskPlaceOnEventList>:
    1530:	cf 93       	push	r28
    1532:	df 93       	push	r29
    1534:	eb 01       	movw	r28, r22
    1536:	60 91 8c 08 	lds	r22, 0x088C	; 0x80088c <pxCurrentTCB>
    153a:	70 91 8d 08 	lds	r23, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
    153e:	64 5f       	subi	r22, 0xF4	; 244
    1540:	7f 4f       	sbci	r23, 0xFF	; 255
    1542:	0e 94 85 01 	call	0x30a	; 0x30a <vListInsert>
    1546:	80 91 8c 08 	lds	r24, 0x088C	; 0x80088c <pxCurrentTCB>
    154a:	90 91 8d 08 	lds	r25, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
    154e:	02 96       	adiw	r24, 0x02	; 2
    1550:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
    1554:	cf 3f       	cpi	r28, 0xFF	; 255
    1556:	8f ef       	ldi	r24, 0xFF	; 255
    1558:	d8 07       	cpc	r29, r24
    155a:	59 f4       	brne	.+22     	; 0x1572 <vTaskPlaceOnEventList+0x42>
    155c:	60 91 8c 08 	lds	r22, 0x088C	; 0x80088c <pxCurrentTCB>
    1560:	70 91 8d 08 	lds	r23, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
    1564:	6e 5f       	subi	r22, 0xFE	; 254
    1566:	7f 4f       	sbci	r23, 0xFF	; 255
    1568:	86 e3       	ldi	r24, 0x36	; 54
    156a:	98 e0       	ldi	r25, 0x08	; 8
    156c:	0e 94 64 01 	call	0x2c8	; 0x2c8 <vListInsertEnd>
    1570:	08 c0       	rjmp	.+16     	; 0x1582 <vTaskPlaceOnEventList+0x52>
    1572:	80 91 31 08 	lds	r24, 0x0831	; 0x800831 <xTickCount>
    1576:	90 91 32 08 	lds	r25, 0x0832	; 0x800832 <xTickCount+0x1>
    157a:	8c 0f       	add	r24, r28
    157c:	9d 1f       	adc	r25, r29
    157e:	0e 94 e4 06 	call	0xdc8	; 0xdc8 <prvAddCurrentTaskToDelayedList>
    1582:	df 91       	pop	r29
    1584:	cf 91       	pop	r28
    1586:	08 95       	ret

00001588 <xTaskRemoveFromEventList>:
    1588:	0f 93       	push	r16
    158a:	1f 93       	push	r17
    158c:	cf 93       	push	r28
    158e:	df 93       	push	r29
    1590:	dc 01       	movw	r26, r24
    1592:	15 96       	adiw	r26, 0x05	; 5
    1594:	ed 91       	ld	r30, X+
    1596:	fc 91       	ld	r31, X
    1598:	16 97       	sbiw	r26, 0x06	; 6
    159a:	c6 81       	ldd	r28, Z+6	; 0x06
    159c:	d7 81       	ldd	r29, Z+7	; 0x07
    159e:	8e 01       	movw	r16, r28
    15a0:	04 5f       	subi	r16, 0xF4	; 244
    15a2:	1f 4f       	sbci	r17, 0xFF	; 255
    15a4:	c8 01       	movw	r24, r16
    15a6:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
    15aa:	80 91 2a 08 	lds	r24, 0x082A	; 0x80082a <uxSchedulerSuspended>
    15ae:	81 11       	cpse	r24, r1
    15b0:	1c c0       	rjmp	.+56     	; 0x15ea <xTaskRemoveFromEventList+0x62>
    15b2:	0a 50       	subi	r16, 0x0A	; 10
    15b4:	11 09       	sbc	r17, r1
    15b6:	c8 01       	movw	r24, r16
    15b8:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
    15bc:	8e 89       	ldd	r24, Y+22	; 0x16
    15be:	90 91 30 08 	lds	r25, 0x0830	; 0x800830 <uxTopReadyPriority>
    15c2:	98 17       	cp	r25, r24
    15c4:	10 f4       	brcc	.+4      	; 0x15ca <xTaskRemoveFromEventList+0x42>
    15c6:	80 93 30 08 	sts	0x0830, r24	; 0x800830 <uxTopReadyPriority>
    15ca:	90 e0       	ldi	r25, 0x00	; 0
    15cc:	9c 01       	movw	r18, r24
    15ce:	22 0f       	add	r18, r18
    15d0:	33 1f       	adc	r19, r19
    15d2:	22 0f       	add	r18, r18
    15d4:	33 1f       	adc	r19, r19
    15d6:	22 0f       	add	r18, r18
    15d8:	33 1f       	adc	r19, r19
    15da:	82 0f       	add	r24, r18
    15dc:	93 1f       	adc	r25, r19
    15de:	b8 01       	movw	r22, r16
    15e0:	88 59       	subi	r24, 0x98	; 152
    15e2:	97 4f       	sbci	r25, 0xF7	; 247
    15e4:	0e 94 64 01 	call	0x2c8	; 0x2c8 <vListInsertEnd>
    15e8:	05 c0       	rjmp	.+10     	; 0x15f4 <xTaskRemoveFromEventList+0x6c>
    15ea:	b8 01       	movw	r22, r16
    15ec:	89 e4       	ldi	r24, 0x49	; 73
    15ee:	98 e0       	ldi	r25, 0x08	; 8
    15f0:	0e 94 64 01 	call	0x2c8	; 0x2c8 <vListInsertEnd>
    15f4:	e0 91 8c 08 	lds	r30, 0x088C	; 0x80088c <pxCurrentTCB>
    15f8:	f0 91 8d 08 	lds	r31, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
    15fc:	9e 89       	ldd	r25, Y+22	; 0x16
    15fe:	86 89       	ldd	r24, Z+22	; 0x16
    1600:	89 17       	cp	r24, r25
    1602:	20 f4       	brcc	.+8      	; 0x160c <xTaskRemoveFromEventList+0x84>
    1604:	81 e0       	ldi	r24, 0x01	; 1
    1606:	80 93 2d 08 	sts	0x082D, r24	; 0x80082d <xYieldPending>
    160a:	01 c0       	rjmp	.+2      	; 0x160e <xTaskRemoveFromEventList+0x86>
    160c:	80 e0       	ldi	r24, 0x00	; 0
    160e:	df 91       	pop	r29
    1610:	cf 91       	pop	r28
    1612:	1f 91       	pop	r17
    1614:	0f 91       	pop	r16
    1616:	08 95       	ret

00001618 <vTaskSetTimeOutState>:
    1618:	20 91 2c 08 	lds	r18, 0x082C	; 0x80082c <xNumOfOverflows>
    161c:	fc 01       	movw	r30, r24
    161e:	20 83       	st	Z, r18
    1620:	20 91 31 08 	lds	r18, 0x0831	; 0x800831 <xTickCount>
    1624:	30 91 32 08 	lds	r19, 0x0832	; 0x800832 <xTickCount+0x1>
    1628:	32 83       	std	Z+2, r19	; 0x02
    162a:	21 83       	std	Z+1, r18	; 0x01
    162c:	08 95       	ret

0000162e <xTaskCheckForTimeOut>:
    162e:	0f b6       	in	r0, 0x3f	; 63
    1630:	f8 94       	cli
    1632:	0f 92       	push	r0
    1634:	40 91 31 08 	lds	r20, 0x0831	; 0x800831 <xTickCount>
    1638:	50 91 32 08 	lds	r21, 0x0832	; 0x800832 <xTickCount+0x1>
    163c:	db 01       	movw	r26, r22
    163e:	2d 91       	ld	r18, X+
    1640:	3c 91       	ld	r19, X
    1642:	2f 3f       	cpi	r18, 0xFF	; 255
    1644:	bf ef       	ldi	r27, 0xFF	; 255
    1646:	3b 07       	cpc	r19, r27
    1648:	19 f1       	breq	.+70     	; 0x1690 <xTaskCheckForTimeOut+0x62>
    164a:	e0 91 2c 08 	lds	r30, 0x082C	; 0x80082c <xNumOfOverflows>
    164e:	dc 01       	movw	r26, r24
    1650:	fc 91       	ld	r31, X
    1652:	fe 17       	cp	r31, r30
    1654:	39 f0       	breq	.+14     	; 0x1664 <xTaskCheckForTimeOut+0x36>
    1656:	11 96       	adiw	r26, 0x01	; 1
    1658:	ed 91       	ld	r30, X+
    165a:	fc 91       	ld	r31, X
    165c:	12 97       	sbiw	r26, 0x02	; 2
    165e:	4e 17       	cp	r20, r30
    1660:	5f 07       	cpc	r21, r31
    1662:	c0 f4       	brcc	.+48     	; 0x1694 <xTaskCheckForTimeOut+0x66>
    1664:	dc 01       	movw	r26, r24
    1666:	11 96       	adiw	r26, 0x01	; 1
    1668:	ed 91       	ld	r30, X+
    166a:	fc 91       	ld	r31, X
    166c:	12 97       	sbiw	r26, 0x02	; 2
    166e:	da 01       	movw	r26, r20
    1670:	ae 1b       	sub	r26, r30
    1672:	bf 0b       	sbc	r27, r31
    1674:	a2 17       	cp	r26, r18
    1676:	b3 07       	cpc	r27, r19
    1678:	78 f4       	brcc	.+30     	; 0x1698 <xTaskCheckForTimeOut+0x6a>
    167a:	db 01       	movw	r26, r22
    167c:	e4 1b       	sub	r30, r20
    167e:	f5 0b       	sbc	r31, r21
    1680:	2e 0f       	add	r18, r30
    1682:	3f 1f       	adc	r19, r31
    1684:	2d 93       	st	X+, r18
    1686:	3c 93       	st	X, r19
    1688:	0e 94 0c 0b 	call	0x1618	; 0x1618 <vTaskSetTimeOutState>
    168c:	80 e0       	ldi	r24, 0x00	; 0
    168e:	05 c0       	rjmp	.+10     	; 0x169a <xTaskCheckForTimeOut+0x6c>
    1690:	80 e0       	ldi	r24, 0x00	; 0
    1692:	03 c0       	rjmp	.+6      	; 0x169a <xTaskCheckForTimeOut+0x6c>
    1694:	81 e0       	ldi	r24, 0x01	; 1
    1696:	01 c0       	rjmp	.+2      	; 0x169a <xTaskCheckForTimeOut+0x6c>
    1698:	81 e0       	ldi	r24, 0x01	; 1
    169a:	0f 90       	pop	r0
    169c:	0f be       	out	0x3f, r0	; 63
    169e:	08 95       	ret

000016a0 <vTaskMissedYield>:
    16a0:	81 e0       	ldi	r24, 0x01	; 1
    16a2:	80 93 2d 08 	sts	0x082D, r24	; 0x80082d <xYieldPending>
    16a6:	08 95       	ret

000016a8 <vTaskPriorityInherit>:
    16a8:	0f 93       	push	r16
    16aa:	1f 93       	push	r17
    16ac:	cf 93       	push	r28
    16ae:	df 93       	push	r29
    16b0:	fc 01       	movw	r30, r24
    16b2:	89 2b       	or	r24, r25
    16b4:	09 f4       	brne	.+2      	; 0x16b8 <vTaskPriorityInherit+0x10>
    16b6:	55 c0       	rjmp	.+170    	; 0x1762 <vTaskPriorityInherit+0xba>
    16b8:	26 89       	ldd	r18, Z+22	; 0x16
    16ba:	a0 91 8c 08 	lds	r26, 0x088C	; 0x80088c <pxCurrentTCB>
    16be:	b0 91 8d 08 	lds	r27, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
    16c2:	56 96       	adiw	r26, 0x16	; 22
    16c4:	8c 91       	ld	r24, X
    16c6:	28 17       	cp	r18, r24
    16c8:	08 f0       	brcs	.+2      	; 0x16cc <vTaskPriorityInherit+0x24>
    16ca:	4b c0       	rjmp	.+150    	; 0x1762 <vTaskPriorityInherit+0xba>
    16cc:	84 85       	ldd	r24, Z+12	; 0x0c
    16ce:	95 85       	ldd	r25, Z+13	; 0x0d
    16d0:	99 23       	and	r25, r25
    16d2:	64 f0       	brlt	.+24     	; 0x16ec <vTaskPriorityInherit+0x44>
    16d4:	a0 91 8c 08 	lds	r26, 0x088C	; 0x80088c <pxCurrentTCB>
    16d8:	b0 91 8d 08 	lds	r27, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
    16dc:	56 96       	adiw	r26, 0x16	; 22
    16de:	3c 91       	ld	r19, X
    16e0:	84 e0       	ldi	r24, 0x04	; 4
    16e2:	90 e0       	ldi	r25, 0x00	; 0
    16e4:	83 1b       	sub	r24, r19
    16e6:	91 09       	sbc	r25, r1
    16e8:	95 87       	std	Z+13, r25	; 0x0d
    16ea:	84 87       	std	Z+12, r24	; 0x0c
    16ec:	30 e0       	ldi	r19, 0x00	; 0
    16ee:	c9 01       	movw	r24, r18
    16f0:	88 0f       	add	r24, r24
    16f2:	99 1f       	adc	r25, r25
    16f4:	88 0f       	add	r24, r24
    16f6:	99 1f       	adc	r25, r25
    16f8:	88 0f       	add	r24, r24
    16fa:	99 1f       	adc	r25, r25
    16fc:	28 0f       	add	r18, r24
    16fe:	39 1f       	adc	r19, r25
    1700:	28 59       	subi	r18, 0x98	; 152
    1702:	37 4f       	sbci	r19, 0xF7	; 247
    1704:	82 85       	ldd	r24, Z+10	; 0x0a
    1706:	93 85       	ldd	r25, Z+11	; 0x0b
    1708:	82 17       	cp	r24, r18
    170a:	93 07       	cpc	r25, r19
    170c:	19 f5       	brne	.+70     	; 0x1754 <vTaskPriorityInherit+0xac>
    170e:	8f 01       	movw	r16, r30
    1710:	ef 01       	movw	r28, r30
    1712:	22 96       	adiw	r28, 0x02	; 2
    1714:	ce 01       	movw	r24, r28
    1716:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
    171a:	e0 91 8c 08 	lds	r30, 0x088C	; 0x80088c <pxCurrentTCB>
    171e:	f0 91 8d 08 	lds	r31, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
    1722:	86 89       	ldd	r24, Z+22	; 0x16
    1724:	f8 01       	movw	r30, r16
    1726:	86 8b       	std	Z+22, r24	; 0x16
    1728:	90 91 30 08 	lds	r25, 0x0830	; 0x800830 <uxTopReadyPriority>
    172c:	98 17       	cp	r25, r24
    172e:	10 f4       	brcc	.+4      	; 0x1734 <vTaskPriorityInherit+0x8c>
    1730:	80 93 30 08 	sts	0x0830, r24	; 0x800830 <uxTopReadyPriority>
    1734:	90 e0       	ldi	r25, 0x00	; 0
    1736:	9c 01       	movw	r18, r24
    1738:	22 0f       	add	r18, r18
    173a:	33 1f       	adc	r19, r19
    173c:	22 0f       	add	r18, r18
    173e:	33 1f       	adc	r19, r19
    1740:	22 0f       	add	r18, r18
    1742:	33 1f       	adc	r19, r19
    1744:	82 0f       	add	r24, r18
    1746:	93 1f       	adc	r25, r19
    1748:	be 01       	movw	r22, r28
    174a:	88 59       	subi	r24, 0x98	; 152
    174c:	97 4f       	sbci	r25, 0xF7	; 247
    174e:	0e 94 64 01 	call	0x2c8	; 0x2c8 <vListInsertEnd>
    1752:	07 c0       	rjmp	.+14     	; 0x1762 <vTaskPriorityInherit+0xba>
    1754:	a0 91 8c 08 	lds	r26, 0x088C	; 0x80088c <pxCurrentTCB>
    1758:	b0 91 8d 08 	lds	r27, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
    175c:	56 96       	adiw	r26, 0x16	; 22
    175e:	8c 91       	ld	r24, X
    1760:	86 8b       	std	Z+22, r24	; 0x16
    1762:	df 91       	pop	r29
    1764:	cf 91       	pop	r28
    1766:	1f 91       	pop	r17
    1768:	0f 91       	pop	r16
    176a:	08 95       	ret

0000176c <xTaskPriorityDisinherit>:
    176c:	0f 93       	push	r16
    176e:	1f 93       	push	r17
    1770:	cf 93       	push	r28
    1772:	df 93       	push	r29
    1774:	fc 01       	movw	r30, r24
    1776:	89 2b       	or	r24, r25
    1778:	79 f1       	breq	.+94     	; 0x17d8 <xTaskPriorityDisinherit+0x6c>
    177a:	82 a1       	ldd	r24, Z+34	; 0x22
    177c:	81 50       	subi	r24, 0x01	; 1
    177e:	82 a3       	std	Z+34, r24	; 0x22
    1780:	26 89       	ldd	r18, Z+22	; 0x16
    1782:	91 a1       	ldd	r25, Z+33	; 0x21
    1784:	29 17       	cp	r18, r25
    1786:	51 f1       	breq	.+84     	; 0x17dc <xTaskPriorityDisinherit+0x70>
    1788:	81 11       	cpse	r24, r1
    178a:	2a c0       	rjmp	.+84     	; 0x17e0 <xTaskPriorityDisinherit+0x74>
    178c:	ef 01       	movw	r28, r30
    178e:	8f 01       	movw	r16, r30
    1790:	0e 5f       	subi	r16, 0xFE	; 254
    1792:	1f 4f       	sbci	r17, 0xFF	; 255
    1794:	c8 01       	movw	r24, r16
    1796:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
    179a:	89 a1       	ldd	r24, Y+33	; 0x21
    179c:	8e 8b       	std	Y+22, r24	; 0x16
    179e:	24 e0       	ldi	r18, 0x04	; 4
    17a0:	30 e0       	ldi	r19, 0x00	; 0
    17a2:	28 1b       	sub	r18, r24
    17a4:	31 09       	sbc	r19, r1
    17a6:	3d 87       	std	Y+13, r19	; 0x0d
    17a8:	2c 87       	std	Y+12, r18	; 0x0c
    17aa:	90 91 30 08 	lds	r25, 0x0830	; 0x800830 <uxTopReadyPriority>
    17ae:	98 17       	cp	r25, r24
    17b0:	10 f4       	brcc	.+4      	; 0x17b6 <xTaskPriorityDisinherit+0x4a>
    17b2:	80 93 30 08 	sts	0x0830, r24	; 0x800830 <uxTopReadyPriority>
    17b6:	90 e0       	ldi	r25, 0x00	; 0
    17b8:	9c 01       	movw	r18, r24
    17ba:	22 0f       	add	r18, r18
    17bc:	33 1f       	adc	r19, r19
    17be:	22 0f       	add	r18, r18
    17c0:	33 1f       	adc	r19, r19
    17c2:	22 0f       	add	r18, r18
    17c4:	33 1f       	adc	r19, r19
    17c6:	82 0f       	add	r24, r18
    17c8:	93 1f       	adc	r25, r19
    17ca:	b8 01       	movw	r22, r16
    17cc:	88 59       	subi	r24, 0x98	; 152
    17ce:	97 4f       	sbci	r25, 0xF7	; 247
    17d0:	0e 94 64 01 	call	0x2c8	; 0x2c8 <vListInsertEnd>
    17d4:	81 e0       	ldi	r24, 0x01	; 1
    17d6:	05 c0       	rjmp	.+10     	; 0x17e2 <xTaskPriorityDisinherit+0x76>
    17d8:	80 e0       	ldi	r24, 0x00	; 0
    17da:	03 c0       	rjmp	.+6      	; 0x17e2 <xTaskPriorityDisinherit+0x76>
    17dc:	80 e0       	ldi	r24, 0x00	; 0
    17de:	01 c0       	rjmp	.+2      	; 0x17e2 <xTaskPriorityDisinherit+0x76>
    17e0:	80 e0       	ldi	r24, 0x00	; 0
    17e2:	df 91       	pop	r29
    17e4:	cf 91       	pop	r28
    17e6:	1f 91       	pop	r17
    17e8:	0f 91       	pop	r16
    17ea:	08 95       	ret

000017ec <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    17ec:	80 91 8c 08 	lds	r24, 0x088C	; 0x80088c <pxCurrentTCB>
    17f0:	90 91 8d 08 	lds	r25, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
    17f4:	89 2b       	or	r24, r25
    17f6:	39 f0       	breq	.+14     	; 0x1806 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    17f8:	e0 91 8c 08 	lds	r30, 0x088C	; 0x80088c <pxCurrentTCB>
    17fc:	f0 91 8d 08 	lds	r31, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
    1800:	82 a1       	ldd	r24, Z+34	; 0x22
    1802:	8f 5f       	subi	r24, 0xFF	; 255
    1804:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    1806:	80 91 8c 08 	lds	r24, 0x088C	; 0x80088c <pxCurrentTCB>
    180a:	90 91 8d 08 	lds	r25, 0x088D	; 0x80088d <pxCurrentTCB+0x1>
	}
    180e:	08 95       	ret

00001810 <attachInterrupt>:
    #endif
      break;
#endif
    }
      
    intFunc[interruptNum] = 0;
    1810:	82 30       	cpi	r24, 0x02	; 2
    1812:	00 f5       	brcc	.+64     	; 0x1854 <attachInterrupt+0x44>
    1814:	e8 2f       	mov	r30, r24
    1816:	f0 e0       	ldi	r31, 0x00	; 0
    1818:	ee 0f       	add	r30, r30
    181a:	ff 1f       	adc	r31, r31
    181c:	e2 57       	subi	r30, 0x72	; 114
    181e:	f7 4f       	sbci	r31, 0xF7	; 247
    1820:	71 83       	std	Z+1, r23	; 0x01
    1822:	60 83       	st	Z, r22
    1824:	88 23       	and	r24, r24
    1826:	19 f0       	breq	.+6      	; 0x182e <attachInterrupt+0x1e>
    1828:	81 30       	cpi	r24, 0x01	; 1
    182a:	49 f0       	breq	.+18     	; 0x183e <attachInterrupt+0x2e>
    182c:	08 95       	ret
    182e:	e9 e6       	ldi	r30, 0x69	; 105
    1830:	f0 e0       	ldi	r31, 0x00	; 0
    1832:	80 81       	ld	r24, Z
    1834:	8c 7f       	andi	r24, 0xFC	; 252
    1836:	48 2b       	or	r20, r24
    1838:	40 83       	st	Z, r20
    183a:	e8 9a       	sbi	0x1d, 0	; 29
    183c:	08 95       	ret
    183e:	e9 e6       	ldi	r30, 0x69	; 105
    1840:	f0 e0       	ldi	r31, 0x00	; 0
    1842:	80 81       	ld	r24, Z
    1844:	83 7f       	andi	r24, 0xF3	; 243
    1846:	44 0f       	add	r20, r20
    1848:	55 1f       	adc	r21, r21
    184a:	44 0f       	add	r20, r20
    184c:	55 1f       	adc	r21, r21
    184e:	48 2b       	or	r20, r24
    1850:	40 83       	st	Z, r20
    1852:	e9 9a       	sbi	0x1d, 1	; 29
    1854:	08 95       	ret

00001856 <__vector_1>:
    intFunc[EXTERNAL_INT_7]();
}

#else

ISR(INT0_vect) {
    1856:	1f 92       	push	r1
    1858:	0f 92       	push	r0
    185a:	0f b6       	in	r0, 0x3f	; 63
    185c:	0f 92       	push	r0
    185e:	11 24       	eor	r1, r1
    1860:	2f 93       	push	r18
    1862:	3f 93       	push	r19
    1864:	4f 93       	push	r20
    1866:	5f 93       	push	r21
    1868:	6f 93       	push	r22
    186a:	7f 93       	push	r23
    186c:	8f 93       	push	r24
    186e:	9f 93       	push	r25
    1870:	af 93       	push	r26
    1872:	bf 93       	push	r27
    1874:	ef 93       	push	r30
    1876:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_0])
    1878:	80 91 8e 08 	lds	r24, 0x088E	; 0x80088e <intFunc>
    187c:	90 91 8f 08 	lds	r25, 0x088F	; 0x80088f <intFunc+0x1>
    1880:	89 2b       	or	r24, r25
    1882:	29 f0       	breq	.+10     	; 0x188e <__vector_1+0x38>
    intFunc[EXTERNAL_INT_0]();
    1884:	e0 91 8e 08 	lds	r30, 0x088E	; 0x80088e <intFunc>
    1888:	f0 91 8f 08 	lds	r31, 0x088F	; 0x80088f <intFunc+0x1>
    188c:	09 95       	icall
}
    188e:	ff 91       	pop	r31
    1890:	ef 91       	pop	r30
    1892:	bf 91       	pop	r27
    1894:	af 91       	pop	r26
    1896:	9f 91       	pop	r25
    1898:	8f 91       	pop	r24
    189a:	7f 91       	pop	r23
    189c:	6f 91       	pop	r22
    189e:	5f 91       	pop	r21
    18a0:	4f 91       	pop	r20
    18a2:	3f 91       	pop	r19
    18a4:	2f 91       	pop	r18
    18a6:	0f 90       	pop	r0
    18a8:	0f be       	out	0x3f, r0	; 63
    18aa:	0f 90       	pop	r0
    18ac:	1f 90       	pop	r1
    18ae:	18 95       	reti

000018b0 <__vector_2>:

ISR(INT1_vect) {
    18b0:	1f 92       	push	r1
    18b2:	0f 92       	push	r0
    18b4:	0f b6       	in	r0, 0x3f	; 63
    18b6:	0f 92       	push	r0
    18b8:	11 24       	eor	r1, r1
    18ba:	2f 93       	push	r18
    18bc:	3f 93       	push	r19
    18be:	4f 93       	push	r20
    18c0:	5f 93       	push	r21
    18c2:	6f 93       	push	r22
    18c4:	7f 93       	push	r23
    18c6:	8f 93       	push	r24
    18c8:	9f 93       	push	r25
    18ca:	af 93       	push	r26
    18cc:	bf 93       	push	r27
    18ce:	ef 93       	push	r30
    18d0:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_1])
    18d2:	80 91 90 08 	lds	r24, 0x0890	; 0x800890 <intFunc+0x2>
    18d6:	90 91 91 08 	lds	r25, 0x0891	; 0x800891 <intFunc+0x3>
    18da:	89 2b       	or	r24, r25
    18dc:	29 f0       	breq	.+10     	; 0x18e8 <__vector_2+0x38>
    intFunc[EXTERNAL_INT_1]();
    18de:	e0 91 90 08 	lds	r30, 0x0890	; 0x800890 <intFunc+0x2>
    18e2:	f0 91 91 08 	lds	r31, 0x0891	; 0x800891 <intFunc+0x3>
    18e6:	09 95       	icall
}
    18e8:	ff 91       	pop	r31
    18ea:	ef 91       	pop	r30
    18ec:	bf 91       	pop	r27
    18ee:	af 91       	pop	r26
    18f0:	9f 91       	pop	r25
    18f2:	8f 91       	pop	r24
    18f4:	7f 91       	pop	r23
    18f6:	6f 91       	pop	r22
    18f8:	5f 91       	pop	r21
    18fa:	4f 91       	pop	r20
    18fc:	3f 91       	pop	r19
    18fe:	2f 91       	pop	r18
    1900:	0f 90       	pop	r0
    1902:	0f be       	out	0x3f, r0	; 63
    1904:	0f 90       	pop	r0
    1906:	1f 90       	pop	r1
    1908:	18 95       	reti

0000190a <USART_init>:



void USART_init(void){
	
	UBRR0H = (uint8_t)(BAUD_PRESCALLER>>8);
    190a:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
	UBRR0L = (uint8_t)(BAUD_PRESCALLER);
    190e:	87 e6       	ldi	r24, 0x67	; 103
    1910:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	UCSR0B = (1<<RXEN0)|(1<<TXEN0)|(1<<UCSZ02);
    1914:	8c e1       	ldi	r24, 0x1C	; 28
    1916:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));
    191a:	86 e0       	ldi	r24, 0x06	; 6
    191c:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    1920:	08 95       	ret

00001922 <USART_send>:
	}
}

void USART_send( unsigned char data){
	
	while(!(UCSR0A & (1<<UDRE0)));
    1922:	e0 ec       	ldi	r30, 0xC0	; 192
    1924:	f0 e0       	ldi	r31, 0x00	; 0
    1926:	90 81       	ld	r25, Z
    1928:	95 ff       	sbrs	r25, 5
    192a:	fd cf       	rjmp	.-6      	; 0x1926 <USART_send+0x4>
	UDR0 = data;
    192c:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
    1930:	08 95       	ret

00001932 <USART_sendstr>:
	UCSR0B = (1<<RXEN0)|(1<<TXEN0)|(1<<UCSZ02);
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));
}


void USART_sendstr( unsigned char* str){
    1932:	cf 93       	push	r28
    1934:	df 93       	push	r29
    1936:	ec 01       	movw	r28, r24
	int i =0;
	
	while (str[i] != 0x00)
    1938:	88 81       	ld	r24, Y
    193a:	88 23       	and	r24, r24
    193c:	31 f0       	breq	.+12     	; 0x194a <USART_sendstr+0x18>
    193e:	21 96       	adiw	r28, 0x01	; 1
	{
		USART_send(str[i]);
    1940:	0e 94 91 0c 	call	0x1922	; 0x1922 <USART_send>


void USART_sendstr( unsigned char* str){
	int i =0;
	
	while (str[i] != 0x00)
    1944:	89 91       	ld	r24, Y+
    1946:	81 11       	cpse	r24, r1
    1948:	fb cf       	rjmp	.-10     	; 0x1940 <USART_sendstr+0xe>
	{
		USART_send(str[i]);
		i++;
	}
}
    194a:	df 91       	pop	r29
    194c:	cf 91       	pop	r28
    194e:	08 95       	ret

00001950 <memcpy>:
    1950:	fb 01       	movw	r30, r22
    1952:	dc 01       	movw	r26, r24
    1954:	02 c0       	rjmp	.+4      	; 0x195a <memcpy+0xa>
    1956:	01 90       	ld	r0, Z+
    1958:	0d 92       	st	X+, r0
    195a:	41 50       	subi	r20, 0x01	; 1
    195c:	50 40       	sbci	r21, 0x00	; 0
    195e:	d8 f7       	brcc	.-10     	; 0x1956 <memcpy+0x6>
    1960:	08 95       	ret

00001962 <_exit>:
    1962:	f8 94       	cli

00001964 <__stop_program>:
    1964:	ff cf       	rjmp	.-2      	; 0x1964 <__stop_program>

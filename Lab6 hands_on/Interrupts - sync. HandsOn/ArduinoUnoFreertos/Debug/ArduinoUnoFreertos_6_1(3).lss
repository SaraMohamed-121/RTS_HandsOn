
ArduinoUnoFreertos_6_1(3).elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000008a  00800100  00001e98  00001f2c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001e98  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000066b  0080018a  0080018a  00001fb6  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00001fb6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002014  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000370  00000000  00000000  00002054  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000042a1  00000000  00000000  000023c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000cd3  00000000  00000000  00006665  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000014f3  00000000  00000000  00007338  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000a68  00000000  00000000  0000882c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001425  00000000  00000000  00009294  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004485  00000000  00000000  0000a6b9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000378  00000000  00000000  0000eb3e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 0f 03 	jmp	0x61e	; 0x61e <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e8 e9       	ldi	r30, 0x98	; 152
      7c:	fe e1       	ldi	r31, 0x1E	; 30
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	aa 38       	cpi	r26, 0x8A	; 138
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	aa e8       	ldi	r26, 0x8A	; 138
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a5 3f       	cpi	r26, 0xF5	; 245
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <main>
      9e:	0c 94 4a 0f 	jmp	0x1e94	; 0x1e94 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <producer>:


void* producer(void* arg) {
	while (1) {

	int item = rand() % 100; // Generate a random number as an item 
      a6:	0f 2e       	mov	r0, r31
      a8:	f4 e6       	ldi	r31, 0x64	; 100
      aa:	ef 2e       	mov	r14, r31
      ac:	f1 2c       	mov	r15, r1
      ae:	f0 2d       	mov	r31, r0
           	{
	           	buffer[count]=item;
	           	count++;
           	}
		   //TO DO 3  //print ("Produced: %d\n", item);
       printf("Consumed: %d\n", item);
      b0:	08 e0       	ldi	r16, 0x08	; 8
      b2:	11 e0       	ldi	r17, 0x01	; 1


void* producer(void* arg) {
	while (1) {

	int item = rand() % 100; // Generate a random number as an item 
      b4:	0e 94 03 0c 	call	0x1806	; 0x1806 <rand>
      b8:	ec 01       	movw	r28, r24
 if(  xSemaphoreTake(sem,portMAX_DELAY)==pdTRUE /* TODO 5 call an API to get/take the semaphore*/)
      ba:	20 e0       	ldi	r18, 0x00	; 0
      bc:	4f ef       	ldi	r20, 0xFF	; 255
      be:	5f ef       	ldi	r21, 0xFF	; 255
      c0:	60 e0       	ldi	r22, 0x00	; 0
      c2:	70 e0       	ldi	r23, 0x00	; 0
      c4:	80 91 d5 07 	lds	r24, 0x07D5
      c8:	90 91 d6 07 	lds	r25, 0x07D6
      cc:	0e 94 b1 05 	call	0xb62	; 0xb62 <xQueueGenericReceive>
      d0:	81 30       	cpi	r24, 0x01	; 1
      d2:	81 f7       	brne	.-32     	; 0xb4 <producer+0xe>


void* producer(void* arg) {
	while (1) {

	int item = rand() % 100; // Generate a random number as an item 
      d4:	ce 01       	movw	r24, r28
      d6:	b7 01       	movw	r22, r14
      d8:	0e 94 8f 0b 	call	0x171e	; 0x171e <__divmodhi4>
      dc:	d8 2f       	mov	r29, r24
      de:	c9 2f       	mov	r28, r25
 if(  xSemaphoreTake(sem,portMAX_DELAY)==pdTRUE /* TODO 5 call an API to get/take the semaphore*/)
        {
		 // TO DO 2  // Produce item (fill the buffer with the item ) then increment the count
           	if (count<10)
      e0:	20 91 8a 01 	lds	r18, 0x018A
      e4:	30 91 8b 01 	lds	r19, 0x018B
      e8:	2a 30       	cpi	r18, 0x0A	; 10
      ea:	31 05       	cpc	r19, r1
      ec:	6c f4       	brge	.+26     	; 0x108 <producer+0x62>
           	{
	           	buffer[count]=item;
      ee:	f9 01       	movw	r30, r18
      f0:	ee 0f       	add	r30, r30
      f2:	ff 1f       	adc	r31, r31
      f4:	e7 52       	subi	r30, 0x27	; 39
      f6:	f8 4f       	sbci	r31, 0xF8	; 248
      f8:	80 83       	st	Z, r24
      fa:	91 83       	std	Z+1, r25	; 0x01
	           	count++;
      fc:	2f 5f       	subi	r18, 0xFF	; 255
      fe:	3f 4f       	sbci	r19, 0xFF	; 255
     100:	30 93 8b 01 	sts	0x018B, r19
     104:	20 93 8a 01 	sts	0x018A, r18
           	}
		   //TO DO 3  //print ("Produced: %d\n", item);
       printf("Consumed: %d\n", item);
     108:	cf 93       	push	r28
     10a:	df 93       	push	r29
     10c:	1f 93       	push	r17
     10e:	0f 93       	push	r16
     110:	0e 94 1c 0c 	call	0x1838	; 0x1838 <printf>
       USART_sendstr(item);
     114:	8d 2f       	mov	r24, r29
     116:	9c 2f       	mov	r25, r28
     118:	0e 94 80 0b 	call	0x1700	; 0x1700 <USART_sendstr>

        // Exit critical section
        	if( xSemaphoreGive(sem)!=pdTRUE ) //TO DO 4 IF releasing the semaphore"" != pdTRUE 
     11c:	20 e0       	ldi	r18, 0x00	; 0
     11e:	40 e0       	ldi	r20, 0x00	; 0
     120:	50 e0       	ldi	r21, 0x00	; 0
     122:	60 e0       	ldi	r22, 0x00	; 0
     124:	70 e0       	ldi	r23, 0x00	; 0
     126:	80 91 d5 07 	lds	r24, 0x07D5
     12a:	90 91 d6 07 	lds	r25, 0x07D6
     12e:	0e 94 10 05 	call	0xa20	; 0xa20 <xQueueGenericSend>
     132:	0f 90       	pop	r0
     134:	0f 90       	pop	r0
     136:	0f 90       	pop	r0
     138:	0f 90       	pop	r0
     13a:	81 30       	cpi	r24, 0x01	; 1
     13c:	09 f4       	brne	.+2      	; 0x140 <producer+0x9a>
     13e:	ba cf       	rjmp	.-140    	; 0xb4 <producer+0xe>
				USART_sendstr("Semaphore can not release by PRODUCER Task \r\n");
     140:	86 e1       	ldi	r24, 0x16	; 22
     142:	91 e0       	ldi	r25, 0x01	; 1
     144:	0e 94 80 0b 	call	0x1700	; 0x1700 <USART_sendstr>
     148:	b5 cf       	rjmp	.-150    	; 0xb4 <producer+0xe>

0000014a <consumer>:
    }
 }
    return NULL;

}
void* consumer(void* arg) {
     14a:	cf 93       	push	r28
     14c:	df 93       	push	r29
    while (1) {
         if( xSemaphoreTake(sem,portMAX_DELAY)==pdTRUE /* TODO 5 call an API to get/take the semaphore*/)
     14e:	20 e0       	ldi	r18, 0x00	; 0
     150:	4f ef       	ldi	r20, 0xFF	; 255
     152:	5f ef       	ldi	r21, 0xFF	; 255
     154:	60 e0       	ldi	r22, 0x00	; 0
     156:	70 e0       	ldi	r23, 0x00	; 0
     158:	80 91 d5 07 	lds	r24, 0x07D5
     15c:	90 91 d6 07 	lds	r25, 0x07D6
     160:	0e 94 b1 05 	call	0xb62	; 0xb62 <xQueueGenericReceive>
     164:	81 30       	cpi	r24, 0x01	; 1
     166:	91 f5       	brne	.+100    	; 0x1cc <consumer+0x82>
			 {

        // Consume item
        int item = buffer[count - 1];
     168:	20 91 8a 01 	lds	r18, 0x018A
     16c:	30 91 8b 01 	lds	r19, 0x018B
     170:	21 50       	subi	r18, 0x01	; 1
     172:	31 09       	sbc	r19, r1
     174:	f9 01       	movw	r30, r18
     176:	ee 0f       	add	r30, r30
     178:	ff 1f       	adc	r31, r31
     17a:	e7 52       	subi	r30, 0x27	; 39
     17c:	f8 4f       	sbci	r31, 0xF8	; 248
     17e:	d0 81       	ld	r29, Z
     180:	c1 81       	ldd	r28, Z+1	; 0x01
        count--;
     182:	30 93 8b 01 	sts	0x018B, r19
     186:	20 93 8a 01 	sts	0x018A, r18
	 //TO DO 6 //print ("Consumed: %d\n", item);
       printf("Consumed: %d\n", item);
     18a:	cf 93       	push	r28
     18c:	df 93       	push	r29
     18e:	88 e0       	ldi	r24, 0x08	; 8
     190:	91 e0       	ldi	r25, 0x01	; 1
     192:	9f 93       	push	r25
     194:	8f 93       	push	r24
     196:	0e 94 1c 0c 	call	0x1838	; 0x1838 <printf>
       USART_sendstr(item);
     19a:	8d 2f       	mov	r24, r29
     19c:	9c 2f       	mov	r25, r28
     19e:	0e 94 80 0b 	call	0x1700	; 0x1700 <USART_sendstr>
        

      
        if( xSemaphoreGive(sem)!=pdTRUE) //TO DO 7 IF releasing the semaphore"" != pdTRUE 
     1a2:	20 e0       	ldi	r18, 0x00	; 0
     1a4:	40 e0       	ldi	r20, 0x00	; 0
     1a6:	50 e0       	ldi	r21, 0x00	; 0
     1a8:	60 e0       	ldi	r22, 0x00	; 0
     1aa:	70 e0       	ldi	r23, 0x00	; 0
     1ac:	80 91 d5 07 	lds	r24, 0x07D5
     1b0:	90 91 d6 07 	lds	r25, 0x07D6
     1b4:	0e 94 10 05 	call	0xa20	; 0xa20 <xQueueGenericSend>
     1b8:	0f 90       	pop	r0
     1ba:	0f 90       	pop	r0
     1bc:	0f 90       	pop	r0
     1be:	0f 90       	pop	r0
     1c0:	81 30       	cpi	r24, 0x01	; 1
     1c2:	21 f0       	breq	.+8      	; 0x1cc <consumer+0x82>
			USART_sendstr("Semaphore can not release by PRODUCER Task \r\n");
     1c4:	86 e1       	ldi	r24, 0x16	; 22
     1c6:	91 e0       	ldi	r25, 0x01	; 1
     1c8:	0e 94 80 0b 	call	0x1700	; 0x1700 <USART_sendstr>
        // Simulate work
        //sleep(2);
    }
    return NULL;
}
}
     1cc:	80 e0       	ldi	r24, 0x00	; 0
     1ce:	90 e0       	ldi	r25, 0x00	; 0
     1d0:	df 91       	pop	r29
     1d2:	cf 91       	pop	r28
     1d4:	08 95       	ret

000001d6 <main>:
int count = 0; // Number of items in the buffer

SemaphoreHandle_t sem;
int main(void)
{ 
  cli();
     1d6:	f8 94       	cli
 
  USART_init();
     1d8:	0e 94 6c 0b 	call	0x16d8	; 0x16d8 <USART_init>
  sem =  xSemaphoreCreateBinary();
     1dc:	43 e0       	ldi	r20, 0x03	; 3
     1de:	60 e0       	ldi	r22, 0x00	; 0
     1e0:	81 e0       	ldi	r24, 0x01	; 1
     1e2:	0e 94 e4 04 	call	0x9c8	; 0x9c8 <xQueueGenericCreate>
     1e6:	90 93 d6 07 	sts	0x07D6, r25
     1ea:	80 93 d5 07 	sts	0x07D5, r24
  if(sem != NULL){
     1ee:	89 2b       	or	r24, r25
     1f0:	61 f1       	breq	.+88     	; 0x24a <main+0x74>
    DDRD = 0xff;
     1f2:	8f ef       	ldi	r24, 0xFF	; 255
     1f4:	8a b9       	out	0x0a, r24	; 10
	xTaskCreate( producer, "producer", 256, NULL, 1, &TaskHandle_1 );
     1f6:	a1 2c       	mov	r10, r1
     1f8:	b1 2c       	mov	r11, r1
     1fa:	c1 2c       	mov	r12, r1
     1fc:	d1 2c       	mov	r13, r1
     1fe:	0f 2e       	mov	r0, r31
     200:	fd ee       	ldi	r31, 0xED	; 237
     202:	ef 2e       	mov	r14, r31
     204:	f7 e0       	ldi	r31, 0x07	; 7
     206:	ff 2e       	mov	r15, r31
     208:	f0 2d       	mov	r31, r0
     20a:	01 e0       	ldi	r16, 0x01	; 1
     20c:	20 e0       	ldi	r18, 0x00	; 0
     20e:	30 e0       	ldi	r19, 0x00	; 0
     210:	40 e0       	ldi	r20, 0x00	; 0
     212:	51 e0       	ldi	r21, 0x01	; 1
     214:	64 e4       	ldi	r22, 0x44	; 68
     216:	71 e0       	ldi	r23, 0x01	; 1
     218:	83 e5       	ldi	r24, 0x53	; 83
     21a:	90 e0       	ldi	r25, 0x00	; 0
     21c:	0e 94 ca 06 	call	0xd94	; 0xd94 <xTaskGenericCreate>
	xTaskCreate( consumer, "consumer", 256, NULL, 3, &TaskHandle_2 );
     220:	0f 2e       	mov	r0, r31
     222:	f7 ed       	ldi	r31, 0xD7	; 215
     224:	ef 2e       	mov	r14, r31
     226:	f7 e0       	ldi	r31, 0x07	; 7
     228:	ff 2e       	mov	r15, r31
     22a:	f0 2d       	mov	r31, r0
     22c:	03 e0       	ldi	r16, 0x03	; 3
     22e:	20 e0       	ldi	r18, 0x00	; 0
     230:	30 e0       	ldi	r19, 0x00	; 0
     232:	40 e0       	ldi	r20, 0x00	; 0
     234:	51 e0       	ldi	r21, 0x01	; 1
     236:	6d e4       	ldi	r22, 0x4D	; 77
     238:	71 e0       	ldi	r23, 0x01	; 1
     23a:	85 ea       	ldi	r24, 0xA5	; 165
     23c:	90 e0       	ldi	r25, 0x00	; 0
     23e:	0e 94 ca 06 	call	0xd94	; 0xd94 <xTaskGenericCreate>
	sei();
     242:	78 94       	sei
	vTaskStartScheduler();
     244:	0e 94 dd 07 	call	0xfba	; 0xfba <vTaskStartScheduler>
     248:	04 c0       	rjmp	.+8      	; 0x252 <main+0x7c>
	}
  else
	   USART_sendstr("Semaphore not Created Correctly !!");
     24a:	86 e5       	ldi	r24, 0x56	; 86
     24c:	91 e0       	ldi	r25, 0x01	; 1
     24e:	0e 94 80 0b 	call	0x1700	; 0x1700 <USART_sendstr>
	 
	for( ;; );
     252:	ff cf       	rjmp	.-2      	; 0x252 <main+0x7c>

00000254 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     254:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     256:	03 96       	adiw	r24, 0x03	; 3
     258:	92 83       	std	Z+2, r25	; 0x02
     25a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     25c:	2f ef       	ldi	r18, 0xFF	; 255
     25e:	3f ef       	ldi	r19, 0xFF	; 255
     260:	34 83       	std	Z+4, r19	; 0x04
     262:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     264:	96 83       	std	Z+6, r25	; 0x06
     266:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     268:	90 87       	std	Z+8, r25	; 0x08
     26a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     26c:	10 82       	st	Z, r1
     26e:	08 95       	ret

00000270 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     270:	fc 01       	movw	r30, r24
     272:	11 86       	std	Z+9, r1	; 0x09
     274:	10 86       	std	Z+8, r1	; 0x08
     276:	08 95       	ret

00000278 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     278:	cf 93       	push	r28
     27a:	df 93       	push	r29
     27c:	9c 01       	movw	r18, r24
     27e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     280:	dc 01       	movw	r26, r24
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	cd 91       	ld	r28, X+
     286:	dc 91       	ld	r29, X
     288:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     28a:	d3 83       	std	Z+3, r29	; 0x03
     28c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     28e:	8c 81       	ldd	r24, Y+4	; 0x04
     290:	9d 81       	ldd	r25, Y+5	; 0x05
     292:	95 83       	std	Z+5, r25	; 0x05
     294:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     296:	8c 81       	ldd	r24, Y+4	; 0x04
     298:	9d 81       	ldd	r25, Y+5	; 0x05
     29a:	dc 01       	movw	r26, r24
     29c:	13 96       	adiw	r26, 0x03	; 3
     29e:	7c 93       	st	X, r23
     2a0:	6e 93       	st	-X, r22
     2a2:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     2a4:	7d 83       	std	Y+5, r23	; 0x05
     2a6:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2a8:	31 87       	std	Z+9, r19	; 0x09
     2aa:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     2ac:	f9 01       	movw	r30, r18
     2ae:	80 81       	ld	r24, Z
     2b0:	8f 5f       	subi	r24, 0xFF	; 255
     2b2:	80 83       	st	Z, r24
}
     2b4:	df 91       	pop	r29
     2b6:	cf 91       	pop	r28
     2b8:	08 95       	ret

000002ba <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     2ba:	cf 93       	push	r28
     2bc:	df 93       	push	r29
     2be:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     2c0:	48 81       	ld	r20, Y
     2c2:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     2c4:	4f 3f       	cpi	r20, 0xFF	; 255
     2c6:	2f ef       	ldi	r18, 0xFF	; 255
     2c8:	52 07       	cpc	r21, r18
     2ca:	21 f4       	brne	.+8      	; 0x2d4 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     2cc:	fc 01       	movw	r30, r24
     2ce:	a7 81       	ldd	r26, Z+7	; 0x07
     2d0:	b0 85       	ldd	r27, Z+8	; 0x08
     2d2:	0d c0       	rjmp	.+26     	; 0x2ee <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2d4:	dc 01       	movw	r26, r24
     2d6:	13 96       	adiw	r26, 0x03	; 3
     2d8:	01 c0       	rjmp	.+2      	; 0x2dc <vListInsert+0x22>
     2da:	df 01       	movw	r26, r30
     2dc:	12 96       	adiw	r26, 0x02	; 2
     2de:	ed 91       	ld	r30, X+
     2e0:	fc 91       	ld	r31, X
     2e2:	13 97       	sbiw	r26, 0x03	; 3
     2e4:	20 81       	ld	r18, Z
     2e6:	31 81       	ldd	r19, Z+1	; 0x01
     2e8:	42 17       	cp	r20, r18
     2ea:	53 07       	cpc	r21, r19
     2ec:	b0 f7       	brcc	.-20     	; 0x2da <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     2ee:	12 96       	adiw	r26, 0x02	; 2
     2f0:	ed 91       	ld	r30, X+
     2f2:	fc 91       	ld	r31, X
     2f4:	13 97       	sbiw	r26, 0x03	; 3
     2f6:	fb 83       	std	Y+3, r31	; 0x03
     2f8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     2fa:	d5 83       	std	Z+5, r29	; 0x05
     2fc:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     2fe:	bd 83       	std	Y+5, r27	; 0x05
     300:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     302:	13 96       	adiw	r26, 0x03	; 3
     304:	dc 93       	st	X, r29
     306:	ce 93       	st	-X, r28
     308:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     30a:	99 87       	std	Y+9, r25	; 0x09
     30c:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     30e:	fc 01       	movw	r30, r24
     310:	20 81       	ld	r18, Z
     312:	2f 5f       	subi	r18, 0xFF	; 255
     314:	20 83       	st	Z, r18
}
     316:	df 91       	pop	r29
     318:	cf 91       	pop	r28
     31a:	08 95       	ret

0000031c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     31c:	cf 93       	push	r28
     31e:	df 93       	push	r29
     320:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     322:	a0 85       	ldd	r26, Z+8	; 0x08
     324:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     326:	c2 81       	ldd	r28, Z+2	; 0x02
     328:	d3 81       	ldd	r29, Z+3	; 0x03
     32a:	84 81       	ldd	r24, Z+4	; 0x04
     32c:	95 81       	ldd	r25, Z+5	; 0x05
     32e:	9d 83       	std	Y+5, r25	; 0x05
     330:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     332:	c4 81       	ldd	r28, Z+4	; 0x04
     334:	d5 81       	ldd	r29, Z+5	; 0x05
     336:	82 81       	ldd	r24, Z+2	; 0x02
     338:	93 81       	ldd	r25, Z+3	; 0x03
     33a:	9b 83       	std	Y+3, r25	; 0x03
     33c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     33e:	11 96       	adiw	r26, 0x01	; 1
     340:	cd 91       	ld	r28, X+
     342:	dc 91       	ld	r29, X
     344:	12 97       	sbiw	r26, 0x02	; 2
     346:	ce 17       	cp	r28, r30
     348:	df 07       	cpc	r29, r31
     34a:	31 f4       	brne	.+12     	; 0x358 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     34c:	8c 81       	ldd	r24, Y+4	; 0x04
     34e:	9d 81       	ldd	r25, Y+5	; 0x05
     350:	12 96       	adiw	r26, 0x02	; 2
     352:	9c 93       	st	X, r25
     354:	8e 93       	st	-X, r24
     356:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     358:	11 86       	std	Z+9, r1	; 0x09
     35a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     35c:	8c 91       	ld	r24, X
     35e:	81 50       	subi	r24, 0x01	; 1
     360:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     362:	df 91       	pop	r29
     364:	cf 91       	pop	r28
     366:	08 95       	ret

00000368 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     368:	31 e1       	ldi	r19, 0x11	; 17
     36a:	fc 01       	movw	r30, r24
     36c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     36e:	31 97       	sbiw	r30, 0x01	; 1
     370:	22 e2       	ldi	r18, 0x22	; 34
     372:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     374:	31 97       	sbiw	r30, 0x01	; 1
     376:	a3 e3       	ldi	r26, 0x33	; 51
     378:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     37a:	31 97       	sbiw	r30, 0x01	; 1
     37c:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     37e:	31 97       	sbiw	r30, 0x01	; 1
     380:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     382:	31 97       	sbiw	r30, 0x01	; 1
     384:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     386:	31 97       	sbiw	r30, 0x01	; 1
     388:	60 e8       	ldi	r22, 0x80	; 128
     38a:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     38c:	31 97       	sbiw	r30, 0x01	; 1
     38e:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     390:	31 97       	sbiw	r30, 0x01	; 1
     392:	62 e0       	ldi	r22, 0x02	; 2
     394:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     396:	31 97       	sbiw	r30, 0x01	; 1
     398:	63 e0       	ldi	r22, 0x03	; 3
     39a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     39c:	31 97       	sbiw	r30, 0x01	; 1
     39e:	64 e0       	ldi	r22, 0x04	; 4
     3a0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     3a2:	31 97       	sbiw	r30, 0x01	; 1
     3a4:	65 e0       	ldi	r22, 0x05	; 5
     3a6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     3a8:	31 97       	sbiw	r30, 0x01	; 1
     3aa:	66 e0       	ldi	r22, 0x06	; 6
     3ac:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     3ae:	31 97       	sbiw	r30, 0x01	; 1
     3b0:	67 e0       	ldi	r22, 0x07	; 7
     3b2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     3b4:	31 97       	sbiw	r30, 0x01	; 1
     3b6:	68 e0       	ldi	r22, 0x08	; 8
     3b8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     3ba:	31 97       	sbiw	r30, 0x01	; 1
     3bc:	69 e0       	ldi	r22, 0x09	; 9
     3be:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     3c0:	31 97       	sbiw	r30, 0x01	; 1
     3c2:	60 e1       	ldi	r22, 0x10	; 16
     3c4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     3c6:	31 97       	sbiw	r30, 0x01	; 1
     3c8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     3ca:	31 97       	sbiw	r30, 0x01	; 1
     3cc:	32 e1       	ldi	r19, 0x12	; 18
     3ce:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     3d0:	31 97       	sbiw	r30, 0x01	; 1
     3d2:	33 e1       	ldi	r19, 0x13	; 19
     3d4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     3d6:	31 97       	sbiw	r30, 0x01	; 1
     3d8:	34 e1       	ldi	r19, 0x14	; 20
     3da:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     3dc:	31 97       	sbiw	r30, 0x01	; 1
     3de:	35 e1       	ldi	r19, 0x15	; 21
     3e0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     3e2:	31 97       	sbiw	r30, 0x01	; 1
     3e4:	36 e1       	ldi	r19, 0x16	; 22
     3e6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     3e8:	31 97       	sbiw	r30, 0x01	; 1
     3ea:	37 e1       	ldi	r19, 0x17	; 23
     3ec:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     3ee:	31 97       	sbiw	r30, 0x01	; 1
     3f0:	38 e1       	ldi	r19, 0x18	; 24
     3f2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     3f4:	31 97       	sbiw	r30, 0x01	; 1
     3f6:	39 e1       	ldi	r19, 0x19	; 25
     3f8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     3fa:	31 97       	sbiw	r30, 0x01	; 1
     3fc:	30 e2       	ldi	r19, 0x20	; 32
     3fe:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     400:	31 97       	sbiw	r30, 0x01	; 1
     402:	31 e2       	ldi	r19, 0x21	; 33
     404:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     406:	31 97       	sbiw	r30, 0x01	; 1
     408:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     40a:	31 97       	sbiw	r30, 0x01	; 1
     40c:	23 e2       	ldi	r18, 0x23	; 35
     40e:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     410:	31 97       	sbiw	r30, 0x01	; 1
     412:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     414:	31 97       	sbiw	r30, 0x01	; 1
     416:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     418:	31 97       	sbiw	r30, 0x01	; 1
     41a:	26 e2       	ldi	r18, 0x26	; 38
     41c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     41e:	31 97       	sbiw	r30, 0x01	; 1
     420:	27 e2       	ldi	r18, 0x27	; 39
     422:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     424:	31 97       	sbiw	r30, 0x01	; 1
     426:	28 e2       	ldi	r18, 0x28	; 40
     428:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     42a:	31 97       	sbiw	r30, 0x01	; 1
     42c:	29 e2       	ldi	r18, 0x29	; 41
     42e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     430:	31 97       	sbiw	r30, 0x01	; 1
     432:	20 e3       	ldi	r18, 0x30	; 48
     434:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     436:	31 97       	sbiw	r30, 0x01	; 1
     438:	21 e3       	ldi	r18, 0x31	; 49
     43a:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     43c:	86 97       	sbiw	r24, 0x26	; 38
     43e:	08 95       	ret

00000440 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     440:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
     444:	8c e7       	ldi	r24, 0x7C	; 124
     446:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     44a:	8b e0       	ldi	r24, 0x0B	; 11
     44c:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     450:	ef e6       	ldi	r30, 0x6F	; 111
     452:	f0 e0       	ldi	r31, 0x00	; 0
     454:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     456:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
     458:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     45a:	a0 91 d3 07 	lds	r26, 0x07D3
     45e:	b0 91 d4 07 	lds	r27, 0x07D4
     462:	cd 91       	ld	r28, X+
     464:	cd bf       	out	0x3d, r28	; 61
     466:	dd 91       	ld	r29, X+
     468:	de bf       	out	0x3e, r29	; 62
     46a:	ff 91       	pop	r31
     46c:	ef 91       	pop	r30
     46e:	df 91       	pop	r29
     470:	cf 91       	pop	r28
     472:	bf 91       	pop	r27
     474:	af 91       	pop	r26
     476:	9f 91       	pop	r25
     478:	8f 91       	pop	r24
     47a:	7f 91       	pop	r23
     47c:	6f 91       	pop	r22
     47e:	5f 91       	pop	r21
     480:	4f 91       	pop	r20
     482:	3f 91       	pop	r19
     484:	2f 91       	pop	r18
     486:	1f 91       	pop	r17
     488:	0f 91       	pop	r16
     48a:	ff 90       	pop	r15
     48c:	ef 90       	pop	r14
     48e:	df 90       	pop	r13
     490:	cf 90       	pop	r12
     492:	bf 90       	pop	r11
     494:	af 90       	pop	r10
     496:	9f 90       	pop	r9
     498:	8f 90       	pop	r8
     49a:	7f 90       	pop	r7
     49c:	6f 90       	pop	r6
     49e:	5f 90       	pop	r5
     4a0:	4f 90       	pop	r4
     4a2:	3f 90       	pop	r3
     4a4:	2f 90       	pop	r2
     4a6:	1f 90       	pop	r1
     4a8:	0f 90       	pop	r0
     4aa:	0f be       	out	0x3f, r0	; 63
     4ac:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     4ae:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     4b0:	81 e0       	ldi	r24, 0x01	; 1
     4b2:	08 95       	ret

000004b4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     4b4:	0f 92       	push	r0
     4b6:	0f b6       	in	r0, 0x3f	; 63
     4b8:	f8 94       	cli
     4ba:	0f 92       	push	r0
     4bc:	1f 92       	push	r1
     4be:	11 24       	eor	r1, r1
     4c0:	2f 92       	push	r2
     4c2:	3f 92       	push	r3
     4c4:	4f 92       	push	r4
     4c6:	5f 92       	push	r5
     4c8:	6f 92       	push	r6
     4ca:	7f 92       	push	r7
     4cc:	8f 92       	push	r8
     4ce:	9f 92       	push	r9
     4d0:	af 92       	push	r10
     4d2:	bf 92       	push	r11
     4d4:	cf 92       	push	r12
     4d6:	df 92       	push	r13
     4d8:	ef 92       	push	r14
     4da:	ff 92       	push	r15
     4dc:	0f 93       	push	r16
     4de:	1f 93       	push	r17
     4e0:	2f 93       	push	r18
     4e2:	3f 93       	push	r19
     4e4:	4f 93       	push	r20
     4e6:	5f 93       	push	r21
     4e8:	6f 93       	push	r22
     4ea:	7f 93       	push	r23
     4ec:	8f 93       	push	r24
     4ee:	9f 93       	push	r25
     4f0:	af 93       	push	r26
     4f2:	bf 93       	push	r27
     4f4:	cf 93       	push	r28
     4f6:	df 93       	push	r29
     4f8:	ef 93       	push	r30
     4fa:	ff 93       	push	r31
     4fc:	a0 91 d3 07 	lds	r26, 0x07D3
     500:	b0 91 d4 07 	lds	r27, 0x07D4
     504:	0d b6       	in	r0, 0x3d	; 61
     506:	0d 92       	st	X+, r0
     508:	0e b6       	in	r0, 0x3e	; 62
     50a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     50c:	0e 94 8e 09 	call	0x131c	; 0x131c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     510:	a0 91 d3 07 	lds	r26, 0x07D3
     514:	b0 91 d4 07 	lds	r27, 0x07D4
     518:	cd 91       	ld	r28, X+
     51a:	cd bf       	out	0x3d, r28	; 61
     51c:	dd 91       	ld	r29, X+
     51e:	de bf       	out	0x3e, r29	; 62
     520:	ff 91       	pop	r31
     522:	ef 91       	pop	r30
     524:	df 91       	pop	r29
     526:	cf 91       	pop	r28
     528:	bf 91       	pop	r27
     52a:	af 91       	pop	r26
     52c:	9f 91       	pop	r25
     52e:	8f 91       	pop	r24
     530:	7f 91       	pop	r23
     532:	6f 91       	pop	r22
     534:	5f 91       	pop	r21
     536:	4f 91       	pop	r20
     538:	3f 91       	pop	r19
     53a:	2f 91       	pop	r18
     53c:	1f 91       	pop	r17
     53e:	0f 91       	pop	r16
     540:	ff 90       	pop	r15
     542:	ef 90       	pop	r14
     544:	df 90       	pop	r13
     546:	cf 90       	pop	r12
     548:	bf 90       	pop	r11
     54a:	af 90       	pop	r10
     54c:	9f 90       	pop	r9
     54e:	8f 90       	pop	r8
     550:	7f 90       	pop	r7
     552:	6f 90       	pop	r6
     554:	5f 90       	pop	r5
     556:	4f 90       	pop	r4
     558:	3f 90       	pop	r3
     55a:	2f 90       	pop	r2
     55c:	1f 90       	pop	r1
     55e:	0f 90       	pop	r0
     560:	0f be       	out	0x3f, r0	; 63
     562:	0f 90       	pop	r0

	asm volatile ( "ret" );
     564:	08 95       	ret

00000566 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     566:	0f 92       	push	r0
     568:	0f b6       	in	r0, 0x3f	; 63
     56a:	f8 94       	cli
     56c:	0f 92       	push	r0
     56e:	1f 92       	push	r1
     570:	11 24       	eor	r1, r1
     572:	2f 92       	push	r2
     574:	3f 92       	push	r3
     576:	4f 92       	push	r4
     578:	5f 92       	push	r5
     57a:	6f 92       	push	r6
     57c:	7f 92       	push	r7
     57e:	8f 92       	push	r8
     580:	9f 92       	push	r9
     582:	af 92       	push	r10
     584:	bf 92       	push	r11
     586:	cf 92       	push	r12
     588:	df 92       	push	r13
     58a:	ef 92       	push	r14
     58c:	ff 92       	push	r15
     58e:	0f 93       	push	r16
     590:	1f 93       	push	r17
     592:	2f 93       	push	r18
     594:	3f 93       	push	r19
     596:	4f 93       	push	r20
     598:	5f 93       	push	r21
     59a:	6f 93       	push	r22
     59c:	7f 93       	push	r23
     59e:	8f 93       	push	r24
     5a0:	9f 93       	push	r25
     5a2:	af 93       	push	r26
     5a4:	bf 93       	push	r27
     5a6:	cf 93       	push	r28
     5a8:	df 93       	push	r29
     5aa:	ef 93       	push	r30
     5ac:	ff 93       	push	r31
     5ae:	a0 91 d3 07 	lds	r26, 0x07D3
     5b2:	b0 91 d4 07 	lds	r27, 0x07D4
     5b6:	0d b6       	in	r0, 0x3d	; 61
     5b8:	0d 92       	st	X+, r0
     5ba:	0e b6       	in	r0, 0x3e	; 62
     5bc:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     5be:	0e 94 12 08 	call	0x1024	; 0x1024 <xTaskIncrementTick>
     5c2:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     5c4:	0e 94 8e 09 	call	0x131c	; 0x131c <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     5c8:	a0 91 d3 07 	lds	r26, 0x07D3
     5cc:	b0 91 d4 07 	lds	r27, 0x07D4
     5d0:	cd 91       	ld	r28, X+
     5d2:	cd bf       	out	0x3d, r28	; 61
     5d4:	dd 91       	ld	r29, X+
     5d6:	de bf       	out	0x3e, r29	; 62
     5d8:	ff 91       	pop	r31
     5da:	ef 91       	pop	r30
     5dc:	df 91       	pop	r29
     5de:	cf 91       	pop	r28
     5e0:	bf 91       	pop	r27
     5e2:	af 91       	pop	r26
     5e4:	9f 91       	pop	r25
     5e6:	8f 91       	pop	r24
     5e8:	7f 91       	pop	r23
     5ea:	6f 91       	pop	r22
     5ec:	5f 91       	pop	r21
     5ee:	4f 91       	pop	r20
     5f0:	3f 91       	pop	r19
     5f2:	2f 91       	pop	r18
     5f4:	1f 91       	pop	r17
     5f6:	0f 91       	pop	r16
     5f8:	ff 90       	pop	r15
     5fa:	ef 90       	pop	r14
     5fc:	df 90       	pop	r13
     5fe:	cf 90       	pop	r12
     600:	bf 90       	pop	r11
     602:	af 90       	pop	r10
     604:	9f 90       	pop	r9
     606:	8f 90       	pop	r8
     608:	7f 90       	pop	r7
     60a:	6f 90       	pop	r6
     60c:	5f 90       	pop	r5
     60e:	4f 90       	pop	r4
     610:	3f 90       	pop	r3
     612:	2f 90       	pop	r2
     614:	1f 90       	pop	r1
     616:	0f 90       	pop	r0
     618:	0f be       	out	0x3f, r0	; 63
     61a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     61c:	08 95       	ret

0000061e <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect(void) __attribute__ ((signal, naked));
	void TIMER1_COMPA_vect(void)
	{
		vPortYieldFromTick();
     61e:	0e 94 b3 02 	call	0x566	; 0x566 <vPortYieldFromTick>
		asm volatile ( "reti" );
     622:	18 95       	reti

00000624 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     624:	0f 93       	push	r16
     626:	1f 93       	push	r17
     628:	cf 93       	push	r28
     62a:	df 93       	push	r29
     62c:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     62e:	0e 94 0c 08 	call	0x1018	; 0x1018 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     632:	80 91 8c 01 	lds	r24, 0x018C
     636:	81 11       	cpse	r24, r1
     638:	1d c0       	rjmp	.+58     	; 0x674 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     63a:	e1 e9       	ldi	r30, 0x91	; 145
     63c:	f1 e0       	ldi	r31, 0x01	; 1
     63e:	86 e9       	ldi	r24, 0x96	; 150
     640:	91 e0       	ldi	r25, 0x01	; 1
     642:	91 83       	std	Z+1, r25	; 0x01
     644:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     646:	13 82       	std	Z+3, r1	; 0x03
     648:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     64a:	ed e8       	ldi	r30, 0x8D	; 141
     64c:	f1 e0       	ldi	r31, 0x01	; 1
     64e:	8b ed       	ldi	r24, 0xDB	; 219
     650:	95 e0       	ldi	r25, 0x05	; 5
     652:	93 83       	std	Z+3, r25	; 0x03
     654:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     656:	11 82       	std	Z+1, r1	; 0x01
     658:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     65a:	a5 e9       	ldi	r26, 0x95	; 149
     65c:	b1 e0       	ldi	r27, 0x01	; 1
     65e:	14 96       	adiw	r26, 0x04	; 4
     660:	9c 93       	st	X, r25
     662:	8e 93       	st	-X, r24
     664:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     666:	12 96       	adiw	r26, 0x02	; 2
     668:	fc 93       	st	X, r31
     66a:	ee 93       	st	-X, r30
     66c:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     66e:	81 e0       	ldi	r24, 0x01	; 1
     670:	80 93 8c 01 	sts	0x018C, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     674:	20 97       	sbiw	r28, 0x00	; 0
     676:	09 f4       	brne	.+2      	; 0x67a <pvPortMalloc+0x56>
     678:	5f c0       	rjmp	.+190    	; 0x738 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
     67a:	9e 01       	movw	r18, r28
     67c:	2c 5f       	subi	r18, 0xFC	; 252
     67e:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     680:	23 96       	adiw	r28, 0x03	; 3
     682:	ca 3d       	cpi	r28, 0xDA	; 218
     684:	d5 40       	sbci	r29, 0x05	; 5
     686:	08 f0       	brcs	.+2      	; 0x68a <pvPortMalloc+0x66>
     688:	5a c0       	rjmp	.+180    	; 0x73e <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     68a:	e0 91 91 01 	lds	r30, 0x0191
     68e:	f0 91 92 01 	lds	r31, 0x0192

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     692:	a1 e9       	ldi	r26, 0x91	; 145
     694:	b1 e0       	ldi	r27, 0x01	; 1
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     696:	02 c0       	rjmp	.+4      	; 0x69c <pvPortMalloc+0x78>
     698:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     69a:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     69c:	82 81       	ldd	r24, Z+2	; 0x02
     69e:	93 81       	ldd	r25, Z+3	; 0x03
     6a0:	82 17       	cp	r24, r18
     6a2:	93 07       	cpc	r25, r19
     6a4:	20 f4       	brcc	.+8      	; 0x6ae <pvPortMalloc+0x8a>
     6a6:	80 81       	ld	r24, Z
     6a8:	91 81       	ldd	r25, Z+1	; 0x01
     6aa:	00 97       	sbiw	r24, 0x00	; 0
     6ac:	a9 f7       	brne	.-22     	; 0x698 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     6ae:	c1 e0       	ldi	r28, 0x01	; 1
     6b0:	ed 38       	cpi	r30, 0x8D	; 141
     6b2:	fc 07       	cpc	r31, r28
     6b4:	09 f4       	brne	.+2      	; 0x6b8 <pvPortMalloc+0x94>
     6b6:	46 c0       	rjmp	.+140    	; 0x744 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     6b8:	cd 91       	ld	r28, X+
     6ba:	dc 91       	ld	r29, X
     6bc:	11 97       	sbiw	r26, 0x01	; 1
     6be:	8e 01       	movw	r16, r28
     6c0:	0c 5f       	subi	r16, 0xFC	; 252
     6c2:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     6c4:	80 81       	ld	r24, Z
     6c6:	91 81       	ldd	r25, Z+1	; 0x01
     6c8:	8d 93       	st	X+, r24
     6ca:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     6cc:	82 81       	ldd	r24, Z+2	; 0x02
     6ce:	93 81       	ldd	r25, Z+3	; 0x03
     6d0:	82 1b       	sub	r24, r18
     6d2:	93 0b       	sbc	r25, r19
     6d4:	89 30       	cpi	r24, 0x09	; 9
     6d6:	91 05       	cpc	r25, r1
     6d8:	10 f1       	brcs	.+68     	; 0x71e <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     6da:	bf 01       	movw	r22, r30
     6dc:	62 0f       	add	r22, r18
     6de:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     6e0:	db 01       	movw	r26, r22
     6e2:	13 96       	adiw	r26, 0x03	; 3
     6e4:	9c 93       	st	X, r25
     6e6:	8e 93       	st	-X, r24
     6e8:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     6ea:	33 83       	std	Z+3, r19	; 0x03
     6ec:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     6ee:	12 96       	adiw	r26, 0x02	; 2
     6f0:	4d 91       	ld	r20, X+
     6f2:	5c 91       	ld	r21, X
     6f4:	13 97       	sbiw	r26, 0x03	; 3
     6f6:	81 e9       	ldi	r24, 0x91	; 145
     6f8:	91 e0       	ldi	r25, 0x01	; 1
     6fa:	01 c0       	rjmp	.+2      	; 0x6fe <pvPortMalloc+0xda>
     6fc:	cd 01       	movw	r24, r26
     6fe:	ec 01       	movw	r28, r24
     700:	a8 81       	ld	r26, Y
     702:	b9 81       	ldd	r27, Y+1	; 0x01
     704:	12 96       	adiw	r26, 0x02	; 2
     706:	2d 91       	ld	r18, X+
     708:	3c 91       	ld	r19, X
     70a:	13 97       	sbiw	r26, 0x03	; 3
     70c:	24 17       	cp	r18, r20
     70e:	35 07       	cpc	r19, r21
     710:	a8 f3       	brcs	.-22     	; 0x6fc <pvPortMalloc+0xd8>
     712:	eb 01       	movw	r28, r22
     714:	b9 83       	std	Y+1, r27	; 0x01
     716:	a8 83       	st	Y, r26
     718:	dc 01       	movw	r26, r24
     71a:	6d 93       	st	X+, r22
     71c:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     71e:	80 91 04 01 	lds	r24, 0x0104
     722:	90 91 05 01 	lds	r25, 0x0105
     726:	22 81       	ldd	r18, Z+2	; 0x02
     728:	33 81       	ldd	r19, Z+3	; 0x03
     72a:	82 1b       	sub	r24, r18
     72c:	93 0b       	sbc	r25, r19
     72e:	90 93 05 01 	sts	0x0105, r25
     732:	80 93 04 01 	sts	0x0104, r24
     736:	08 c0       	rjmp	.+16     	; 0x748 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     738:	00 e0       	ldi	r16, 0x00	; 0
     73a:	10 e0       	ldi	r17, 0x00	; 0
     73c:	05 c0       	rjmp	.+10     	; 0x748 <pvPortMalloc+0x124>
     73e:	00 e0       	ldi	r16, 0x00	; 0
     740:	10 e0       	ldi	r17, 0x00	; 0
     742:	02 c0       	rjmp	.+4      	; 0x748 <pvPortMalloc+0x124>
     744:	00 e0       	ldi	r16, 0x00	; 0
     746:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     748:	0e 94 cf 08 	call	0x119e	; 0x119e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     74c:	c8 01       	movw	r24, r16
     74e:	df 91       	pop	r29
     750:	cf 91       	pop	r28
     752:	1f 91       	pop	r17
     754:	0f 91       	pop	r16
     756:	08 95       	ret

00000758 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     758:	0f 93       	push	r16
     75a:	1f 93       	push	r17
     75c:	cf 93       	push	r28
     75e:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     760:	00 97       	sbiw	r24, 0x00	; 0
     762:	41 f1       	breq	.+80     	; 0x7b4 <vPortFree+0x5c>
     764:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     766:	8c 01       	movw	r16, r24
     768:	04 50       	subi	r16, 0x04	; 4
     76a:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     76c:	0e 94 0c 08 	call	0x1018	; 0x1018 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     770:	f8 01       	movw	r30, r16
     772:	42 81       	ldd	r20, Z+2	; 0x02
     774:	53 81       	ldd	r21, Z+3	; 0x03
     776:	a1 e9       	ldi	r26, 0x91	; 145
     778:	b1 e0       	ldi	r27, 0x01	; 1
     77a:	01 c0       	rjmp	.+2      	; 0x77e <vPortFree+0x26>
     77c:	df 01       	movw	r26, r30
     77e:	ed 91       	ld	r30, X+
     780:	fc 91       	ld	r31, X
     782:	11 97       	sbiw	r26, 0x01	; 1
     784:	22 81       	ldd	r18, Z+2	; 0x02
     786:	33 81       	ldd	r19, Z+3	; 0x03
     788:	24 17       	cp	r18, r20
     78a:	35 07       	cpc	r19, r21
     78c:	b8 f3       	brcs	.-18     	; 0x77c <vPortFree+0x24>
     78e:	24 97       	sbiw	r28, 0x04	; 4
     790:	f9 83       	std	Y+1, r31	; 0x01
     792:	e8 83       	st	Y, r30
     794:	0d 93       	st	X+, r16
     796:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     798:	20 91 04 01 	lds	r18, 0x0104
     79c:	30 91 05 01 	lds	r19, 0x0105
     7a0:	8a 81       	ldd	r24, Y+2	; 0x02
     7a2:	9b 81       	ldd	r25, Y+3	; 0x03
     7a4:	82 0f       	add	r24, r18
     7a6:	93 1f       	adc	r25, r19
     7a8:	90 93 05 01 	sts	0x0105, r25
     7ac:	80 93 04 01 	sts	0x0104, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     7b0:	0e 94 cf 08 	call	0x119e	; 0x119e <xTaskResumeAll>
	}
}
     7b4:	df 91       	pop	r29
     7b6:	cf 91       	pop	r28
     7b8:	1f 91       	pop	r17
     7ba:	0f 91       	pop	r16
     7bc:	08 95       	ret

000007be <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     7be:	1f 93       	push	r17
     7c0:	cf 93       	push	r28
     7c2:	df 93       	push	r29
     7c4:	ec 01       	movw	r28, r24
     7c6:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     7c8:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7ca:	81 11       	cpse	r24, r1
     7cc:	0c c0       	rjmp	.+24     	; 0x7e6 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     7ce:	88 81       	ld	r24, Y
     7d0:	99 81       	ldd	r25, Y+1	; 0x01
     7d2:	89 2b       	or	r24, r25
     7d4:	09 f0       	breq	.+2      	; 0x7d8 <prvCopyDataToQueue+0x1a>
     7d6:	47 c0       	rjmp	.+142    	; 0x866 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     7d8:	8a 81       	ldd	r24, Y+2	; 0x02
     7da:	9b 81       	ldd	r25, Y+3	; 0x03
     7dc:	0e 94 1a 0b 	call	0x1634	; 0x1634 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     7e0:	1b 82       	std	Y+3, r1	; 0x03
     7e2:	1a 82       	std	Y+2, r1	; 0x02
     7e4:	47 c0       	rjmp	.+142    	; 0x874 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     7e6:	41 11       	cpse	r20, r1
     7e8:	18 c0       	rjmp	.+48     	; 0x81a <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     7ea:	48 2f       	mov	r20, r24
     7ec:	50 e0       	ldi	r21, 0x00	; 0
     7ee:	8c 81       	ldd	r24, Y+4	; 0x04
     7f0:	9d 81       	ldd	r25, Y+5	; 0x05
     7f2:	0e 94 13 0c 	call	0x1826	; 0x1826 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     7f6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     7f8:	8c 81       	ldd	r24, Y+4	; 0x04
     7fa:	9d 81       	ldd	r25, Y+5	; 0x05
     7fc:	82 0f       	add	r24, r18
     7fe:	91 1d       	adc	r25, r1
     800:	9d 83       	std	Y+5, r25	; 0x05
     802:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     804:	2a 81       	ldd	r18, Y+2	; 0x02
     806:	3b 81       	ldd	r19, Y+3	; 0x03
     808:	82 17       	cp	r24, r18
     80a:	93 07       	cpc	r25, r19
     80c:	70 f1       	brcs	.+92     	; 0x86a <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     80e:	88 81       	ld	r24, Y
     810:	99 81       	ldd	r25, Y+1	; 0x01
     812:	9d 83       	std	Y+5, r25	; 0x05
     814:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	2d c0       	rjmp	.+90     	; 0x874 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     81a:	48 2f       	mov	r20, r24
     81c:	50 e0       	ldi	r21, 0x00	; 0
     81e:	8e 81       	ldd	r24, Y+6	; 0x06
     820:	9f 81       	ldd	r25, Y+7	; 0x07
     822:	0e 94 13 0c 	call	0x1826	; 0x1826 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     826:	8c 8d       	ldd	r24, Y+28	; 0x1c
     828:	90 e0       	ldi	r25, 0x00	; 0
     82a:	91 95       	neg	r25
     82c:	81 95       	neg	r24
     82e:	91 09       	sbc	r25, r1
     830:	2e 81       	ldd	r18, Y+6	; 0x06
     832:	3f 81       	ldd	r19, Y+7	; 0x07
     834:	28 0f       	add	r18, r24
     836:	39 1f       	adc	r19, r25
     838:	3f 83       	std	Y+7, r19	; 0x07
     83a:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     83c:	48 81       	ld	r20, Y
     83e:	59 81       	ldd	r21, Y+1	; 0x01
     840:	24 17       	cp	r18, r20
     842:	35 07       	cpc	r19, r21
     844:	30 f4       	brcc	.+12     	; 0x852 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     846:	2a 81       	ldd	r18, Y+2	; 0x02
     848:	3b 81       	ldd	r19, Y+3	; 0x03
     84a:	82 0f       	add	r24, r18
     84c:	93 1f       	adc	r25, r19
     84e:	9f 83       	std	Y+7, r25	; 0x07
     850:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     852:	12 30       	cpi	r17, 0x02	; 2
     854:	61 f4       	brne	.+24     	; 0x86e <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     856:	8a 8d       	ldd	r24, Y+26	; 0x1a
     858:	88 23       	and	r24, r24
     85a:	59 f0       	breq	.+22     	; 0x872 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
     85c:	8a 8d       	ldd	r24, Y+26	; 0x1a
     85e:	81 50       	subi	r24, 0x01	; 1
     860:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     862:	80 e0       	ldi	r24, 0x00	; 0
     864:	07 c0       	rjmp	.+14     	; 0x874 <prvCopyDataToQueue+0xb6>
     866:	80 e0       	ldi	r24, 0x00	; 0
     868:	05 c0       	rjmp	.+10     	; 0x874 <prvCopyDataToQueue+0xb6>
     86a:	80 e0       	ldi	r24, 0x00	; 0
     86c:	03 c0       	rjmp	.+6      	; 0x874 <prvCopyDataToQueue+0xb6>
     86e:	80 e0       	ldi	r24, 0x00	; 0
     870:	01 c0       	rjmp	.+2      	; 0x874 <prvCopyDataToQueue+0xb6>
     872:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
     874:	9a 8d       	ldd	r25, Y+26	; 0x1a
     876:	9f 5f       	subi	r25, 0xFF	; 255
     878:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
     87a:	df 91       	pop	r29
     87c:	cf 91       	pop	r28
     87e:	1f 91       	pop	r17
     880:	08 95       	ret

00000882 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     882:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     884:	44 8d       	ldd	r20, Z+28	; 0x1c
     886:	44 23       	and	r20, r20
     888:	a9 f0       	breq	.+42     	; 0x8b4 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     88a:	50 e0       	ldi	r21, 0x00	; 0
     88c:	26 81       	ldd	r18, Z+6	; 0x06
     88e:	37 81       	ldd	r19, Z+7	; 0x07
     890:	24 0f       	add	r18, r20
     892:	35 1f       	adc	r19, r21
     894:	37 83       	std	Z+7, r19	; 0x07
     896:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     898:	82 81       	ldd	r24, Z+2	; 0x02
     89a:	93 81       	ldd	r25, Z+3	; 0x03
     89c:	28 17       	cp	r18, r24
     89e:	39 07       	cpc	r19, r25
     8a0:	20 f0       	brcs	.+8      	; 0x8aa <prvCopyDataFromQueue+0x28>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     8a2:	80 81       	ld	r24, Z
     8a4:	91 81       	ldd	r25, Z+1	; 0x01
     8a6:	97 83       	std	Z+7, r25	; 0x07
     8a8:	86 83       	std	Z+6, r24	; 0x06
     8aa:	cb 01       	movw	r24, r22
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     8ac:	66 81       	ldd	r22, Z+6	; 0x06
     8ae:	77 81       	ldd	r23, Z+7	; 0x07
     8b0:	0e 94 13 0c 	call	0x1826	; 0x1826 <memcpy>
     8b4:	08 95       	ret

000008b6 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     8b6:	0f 93       	push	r16
     8b8:	1f 93       	push	r17
     8ba:	cf 93       	push	r28
     8bc:	df 93       	push	r29
     8be:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     8c0:	0f b6       	in	r0, 0x3f	; 63
     8c2:	f8 94       	cli
     8c4:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     8c6:	8e 8d       	ldd	r24, Y+30	; 0x1e
     8c8:	18 16       	cp	r1, r24
     8ca:	bc f4       	brge	.+46     	; 0x8fa <prvUnlockQueue+0x44>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     8cc:	89 89       	ldd	r24, Y+17	; 0x11
     8ce:	81 11       	cpse	r24, r1
     8d0:	05 c0       	rjmp	.+10     	; 0x8dc <prvUnlockQueue+0x26>
     8d2:	13 c0       	rjmp	.+38     	; 0x8fa <prvUnlockQueue+0x44>
     8d4:	99 89       	ldd	r25, Y+17	; 0x11
     8d6:	91 11       	cpse	r25, r1
     8d8:	04 c0       	rjmp	.+8      	; 0x8e2 <prvUnlockQueue+0x2c>
     8da:	0f c0       	rjmp	.+30     	; 0x8fa <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     8dc:	8e 01       	movw	r16, r28
     8de:	0f 5e       	subi	r16, 0xEF	; 239
     8e0:	1f 4f       	sbci	r17, 0xFF	; 255
     8e2:	c8 01       	movw	r24, r16
     8e4:	0e 94 28 0a 	call	0x1450	; 0x1450 <xTaskRemoveFromEventList>
     8e8:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
     8ea:	0e 94 b4 0a 	call	0x1568	; 0x1568 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
     8ee:	9e 8d       	ldd	r25, Y+30	; 0x1e
     8f0:	91 50       	subi	r25, 0x01	; 1
     8f2:	9e 8f       	std	Y+30, r25	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     8f4:	9e 8d       	ldd	r25, Y+30	; 0x1e
     8f6:	19 16       	cp	r1, r25
     8f8:	6c f3       	brlt	.-38     	; 0x8d4 <prvUnlockQueue+0x1e>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
     8fa:	8f ef       	ldi	r24, 0xFF	; 255
     8fc:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     8fe:	0f 90       	pop	r0
     900:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     902:	0f b6       	in	r0, 0x3f	; 63
     904:	f8 94       	cli
     906:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     908:	8d 8d       	ldd	r24, Y+29	; 0x1d
     90a:	18 16       	cp	r1, r24
     90c:	bc f4       	brge	.+46     	; 0x93c <__stack+0x3d>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     90e:	88 85       	ldd	r24, Y+8	; 0x08
     910:	81 11       	cpse	r24, r1
     912:	05 c0       	rjmp	.+10     	; 0x91e <__stack+0x1f>
     914:	13 c0       	rjmp	.+38     	; 0x93c <__stack+0x3d>
     916:	98 85       	ldd	r25, Y+8	; 0x08
     918:	91 11       	cpse	r25, r1
     91a:	04 c0       	rjmp	.+8      	; 0x924 <__stack+0x25>
     91c:	0f c0       	rjmp	.+30     	; 0x93c <__stack+0x3d>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     91e:	8e 01       	movw	r16, r28
     920:	08 5f       	subi	r16, 0xF8	; 248
     922:	1f 4f       	sbci	r17, 0xFF	; 255
     924:	c8 01       	movw	r24, r16
     926:	0e 94 28 0a 	call	0x1450	; 0x1450 <xTaskRemoveFromEventList>
     92a:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     92c:	0e 94 b4 0a 	call	0x1568	; 0x1568 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
     930:	9d 8d       	ldd	r25, Y+29	; 0x1d
     932:	91 50       	subi	r25, 0x01	; 1
     934:	9d 8f       	std	Y+29, r25	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     936:	9d 8d       	ldd	r25, Y+29	; 0x1d
     938:	19 16       	cp	r1, r25
     93a:	6c f3       	brlt	.-38     	; 0x916 <__stack+0x17>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     93c:	8f ef       	ldi	r24, 0xFF	; 255
     93e:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     940:	0f 90       	pop	r0
     942:	0f be       	out	0x3f, r0	; 63
}
     944:	df 91       	pop	r29
     946:	cf 91       	pop	r28
     948:	1f 91       	pop	r17
     94a:	0f 91       	pop	r16
     94c:	08 95       	ret

0000094e <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     94e:	cf 93       	push	r28
     950:	df 93       	push	r29
     952:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     954:	0f b6       	in	r0, 0x3f	; 63
     956:	f8 94       	cli
     958:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     95a:	48 81       	ld	r20, Y
     95c:	59 81       	ldd	r21, Y+1	; 0x01
     95e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     960:	30 e0       	ldi	r19, 0x00	; 0
     962:	7b 8d       	ldd	r23, Y+27	; 0x1b
     964:	72 9f       	mul	r23, r18
     966:	c0 01       	movw	r24, r0
     968:	73 9f       	mul	r23, r19
     96a:	90 0d       	add	r25, r0
     96c:	11 24       	eor	r1, r1
     96e:	fa 01       	movw	r30, r20
     970:	e8 0f       	add	r30, r24
     972:	f9 1f       	adc	r31, r25
     974:	fb 83       	std	Y+3, r31	; 0x03
     976:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     978:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     97a:	5d 83       	std	Y+5, r21	; 0x05
     97c:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     97e:	82 1b       	sub	r24, r18
     980:	93 0b       	sbc	r25, r19
     982:	84 0f       	add	r24, r20
     984:	95 1f       	adc	r25, r21
     986:	9f 83       	std	Y+7, r25	; 0x07
     988:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     98a:	8f ef       	ldi	r24, 0xFF	; 255
     98c:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     98e:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     990:	61 11       	cpse	r22, r1
     992:	0c c0       	rjmp	.+24     	; 0x9ac <xQueueGenericReset+0x5e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     994:	88 85       	ldd	r24, Y+8	; 0x08
     996:	88 23       	and	r24, r24
     998:	89 f0       	breq	.+34     	; 0x9bc <xQueueGenericReset+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     99a:	ce 01       	movw	r24, r28
     99c:	08 96       	adiw	r24, 0x08	; 8
     99e:	0e 94 28 0a 	call	0x1450	; 0x1450 <xTaskRemoveFromEventList>
     9a2:	81 30       	cpi	r24, 0x01	; 1
     9a4:	59 f4       	brne	.+22     	; 0x9bc <xQueueGenericReset+0x6e>
				{
					queueYIELD_IF_USING_PREEMPTION();
     9a6:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <vPortYield>
     9aa:	08 c0       	rjmp	.+16     	; 0x9bc <xQueueGenericReset+0x6e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     9ac:	ce 01       	movw	r24, r28
     9ae:	08 96       	adiw	r24, 0x08	; 8
     9b0:	0e 94 2a 01 	call	0x254	; 0x254 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     9b4:	ce 01       	movw	r24, r28
     9b6:	41 96       	adiw	r24, 0x11	; 17
     9b8:	0e 94 2a 01 	call	0x254	; 0x254 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     9bc:	0f 90       	pop	r0
     9be:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     9c0:	81 e0       	ldi	r24, 0x01	; 1
     9c2:	df 91       	pop	r29
     9c4:	cf 91       	pop	r28
     9c6:	08 95       	ret

000009c8 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
     9c8:	0f 93       	push	r16
     9ca:	1f 93       	push	r17
     9cc:	cf 93       	push	r28
     9ce:	df 93       	push	r29
     9d0:	08 2f       	mov	r16, r24
     9d2:	16 2f       	mov	r17, r22
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
     9d4:	66 23       	and	r22, r22
     9d6:	b9 f0       	breq	.+46     	; 0xa06 <xQueueGenericCreate+0x3e>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     9d8:	86 9f       	mul	r24, r22
     9da:	c0 01       	movw	r24, r0
     9dc:	11 24       	eor	r1, r1
	}

	/* Allocate the new queue structure and storage area. */
	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     9de:	80 96       	adiw	r24, 0x20	; 32
     9e0:	0e 94 12 03 	call	0x624	; 0x624 <pvPortMalloc>
     9e4:	ec 01       	movw	r28, r24

	if( pcAllocatedBuffer != NULL )
     9e6:	00 97       	sbiw	r24, 0x00	; 0
     9e8:	21 f4       	brne	.+8      	; 0x9f2 <xQueueGenericCreate+0x2a>
     9ea:	14 c0       	rjmp	.+40     	; 0xa14 <xQueueGenericCreate+0x4c>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     9ec:	d9 83       	std	Y+1, r29	; 0x01
     9ee:	c8 83       	st	Y, r28
     9f0:	03 c0       	rjmp	.+6      	; 0x9f8 <xQueueGenericCreate+0x30>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area - adding the padding bytes to get a better alignment. */
			pxNewQueue->pcHead = pcAllocatedBuffer + sizeof( Queue_t );
     9f2:	4f 96       	adiw	r24, 0x1f	; 31
     9f4:	99 83       	std	Y+1, r25	; 0x01
     9f6:	88 83       	st	Y, r24
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
     9f8:	0b 8f       	std	Y+27, r16	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
     9fa:	1c 8f       	std	Y+28, r17	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     9fc:	61 e0       	ldi	r22, 0x01	; 1
     9fe:	ce 01       	movw	r24, r28
     a00:	0e 94 a7 04 	call	0x94e	; 0x94e <xQueueGenericReset>
     a04:	07 c0       	rjmp	.+14     	; 0xa14 <xQueueGenericCreate+0x4c>
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}

	/* Allocate the new queue structure and storage area. */
	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     a06:	8f e1       	ldi	r24, 0x1F	; 31
     a08:	90 e0       	ldi	r25, 0x00	; 0
     a0a:	0e 94 12 03 	call	0x624	; 0x624 <pvPortMalloc>
     a0e:	ec 01       	movw	r28, r24

	if( pcAllocatedBuffer != NULL )
     a10:	89 2b       	or	r24, r25
     a12:	61 f7       	brne	.-40     	; 0x9ec <xQueueGenericCreate+0x24>
	}

	configASSERT( xReturn );

	return xReturn;
}
     a14:	ce 01       	movw	r24, r28
     a16:	df 91       	pop	r29
     a18:	cf 91       	pop	r28
     a1a:	1f 91       	pop	r17
     a1c:	0f 91       	pop	r16
     a1e:	08 95       	ret

00000a20 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     a20:	9f 92       	push	r9
     a22:	af 92       	push	r10
     a24:	bf 92       	push	r11
     a26:	cf 92       	push	r12
     a28:	df 92       	push	r13
     a2a:	ef 92       	push	r14
     a2c:	ff 92       	push	r15
     a2e:	0f 93       	push	r16
     a30:	1f 93       	push	r17
     a32:	cf 93       	push	r28
     a34:	df 93       	push	r29
     a36:	00 d0       	rcall	.+0      	; 0xa38 <xQueueGenericSend+0x18>
     a38:	00 d0       	rcall	.+0      	; 0xa3a <xQueueGenericSend+0x1a>
     a3a:	1f 92       	push	r1
     a3c:	cd b7       	in	r28, 0x3d	; 61
     a3e:	de b7       	in	r29, 0x3e	; 62
     a40:	8c 01       	movw	r16, r24
     a42:	6b 01       	movw	r12, r22
     a44:	5d 83       	std	Y+5, r21	; 0x05
     a46:	4c 83       	std	Y+4, r20	; 0x04
     a48:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
     a4a:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     a4c:	99 24       	eor	r9, r9
     a4e:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     a50:	7c 01       	movw	r14, r24
     a52:	88 e0       	ldi	r24, 0x08	; 8
     a54:	e8 0e       	add	r14, r24
     a56:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     a58:	0f b6       	in	r0, 0x3f	; 63
     a5a:	f8 94       	cli
     a5c:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     a5e:	f8 01       	movw	r30, r16
     a60:	32 8d       	ldd	r19, Z+26	; 0x1a
     a62:	93 8d       	ldd	r25, Z+27	; 0x1b
     a64:	39 17       	cp	r19, r25
     a66:	18 f0       	brcs	.+6      	; 0xa6e <xQueueGenericSend+0x4e>
     a68:	f2 e0       	ldi	r31, 0x02	; 2
     a6a:	af 12       	cpse	r10, r31
     a6c:	19 c0       	rjmp	.+50     	; 0xaa0 <xQueueGenericSend+0x80>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     a6e:	4a 2d       	mov	r20, r10
     a70:	b6 01       	movw	r22, r12
     a72:	c8 01       	movw	r24, r16
     a74:	0e 94 df 03 	call	0x7be	; 0x7be <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     a78:	f8 01       	movw	r30, r16
     a7a:	91 89       	ldd	r25, Z+17	; 0x11
     a7c:	99 23       	and	r25, r25
     a7e:	49 f0       	breq	.+18     	; 0xa92 <xQueueGenericSend+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     a80:	c8 01       	movw	r24, r16
     a82:	41 96       	adiw	r24, 0x11	; 17
     a84:	0e 94 28 0a 	call	0x1450	; 0x1450 <xTaskRemoveFromEventList>
     a88:	81 30       	cpi	r24, 0x01	; 1
     a8a:	31 f4       	brne	.+12     	; 0xa98 <xQueueGenericSend+0x78>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
     a8c:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <vPortYield>
     a90:	03 c0       	rjmp	.+6      	; 0xa98 <xQueueGenericSend+0x78>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
     a92:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
     a94:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     a98:	0f 90       	pop	r0
     a9a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     a9c:	81 e0       	ldi	r24, 0x01	; 1
     a9e:	50 c0       	rjmp	.+160    	; 0xb40 <xQueueGenericSend+0x120>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     aa0:	ec 81       	ldd	r30, Y+4	; 0x04
     aa2:	fd 81       	ldd	r31, Y+5	; 0x05
     aa4:	ef 2b       	or	r30, r31
     aa6:	21 f4       	brne	.+8      	; 0xab0 <xQueueGenericSend+0x90>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     aa8:	0f 90       	pop	r0
     aaa:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     aac:	80 e0       	ldi	r24, 0x00	; 0
     aae:	48 c0       	rjmp	.+144    	; 0xb40 <xQueueGenericSend+0x120>
				}
				else if( xEntryTimeSet == pdFALSE )
     ab0:	b1 10       	cpse	r11, r1
     ab2:	05 c0       	rjmp	.+10     	; 0xabe <xQueueGenericSend+0x9e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     ab4:	ce 01       	movw	r24, r28
     ab6:	01 96       	adiw	r24, 0x01	; 1
     ab8:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     abc:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     abe:	0f 90       	pop	r0
     ac0:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     ac2:	0e 94 0c 08 	call	0x1018	; 0x1018 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     ac6:	0f b6       	in	r0, 0x3f	; 63
     ac8:	f8 94       	cli
     aca:	0f 92       	push	r0
     acc:	f8 01       	movw	r30, r16
     ace:	85 8d       	ldd	r24, Z+29	; 0x1d
     ad0:	8f 3f       	cpi	r24, 0xFF	; 255
     ad2:	09 f4       	brne	.+2      	; 0xad6 <xQueueGenericSend+0xb6>
     ad4:	15 8e       	std	Z+29, r1	; 0x1d
     ad6:	f8 01       	movw	r30, r16
     ad8:	86 8d       	ldd	r24, Z+30	; 0x1e
     ada:	8f 3f       	cpi	r24, 0xFF	; 255
     adc:	09 f4       	brne	.+2      	; 0xae0 <xQueueGenericSend+0xc0>
     ade:	16 8e       	std	Z+30, r1	; 0x1e
     ae0:	0f 90       	pop	r0
     ae2:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ae4:	be 01       	movw	r22, r28
     ae6:	6c 5f       	subi	r22, 0xFC	; 252
     ae8:	7f 4f       	sbci	r23, 0xFF	; 255
     aea:	ce 01       	movw	r24, r28
     aec:	01 96       	adiw	r24, 0x01	; 1
     aee:	0e 94 7b 0a 	call	0x14f6	; 0x14f6 <xTaskCheckForTimeOut>
     af2:	81 11       	cpse	r24, r1
     af4:	1f c0       	rjmp	.+62     	; 0xb34 <xQueueGenericSend+0x114>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     af6:	0f b6       	in	r0, 0x3f	; 63
     af8:	f8 94       	cli
     afa:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     afc:	f8 01       	movw	r30, r16
     afe:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     b00:	0f 90       	pop	r0
     b02:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     b04:	83 8d       	ldd	r24, Z+27	; 0x1b
     b06:	98 13       	cpse	r25, r24
     b08:	0f c0       	rjmp	.+30     	; 0xb28 <xQueueGenericSend+0x108>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     b0a:	6c 81       	ldd	r22, Y+4	; 0x04
     b0c:	7d 81       	ldd	r23, Y+5	; 0x05
     b0e:	c7 01       	movw	r24, r14
     b10:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     b14:	c8 01       	movw	r24, r16
     b16:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     b1a:	0e 94 cf 08 	call	0x119e	; 0x119e <xTaskResumeAll>
     b1e:	81 11       	cpse	r24, r1
     b20:	9b cf       	rjmp	.-202    	; 0xa58 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
     b22:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <vPortYield>
     b26:	98 cf       	rjmp	.-208    	; 0xa58 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     b28:	c8 01       	movw	r24, r16
     b2a:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     b2e:	0e 94 cf 08 	call	0x119e	; 0x119e <xTaskResumeAll>
     b32:	92 cf       	rjmp	.-220    	; 0xa58 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     b34:	c8 01       	movw	r24, r16
     b36:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     b3a:	0e 94 cf 08 	call	0x119e	; 0x119e <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     b3e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     b40:	0f 90       	pop	r0
     b42:	0f 90       	pop	r0
     b44:	0f 90       	pop	r0
     b46:	0f 90       	pop	r0
     b48:	0f 90       	pop	r0
     b4a:	df 91       	pop	r29
     b4c:	cf 91       	pop	r28
     b4e:	1f 91       	pop	r17
     b50:	0f 91       	pop	r16
     b52:	ff 90       	pop	r15
     b54:	ef 90       	pop	r14
     b56:	df 90       	pop	r13
     b58:	cf 90       	pop	r12
     b5a:	bf 90       	pop	r11
     b5c:	af 90       	pop	r10
     b5e:	9f 90       	pop	r9
     b60:	08 95       	ret

00000b62 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     b62:	9f 92       	push	r9
     b64:	af 92       	push	r10
     b66:	bf 92       	push	r11
     b68:	cf 92       	push	r12
     b6a:	df 92       	push	r13
     b6c:	ef 92       	push	r14
     b6e:	ff 92       	push	r15
     b70:	0f 93       	push	r16
     b72:	1f 93       	push	r17
     b74:	cf 93       	push	r28
     b76:	df 93       	push	r29
     b78:	00 d0       	rcall	.+0      	; 0xb7a <xQueueGenericReceive+0x18>
     b7a:	00 d0       	rcall	.+0      	; 0xb7c <xQueueGenericReceive+0x1a>
     b7c:	1f 92       	push	r1
     b7e:	cd b7       	in	r28, 0x3d	; 61
     b80:	de b7       	in	r29, 0x3e	; 62
     b82:	8c 01       	movw	r16, r24
     b84:	6b 01       	movw	r12, r22
     b86:	5d 83       	std	Y+5, r21	; 0x05
     b88:	4c 83       	std	Y+4, r20	; 0x04
     b8a:	92 2e       	mov	r9, r18
BaseType_t xEntryTimeSet = pdFALSE;
     b8c:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     b8e:	aa 24       	eor	r10, r10
     b90:	a3 94       	inc	r10
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b92:	7c 01       	movw	r14, r24
     b94:	81 e1       	ldi	r24, 0x11	; 17
     b96:	e8 0e       	add	r14, r24
     b98:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     b9a:	0f b6       	in	r0, 0x3f	; 63
     b9c:	f8 94       	cli
     b9e:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     ba0:	f8 01       	movw	r30, r16
     ba2:	92 8d       	ldd	r25, Z+26	; 0x1a
     ba4:	99 23       	and	r25, r25
     ba6:	99 f1       	breq	.+102    	; 0xc0e <xQueueGenericReceive+0xac>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     ba8:	e6 80       	ldd	r14, Z+6	; 0x06
     baa:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     bac:	b6 01       	movw	r22, r12
     bae:	c8 01       	movw	r24, r16
     bb0:	0e 94 41 04 	call	0x882	; 0x882 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     bb4:	91 10       	cpse	r9, r1
     bb6:	1a c0       	rjmp	.+52     	; 0xbec <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     bb8:	f8 01       	movw	r30, r16
     bba:	82 8d       	ldd	r24, Z+26	; 0x1a
     bbc:	81 50       	subi	r24, 0x01	; 1
     bbe:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     bc0:	80 81       	ld	r24, Z
     bc2:	91 81       	ldd	r25, Z+1	; 0x01
     bc4:	89 2b       	or	r24, r25
     bc6:	29 f4       	brne	.+10     	; 0xbd2 <xQueueGenericReceive+0x70>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     bc8:	0e 94 5a 0b 	call	0x16b4	; 0x16b4 <pvTaskIncrementMutexHeldCount>
     bcc:	f8 01       	movw	r30, r16
     bce:	93 83       	std	Z+3, r25	; 0x03
     bd0:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     bd2:	f8 01       	movw	r30, r16
     bd4:	80 85       	ldd	r24, Z+8	; 0x08
     bd6:	88 23       	and	r24, r24
     bd8:	b1 f0       	breq	.+44     	; 0xc06 <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     bda:	c8 01       	movw	r24, r16
     bdc:	08 96       	adiw	r24, 0x08	; 8
     bde:	0e 94 28 0a 	call	0x1450	; 0x1450 <xTaskRemoveFromEventList>
     be2:	81 30       	cpi	r24, 0x01	; 1
     be4:	81 f4       	brne	.+32     	; 0xc06 <xQueueGenericReceive+0xa4>
						{
							queueYIELD_IF_USING_PREEMPTION();
     be6:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <vPortYield>
     bea:	0d c0       	rjmp	.+26     	; 0xc06 <xQueueGenericReceive+0xa4>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     bec:	f8 01       	movw	r30, r16
     bee:	f7 82       	std	Z+7, r15	; 0x07
     bf0:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     bf2:	81 89       	ldd	r24, Z+17	; 0x11
     bf4:	88 23       	and	r24, r24
     bf6:	39 f0       	breq	.+14     	; 0xc06 <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     bf8:	c8 01       	movw	r24, r16
     bfa:	41 96       	adiw	r24, 0x11	; 17
     bfc:	0e 94 28 0a 	call	0x1450	; 0x1450 <xTaskRemoveFromEventList>
     c00:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     c02:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     c06:	0f 90       	pop	r0
     c08:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     c0a:	81 e0       	ldi	r24, 0x01	; 1
     c0c:	5c c0       	rjmp	.+184    	; 0xcc6 <xQueueGenericReceive+0x164>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     c0e:	4c 81       	ldd	r20, Y+4	; 0x04
     c10:	5d 81       	ldd	r21, Y+5	; 0x05
     c12:	45 2b       	or	r20, r21
     c14:	21 f4       	brne	.+8      	; 0xc1e <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     c16:	0f 90       	pop	r0
     c18:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     c1a:	80 e0       	ldi	r24, 0x00	; 0
     c1c:	54 c0       	rjmp	.+168    	; 0xcc6 <xQueueGenericReceive+0x164>
				}
				else if( xEntryTimeSet == pdFALSE )
     c1e:	b1 10       	cpse	r11, r1
     c20:	05 c0       	rjmp	.+10     	; 0xc2c <xQueueGenericReceive+0xca>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     c22:	ce 01       	movw	r24, r28
     c24:	01 96       	adiw	r24, 0x01	; 1
     c26:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     c2a:	ba 2c       	mov	r11, r10
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     c2c:	0f 90       	pop	r0
     c2e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     c30:	0e 94 0c 08 	call	0x1018	; 0x1018 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     c34:	0f b6       	in	r0, 0x3f	; 63
     c36:	f8 94       	cli
     c38:	0f 92       	push	r0
     c3a:	f8 01       	movw	r30, r16
     c3c:	85 8d       	ldd	r24, Z+29	; 0x1d
     c3e:	8f 3f       	cpi	r24, 0xFF	; 255
     c40:	09 f4       	brne	.+2      	; 0xc44 <xQueueGenericReceive+0xe2>
     c42:	15 8e       	std	Z+29, r1	; 0x1d
     c44:	f8 01       	movw	r30, r16
     c46:	96 8d       	ldd	r25, Z+30	; 0x1e
     c48:	9f 3f       	cpi	r25, 0xFF	; 255
     c4a:	09 f4       	brne	.+2      	; 0xc4e <xQueueGenericReceive+0xec>
     c4c:	16 8e       	std	Z+30, r1	; 0x1e
     c4e:	0f 90       	pop	r0
     c50:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     c52:	be 01       	movw	r22, r28
     c54:	6c 5f       	subi	r22, 0xFC	; 252
     c56:	7f 4f       	sbci	r23, 0xFF	; 255
     c58:	ce 01       	movw	r24, r28
     c5a:	01 96       	adiw	r24, 0x01	; 1
     c5c:	0e 94 7b 0a 	call	0x14f6	; 0x14f6 <xTaskCheckForTimeOut>
     c60:	81 11       	cpse	r24, r1
     c62:	2b c0       	rjmp	.+86     	; 0xcba <xQueueGenericReceive+0x158>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     c64:	0f b6       	in	r0, 0x3f	; 63
     c66:	f8 94       	cli
     c68:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     c6a:	f8 01       	movw	r30, r16
     c6c:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     c6e:	0f 90       	pop	r0
     c70:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     c72:	81 11       	cpse	r24, r1
     c74:	1c c0       	rjmp	.+56     	; 0xcae <xQueueGenericReceive+0x14c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     c76:	80 81       	ld	r24, Z
     c78:	91 81       	ldd	r25, Z+1	; 0x01
     c7a:	89 2b       	or	r24, r25
     c7c:	49 f4       	brne	.+18     	; 0xc90 <xQueueGenericReceive+0x12e>
					{
						taskENTER_CRITICAL();
     c7e:	0f b6       	in	r0, 0x3f	; 63
     c80:	f8 94       	cli
     c82:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     c84:	82 81       	ldd	r24, Z+2	; 0x02
     c86:	93 81       	ldd	r25, Z+3	; 0x03
     c88:	0e 94 b8 0a 	call	0x1570	; 0x1570 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     c8c:	0f 90       	pop	r0
     c8e:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     c90:	6c 81       	ldd	r22, Y+4	; 0x04
     c92:	7d 81       	ldd	r23, Y+5	; 0x05
     c94:	c7 01       	movw	r24, r14
     c96:	0e 94 fb 09 	call	0x13f6	; 0x13f6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     c9a:	c8 01       	movw	r24, r16
     c9c:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     ca0:	0e 94 cf 08 	call	0x119e	; 0x119e <xTaskResumeAll>
     ca4:	81 11       	cpse	r24, r1
     ca6:	79 cf       	rjmp	.-270    	; 0xb9a <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
     ca8:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <vPortYield>
     cac:	76 cf       	rjmp	.-276    	; 0xb9a <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     cae:	c8 01       	movw	r24, r16
     cb0:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     cb4:	0e 94 cf 08 	call	0x119e	; 0x119e <xTaskResumeAll>
     cb8:	70 cf       	rjmp	.-288    	; 0xb9a <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     cba:	c8 01       	movw	r24, r16
     cbc:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     cc0:	0e 94 cf 08 	call	0x119e	; 0x119e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     cc4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     cc6:	0f 90       	pop	r0
     cc8:	0f 90       	pop	r0
     cca:	0f 90       	pop	r0
     ccc:	0f 90       	pop	r0
     cce:	0f 90       	pop	r0
     cd0:	df 91       	pop	r29
     cd2:	cf 91       	pop	r28
     cd4:	1f 91       	pop	r17
     cd6:	0f 91       	pop	r16
     cd8:	ff 90       	pop	r15
     cda:	ef 90       	pop	r14
     cdc:	df 90       	pop	r13
     cde:	cf 90       	pop	r12
     ce0:	bf 90       	pop	r11
     ce2:	af 90       	pop	r10
     ce4:	9f 90       	pop	r9
     ce6:	08 95       	ret

00000ce8 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     ce8:	e0 91 9b 07 	lds	r30, 0x079B
     cec:	f0 91 9c 07 	lds	r31, 0x079C
     cf0:	80 81       	ld	r24, Z
     cf2:	81 11       	cpse	r24, r1
     cf4:	07 c0       	rjmp	.+14     	; 0xd04 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     cf6:	8f ef       	ldi	r24, 0xFF	; 255
     cf8:	9f ef       	ldi	r25, 0xFF	; 255
     cfa:	90 93 07 01 	sts	0x0107, r25
     cfe:	80 93 06 01 	sts	0x0106, r24
     d02:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     d04:	e0 91 9b 07 	lds	r30, 0x079B
     d08:	f0 91 9c 07 	lds	r31, 0x079C
     d0c:	05 80       	ldd	r0, Z+5	; 0x05
     d0e:	f6 81       	ldd	r31, Z+6	; 0x06
     d10:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
     d12:	06 80       	ldd	r0, Z+6	; 0x06
     d14:	f7 81       	ldd	r31, Z+7	; 0x07
     d16:	e0 2d       	mov	r30, r0
     d18:	82 81       	ldd	r24, Z+2	; 0x02
     d1a:	93 81       	ldd	r25, Z+3	; 0x03
     d1c:	90 93 07 01 	sts	0x0107, r25
     d20:	80 93 06 01 	sts	0x0106, r24
     d24:	08 95       	ret

00000d26 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
     d26:	cf 93       	push	r28
     d28:	df 93       	push	r29
     d2a:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     d2c:	e0 91 d3 07 	lds	r30, 0x07D3
     d30:	f0 91 d4 07 	lds	r31, 0x07D4
     d34:	93 83       	std	Z+3, r25	; 0x03
     d36:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
     d38:	80 91 78 07 	lds	r24, 0x0778
     d3c:	90 91 79 07 	lds	r25, 0x0779
     d40:	c8 17       	cp	r28, r24
     d42:	d9 07       	cpc	r29, r25
     d44:	68 f4       	brcc	.+26     	; 0xd60 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     d46:	60 91 d3 07 	lds	r22, 0x07D3
     d4a:	70 91 d4 07 	lds	r23, 0x07D4
     d4e:	80 91 99 07 	lds	r24, 0x0799
     d52:	90 91 9a 07 	lds	r25, 0x079A
     d56:	6e 5f       	subi	r22, 0xFE	; 254
     d58:	7f 4f       	sbci	r23, 0xFF	; 255
     d5a:	0e 94 5d 01 	call	0x2ba	; 0x2ba <vListInsert>
     d5e:	17 c0       	rjmp	.+46     	; 0xd8e <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     d60:	60 91 d3 07 	lds	r22, 0x07D3
     d64:	70 91 d4 07 	lds	r23, 0x07D4
     d68:	80 91 9b 07 	lds	r24, 0x079B
     d6c:	90 91 9c 07 	lds	r25, 0x079C
     d70:	6e 5f       	subi	r22, 0xFE	; 254
     d72:	7f 4f       	sbci	r23, 0xFF	; 255
     d74:	0e 94 5d 01 	call	0x2ba	; 0x2ba <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     d78:	80 91 06 01 	lds	r24, 0x0106
     d7c:	90 91 07 01 	lds	r25, 0x0107
     d80:	c8 17       	cp	r28, r24
     d82:	d9 07       	cpc	r29, r25
     d84:	20 f4       	brcc	.+8      	; 0xd8e <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
     d86:	d0 93 07 01 	sts	0x0107, r29
     d8a:	c0 93 06 01 	sts	0x0106, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     d8e:	df 91       	pop	r29
     d90:	cf 91       	pop	r28
     d92:	08 95       	ret

00000d94 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
     d94:	4f 92       	push	r4
     d96:	5f 92       	push	r5
     d98:	6f 92       	push	r6
     d9a:	7f 92       	push	r7
     d9c:	8f 92       	push	r8
     d9e:	9f 92       	push	r9
     da0:	af 92       	push	r10
     da2:	bf 92       	push	r11
     da4:	cf 92       	push	r12
     da6:	df 92       	push	r13
     da8:	ef 92       	push	r14
     daa:	ff 92       	push	r15
     dac:	0f 93       	push	r16
     dae:	1f 93       	push	r17
     db0:	cf 93       	push	r28
     db2:	df 93       	push	r29
     db4:	4c 01       	movw	r8, r24
     db6:	eb 01       	movw	r28, r22
     db8:	5a 01       	movw	r10, r20
     dba:	29 01       	movw	r4, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     dbc:	c1 14       	cp	r12, r1
     dbe:	d1 04       	cpc	r13, r1
     dc0:	39 f4       	brne	.+14     	; 0xdd0 <xTaskGenericCreate+0x3c>
     dc2:	ca 01       	movw	r24, r20
     dc4:	0e 94 12 03 	call	0x624	; 0x624 <pvPortMalloc>
     dc8:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
     dca:	89 2b       	or	r24, r25
     dcc:	09 f4       	brne	.+2      	; 0xdd0 <xTaskGenericCreate+0x3c>
     dce:	e3 c0       	rjmp	.+454    	; 0xf96 <xTaskGenericCreate+0x202>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     dd0:	88 e2       	ldi	r24, 0x28	; 40
     dd2:	90 e0       	ldi	r25, 0x00	; 0
     dd4:	0e 94 12 03 	call	0x624	; 0x624 <pvPortMalloc>
     dd8:	3c 01       	movw	r6, r24

			if( pxNewTCB != NULL )
     dda:	00 97       	sbiw	r24, 0x00	; 0
     ddc:	79 f0       	breq	.+30     	; 0xdfc <xTaskGenericCreate+0x68>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
     dde:	fc 01       	movw	r30, r24
     de0:	d0 8e       	std	Z+24, r13	; 0x18
     de2:	c7 8a       	std	Z+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
     de4:	f1 e0       	ldi	r31, 0x01	; 1
     de6:	af 1a       	sub	r10, r31
     de8:	b1 08       	sbc	r11, r1
     dea:	ca 0c       	add	r12, r10
     dec:	db 1c       	adc	r13, r11
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     dee:	88 81       	ld	r24, Y
     df0:	f3 01       	movw	r30, r6
     df2:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     df4:	88 81       	ld	r24, Y
     df6:	81 11       	cpse	r24, r1
     df8:	05 c0       	rjmp	.+10     	; 0xe04 <xTaskGenericCreate+0x70>
     dfa:	14 c0       	rjmp	.+40     	; 0xe24 <xTaskGenericCreate+0x90>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
     dfc:	c6 01       	movw	r24, r12
     dfe:	0e 94 ac 03 	call	0x758	; 0x758 <vPortFree>
     e02:	c9 c0       	rjmp	.+402    	; 0xf96 <xTaskGenericCreate+0x202>
     e04:	d3 01       	movw	r26, r6
     e06:	5a 96       	adiw	r26, 0x1a	; 26
     e08:	fe 01       	movw	r30, r28
     e0a:	31 96       	adiw	r30, 0x01	; 1
     e0c:	9e 01       	movw	r18, r28
     e0e:	28 5f       	subi	r18, 0xF8	; 248
     e10:	3f 4f       	sbci	r19, 0xFF	; 255
     e12:	ef 01       	movw	r28, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     e14:	81 91       	ld	r24, Z+
     e16:	8d 93       	st	X+, r24

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     e18:	88 81       	ld	r24, Y
     e1a:	88 23       	and	r24, r24
     e1c:	19 f0       	breq	.+6      	; 0xe24 <xTaskGenericCreate+0x90>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     e1e:	e2 17       	cp	r30, r18
     e20:	f3 07       	cpc	r31, r19
     e22:	b9 f7       	brne	.-18     	; 0xe12 <xTaskGenericCreate+0x7e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     e24:	f3 01       	movw	r30, r6
     e26:	10 a2       	std	Z+32, r1	; 0x20
     e28:	10 2f       	mov	r17, r16
     e2a:	04 30       	cpi	r16, 0x04	; 4
     e2c:	08 f0       	brcs	.+2      	; 0xe30 <xTaskGenericCreate+0x9c>
     e2e:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
     e30:	f3 01       	movw	r30, r6
     e32:	16 8b       	std	Z+22, r17	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
     e34:	11 a3       	std	Z+33, r17	; 0x21
		pxTCB->uxMutexesHeld = 0;
     e36:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     e38:	e3 01       	movw	r28, r6
     e3a:	22 96       	adiw	r28, 0x02	; 2
     e3c:	ce 01       	movw	r24, r28
     e3e:	0e 94 38 01 	call	0x270	; 0x270 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     e42:	c3 01       	movw	r24, r6
     e44:	0c 96       	adiw	r24, 0x0c	; 12
     e46:	0e 94 38 01 	call	0x270	; 0x270 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     e4a:	f3 01       	movw	r30, r6
     e4c:	71 86       	std	Z+9, r7	; 0x09
     e4e:	60 86       	std	Z+8, r6	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     e50:	84 e0       	ldi	r24, 0x04	; 4
     e52:	90 e0       	ldi	r25, 0x00	; 0
     e54:	81 1b       	sub	r24, r17
     e56:	91 09       	sbc	r25, r1
     e58:	95 87       	std	Z+13, r25	; 0x0d
     e5a:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     e5c:	73 8a       	std	Z+19, r7	; 0x13
     e5e:	62 8a       	std	Z+18, r6	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
     e60:	13 a2       	std	Z+35, r1	; 0x23
     e62:	14 a2       	std	Z+36, r1	; 0x24
     e64:	15 a2       	std	Z+37, r1	; 0x25
     e66:	16 a2       	std	Z+38, r1	; 0x26
		pxTCB->eNotifyState = eNotWaitingNotification;
     e68:	17 a2       	std	Z+39, r1	; 0x27
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     e6a:	a2 01       	movw	r20, r4
     e6c:	b4 01       	movw	r22, r8
     e6e:	c6 01       	movw	r24, r12
     e70:	0e 94 b4 01 	call	0x368	; 0x368 <pxPortInitialiseStack>
     e74:	f3 01       	movw	r30, r6
     e76:	91 83       	std	Z+1, r25	; 0x01
     e78:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     e7a:	e1 14       	cp	r14, r1
     e7c:	f1 04       	cpc	r15, r1
     e7e:	19 f0       	breq	.+6      	; 0xe86 <xTaskGenericCreate+0xf2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     e80:	f7 01       	movw	r30, r14
     e82:	71 82       	std	Z+1, r7	; 0x01
     e84:	60 82       	st	Z, r6
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     e86:	0f b6       	in	r0, 0x3f	; 63
     e88:	f8 94       	cli
     e8a:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     e8c:	80 91 7a 07 	lds	r24, 0x077A
     e90:	8f 5f       	subi	r24, 0xFF	; 255
     e92:	80 93 7a 07 	sts	0x077A, r24
			if( pxCurrentTCB == NULL )
     e96:	80 91 d3 07 	lds	r24, 0x07D3
     e9a:	90 91 d4 07 	lds	r25, 0x07D4
     e9e:	89 2b       	or	r24, r25
     ea0:	d1 f5       	brne	.+116    	; 0xf16 <xTaskGenericCreate+0x182>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     ea2:	70 92 d4 07 	sts	0x07D4, r7
     ea6:	60 92 d3 07 	sts	0x07D3, r6

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     eaa:	80 91 7a 07 	lds	r24, 0x077A
     eae:	81 30       	cpi	r24, 0x01	; 1
     eb0:	09 f0       	breq	.+2      	; 0xeb4 <xTaskGenericCreate+0x120>
     eb2:	40 c0       	rjmp	.+128    	; 0xf34 <xTaskGenericCreate+0x1a0>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     eb4:	8f ea       	ldi	r24, 0xAF	; 175
     eb6:	97 e0       	ldi	r25, 0x07	; 7
     eb8:	0e 94 2a 01 	call	0x254	; 0x254 <vListInitialise>
     ebc:	88 eb       	ldi	r24, 0xB8	; 184
     ebe:	97 e0       	ldi	r25, 0x07	; 7
     ec0:	0e 94 2a 01 	call	0x254	; 0x254 <vListInitialise>
     ec4:	81 ec       	ldi	r24, 0xC1	; 193
     ec6:	97 e0       	ldi	r25, 0x07	; 7
     ec8:	0e 94 2a 01 	call	0x254	; 0x254 <vListInitialise>
     ecc:	8a ec       	ldi	r24, 0xCA	; 202
     ece:	97 e0       	ldi	r25, 0x07	; 7
     ed0:	0e 94 2a 01 	call	0x254	; 0x254 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     ed4:	86 ea       	ldi	r24, 0xA6	; 166
     ed6:	97 e0       	ldi	r25, 0x07	; 7
     ed8:	0e 94 2a 01 	call	0x254	; 0x254 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     edc:	8d e9       	ldi	r24, 0x9D	; 157
     ede:	97 e0       	ldi	r25, 0x07	; 7
     ee0:	0e 94 2a 01 	call	0x254	; 0x254 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     ee4:	80 e9       	ldi	r24, 0x90	; 144
     ee6:	97 e0       	ldi	r25, 0x07	; 7
     ee8:	0e 94 2a 01 	call	0x254	; 0x254 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     eec:	87 e8       	ldi	r24, 0x87	; 135
     eee:	97 e0       	ldi	r25, 0x07	; 7
     ef0:	0e 94 2a 01 	call	0x254	; 0x254 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     ef4:	8d e7       	ldi	r24, 0x7D	; 125
     ef6:	97 e0       	ldi	r25, 0x07	; 7
     ef8:	0e 94 2a 01 	call	0x254	; 0x254 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     efc:	86 ea       	ldi	r24, 0xA6	; 166
     efe:	97 e0       	ldi	r25, 0x07	; 7
     f00:	90 93 9c 07 	sts	0x079C, r25
     f04:	80 93 9b 07 	sts	0x079B, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     f08:	8d e9       	ldi	r24, 0x9D	; 157
     f0a:	97 e0       	ldi	r25, 0x07	; 7
     f0c:	90 93 9a 07 	sts	0x079A, r25
     f10:	80 93 99 07 	sts	0x0799, r24
     f14:	0f c0       	rjmp	.+30     	; 0xf34 <xTaskGenericCreate+0x1a0>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     f16:	80 91 76 07 	lds	r24, 0x0776
     f1a:	81 11       	cpse	r24, r1
     f1c:	0b c0       	rjmp	.+22     	; 0xf34 <xTaskGenericCreate+0x1a0>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     f1e:	e0 91 d3 07 	lds	r30, 0x07D3
     f22:	f0 91 d4 07 	lds	r31, 0x07D4
     f26:	86 89       	ldd	r24, Z+22	; 0x16
     f28:	08 17       	cp	r16, r24
     f2a:	20 f0       	brcs	.+8      	; 0xf34 <xTaskGenericCreate+0x1a0>
					{
						pxCurrentTCB = pxNewTCB;
     f2c:	70 92 d4 07 	sts	0x07D4, r7
     f30:	60 92 d3 07 	sts	0x07D3, r6
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
     f34:	80 91 72 07 	lds	r24, 0x0772
     f38:	8f 5f       	subi	r24, 0xFF	; 255
     f3a:	80 93 72 07 	sts	0x0772, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     f3e:	f3 01       	movw	r30, r6
     f40:	86 89       	ldd	r24, Z+22	; 0x16
     f42:	90 91 77 07 	lds	r25, 0x0777
     f46:	98 17       	cp	r25, r24
     f48:	10 f4       	brcc	.+4      	; 0xf4e <xTaskGenericCreate+0x1ba>
     f4a:	80 93 77 07 	sts	0x0777, r24
     f4e:	90 e0       	ldi	r25, 0x00	; 0
     f50:	9c 01       	movw	r18, r24
     f52:	22 0f       	add	r18, r18
     f54:	33 1f       	adc	r19, r19
     f56:	22 0f       	add	r18, r18
     f58:	33 1f       	adc	r19, r19
     f5a:	22 0f       	add	r18, r18
     f5c:	33 1f       	adc	r19, r19
     f5e:	82 0f       	add	r24, r18
     f60:	93 1f       	adc	r25, r19
     f62:	be 01       	movw	r22, r28
     f64:	81 55       	subi	r24, 0x51	; 81
     f66:	98 4f       	sbci	r25, 0xF8	; 248
     f68:	0e 94 3c 01 	call	0x278	; 0x278 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     f6c:	0f 90       	pop	r0
     f6e:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
     f70:	80 91 76 07 	lds	r24, 0x0776
     f74:	88 23       	and	r24, r24
     f76:	59 f0       	breq	.+22     	; 0xf8e <xTaskGenericCreate+0x1fa>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     f78:	e0 91 d3 07 	lds	r30, 0x07D3
     f7c:	f0 91 d4 07 	lds	r31, 0x07D4
     f80:	86 89       	ldd	r24, Z+22	; 0x16
     f82:	80 17       	cp	r24, r16
     f84:	30 f4       	brcc	.+12     	; 0xf92 <xTaskGenericCreate+0x1fe>
			{
				taskYIELD_IF_USING_PREEMPTION();
     f86:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <vPortYield>
     f8a:	81 e0       	ldi	r24, 0x01	; 1
     f8c:	05 c0       	rjmp	.+10     	; 0xf98 <xTaskGenericCreate+0x204>
     f8e:	81 e0       	ldi	r24, 0x01	; 1
     f90:	03 c0       	rjmp	.+6      	; 0xf98 <xTaskGenericCreate+0x204>
     f92:	81 e0       	ldi	r24, 0x01	; 1
     f94:	01 c0       	rjmp	.+2      	; 0xf98 <xTaskGenericCreate+0x204>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     f96:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
     f98:	df 91       	pop	r29
     f9a:	cf 91       	pop	r28
     f9c:	1f 91       	pop	r17
     f9e:	0f 91       	pop	r16
     fa0:	ff 90       	pop	r15
     fa2:	ef 90       	pop	r14
     fa4:	df 90       	pop	r13
     fa6:	cf 90       	pop	r12
     fa8:	bf 90       	pop	r11
     faa:	af 90       	pop	r10
     fac:	9f 90       	pop	r9
     fae:	8f 90       	pop	r8
     fb0:	7f 90       	pop	r7
     fb2:	6f 90       	pop	r6
     fb4:	5f 90       	pop	r5
     fb6:	4f 90       	pop	r4
     fb8:	08 95       	ret

00000fba <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     fba:	af 92       	push	r10
     fbc:	bf 92       	push	r11
     fbe:	cf 92       	push	r12
     fc0:	df 92       	push	r13
     fc2:	ef 92       	push	r14
     fc4:	ff 92       	push	r15
     fc6:	0f 93       	push	r16
	/* Add the idle task at the lowest priority. */
	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
	{
		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
		be returned by the xTaskGetIdleTaskHandle() function. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
     fc8:	a1 2c       	mov	r10, r1
     fca:	b1 2c       	mov	r11, r1
     fcc:	c1 2c       	mov	r12, r1
     fce:	d1 2c       	mov	r13, r1
     fd0:	0f 2e       	mov	r0, r31
     fd2:	fb e7       	ldi	r31, 0x7B	; 123
     fd4:	ef 2e       	mov	r14, r31
     fd6:	f7 e0       	ldi	r31, 0x07	; 7
     fd8:	ff 2e       	mov	r15, r31
     fda:	f0 2d       	mov	r31, r0
     fdc:	00 e0       	ldi	r16, 0x00	; 0
     fde:	20 e0       	ldi	r18, 0x00	; 0
     fe0:	30 e0       	ldi	r19, 0x00	; 0
     fe2:	45 e5       	ldi	r20, 0x55	; 85
     fe4:	50 e0       	ldi	r21, 0x00	; 0
     fe6:	64 e8       	ldi	r22, 0x84	; 132
     fe8:	71 e0       	ldi	r23, 0x01	; 1
     fea:	81 e5       	ldi	r24, 0x51	; 81
     fec:	99 e0       	ldi	r25, 0x09	; 9
     fee:	0e 94 ca 06 	call	0xd94	; 0xd94 <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     ff2:	81 30       	cpi	r24, 0x01	; 1
     ff4:	49 f4       	brne	.+18     	; 0x1008 <vTaskStartScheduler+0x4e>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     ff6:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
     ff8:	80 93 76 07 	sts	0x0776, r24
		xTickCount = ( TickType_t ) 0U;
     ffc:	10 92 79 07 	sts	0x0779, r1
    1000:	10 92 78 07 	sts	0x0778, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1004:	0e 94 20 02 	call	0x440	; 0x440 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    1008:	0f 91       	pop	r16
    100a:	ff 90       	pop	r15
    100c:	ef 90       	pop	r14
    100e:	df 90       	pop	r13
    1010:	cf 90       	pop	r12
    1012:	bf 90       	pop	r11
    1014:	af 90       	pop	r10
    1016:	08 95       	ret

00001018 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    1018:	80 91 71 07 	lds	r24, 0x0771
    101c:	8f 5f       	subi	r24, 0xFF	; 255
    101e:	80 93 71 07 	sts	0x0771, r24
    1022:	08 95       	ret

00001024 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    1024:	cf 92       	push	r12
    1026:	df 92       	push	r13
    1028:	ef 92       	push	r14
    102a:	ff 92       	push	r15
    102c:	0f 93       	push	r16
    102e:	1f 93       	push	r17
    1030:	cf 93       	push	r28
    1032:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1034:	80 91 71 07 	lds	r24, 0x0771
    1038:	81 11       	cpse	r24, r1
    103a:	9b c0       	rjmp	.+310    	; 0x1172 <xTaskIncrementTick+0x14e>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    103c:	80 91 78 07 	lds	r24, 0x0778
    1040:	90 91 79 07 	lds	r25, 0x0779
    1044:	01 96       	adiw	r24, 0x01	; 1
    1046:	90 93 79 07 	sts	0x0779, r25
    104a:	80 93 78 07 	sts	0x0778, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    104e:	e0 90 78 07 	lds	r14, 0x0778
    1052:	f0 90 79 07 	lds	r15, 0x0779

			if( xConstTickCount == ( TickType_t ) 0U )
    1056:	e1 14       	cp	r14, r1
    1058:	f1 04       	cpc	r15, r1
    105a:	b9 f4       	brne	.+46     	; 0x108a <xTaskIncrementTick+0x66>
			{
				taskSWITCH_DELAYED_LISTS();
    105c:	80 91 9b 07 	lds	r24, 0x079B
    1060:	90 91 9c 07 	lds	r25, 0x079C
    1064:	20 91 99 07 	lds	r18, 0x0799
    1068:	30 91 9a 07 	lds	r19, 0x079A
    106c:	30 93 9c 07 	sts	0x079C, r19
    1070:	20 93 9b 07 	sts	0x079B, r18
    1074:	90 93 9a 07 	sts	0x079A, r25
    1078:	80 93 99 07 	sts	0x0799, r24
    107c:	80 91 73 07 	lds	r24, 0x0773
    1080:	8f 5f       	subi	r24, 0xFF	; 255
    1082:	80 93 73 07 	sts	0x0773, r24
    1086:	0e 94 74 06 	call	0xce8	; 0xce8 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    108a:	80 91 06 01 	lds	r24, 0x0106
    108e:	90 91 07 01 	lds	r25, 0x0107
    1092:	e8 16       	cp	r14, r24
    1094:	f9 06       	cpc	r15, r25
    1096:	10 f4       	brcc	.+4      	; 0x109c <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1098:	d1 2c       	mov	r13, r1
    109a:	53 c0       	rjmp	.+166    	; 0x1142 <xTaskIncrementTick+0x11e>
    109c:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
    109e:	cc 24       	eor	r12, r12
    10a0:	c3 94       	inc	r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    10a2:	e0 91 9b 07 	lds	r30, 0x079B
    10a6:	f0 91 9c 07 	lds	r31, 0x079C
    10aa:	90 81       	ld	r25, Z
    10ac:	91 11       	cpse	r25, r1
    10ae:	07 c0       	rjmp	.+14     	; 0x10be <xTaskIncrementTick+0x9a>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    10b0:	8f ef       	ldi	r24, 0xFF	; 255
    10b2:	9f ef       	ldi	r25, 0xFF	; 255
    10b4:	90 93 07 01 	sts	0x0107, r25
    10b8:	80 93 06 01 	sts	0x0106, r24
						break;
    10bc:	42 c0       	rjmp	.+132    	; 0x1142 <xTaskIncrementTick+0x11e>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    10be:	e0 91 9b 07 	lds	r30, 0x079B
    10c2:	f0 91 9c 07 	lds	r31, 0x079C
    10c6:	05 80       	ldd	r0, Z+5	; 0x05
    10c8:	f6 81       	ldd	r31, Z+6	; 0x06
    10ca:	e0 2d       	mov	r30, r0
    10cc:	c6 81       	ldd	r28, Z+6	; 0x06
    10ce:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    10d0:	2a 81       	ldd	r18, Y+2	; 0x02
    10d2:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
    10d4:	e2 16       	cp	r14, r18
    10d6:	f3 06       	cpc	r15, r19
    10d8:	28 f4       	brcc	.+10     	; 0x10e4 <xTaskIncrementTick+0xc0>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    10da:	30 93 07 01 	sts	0x0107, r19
    10de:	20 93 06 01 	sts	0x0106, r18
							break;
    10e2:	2f c0       	rjmp	.+94     	; 0x1142 <xTaskIncrementTick+0x11e>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    10e4:	8e 01       	movw	r16, r28
    10e6:	0e 5f       	subi	r16, 0xFE	; 254
    10e8:	1f 4f       	sbci	r17, 0xFF	; 255
    10ea:	c8 01       	movw	r24, r16
    10ec:	0e 94 8e 01 	call	0x31c	; 0x31c <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    10f0:	8c 89       	ldd	r24, Y+20	; 0x14
    10f2:	9d 89       	ldd	r25, Y+21	; 0x15
    10f4:	89 2b       	or	r24, r25
    10f6:	21 f0       	breq	.+8      	; 0x1100 <xTaskIncrementTick+0xdc>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    10f8:	ce 01       	movw	r24, r28
    10fa:	0c 96       	adiw	r24, 0x0c	; 12
    10fc:	0e 94 8e 01 	call	0x31c	; 0x31c <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    1100:	2e 89       	ldd	r18, Y+22	; 0x16
    1102:	80 91 77 07 	lds	r24, 0x0777
    1106:	82 17       	cp	r24, r18
    1108:	10 f4       	brcc	.+4      	; 0x110e <xTaskIncrementTick+0xea>
    110a:	20 93 77 07 	sts	0x0777, r18
    110e:	30 e0       	ldi	r19, 0x00	; 0
    1110:	c9 01       	movw	r24, r18
    1112:	88 0f       	add	r24, r24
    1114:	99 1f       	adc	r25, r25
    1116:	88 0f       	add	r24, r24
    1118:	99 1f       	adc	r25, r25
    111a:	88 0f       	add	r24, r24
    111c:	99 1f       	adc	r25, r25
    111e:	82 0f       	add	r24, r18
    1120:	93 1f       	adc	r25, r19
    1122:	b8 01       	movw	r22, r16
    1124:	81 55       	subi	r24, 0x51	; 81
    1126:	98 4f       	sbci	r25, 0xF8	; 248
    1128:	0e 94 3c 01 	call	0x278	; 0x278 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    112c:	e0 91 d3 07 	lds	r30, 0x07D3
    1130:	f0 91 d4 07 	lds	r31, 0x07D4
    1134:	9e 89       	ldd	r25, Y+22	; 0x16
    1136:	86 89       	ldd	r24, Z+22	; 0x16
    1138:	98 17       	cp	r25, r24
    113a:	08 f4       	brcc	.+2      	; 0x113e <xTaskIncrementTick+0x11a>
    113c:	b2 cf       	rjmp	.-156    	; 0x10a2 <xTaskIncrementTick+0x7e>
							{
								xSwitchRequired = pdTRUE;
    113e:	dc 2c       	mov	r13, r12
    1140:	b0 cf       	rjmp	.-160    	; 0x10a2 <xTaskIncrementTick+0x7e>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    1142:	e0 91 d3 07 	lds	r30, 0x07D3
    1146:	f0 91 d4 07 	lds	r31, 0x07D4
    114a:	86 89       	ldd	r24, Z+22	; 0x16
    114c:	90 e0       	ldi	r25, 0x00	; 0
    114e:	fc 01       	movw	r30, r24
    1150:	ee 0f       	add	r30, r30
    1152:	ff 1f       	adc	r31, r31
    1154:	ee 0f       	add	r30, r30
    1156:	ff 1f       	adc	r31, r31
    1158:	ee 0f       	add	r30, r30
    115a:	ff 1f       	adc	r31, r31
    115c:	8e 0f       	add	r24, r30
    115e:	9f 1f       	adc	r25, r31
    1160:	fc 01       	movw	r30, r24
    1162:	e1 55       	subi	r30, 0x51	; 81
    1164:	f8 4f       	sbci	r31, 0xF8	; 248
    1166:	80 81       	ld	r24, Z
    1168:	82 30       	cpi	r24, 0x02	; 2
    116a:	48 f0       	brcs	.+18     	; 0x117e <xTaskIncrementTick+0x15a>
			{
				xSwitchRequired = pdTRUE;
    116c:	dd 24       	eor	r13, r13
    116e:	d3 94       	inc	r13
    1170:	06 c0       	rjmp	.+12     	; 0x117e <xTaskIncrementTick+0x15a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    1172:	80 91 75 07 	lds	r24, 0x0775
    1176:	8f 5f       	subi	r24, 0xFF	; 255
    1178:	80 93 75 07 	sts	0x0775, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    117c:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    117e:	80 91 74 07 	lds	r24, 0x0774
    1182:	88 23       	and	r24, r24
    1184:	11 f0       	breq	.+4      	; 0x118a <xTaskIncrementTick+0x166>
		{
			xSwitchRequired = pdTRUE;
    1186:	dd 24       	eor	r13, r13
    1188:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    118a:	8d 2d       	mov	r24, r13
    118c:	df 91       	pop	r29
    118e:	cf 91       	pop	r28
    1190:	1f 91       	pop	r17
    1192:	0f 91       	pop	r16
    1194:	ff 90       	pop	r15
    1196:	ef 90       	pop	r14
    1198:	df 90       	pop	r13
    119a:	cf 90       	pop	r12
    119c:	08 95       	ret

0000119e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    119e:	df 92       	push	r13
    11a0:	ef 92       	push	r14
    11a2:	ff 92       	push	r15
    11a4:	0f 93       	push	r16
    11a6:	1f 93       	push	r17
    11a8:	cf 93       	push	r28
    11aa:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    11ac:	0f b6       	in	r0, 0x3f	; 63
    11ae:	f8 94       	cli
    11b0:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    11b2:	80 91 71 07 	lds	r24, 0x0771
    11b6:	81 50       	subi	r24, 0x01	; 1
    11b8:	80 93 71 07 	sts	0x0771, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    11bc:	80 91 71 07 	lds	r24, 0x0771
    11c0:	81 11       	cpse	r24, r1
    11c2:	62 c0       	rjmp	.+196    	; 0x1288 <xTaskResumeAll+0xea>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    11c4:	80 91 7a 07 	lds	r24, 0x077A
    11c8:	81 11       	cpse	r24, r1
    11ca:	33 c0       	rjmp	.+102    	; 0x1232 <xTaskResumeAll+0x94>
    11cc:	60 c0       	rjmp	.+192    	; 0x128e <xTaskResumeAll+0xf0>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    11ce:	d7 01       	movw	r26, r14
    11d0:	15 96       	adiw	r26, 0x05	; 5
    11d2:	ed 91       	ld	r30, X+
    11d4:	fc 91       	ld	r31, X
    11d6:	16 97       	sbiw	r26, 0x06	; 6
    11d8:	c6 81       	ldd	r28, Z+6	; 0x06
    11da:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    11dc:	ce 01       	movw	r24, r28
    11de:	0c 96       	adiw	r24, 0x0c	; 12
    11e0:	0e 94 8e 01 	call	0x31c	; 0x31c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    11e4:	8e 01       	movw	r16, r28
    11e6:	0e 5f       	subi	r16, 0xFE	; 254
    11e8:	1f 4f       	sbci	r17, 0xFF	; 255
    11ea:	c8 01       	movw	r24, r16
    11ec:	0e 94 8e 01 	call	0x31c	; 0x31c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    11f0:	2e 89       	ldd	r18, Y+22	; 0x16
    11f2:	80 91 77 07 	lds	r24, 0x0777
    11f6:	82 17       	cp	r24, r18
    11f8:	10 f4       	brcc	.+4      	; 0x11fe <xTaskResumeAll+0x60>
    11fa:	20 93 77 07 	sts	0x0777, r18
    11fe:	30 e0       	ldi	r19, 0x00	; 0
    1200:	c9 01       	movw	r24, r18
    1202:	88 0f       	add	r24, r24
    1204:	99 1f       	adc	r25, r25
    1206:	88 0f       	add	r24, r24
    1208:	99 1f       	adc	r25, r25
    120a:	88 0f       	add	r24, r24
    120c:	99 1f       	adc	r25, r25
    120e:	82 0f       	add	r24, r18
    1210:	93 1f       	adc	r25, r19
    1212:	b8 01       	movw	r22, r16
    1214:	81 55       	subi	r24, 0x51	; 81
    1216:	98 4f       	sbci	r25, 0xF8	; 248
    1218:	0e 94 3c 01 	call	0x278	; 0x278 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    121c:	e0 91 d3 07 	lds	r30, 0x07D3
    1220:	f0 91 d4 07 	lds	r31, 0x07D4
    1224:	9e 89       	ldd	r25, Y+22	; 0x16
    1226:	86 89       	ldd	r24, Z+22	; 0x16
    1228:	98 17       	cp	r25, r24
    122a:	58 f0       	brcs	.+22     	; 0x1242 <xTaskResumeAll+0xa4>
					{
						xYieldPending = pdTRUE;
    122c:	d0 92 74 07 	sts	0x0774, r13
    1230:	08 c0       	rjmp	.+16     	; 0x1242 <xTaskResumeAll+0xa4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1232:	0f 2e       	mov	r0, r31
    1234:	f0 e9       	ldi	r31, 0x90	; 144
    1236:	ef 2e       	mov	r14, r31
    1238:	f7 e0       	ldi	r31, 0x07	; 7
    123a:	ff 2e       	mov	r15, r31
    123c:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    123e:	dd 24       	eor	r13, r13
    1240:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1242:	f7 01       	movw	r30, r14
    1244:	80 81       	ld	r24, Z
    1246:	81 11       	cpse	r24, r1
    1248:	c2 cf       	rjmp	.-124    	; 0x11ce <xTaskResumeAll+0x30>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    124a:	80 91 75 07 	lds	r24, 0x0775
    124e:	88 23       	and	r24, r24
    1250:	99 f0       	breq	.+38     	; 0x1278 <xTaskResumeAll+0xda>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    1252:	80 91 75 07 	lds	r24, 0x0775
    1256:	88 23       	and	r24, r24
    1258:	79 f0       	breq	.+30     	; 0x1278 <xTaskResumeAll+0xda>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
    125a:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    125c:	0e 94 12 08 	call	0x1024	; 0x1024 <xTaskIncrementTick>
    1260:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
    1262:	c0 93 74 07 	sts	0x0774, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    1266:	80 91 75 07 	lds	r24, 0x0775
    126a:	81 50       	subi	r24, 0x01	; 1
    126c:	80 93 75 07 	sts	0x0775, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    1270:	80 91 75 07 	lds	r24, 0x0775
    1274:	81 11       	cpse	r24, r1
    1276:	f2 cf       	rjmp	.-28     	; 0x125c <xTaskResumeAll+0xbe>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    1278:	80 91 74 07 	lds	r24, 0x0774
    127c:	81 30       	cpi	r24, 0x01	; 1
    127e:	31 f4       	brne	.+12     	; 0x128c <xTaskResumeAll+0xee>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    1280:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    1284:	81 e0       	ldi	r24, 0x01	; 1
    1286:	03 c0       	rjmp	.+6      	; 0x128e <xTaskResumeAll+0xf0>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    1288:	80 e0       	ldi	r24, 0x00	; 0
    128a:	01 c0       	rjmp	.+2      	; 0x128e <xTaskResumeAll+0xf0>
    128c:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    128e:	0f 90       	pop	r0
    1290:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    1292:	df 91       	pop	r29
    1294:	cf 91       	pop	r28
    1296:	1f 91       	pop	r17
    1298:	0f 91       	pop	r16
    129a:	ff 90       	pop	r15
    129c:	ef 90       	pop	r14
    129e:	df 90       	pop	r13
    12a0:	08 95       	ret

000012a2 <prvIdleTask>:
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    12a2:	07 e8       	ldi	r16, 0x87	; 135
    12a4:	17 e0       	ldi	r17, 0x07	; 7

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    12a6:	0f 2e       	mov	r0, r31
    12a8:	ff ea       	ldi	r31, 0xAF	; 175
    12aa:	ef 2e       	mov	r14, r31
    12ac:	f7 e0       	ldi	r31, 0x07	; 7
    12ae:	ff 2e       	mov	r15, r31
    12b0:	f0 2d       	mov	r31, r0
    12b2:	29 c0       	rjmp	.+82     	; 0x1306 <prvIdleTask+0x64>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    12b4:	0e 94 0c 08 	call	0x1018	; 0x1018 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    12b8:	d8 01       	movw	r26, r16
    12ba:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
    12bc:	0e 94 cf 08 	call	0x119e	; 0x119e <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    12c0:	cc 23       	and	r28, r28
    12c2:	09 f1       	breq	.+66     	; 0x1306 <prvIdleTask+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    12c4:	0f b6       	in	r0, 0x3f	; 63
    12c6:	f8 94       	cli
    12c8:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    12ca:	d8 01       	movw	r26, r16
    12cc:	15 96       	adiw	r26, 0x05	; 5
    12ce:	ed 91       	ld	r30, X+
    12d0:	fc 91       	ld	r31, X
    12d2:	16 97       	sbiw	r26, 0x06	; 6
    12d4:	c6 81       	ldd	r28, Z+6	; 0x06
    12d6:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    12d8:	ce 01       	movw	r24, r28
    12da:	02 96       	adiw	r24, 0x02	; 2
    12dc:	0e 94 8e 01 	call	0x31c	; 0x31c <uxListRemove>
					--uxCurrentNumberOfTasks;
    12e0:	80 91 7a 07 	lds	r24, 0x077A
    12e4:	81 50       	subi	r24, 0x01	; 1
    12e6:	80 93 7a 07 	sts	0x077A, r24
					--uxTasksDeleted;
    12ea:	80 91 86 07 	lds	r24, 0x0786
    12ee:	81 50       	subi	r24, 0x01	; 1
    12f0:	80 93 86 07 	sts	0x0786, r24
				}
				taskEXIT_CRITICAL();
    12f4:	0f 90       	pop	r0
    12f6:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    12f8:	8f 89       	ldd	r24, Y+23	; 0x17
    12fa:	98 8d       	ldd	r25, Y+24	; 0x18
    12fc:	0e 94 ac 03 	call	0x758	; 0x758 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    1300:	ce 01       	movw	r24, r28
    1302:	0e 94 ac 03 	call	0x758	; 0x758 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    1306:	80 91 86 07 	lds	r24, 0x0786
    130a:	81 11       	cpse	r24, r1
    130c:	d3 cf       	rjmp	.-90     	; 0x12b4 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    130e:	f7 01       	movw	r30, r14
    1310:	80 81       	ld	r24, Z
    1312:	82 30       	cpi	r24, 0x02	; 2
    1314:	c0 f3       	brcs	.-16     	; 0x1306 <prvIdleTask+0x64>
			{
				taskYIELD();
    1316:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <vPortYield>
    131a:	f5 cf       	rjmp	.-22     	; 0x1306 <prvIdleTask+0x64>

0000131c <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    131c:	80 91 71 07 	lds	r24, 0x0771
    1320:	88 23       	and	r24, r24
    1322:	21 f0       	breq	.+8      	; 0x132c <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1324:	81 e0       	ldi	r24, 0x01	; 1
    1326:	80 93 74 07 	sts	0x0774, r24
    132a:	08 95       	ret
	//	USART_sendstr("uxSchedulerSuspended");
	}
	else
	{
		xYieldPending = pdFALSE;
    132c:	10 92 74 07 	sts	0x0774, r1
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
	//	USART_sendstr("HIGHEST_PRIORITY_TASK\n");
		taskSELECT_HIGHEST_PRIORITY_TASK();
    1330:	80 91 77 07 	lds	r24, 0x0777
    1334:	90 e0       	ldi	r25, 0x00	; 0
    1336:	fc 01       	movw	r30, r24
    1338:	ee 0f       	add	r30, r30
    133a:	ff 1f       	adc	r31, r31
    133c:	ee 0f       	add	r30, r30
    133e:	ff 1f       	adc	r31, r31
    1340:	ee 0f       	add	r30, r30
    1342:	ff 1f       	adc	r31, r31
    1344:	8e 0f       	add	r24, r30
    1346:	9f 1f       	adc	r25, r31
    1348:	fc 01       	movw	r30, r24
    134a:	e1 55       	subi	r30, 0x51	; 81
    134c:	f8 4f       	sbci	r31, 0xF8	; 248
    134e:	80 81       	ld	r24, Z
    1350:	81 11       	cpse	r24, r1
    1352:	17 c0       	rjmp	.+46     	; 0x1382 <vTaskSwitchContext+0x66>
    1354:	80 91 77 07 	lds	r24, 0x0777
    1358:	81 50       	subi	r24, 0x01	; 1
    135a:	80 93 77 07 	sts	0x0777, r24
    135e:	80 91 77 07 	lds	r24, 0x0777
    1362:	90 e0       	ldi	r25, 0x00	; 0
    1364:	fc 01       	movw	r30, r24
    1366:	ee 0f       	add	r30, r30
    1368:	ff 1f       	adc	r31, r31
    136a:	ee 0f       	add	r30, r30
    136c:	ff 1f       	adc	r31, r31
    136e:	ee 0f       	add	r30, r30
    1370:	ff 1f       	adc	r31, r31
    1372:	8e 0f       	add	r24, r30
    1374:	9f 1f       	adc	r25, r31
    1376:	fc 01       	movw	r30, r24
    1378:	e1 55       	subi	r30, 0x51	; 81
    137a:	f8 4f       	sbci	r31, 0xF8	; 248
    137c:	80 81       	ld	r24, Z
    137e:	88 23       	and	r24, r24
    1380:	49 f3       	breq	.-46     	; 0x1354 <vTaskSwitchContext+0x38>
    1382:	80 91 77 07 	lds	r24, 0x0777
    1386:	90 e0       	ldi	r25, 0x00	; 0
    1388:	9c 01       	movw	r18, r24
    138a:	22 0f       	add	r18, r18
    138c:	33 1f       	adc	r19, r19
    138e:	22 0f       	add	r18, r18
    1390:	33 1f       	adc	r19, r19
    1392:	22 0f       	add	r18, r18
    1394:	33 1f       	adc	r19, r19
    1396:	28 0f       	add	r18, r24
    1398:	39 1f       	adc	r19, r25
    139a:	d9 01       	movw	r26, r18
    139c:	a1 55       	subi	r26, 0x51	; 81
    139e:	b8 4f       	sbci	r27, 0xF8	; 248
    13a0:	11 96       	adiw	r26, 0x01	; 1
    13a2:	ed 91       	ld	r30, X+
    13a4:	fc 91       	ld	r31, X
    13a6:	12 97       	sbiw	r26, 0x02	; 2
    13a8:	02 80       	ldd	r0, Z+2	; 0x02
    13aa:	f3 81       	ldd	r31, Z+3	; 0x03
    13ac:	e0 2d       	mov	r30, r0
    13ae:	12 96       	adiw	r26, 0x02	; 2
    13b0:	fc 93       	st	X, r31
    13b2:	ee 93       	st	-X, r30
    13b4:	11 97       	sbiw	r26, 0x01	; 1
    13b6:	2e 54       	subi	r18, 0x4E	; 78
    13b8:	38 4f       	sbci	r19, 0xF8	; 248
    13ba:	e2 17       	cp	r30, r18
    13bc:	f3 07       	cpc	r31, r19
    13be:	29 f4       	brne	.+10     	; 0x13ca <vTaskSwitchContext+0xae>
    13c0:	22 81       	ldd	r18, Z+2	; 0x02
    13c2:	33 81       	ldd	r19, Z+3	; 0x03
    13c4:	fd 01       	movw	r30, r26
    13c6:	32 83       	std	Z+2, r19	; 0x02
    13c8:	21 83       	std	Z+1, r18	; 0x01
    13ca:	fc 01       	movw	r30, r24
    13cc:	ee 0f       	add	r30, r30
    13ce:	ff 1f       	adc	r31, r31
    13d0:	ee 0f       	add	r30, r30
    13d2:	ff 1f       	adc	r31, r31
    13d4:	ee 0f       	add	r30, r30
    13d6:	ff 1f       	adc	r31, r31
    13d8:	8e 0f       	add	r24, r30
    13da:	9f 1f       	adc	r25, r31
    13dc:	fc 01       	movw	r30, r24
    13de:	e1 55       	subi	r30, 0x51	; 81
    13e0:	f8 4f       	sbci	r31, 0xF8	; 248
    13e2:	01 80       	ldd	r0, Z+1	; 0x01
    13e4:	f2 81       	ldd	r31, Z+2	; 0x02
    13e6:	e0 2d       	mov	r30, r0
    13e8:	86 81       	ldd	r24, Z+6	; 0x06
    13ea:	97 81       	ldd	r25, Z+7	; 0x07
    13ec:	90 93 d4 07 	sts	0x07D4, r25
    13f0:	80 93 d3 07 	sts	0x07D3, r24
    13f4:	08 95       	ret

000013f6 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    13f6:	cf 93       	push	r28
    13f8:	df 93       	push	r29
    13fa:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    13fc:	20 91 d3 07 	lds	r18, 0x07D3
    1400:	30 91 d4 07 	lds	r19, 0x07D4
    1404:	b9 01       	movw	r22, r18
    1406:	64 5f       	subi	r22, 0xF4	; 244
    1408:	7f 4f       	sbci	r23, 0xFF	; 255
    140a:	0e 94 5d 01 	call	0x2ba	; 0x2ba <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    140e:	80 91 d3 07 	lds	r24, 0x07D3
    1412:	90 91 d4 07 	lds	r25, 0x07D4
    1416:	02 96       	adiw	r24, 0x02	; 2
    1418:	0e 94 8e 01 	call	0x31c	; 0x31c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    141c:	cf 3f       	cpi	r28, 0xFF	; 255
    141e:	8f ef       	ldi	r24, 0xFF	; 255
    1420:	d8 07       	cpc	r29, r24
    1422:	59 f4       	brne	.+22     	; 0x143a <vTaskPlaceOnEventList+0x44>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1424:	60 91 d3 07 	lds	r22, 0x07D3
    1428:	70 91 d4 07 	lds	r23, 0x07D4
    142c:	6e 5f       	subi	r22, 0xFE	; 254
    142e:	7f 4f       	sbci	r23, 0xFF	; 255
    1430:	8d e7       	ldi	r24, 0x7D	; 125
    1432:	97 e0       	ldi	r25, 0x07	; 7
    1434:	0e 94 3c 01 	call	0x278	; 0x278 <vListInsertEnd>
    1438:	08 c0       	rjmp	.+16     	; 0x144a <vTaskPlaceOnEventList+0x54>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    143a:	80 91 78 07 	lds	r24, 0x0778
    143e:	90 91 79 07 	lds	r25, 0x0779
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1442:	8c 0f       	add	r24, r28
    1444:	9d 1f       	adc	r25, r29
    1446:	0e 94 93 06 	call	0xd26	; 0xd26 <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    144a:	df 91       	pop	r29
    144c:	cf 91       	pop	r28
    144e:	08 95       	ret

00001450 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    1450:	0f 93       	push	r16
    1452:	1f 93       	push	r17
    1454:	cf 93       	push	r28
    1456:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1458:	dc 01       	movw	r26, r24
    145a:	15 96       	adiw	r26, 0x05	; 5
    145c:	ed 91       	ld	r30, X+
    145e:	fc 91       	ld	r31, X
    1460:	16 97       	sbiw	r26, 0x06	; 6
    1462:	c6 81       	ldd	r28, Z+6	; 0x06
    1464:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1466:	8e 01       	movw	r16, r28
    1468:	04 5f       	subi	r16, 0xF4	; 244
    146a:	1f 4f       	sbci	r17, 0xFF	; 255
    146c:	c8 01       	movw	r24, r16
    146e:	0e 94 8e 01 	call	0x31c	; 0x31c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1472:	80 91 71 07 	lds	r24, 0x0771
    1476:	81 11       	cpse	r24, r1
    1478:	1c c0       	rjmp	.+56     	; 0x14b2 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    147a:	0a 50       	subi	r16, 0x0A	; 10
    147c:	11 09       	sbc	r17, r1
    147e:	c8 01       	movw	r24, r16
    1480:	0e 94 8e 01 	call	0x31c	; 0x31c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    1484:	2e 89       	ldd	r18, Y+22	; 0x16
    1486:	80 91 77 07 	lds	r24, 0x0777
    148a:	82 17       	cp	r24, r18
    148c:	10 f4       	brcc	.+4      	; 0x1492 <xTaskRemoveFromEventList+0x42>
    148e:	20 93 77 07 	sts	0x0777, r18
    1492:	30 e0       	ldi	r19, 0x00	; 0
    1494:	c9 01       	movw	r24, r18
    1496:	88 0f       	add	r24, r24
    1498:	99 1f       	adc	r25, r25
    149a:	88 0f       	add	r24, r24
    149c:	99 1f       	adc	r25, r25
    149e:	88 0f       	add	r24, r24
    14a0:	99 1f       	adc	r25, r25
    14a2:	82 0f       	add	r24, r18
    14a4:	93 1f       	adc	r25, r19
    14a6:	b8 01       	movw	r22, r16
    14a8:	81 55       	subi	r24, 0x51	; 81
    14aa:	98 4f       	sbci	r25, 0xF8	; 248
    14ac:	0e 94 3c 01 	call	0x278	; 0x278 <vListInsertEnd>
    14b0:	05 c0       	rjmp	.+10     	; 0x14bc <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    14b2:	b8 01       	movw	r22, r16
    14b4:	80 e9       	ldi	r24, 0x90	; 144
    14b6:	97 e0       	ldi	r25, 0x07	; 7
    14b8:	0e 94 3c 01 	call	0x278	; 0x278 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    14bc:	e0 91 d3 07 	lds	r30, 0x07D3
    14c0:	f0 91 d4 07 	lds	r31, 0x07D4
    14c4:	9e 89       	ldd	r25, Y+22	; 0x16
    14c6:	86 89       	ldd	r24, Z+22	; 0x16
    14c8:	89 17       	cp	r24, r25
    14ca:	20 f4       	brcc	.+8      	; 0x14d4 <xTaskRemoveFromEventList+0x84>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    14cc:	81 e0       	ldi	r24, 0x01	; 1
    14ce:	80 93 74 07 	sts	0x0774, r24
    14d2:	01 c0       	rjmp	.+2      	; 0x14d6 <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		xReturn = pdFALSE;
    14d4:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    14d6:	df 91       	pop	r29
    14d8:	cf 91       	pop	r28
    14da:	1f 91       	pop	r17
    14dc:	0f 91       	pop	r16
    14de:	08 95       	ret

000014e0 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    14e0:	20 91 73 07 	lds	r18, 0x0773
    14e4:	fc 01       	movw	r30, r24
    14e6:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    14e8:	20 91 78 07 	lds	r18, 0x0778
    14ec:	30 91 79 07 	lds	r19, 0x0779
    14f0:	32 83       	std	Z+2, r19	; 0x02
    14f2:	21 83       	std	Z+1, r18	; 0x01
    14f4:	08 95       	ret

000014f6 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    14f6:	0f b6       	in	r0, 0x3f	; 63
    14f8:	f8 94       	cli
    14fa:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    14fc:	40 91 78 07 	lds	r20, 0x0778
    1500:	50 91 79 07 	lds	r21, 0x0779

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    1504:	db 01       	movw	r26, r22
    1506:	2d 91       	ld	r18, X+
    1508:	3c 91       	ld	r19, X
    150a:	2f 3f       	cpi	r18, 0xFF	; 255
    150c:	bf ef       	ldi	r27, 0xFF	; 255
    150e:	3b 07       	cpc	r19, r27
    1510:	19 f1       	breq	.+70     	; 0x1558 <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1512:	e0 91 73 07 	lds	r30, 0x0773
    1516:	dc 01       	movw	r26, r24
    1518:	fc 91       	ld	r31, X
    151a:	fe 17       	cp	r31, r30
    151c:	39 f0       	breq	.+14     	; 0x152c <xTaskCheckForTimeOut+0x36>
    151e:	11 96       	adiw	r26, 0x01	; 1
    1520:	ed 91       	ld	r30, X+
    1522:	fc 91       	ld	r31, X
    1524:	12 97       	sbiw	r26, 0x02	; 2
    1526:	4e 17       	cp	r20, r30
    1528:	5f 07       	cpc	r21, r31
    152a:	c0 f4       	brcc	.+48     	; 0x155c <xTaskCheckForTimeOut+0x66>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    152c:	dc 01       	movw	r26, r24
    152e:	11 96       	adiw	r26, 0x01	; 1
    1530:	ed 91       	ld	r30, X+
    1532:	fc 91       	ld	r31, X
    1534:	12 97       	sbiw	r26, 0x02	; 2
    1536:	da 01       	movw	r26, r20
    1538:	ae 1b       	sub	r26, r30
    153a:	bf 0b       	sbc	r27, r31
    153c:	a2 17       	cp	r26, r18
    153e:	b3 07       	cpc	r27, r19
    1540:	78 f4       	brcc	.+30     	; 0x1560 <xTaskCheckForTimeOut+0x6a>
    1542:	db 01       	movw	r26, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    1544:	e4 1b       	sub	r30, r20
    1546:	f5 0b       	sbc	r31, r21
    1548:	2e 0f       	add	r18, r30
    154a:	3f 1f       	adc	r19, r31
    154c:	2d 93       	st	X+, r18
    154e:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    1550:	0e 94 70 0a 	call	0x14e0	; 0x14e0 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1554:	80 e0       	ldi	r24, 0x00	; 0
    1556:	05 c0       	rjmp	.+10     	; 0x1562 <xTaskCheckForTimeOut+0x6c>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    1558:	80 e0       	ldi	r24, 0x00	; 0
    155a:	03 c0       	rjmp	.+6      	; 0x1562 <xTaskCheckForTimeOut+0x6c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    155c:	81 e0       	ldi	r24, 0x01	; 1
    155e:	01 c0       	rjmp	.+2      	; 0x1562 <xTaskCheckForTimeOut+0x6c>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1560:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1562:	0f 90       	pop	r0
    1564:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1566:	08 95       	ret

00001568 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1568:	81 e0       	ldi	r24, 0x01	; 1
    156a:	80 93 74 07 	sts	0x0774, r24
    156e:	08 95       	ret

00001570 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    1570:	0f 93       	push	r16
    1572:	1f 93       	push	r17
    1574:	cf 93       	push	r28
    1576:	df 93       	push	r29
    1578:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    157a:	89 2b       	or	r24, r25
    157c:	09 f4       	brne	.+2      	; 0x1580 <vTaskPriorityInherit+0x10>
    157e:	55 c0       	rjmp	.+170    	; 0x162a <vTaskPriorityInherit+0xba>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    1580:	26 89       	ldd	r18, Z+22	; 0x16
    1582:	a0 91 d3 07 	lds	r26, 0x07D3
    1586:	b0 91 d4 07 	lds	r27, 0x07D4
    158a:	56 96       	adiw	r26, 0x16	; 22
    158c:	8c 91       	ld	r24, X
    158e:	28 17       	cp	r18, r24
    1590:	08 f0       	brcs	.+2      	; 0x1594 <vTaskPriorityInherit+0x24>
    1592:	4b c0       	rjmp	.+150    	; 0x162a <vTaskPriorityInherit+0xba>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1594:	84 85       	ldd	r24, Z+12	; 0x0c
    1596:	95 85       	ldd	r25, Z+13	; 0x0d
    1598:	99 23       	and	r25, r25
    159a:	64 f0       	brlt	.+24     	; 0x15b4 <vTaskPriorityInherit+0x44>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    159c:	a0 91 d3 07 	lds	r26, 0x07D3
    15a0:	b0 91 d4 07 	lds	r27, 0x07D4
    15a4:	56 96       	adiw	r26, 0x16	; 22
    15a6:	3c 91       	ld	r19, X
    15a8:	84 e0       	ldi	r24, 0x04	; 4
    15aa:	90 e0       	ldi	r25, 0x00	; 0
    15ac:	83 1b       	sub	r24, r19
    15ae:	91 09       	sbc	r25, r1
    15b0:	95 87       	std	Z+13, r25	; 0x0d
    15b2:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    15b4:	30 e0       	ldi	r19, 0x00	; 0
    15b6:	c9 01       	movw	r24, r18
    15b8:	88 0f       	add	r24, r24
    15ba:	99 1f       	adc	r25, r25
    15bc:	88 0f       	add	r24, r24
    15be:	99 1f       	adc	r25, r25
    15c0:	88 0f       	add	r24, r24
    15c2:	99 1f       	adc	r25, r25
    15c4:	28 0f       	add	r18, r24
    15c6:	39 1f       	adc	r19, r25
    15c8:	21 55       	subi	r18, 0x51	; 81
    15ca:	38 4f       	sbci	r19, 0xF8	; 248
    15cc:	82 85       	ldd	r24, Z+10	; 0x0a
    15ce:	93 85       	ldd	r25, Z+11	; 0x0b
    15d0:	82 17       	cp	r24, r18
    15d2:	93 07       	cpc	r25, r19
    15d4:	19 f5       	brne	.+70     	; 0x161c <vTaskPriorityInherit+0xac>
    15d6:	8f 01       	movw	r16, r30
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    15d8:	ef 01       	movw	r28, r30
    15da:	22 96       	adiw	r28, 0x02	; 2
    15dc:	ce 01       	movw	r24, r28
    15de:	0e 94 8e 01 	call	0x31c	; 0x31c <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    15e2:	e0 91 d3 07 	lds	r30, 0x07D3
    15e6:	f0 91 d4 07 	lds	r31, 0x07D4
    15ea:	26 89       	ldd	r18, Z+22	; 0x16
    15ec:	f8 01       	movw	r30, r16
    15ee:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyList( pxTCB );
    15f0:	80 91 77 07 	lds	r24, 0x0777
    15f4:	82 17       	cp	r24, r18
    15f6:	10 f4       	brcc	.+4      	; 0x15fc <vTaskPriorityInherit+0x8c>
    15f8:	20 93 77 07 	sts	0x0777, r18
    15fc:	30 e0       	ldi	r19, 0x00	; 0
    15fe:	c9 01       	movw	r24, r18
    1600:	88 0f       	add	r24, r24
    1602:	99 1f       	adc	r25, r25
    1604:	88 0f       	add	r24, r24
    1606:	99 1f       	adc	r25, r25
    1608:	88 0f       	add	r24, r24
    160a:	99 1f       	adc	r25, r25
    160c:	82 0f       	add	r24, r18
    160e:	93 1f       	adc	r25, r19
    1610:	be 01       	movw	r22, r28
    1612:	81 55       	subi	r24, 0x51	; 81
    1614:	98 4f       	sbci	r25, 0xF8	; 248
    1616:	0e 94 3c 01 	call	0x278	; 0x278 <vListInsertEnd>
    161a:	07 c0       	rjmp	.+14     	; 0x162a <vTaskPriorityInherit+0xba>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    161c:	a0 91 d3 07 	lds	r26, 0x07D3
    1620:	b0 91 d4 07 	lds	r27, 0x07D4
    1624:	56 96       	adiw	r26, 0x16	; 22
    1626:	8c 91       	ld	r24, X
    1628:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    162a:	df 91       	pop	r29
    162c:	cf 91       	pop	r28
    162e:	1f 91       	pop	r17
    1630:	0f 91       	pop	r16
    1632:	08 95       	ret

00001634 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    1634:	0f 93       	push	r16
    1636:	1f 93       	push	r17
    1638:	cf 93       	push	r28
    163a:	df 93       	push	r29
    163c:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    163e:	89 2b       	or	r24, r25
    1640:	79 f1       	breq	.+94     	; 0x16a0 <xTaskPriorityDisinherit+0x6c>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    1642:	82 a1       	ldd	r24, Z+34	; 0x22
    1644:	81 50       	subi	r24, 0x01	; 1
    1646:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1648:	26 89       	ldd	r18, Z+22	; 0x16
    164a:	91 a1       	ldd	r25, Z+33	; 0x21
    164c:	29 17       	cp	r18, r25
    164e:	51 f1       	breq	.+84     	; 0x16a4 <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    1650:	81 11       	cpse	r24, r1
    1652:	2a c0       	rjmp	.+84     	; 0x16a8 <xTaskPriorityDisinherit+0x74>
    1654:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1656:	8f 01       	movw	r16, r30
    1658:	0e 5f       	subi	r16, 0xFE	; 254
    165a:	1f 4f       	sbci	r17, 0xFF	; 255
    165c:	c8 01       	movw	r24, r16
    165e:	0e 94 8e 01 	call	0x31c	; 0x31c <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    1662:	29 a1       	ldd	r18, Y+33	; 0x21
    1664:	2e 8b       	std	Y+22, r18	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1666:	44 e0       	ldi	r20, 0x04	; 4
    1668:	50 e0       	ldi	r21, 0x00	; 0
    166a:	42 1b       	sub	r20, r18
    166c:	51 09       	sbc	r21, r1
    166e:	5d 87       	std	Y+13, r21	; 0x0d
    1670:	4c 87       	std	Y+12, r20	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    1672:	80 91 77 07 	lds	r24, 0x0777
    1676:	82 17       	cp	r24, r18
    1678:	10 f4       	brcc	.+4      	; 0x167e <xTaskPriorityDisinherit+0x4a>
    167a:	20 93 77 07 	sts	0x0777, r18
    167e:	30 e0       	ldi	r19, 0x00	; 0
    1680:	c9 01       	movw	r24, r18
    1682:	88 0f       	add	r24, r24
    1684:	99 1f       	adc	r25, r25
    1686:	88 0f       	add	r24, r24
    1688:	99 1f       	adc	r25, r25
    168a:	88 0f       	add	r24, r24
    168c:	99 1f       	adc	r25, r25
    168e:	82 0f       	add	r24, r18
    1690:	93 1f       	adc	r25, r19
    1692:	b8 01       	movw	r22, r16
    1694:	81 55       	subi	r24, 0x51	; 81
    1696:	98 4f       	sbci	r25, 0xF8	; 248
    1698:	0e 94 3c 01 	call	0x278	; 0x278 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    169c:	81 e0       	ldi	r24, 0x01	; 1
    169e:	05 c0       	rjmp	.+10     	; 0x16aa <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    16a0:	80 e0       	ldi	r24, 0x00	; 0
    16a2:	03 c0       	rjmp	.+6      	; 0x16aa <xTaskPriorityDisinherit+0x76>
    16a4:	80 e0       	ldi	r24, 0x00	; 0
    16a6:	01 c0       	rjmp	.+2      	; 0x16aa <xTaskPriorityDisinherit+0x76>
    16a8:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    16aa:	df 91       	pop	r29
    16ac:	cf 91       	pop	r28
    16ae:	1f 91       	pop	r17
    16b0:	0f 91       	pop	r16
    16b2:	08 95       	ret

000016b4 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    16b4:	80 91 d3 07 	lds	r24, 0x07D3
    16b8:	90 91 d4 07 	lds	r25, 0x07D4
    16bc:	89 2b       	or	r24, r25
    16be:	39 f0       	breq	.+14     	; 0x16ce <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    16c0:	e0 91 d3 07 	lds	r30, 0x07D3
    16c4:	f0 91 d4 07 	lds	r31, 0x07D4
    16c8:	82 a1       	ldd	r24, Z+34	; 0x22
    16ca:	8f 5f       	subi	r24, 0xFF	; 255
    16cc:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    16ce:	80 91 d3 07 	lds	r24, 0x07D3
    16d2:	90 91 d4 07 	lds	r25, 0x07D4
	}
    16d6:	08 95       	ret

000016d8 <USART_init>:



void USART_init(void){
	
	UBRR0H = (uint8_t)(BAUD_PRESCALLER>>8);
    16d8:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = (uint8_t)(BAUD_PRESCALLER);
    16dc:	87 e6       	ldi	r24, 0x67	; 103
    16de:	80 93 c4 00 	sts	0x00C4, r24
	UCSR0B = (1<<RXEN0)|(1<<TXEN0)|(1<<UCSZ02);
    16e2:	8c e1       	ldi	r24, 0x1C	; 28
    16e4:	80 93 c1 00 	sts	0x00C1, r24
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));
    16e8:	86 e0       	ldi	r24, 0x06	; 6
    16ea:	80 93 c2 00 	sts	0x00C2, r24
    16ee:	08 95       	ret

000016f0 <USART_send>:
	}
}

void USART_send( unsigned char data){
	
	while(!(UCSR0A & (1<<UDRE0)));
    16f0:	e0 ec       	ldi	r30, 0xC0	; 192
    16f2:	f0 e0       	ldi	r31, 0x00	; 0
    16f4:	90 81       	ld	r25, Z
    16f6:	95 ff       	sbrs	r25, 5
    16f8:	fd cf       	rjmp	.-6      	; 0x16f4 <USART_send+0x4>
	UDR0 = data;
    16fa:	80 93 c6 00 	sts	0x00C6, r24
    16fe:	08 95       	ret

00001700 <USART_sendstr>:
	UCSR0B = (1<<RXEN0)|(1<<TXEN0)|(1<<UCSZ02);
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));
}


void USART_sendstr( unsigned char* str){
    1700:	cf 93       	push	r28
    1702:	df 93       	push	r29
    1704:	ec 01       	movw	r28, r24
	int i =0;
	
	while (str[i] != 0x00)
    1706:	88 81       	ld	r24, Y
    1708:	88 23       	and	r24, r24
    170a:	31 f0       	breq	.+12     	; 0x1718 <USART_sendstr+0x18>
    170c:	21 96       	adiw	r28, 0x01	; 1
	{
		USART_send(str[i]);
    170e:	0e 94 78 0b 	call	0x16f0	; 0x16f0 <USART_send>


void USART_sendstr( unsigned char* str){
	int i =0;
	
	while (str[i] != 0x00)
    1712:	89 91       	ld	r24, Y+
    1714:	81 11       	cpse	r24, r1
    1716:	fb cf       	rjmp	.-10     	; 0x170e <USART_sendstr+0xe>
	{
		USART_send(str[i]);
		i++;
	}
}
    1718:	df 91       	pop	r29
    171a:	cf 91       	pop	r28
    171c:	08 95       	ret

0000171e <__divmodhi4>:
    171e:	97 fb       	bst	r25, 7
    1720:	07 2e       	mov	r0, r23
    1722:	16 f4       	brtc	.+4      	; 0x1728 <__divmodhi4+0xa>
    1724:	00 94       	com	r0
    1726:	07 d0       	rcall	.+14     	; 0x1736 <__divmodhi4_neg1>
    1728:	77 fd       	sbrc	r23, 7
    172a:	09 d0       	rcall	.+18     	; 0x173e <__divmodhi4_neg2>
    172c:	0e 94 a3 0b 	call	0x1746	; 0x1746 <__udivmodhi4>
    1730:	07 fc       	sbrc	r0, 7
    1732:	05 d0       	rcall	.+10     	; 0x173e <__divmodhi4_neg2>
    1734:	3e f4       	brtc	.+14     	; 0x1744 <__divmodhi4_exit>

00001736 <__divmodhi4_neg1>:
    1736:	90 95       	com	r25
    1738:	81 95       	neg	r24
    173a:	9f 4f       	sbci	r25, 0xFF	; 255
    173c:	08 95       	ret

0000173e <__divmodhi4_neg2>:
    173e:	70 95       	com	r23
    1740:	61 95       	neg	r22
    1742:	7f 4f       	sbci	r23, 0xFF	; 255

00001744 <__divmodhi4_exit>:
    1744:	08 95       	ret

00001746 <__udivmodhi4>:
    1746:	aa 1b       	sub	r26, r26
    1748:	bb 1b       	sub	r27, r27
    174a:	51 e1       	ldi	r21, 0x11	; 17
    174c:	07 c0       	rjmp	.+14     	; 0x175c <__udivmodhi4_ep>

0000174e <__udivmodhi4_loop>:
    174e:	aa 1f       	adc	r26, r26
    1750:	bb 1f       	adc	r27, r27
    1752:	a6 17       	cp	r26, r22
    1754:	b7 07       	cpc	r27, r23
    1756:	10 f0       	brcs	.+4      	; 0x175c <__udivmodhi4_ep>
    1758:	a6 1b       	sub	r26, r22
    175a:	b7 0b       	sbc	r27, r23

0000175c <__udivmodhi4_ep>:
    175c:	88 1f       	adc	r24, r24
    175e:	99 1f       	adc	r25, r25
    1760:	5a 95       	dec	r21
    1762:	a9 f7       	brne	.-22     	; 0x174e <__udivmodhi4_loop>
    1764:	80 95       	com	r24
    1766:	90 95       	com	r25
    1768:	bc 01       	movw	r22, r24
    176a:	cd 01       	movw	r24, r26
    176c:	08 95       	ret

0000176e <do_rand>:
    176e:	8f 92       	push	r8
    1770:	9f 92       	push	r9
    1772:	af 92       	push	r10
    1774:	bf 92       	push	r11
    1776:	cf 92       	push	r12
    1778:	df 92       	push	r13
    177a:	ef 92       	push	r14
    177c:	ff 92       	push	r15
    177e:	cf 93       	push	r28
    1780:	df 93       	push	r29
    1782:	ec 01       	movw	r28, r24
    1784:	68 81       	ld	r22, Y
    1786:	79 81       	ldd	r23, Y+1	; 0x01
    1788:	8a 81       	ldd	r24, Y+2	; 0x02
    178a:	9b 81       	ldd	r25, Y+3	; 0x03
    178c:	61 15       	cp	r22, r1
    178e:	71 05       	cpc	r23, r1
    1790:	81 05       	cpc	r24, r1
    1792:	91 05       	cpc	r25, r1
    1794:	21 f4       	brne	.+8      	; 0x179e <do_rand+0x30>
    1796:	64 e2       	ldi	r22, 0x24	; 36
    1798:	79 ed       	ldi	r23, 0xD9	; 217
    179a:	8b e5       	ldi	r24, 0x5B	; 91
    179c:	97 e0       	ldi	r25, 0x07	; 7
    179e:	2d e1       	ldi	r18, 0x1D	; 29
    17a0:	33 ef       	ldi	r19, 0xF3	; 243
    17a2:	41 e0       	ldi	r20, 0x01	; 1
    17a4:	50 e0       	ldi	r21, 0x00	; 0
    17a6:	0e 94 b0 0e 	call	0x1d60	; 0x1d60 <__divmodsi4>
    17aa:	49 01       	movw	r8, r18
    17ac:	5a 01       	movw	r10, r20
    17ae:	9b 01       	movw	r18, r22
    17b0:	ac 01       	movw	r20, r24
    17b2:	a7 ea       	ldi	r26, 0xA7	; 167
    17b4:	b1 e4       	ldi	r27, 0x41	; 65
    17b6:	0e 94 cf 0e 	call	0x1d9e	; 0x1d9e <__muluhisi3>
    17ba:	6b 01       	movw	r12, r22
    17bc:	7c 01       	movw	r14, r24
    17be:	ac ee       	ldi	r26, 0xEC	; 236
    17c0:	b4 ef       	ldi	r27, 0xF4	; 244
    17c2:	a5 01       	movw	r20, r10
    17c4:	94 01       	movw	r18, r8
    17c6:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <__mulohisi3>
    17ca:	dc 01       	movw	r26, r24
    17cc:	cb 01       	movw	r24, r22
    17ce:	8c 0d       	add	r24, r12
    17d0:	9d 1d       	adc	r25, r13
    17d2:	ae 1d       	adc	r26, r14
    17d4:	bf 1d       	adc	r27, r15
    17d6:	b7 ff       	sbrs	r27, 7
    17d8:	03 c0       	rjmp	.+6      	; 0x17e0 <do_rand+0x72>
    17da:	01 97       	sbiw	r24, 0x01	; 1
    17dc:	a1 09       	sbc	r26, r1
    17de:	b0 48       	sbci	r27, 0x80	; 128
    17e0:	88 83       	st	Y, r24
    17e2:	99 83       	std	Y+1, r25	; 0x01
    17e4:	aa 83       	std	Y+2, r26	; 0x02
    17e6:	bb 83       	std	Y+3, r27	; 0x03
    17e8:	9f 77       	andi	r25, 0x7F	; 127
    17ea:	df 91       	pop	r29
    17ec:	cf 91       	pop	r28
    17ee:	ff 90       	pop	r15
    17f0:	ef 90       	pop	r14
    17f2:	df 90       	pop	r13
    17f4:	cf 90       	pop	r12
    17f6:	bf 90       	pop	r11
    17f8:	af 90       	pop	r10
    17fa:	9f 90       	pop	r9
    17fc:	8f 90       	pop	r8
    17fe:	08 95       	ret

00001800 <rand_r>:
    1800:	0e 94 b7 0b 	call	0x176e	; 0x176e <do_rand>
    1804:	08 95       	ret

00001806 <rand>:
    1806:	80 e0       	ldi	r24, 0x00	; 0
    1808:	91 e0       	ldi	r25, 0x01	; 1
    180a:	0e 94 b7 0b 	call	0x176e	; 0x176e <do_rand>
    180e:	08 95       	ret

00001810 <srand>:
    1810:	a0 e0       	ldi	r26, 0x00	; 0
    1812:	b0 e0       	ldi	r27, 0x00	; 0
    1814:	80 93 00 01 	sts	0x0100, r24
    1818:	90 93 01 01 	sts	0x0101, r25
    181c:	a0 93 02 01 	sts	0x0102, r26
    1820:	b0 93 03 01 	sts	0x0103, r27
    1824:	08 95       	ret

00001826 <memcpy>:
    1826:	fb 01       	movw	r30, r22
    1828:	dc 01       	movw	r26, r24
    182a:	02 c0       	rjmp	.+4      	; 0x1830 <memcpy+0xa>
    182c:	01 90       	ld	r0, Z+
    182e:	0d 92       	st	X+, r0
    1830:	41 50       	subi	r20, 0x01	; 1
    1832:	50 40       	sbci	r21, 0x00	; 0
    1834:	d8 f7       	brcc	.-10     	; 0x182c <memcpy+0x6>
    1836:	08 95       	ret

00001838 <printf>:
    1838:	a0 e0       	ldi	r26, 0x00	; 0
    183a:	b0 e0       	ldi	r27, 0x00	; 0
    183c:	e2 e2       	ldi	r30, 0x22	; 34
    183e:	fc e0       	ldi	r31, 0x0C	; 12
    1840:	0c 94 f2 0e 	jmp	0x1de4	; 0x1de4 <__prologue_saves__+0x20>
    1844:	ae 01       	movw	r20, r28
    1846:	4b 5f       	subi	r20, 0xFB	; 251
    1848:	5f 4f       	sbci	r21, 0xFF	; 255
    184a:	fa 01       	movw	r30, r20
    184c:	61 91       	ld	r22, Z+
    184e:	71 91       	ld	r23, Z+
    1850:	af 01       	movw	r20, r30
    1852:	80 91 f1 07 	lds	r24, 0x07F1
    1856:	90 91 f2 07 	lds	r25, 0x07F2
    185a:	0e 94 32 0c 	call	0x1864	; 0x1864 <vfprintf>
    185e:	e2 e0       	ldi	r30, 0x02	; 2
    1860:	0c 94 0e 0f 	jmp	0x1e1c	; 0x1e1c <__epilogue_restores__+0x20>

00001864 <vfprintf>:
    1864:	ac e0       	ldi	r26, 0x0C	; 12
    1866:	b0 e0       	ldi	r27, 0x00	; 0
    1868:	e8 e3       	ldi	r30, 0x38	; 56
    186a:	fc e0       	ldi	r31, 0x0C	; 12
    186c:	0c 94 e2 0e 	jmp	0x1dc4	; 0x1dc4 <__prologue_saves__>
    1870:	7c 01       	movw	r14, r24
    1872:	6b 01       	movw	r12, r22
    1874:	8a 01       	movw	r16, r20
    1876:	fc 01       	movw	r30, r24
    1878:	17 82       	std	Z+7, r1	; 0x07
    187a:	16 82       	std	Z+6, r1	; 0x06
    187c:	83 81       	ldd	r24, Z+3	; 0x03
    187e:	81 ff       	sbrs	r24, 1
    1880:	bd c1       	rjmp	.+890    	; 0x1bfc <vfprintf+0x398>
    1882:	ce 01       	movw	r24, r28
    1884:	01 96       	adiw	r24, 0x01	; 1
    1886:	4c 01       	movw	r8, r24
    1888:	f7 01       	movw	r30, r14
    188a:	93 81       	ldd	r25, Z+3	; 0x03
    188c:	f6 01       	movw	r30, r12
    188e:	93 fd       	sbrc	r25, 3
    1890:	85 91       	lpm	r24, Z+
    1892:	93 ff       	sbrs	r25, 3
    1894:	81 91       	ld	r24, Z+
    1896:	6f 01       	movw	r12, r30
    1898:	88 23       	and	r24, r24
    189a:	09 f4       	brne	.+2      	; 0x189e <vfprintf+0x3a>
    189c:	ab c1       	rjmp	.+854    	; 0x1bf4 <vfprintf+0x390>
    189e:	85 32       	cpi	r24, 0x25	; 37
    18a0:	39 f4       	brne	.+14     	; 0x18b0 <vfprintf+0x4c>
    18a2:	93 fd       	sbrc	r25, 3
    18a4:	85 91       	lpm	r24, Z+
    18a6:	93 ff       	sbrs	r25, 3
    18a8:	81 91       	ld	r24, Z+
    18aa:	6f 01       	movw	r12, r30
    18ac:	85 32       	cpi	r24, 0x25	; 37
    18ae:	29 f4       	brne	.+10     	; 0x18ba <vfprintf+0x56>
    18b0:	b7 01       	movw	r22, r14
    18b2:	90 e0       	ldi	r25, 0x00	; 0
    18b4:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <fputc>
    18b8:	e7 cf       	rjmp	.-50     	; 0x1888 <vfprintf+0x24>
    18ba:	51 2c       	mov	r5, r1
    18bc:	31 2c       	mov	r3, r1
    18be:	20 e0       	ldi	r18, 0x00	; 0
    18c0:	20 32       	cpi	r18, 0x20	; 32
    18c2:	a0 f4       	brcc	.+40     	; 0x18ec <vfprintf+0x88>
    18c4:	8b 32       	cpi	r24, 0x2B	; 43
    18c6:	69 f0       	breq	.+26     	; 0x18e2 <vfprintf+0x7e>
    18c8:	30 f4       	brcc	.+12     	; 0x18d6 <vfprintf+0x72>
    18ca:	80 32       	cpi	r24, 0x20	; 32
    18cc:	59 f0       	breq	.+22     	; 0x18e4 <vfprintf+0x80>
    18ce:	83 32       	cpi	r24, 0x23	; 35
    18d0:	69 f4       	brne	.+26     	; 0x18ec <vfprintf+0x88>
    18d2:	20 61       	ori	r18, 0x10	; 16
    18d4:	2c c0       	rjmp	.+88     	; 0x192e <vfprintf+0xca>
    18d6:	8d 32       	cpi	r24, 0x2D	; 45
    18d8:	39 f0       	breq	.+14     	; 0x18e8 <vfprintf+0x84>
    18da:	80 33       	cpi	r24, 0x30	; 48
    18dc:	39 f4       	brne	.+14     	; 0x18ec <vfprintf+0x88>
    18de:	21 60       	ori	r18, 0x01	; 1
    18e0:	26 c0       	rjmp	.+76     	; 0x192e <vfprintf+0xca>
    18e2:	22 60       	ori	r18, 0x02	; 2
    18e4:	24 60       	ori	r18, 0x04	; 4
    18e6:	23 c0       	rjmp	.+70     	; 0x192e <vfprintf+0xca>
    18e8:	28 60       	ori	r18, 0x08	; 8
    18ea:	21 c0       	rjmp	.+66     	; 0x192e <vfprintf+0xca>
    18ec:	27 fd       	sbrc	r18, 7
    18ee:	27 c0       	rjmp	.+78     	; 0x193e <vfprintf+0xda>
    18f0:	30 ed       	ldi	r19, 0xD0	; 208
    18f2:	38 0f       	add	r19, r24
    18f4:	3a 30       	cpi	r19, 0x0A	; 10
    18f6:	78 f4       	brcc	.+30     	; 0x1916 <vfprintf+0xb2>
    18f8:	26 ff       	sbrs	r18, 6
    18fa:	06 c0       	rjmp	.+12     	; 0x1908 <vfprintf+0xa4>
    18fc:	fa e0       	ldi	r31, 0x0A	; 10
    18fe:	5f 9e       	mul	r5, r31
    1900:	30 0d       	add	r19, r0
    1902:	11 24       	eor	r1, r1
    1904:	53 2e       	mov	r5, r19
    1906:	13 c0       	rjmp	.+38     	; 0x192e <vfprintf+0xca>
    1908:	8a e0       	ldi	r24, 0x0A	; 10
    190a:	38 9e       	mul	r3, r24
    190c:	30 0d       	add	r19, r0
    190e:	11 24       	eor	r1, r1
    1910:	33 2e       	mov	r3, r19
    1912:	20 62       	ori	r18, 0x20	; 32
    1914:	0c c0       	rjmp	.+24     	; 0x192e <vfprintf+0xca>
    1916:	8e 32       	cpi	r24, 0x2E	; 46
    1918:	21 f4       	brne	.+8      	; 0x1922 <vfprintf+0xbe>
    191a:	26 fd       	sbrc	r18, 6
    191c:	6b c1       	rjmp	.+726    	; 0x1bf4 <vfprintf+0x390>
    191e:	20 64       	ori	r18, 0x40	; 64
    1920:	06 c0       	rjmp	.+12     	; 0x192e <vfprintf+0xca>
    1922:	8c 36       	cpi	r24, 0x6C	; 108
    1924:	11 f4       	brne	.+4      	; 0x192a <vfprintf+0xc6>
    1926:	20 68       	ori	r18, 0x80	; 128
    1928:	02 c0       	rjmp	.+4      	; 0x192e <vfprintf+0xca>
    192a:	88 36       	cpi	r24, 0x68	; 104
    192c:	41 f4       	brne	.+16     	; 0x193e <vfprintf+0xda>
    192e:	f6 01       	movw	r30, r12
    1930:	93 fd       	sbrc	r25, 3
    1932:	85 91       	lpm	r24, Z+
    1934:	93 ff       	sbrs	r25, 3
    1936:	81 91       	ld	r24, Z+
    1938:	6f 01       	movw	r12, r30
    193a:	81 11       	cpse	r24, r1
    193c:	c1 cf       	rjmp	.-126    	; 0x18c0 <vfprintf+0x5c>
    193e:	98 2f       	mov	r25, r24
    1940:	9f 7d       	andi	r25, 0xDF	; 223
    1942:	95 54       	subi	r25, 0x45	; 69
    1944:	93 30       	cpi	r25, 0x03	; 3
    1946:	28 f4       	brcc	.+10     	; 0x1952 <vfprintf+0xee>
    1948:	0c 5f       	subi	r16, 0xFC	; 252
    194a:	1f 4f       	sbci	r17, 0xFF	; 255
    194c:	ff e3       	ldi	r31, 0x3F	; 63
    194e:	f9 83       	std	Y+1, r31	; 0x01
    1950:	0d c0       	rjmp	.+26     	; 0x196c <vfprintf+0x108>
    1952:	83 36       	cpi	r24, 0x63	; 99
    1954:	31 f0       	breq	.+12     	; 0x1962 <vfprintf+0xfe>
    1956:	83 37       	cpi	r24, 0x73	; 115
    1958:	71 f0       	breq	.+28     	; 0x1976 <vfprintf+0x112>
    195a:	83 35       	cpi	r24, 0x53	; 83
    195c:	09 f0       	breq	.+2      	; 0x1960 <vfprintf+0xfc>
    195e:	5b c0       	rjmp	.+182    	; 0x1a16 <vfprintf+0x1b2>
    1960:	22 c0       	rjmp	.+68     	; 0x19a6 <vfprintf+0x142>
    1962:	f8 01       	movw	r30, r16
    1964:	80 81       	ld	r24, Z
    1966:	89 83       	std	Y+1, r24	; 0x01
    1968:	0e 5f       	subi	r16, 0xFE	; 254
    196a:	1f 4f       	sbci	r17, 0xFF	; 255
    196c:	44 24       	eor	r4, r4
    196e:	43 94       	inc	r4
    1970:	51 2c       	mov	r5, r1
    1972:	54 01       	movw	r10, r8
    1974:	15 c0       	rjmp	.+42     	; 0x19a0 <vfprintf+0x13c>
    1976:	38 01       	movw	r6, r16
    1978:	f2 e0       	ldi	r31, 0x02	; 2
    197a:	6f 0e       	add	r6, r31
    197c:	71 1c       	adc	r7, r1
    197e:	f8 01       	movw	r30, r16
    1980:	a0 80       	ld	r10, Z
    1982:	b1 80       	ldd	r11, Z+1	; 0x01
    1984:	26 ff       	sbrs	r18, 6
    1986:	03 c0       	rjmp	.+6      	; 0x198e <vfprintf+0x12a>
    1988:	65 2d       	mov	r22, r5
    198a:	70 e0       	ldi	r23, 0x00	; 0
    198c:	02 c0       	rjmp	.+4      	; 0x1992 <vfprintf+0x12e>
    198e:	6f ef       	ldi	r22, 0xFF	; 255
    1990:	7f ef       	ldi	r23, 0xFF	; 255
    1992:	c5 01       	movw	r24, r10
    1994:	2c 87       	std	Y+12, r18	; 0x0c
    1996:	0e 94 0f 0e 	call	0x1c1e	; 0x1c1e <strnlen>
    199a:	2c 01       	movw	r4, r24
    199c:	83 01       	movw	r16, r6
    199e:	2c 85       	ldd	r18, Y+12	; 0x0c
    19a0:	2f 77       	andi	r18, 0x7F	; 127
    19a2:	22 2e       	mov	r2, r18
    19a4:	17 c0       	rjmp	.+46     	; 0x19d4 <vfprintf+0x170>
    19a6:	38 01       	movw	r6, r16
    19a8:	f2 e0       	ldi	r31, 0x02	; 2
    19aa:	6f 0e       	add	r6, r31
    19ac:	71 1c       	adc	r7, r1
    19ae:	f8 01       	movw	r30, r16
    19b0:	a0 80       	ld	r10, Z
    19b2:	b1 80       	ldd	r11, Z+1	; 0x01
    19b4:	26 ff       	sbrs	r18, 6
    19b6:	03 c0       	rjmp	.+6      	; 0x19be <vfprintf+0x15a>
    19b8:	65 2d       	mov	r22, r5
    19ba:	70 e0       	ldi	r23, 0x00	; 0
    19bc:	02 c0       	rjmp	.+4      	; 0x19c2 <vfprintf+0x15e>
    19be:	6f ef       	ldi	r22, 0xFF	; 255
    19c0:	7f ef       	ldi	r23, 0xFF	; 255
    19c2:	c5 01       	movw	r24, r10
    19c4:	2c 87       	std	Y+12, r18	; 0x0c
    19c6:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <strnlen_P>
    19ca:	2c 01       	movw	r4, r24
    19cc:	2c 85       	ldd	r18, Y+12	; 0x0c
    19ce:	20 68       	ori	r18, 0x80	; 128
    19d0:	22 2e       	mov	r2, r18
    19d2:	83 01       	movw	r16, r6
    19d4:	23 fc       	sbrc	r2, 3
    19d6:	1b c0       	rjmp	.+54     	; 0x1a0e <vfprintf+0x1aa>
    19d8:	83 2d       	mov	r24, r3
    19da:	90 e0       	ldi	r25, 0x00	; 0
    19dc:	48 16       	cp	r4, r24
    19de:	59 06       	cpc	r5, r25
    19e0:	b0 f4       	brcc	.+44     	; 0x1a0e <vfprintf+0x1aa>
    19e2:	b7 01       	movw	r22, r14
    19e4:	80 e2       	ldi	r24, 0x20	; 32
    19e6:	90 e0       	ldi	r25, 0x00	; 0
    19e8:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <fputc>
    19ec:	3a 94       	dec	r3
    19ee:	f4 cf       	rjmp	.-24     	; 0x19d8 <vfprintf+0x174>
    19f0:	f5 01       	movw	r30, r10
    19f2:	27 fc       	sbrc	r2, 7
    19f4:	85 91       	lpm	r24, Z+
    19f6:	27 fe       	sbrs	r2, 7
    19f8:	81 91       	ld	r24, Z+
    19fa:	5f 01       	movw	r10, r30
    19fc:	b7 01       	movw	r22, r14
    19fe:	90 e0       	ldi	r25, 0x00	; 0
    1a00:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <fputc>
    1a04:	31 10       	cpse	r3, r1
    1a06:	3a 94       	dec	r3
    1a08:	f1 e0       	ldi	r31, 0x01	; 1
    1a0a:	4f 1a       	sub	r4, r31
    1a0c:	51 08       	sbc	r5, r1
    1a0e:	41 14       	cp	r4, r1
    1a10:	51 04       	cpc	r5, r1
    1a12:	71 f7       	brne	.-36     	; 0x19f0 <vfprintf+0x18c>
    1a14:	e5 c0       	rjmp	.+458    	; 0x1be0 <vfprintf+0x37c>
    1a16:	84 36       	cpi	r24, 0x64	; 100
    1a18:	11 f0       	breq	.+4      	; 0x1a1e <vfprintf+0x1ba>
    1a1a:	89 36       	cpi	r24, 0x69	; 105
    1a1c:	39 f5       	brne	.+78     	; 0x1a6c <vfprintf+0x208>
    1a1e:	f8 01       	movw	r30, r16
    1a20:	27 ff       	sbrs	r18, 7
    1a22:	07 c0       	rjmp	.+14     	; 0x1a32 <vfprintf+0x1ce>
    1a24:	60 81       	ld	r22, Z
    1a26:	71 81       	ldd	r23, Z+1	; 0x01
    1a28:	82 81       	ldd	r24, Z+2	; 0x02
    1a2a:	93 81       	ldd	r25, Z+3	; 0x03
    1a2c:	0c 5f       	subi	r16, 0xFC	; 252
    1a2e:	1f 4f       	sbci	r17, 0xFF	; 255
    1a30:	08 c0       	rjmp	.+16     	; 0x1a42 <vfprintf+0x1de>
    1a32:	60 81       	ld	r22, Z
    1a34:	71 81       	ldd	r23, Z+1	; 0x01
    1a36:	07 2e       	mov	r0, r23
    1a38:	00 0c       	add	r0, r0
    1a3a:	88 0b       	sbc	r24, r24
    1a3c:	99 0b       	sbc	r25, r25
    1a3e:	0e 5f       	subi	r16, 0xFE	; 254
    1a40:	1f 4f       	sbci	r17, 0xFF	; 255
    1a42:	2f 76       	andi	r18, 0x6F	; 111
    1a44:	72 2e       	mov	r7, r18
    1a46:	97 ff       	sbrs	r25, 7
    1a48:	09 c0       	rjmp	.+18     	; 0x1a5c <vfprintf+0x1f8>
    1a4a:	90 95       	com	r25
    1a4c:	80 95       	com	r24
    1a4e:	70 95       	com	r23
    1a50:	61 95       	neg	r22
    1a52:	7f 4f       	sbci	r23, 0xFF	; 255
    1a54:	8f 4f       	sbci	r24, 0xFF	; 255
    1a56:	9f 4f       	sbci	r25, 0xFF	; 255
    1a58:	20 68       	ori	r18, 0x80	; 128
    1a5a:	72 2e       	mov	r7, r18
    1a5c:	2a e0       	ldi	r18, 0x0A	; 10
    1a5e:	30 e0       	ldi	r19, 0x00	; 0
    1a60:	a4 01       	movw	r20, r8
    1a62:	0e 94 52 0e 	call	0x1ca4	; 0x1ca4 <__ultoa_invert>
    1a66:	a8 2e       	mov	r10, r24
    1a68:	a8 18       	sub	r10, r8
    1a6a:	44 c0       	rjmp	.+136    	; 0x1af4 <vfprintf+0x290>
    1a6c:	85 37       	cpi	r24, 0x75	; 117
    1a6e:	29 f4       	brne	.+10     	; 0x1a7a <vfprintf+0x216>
    1a70:	2f 7e       	andi	r18, 0xEF	; 239
    1a72:	b2 2e       	mov	r11, r18
    1a74:	2a e0       	ldi	r18, 0x0A	; 10
    1a76:	30 e0       	ldi	r19, 0x00	; 0
    1a78:	25 c0       	rjmp	.+74     	; 0x1ac4 <vfprintf+0x260>
    1a7a:	f2 2f       	mov	r31, r18
    1a7c:	f9 7f       	andi	r31, 0xF9	; 249
    1a7e:	bf 2e       	mov	r11, r31
    1a80:	8f 36       	cpi	r24, 0x6F	; 111
    1a82:	c1 f0       	breq	.+48     	; 0x1ab4 <vfprintf+0x250>
    1a84:	18 f4       	brcc	.+6      	; 0x1a8c <vfprintf+0x228>
    1a86:	88 35       	cpi	r24, 0x58	; 88
    1a88:	79 f0       	breq	.+30     	; 0x1aa8 <vfprintf+0x244>
    1a8a:	b4 c0       	rjmp	.+360    	; 0x1bf4 <vfprintf+0x390>
    1a8c:	80 37       	cpi	r24, 0x70	; 112
    1a8e:	19 f0       	breq	.+6      	; 0x1a96 <vfprintf+0x232>
    1a90:	88 37       	cpi	r24, 0x78	; 120
    1a92:	21 f0       	breq	.+8      	; 0x1a9c <vfprintf+0x238>
    1a94:	af c0       	rjmp	.+350    	; 0x1bf4 <vfprintf+0x390>
    1a96:	2f 2f       	mov	r18, r31
    1a98:	20 61       	ori	r18, 0x10	; 16
    1a9a:	b2 2e       	mov	r11, r18
    1a9c:	b4 fe       	sbrs	r11, 4
    1a9e:	0d c0       	rjmp	.+26     	; 0x1aba <vfprintf+0x256>
    1aa0:	8b 2d       	mov	r24, r11
    1aa2:	84 60       	ori	r24, 0x04	; 4
    1aa4:	b8 2e       	mov	r11, r24
    1aa6:	09 c0       	rjmp	.+18     	; 0x1aba <vfprintf+0x256>
    1aa8:	24 ff       	sbrs	r18, 4
    1aaa:	0a c0       	rjmp	.+20     	; 0x1ac0 <vfprintf+0x25c>
    1aac:	9f 2f       	mov	r25, r31
    1aae:	96 60       	ori	r25, 0x06	; 6
    1ab0:	b9 2e       	mov	r11, r25
    1ab2:	06 c0       	rjmp	.+12     	; 0x1ac0 <vfprintf+0x25c>
    1ab4:	28 e0       	ldi	r18, 0x08	; 8
    1ab6:	30 e0       	ldi	r19, 0x00	; 0
    1ab8:	05 c0       	rjmp	.+10     	; 0x1ac4 <vfprintf+0x260>
    1aba:	20 e1       	ldi	r18, 0x10	; 16
    1abc:	30 e0       	ldi	r19, 0x00	; 0
    1abe:	02 c0       	rjmp	.+4      	; 0x1ac4 <vfprintf+0x260>
    1ac0:	20 e1       	ldi	r18, 0x10	; 16
    1ac2:	32 e0       	ldi	r19, 0x02	; 2
    1ac4:	f8 01       	movw	r30, r16
    1ac6:	b7 fe       	sbrs	r11, 7
    1ac8:	07 c0       	rjmp	.+14     	; 0x1ad8 <vfprintf+0x274>
    1aca:	60 81       	ld	r22, Z
    1acc:	71 81       	ldd	r23, Z+1	; 0x01
    1ace:	82 81       	ldd	r24, Z+2	; 0x02
    1ad0:	93 81       	ldd	r25, Z+3	; 0x03
    1ad2:	0c 5f       	subi	r16, 0xFC	; 252
    1ad4:	1f 4f       	sbci	r17, 0xFF	; 255
    1ad6:	06 c0       	rjmp	.+12     	; 0x1ae4 <vfprintf+0x280>
    1ad8:	60 81       	ld	r22, Z
    1ada:	71 81       	ldd	r23, Z+1	; 0x01
    1adc:	80 e0       	ldi	r24, 0x00	; 0
    1ade:	90 e0       	ldi	r25, 0x00	; 0
    1ae0:	0e 5f       	subi	r16, 0xFE	; 254
    1ae2:	1f 4f       	sbci	r17, 0xFF	; 255
    1ae4:	a4 01       	movw	r20, r8
    1ae6:	0e 94 52 0e 	call	0x1ca4	; 0x1ca4 <__ultoa_invert>
    1aea:	a8 2e       	mov	r10, r24
    1aec:	a8 18       	sub	r10, r8
    1aee:	fb 2d       	mov	r31, r11
    1af0:	ff 77       	andi	r31, 0x7F	; 127
    1af2:	7f 2e       	mov	r7, r31
    1af4:	76 fe       	sbrs	r7, 6
    1af6:	0b c0       	rjmp	.+22     	; 0x1b0e <vfprintf+0x2aa>
    1af8:	37 2d       	mov	r19, r7
    1afa:	3e 7f       	andi	r19, 0xFE	; 254
    1afc:	a5 14       	cp	r10, r5
    1afe:	50 f4       	brcc	.+20     	; 0x1b14 <vfprintf+0x2b0>
    1b00:	74 fe       	sbrs	r7, 4
    1b02:	0a c0       	rjmp	.+20     	; 0x1b18 <vfprintf+0x2b4>
    1b04:	72 fc       	sbrc	r7, 2
    1b06:	08 c0       	rjmp	.+16     	; 0x1b18 <vfprintf+0x2b4>
    1b08:	37 2d       	mov	r19, r7
    1b0a:	3e 7e       	andi	r19, 0xEE	; 238
    1b0c:	05 c0       	rjmp	.+10     	; 0x1b18 <vfprintf+0x2b4>
    1b0e:	ba 2c       	mov	r11, r10
    1b10:	37 2d       	mov	r19, r7
    1b12:	03 c0       	rjmp	.+6      	; 0x1b1a <vfprintf+0x2b6>
    1b14:	ba 2c       	mov	r11, r10
    1b16:	01 c0       	rjmp	.+2      	; 0x1b1a <vfprintf+0x2b6>
    1b18:	b5 2c       	mov	r11, r5
    1b1a:	34 ff       	sbrs	r19, 4
    1b1c:	0d c0       	rjmp	.+26     	; 0x1b38 <vfprintf+0x2d4>
    1b1e:	fe 01       	movw	r30, r28
    1b20:	ea 0d       	add	r30, r10
    1b22:	f1 1d       	adc	r31, r1
    1b24:	80 81       	ld	r24, Z
    1b26:	80 33       	cpi	r24, 0x30	; 48
    1b28:	11 f4       	brne	.+4      	; 0x1b2e <vfprintf+0x2ca>
    1b2a:	39 7e       	andi	r19, 0xE9	; 233
    1b2c:	09 c0       	rjmp	.+18     	; 0x1b40 <vfprintf+0x2dc>
    1b2e:	32 ff       	sbrs	r19, 2
    1b30:	06 c0       	rjmp	.+12     	; 0x1b3e <vfprintf+0x2da>
    1b32:	b3 94       	inc	r11
    1b34:	b3 94       	inc	r11
    1b36:	04 c0       	rjmp	.+8      	; 0x1b40 <vfprintf+0x2dc>
    1b38:	83 2f       	mov	r24, r19
    1b3a:	86 78       	andi	r24, 0x86	; 134
    1b3c:	09 f0       	breq	.+2      	; 0x1b40 <vfprintf+0x2dc>
    1b3e:	b3 94       	inc	r11
    1b40:	33 fd       	sbrc	r19, 3
    1b42:	13 c0       	rjmp	.+38     	; 0x1b6a <vfprintf+0x306>
    1b44:	30 ff       	sbrs	r19, 0
    1b46:	06 c0       	rjmp	.+12     	; 0x1b54 <vfprintf+0x2f0>
    1b48:	5a 2c       	mov	r5, r10
    1b4a:	b3 14       	cp	r11, r3
    1b4c:	18 f4       	brcc	.+6      	; 0x1b54 <vfprintf+0x2f0>
    1b4e:	53 0c       	add	r5, r3
    1b50:	5b 18       	sub	r5, r11
    1b52:	b3 2c       	mov	r11, r3
    1b54:	b3 14       	cp	r11, r3
    1b56:	68 f4       	brcc	.+26     	; 0x1b72 <vfprintf+0x30e>
    1b58:	b7 01       	movw	r22, r14
    1b5a:	80 e2       	ldi	r24, 0x20	; 32
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	3c 87       	std	Y+12, r19	; 0x0c
    1b60:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <fputc>
    1b64:	b3 94       	inc	r11
    1b66:	3c 85       	ldd	r19, Y+12	; 0x0c
    1b68:	f5 cf       	rjmp	.-22     	; 0x1b54 <vfprintf+0x2f0>
    1b6a:	b3 14       	cp	r11, r3
    1b6c:	10 f4       	brcc	.+4      	; 0x1b72 <vfprintf+0x30e>
    1b6e:	3b 18       	sub	r3, r11
    1b70:	01 c0       	rjmp	.+2      	; 0x1b74 <vfprintf+0x310>
    1b72:	31 2c       	mov	r3, r1
    1b74:	34 ff       	sbrs	r19, 4
    1b76:	12 c0       	rjmp	.+36     	; 0x1b9c <vfprintf+0x338>
    1b78:	b7 01       	movw	r22, r14
    1b7a:	80 e3       	ldi	r24, 0x30	; 48
    1b7c:	90 e0       	ldi	r25, 0x00	; 0
    1b7e:	3c 87       	std	Y+12, r19	; 0x0c
    1b80:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <fputc>
    1b84:	3c 85       	ldd	r19, Y+12	; 0x0c
    1b86:	32 ff       	sbrs	r19, 2
    1b88:	17 c0       	rjmp	.+46     	; 0x1bb8 <vfprintf+0x354>
    1b8a:	31 fd       	sbrc	r19, 1
    1b8c:	03 c0       	rjmp	.+6      	; 0x1b94 <vfprintf+0x330>
    1b8e:	88 e7       	ldi	r24, 0x78	; 120
    1b90:	90 e0       	ldi	r25, 0x00	; 0
    1b92:	02 c0       	rjmp	.+4      	; 0x1b98 <vfprintf+0x334>
    1b94:	88 e5       	ldi	r24, 0x58	; 88
    1b96:	90 e0       	ldi	r25, 0x00	; 0
    1b98:	b7 01       	movw	r22, r14
    1b9a:	0c c0       	rjmp	.+24     	; 0x1bb4 <vfprintf+0x350>
    1b9c:	83 2f       	mov	r24, r19
    1b9e:	86 78       	andi	r24, 0x86	; 134
    1ba0:	59 f0       	breq	.+22     	; 0x1bb8 <vfprintf+0x354>
    1ba2:	31 ff       	sbrs	r19, 1
    1ba4:	02 c0       	rjmp	.+4      	; 0x1baa <vfprintf+0x346>
    1ba6:	8b e2       	ldi	r24, 0x2B	; 43
    1ba8:	01 c0       	rjmp	.+2      	; 0x1bac <vfprintf+0x348>
    1baa:	80 e2       	ldi	r24, 0x20	; 32
    1bac:	37 fd       	sbrc	r19, 7
    1bae:	8d e2       	ldi	r24, 0x2D	; 45
    1bb0:	b7 01       	movw	r22, r14
    1bb2:	90 e0       	ldi	r25, 0x00	; 0
    1bb4:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <fputc>
    1bb8:	a5 14       	cp	r10, r5
    1bba:	38 f4       	brcc	.+14     	; 0x1bca <vfprintf+0x366>
    1bbc:	b7 01       	movw	r22, r14
    1bbe:	80 e3       	ldi	r24, 0x30	; 48
    1bc0:	90 e0       	ldi	r25, 0x00	; 0
    1bc2:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <fputc>
    1bc6:	5a 94       	dec	r5
    1bc8:	f7 cf       	rjmp	.-18     	; 0x1bb8 <vfprintf+0x354>
    1bca:	aa 94       	dec	r10
    1bcc:	f4 01       	movw	r30, r8
    1bce:	ea 0d       	add	r30, r10
    1bd0:	f1 1d       	adc	r31, r1
    1bd2:	80 81       	ld	r24, Z
    1bd4:	b7 01       	movw	r22, r14
    1bd6:	90 e0       	ldi	r25, 0x00	; 0
    1bd8:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <fputc>
    1bdc:	a1 10       	cpse	r10, r1
    1bde:	f5 cf       	rjmp	.-22     	; 0x1bca <vfprintf+0x366>
    1be0:	33 20       	and	r3, r3
    1be2:	09 f4       	brne	.+2      	; 0x1be6 <vfprintf+0x382>
    1be4:	51 ce       	rjmp	.-862    	; 0x1888 <vfprintf+0x24>
    1be6:	b7 01       	movw	r22, r14
    1be8:	80 e2       	ldi	r24, 0x20	; 32
    1bea:	90 e0       	ldi	r25, 0x00	; 0
    1bec:	0e 94 1a 0e 	call	0x1c34	; 0x1c34 <fputc>
    1bf0:	3a 94       	dec	r3
    1bf2:	f6 cf       	rjmp	.-20     	; 0x1be0 <vfprintf+0x37c>
    1bf4:	f7 01       	movw	r30, r14
    1bf6:	86 81       	ldd	r24, Z+6	; 0x06
    1bf8:	97 81       	ldd	r25, Z+7	; 0x07
    1bfa:	02 c0       	rjmp	.+4      	; 0x1c00 <vfprintf+0x39c>
    1bfc:	8f ef       	ldi	r24, 0xFF	; 255
    1bfe:	9f ef       	ldi	r25, 0xFF	; 255
    1c00:	2c 96       	adiw	r28, 0x0c	; 12
    1c02:	e2 e1       	ldi	r30, 0x12	; 18
    1c04:	0c 94 fe 0e 	jmp	0x1dfc	; 0x1dfc <__epilogue_restores__>

00001c08 <strnlen_P>:
    1c08:	fc 01       	movw	r30, r24
    1c0a:	05 90       	lpm	r0, Z+
    1c0c:	61 50       	subi	r22, 0x01	; 1
    1c0e:	70 40       	sbci	r23, 0x00	; 0
    1c10:	01 10       	cpse	r0, r1
    1c12:	d8 f7       	brcc	.-10     	; 0x1c0a <strnlen_P+0x2>
    1c14:	80 95       	com	r24
    1c16:	90 95       	com	r25
    1c18:	8e 0f       	add	r24, r30
    1c1a:	9f 1f       	adc	r25, r31
    1c1c:	08 95       	ret

00001c1e <strnlen>:
    1c1e:	fc 01       	movw	r30, r24
    1c20:	61 50       	subi	r22, 0x01	; 1
    1c22:	70 40       	sbci	r23, 0x00	; 0
    1c24:	01 90       	ld	r0, Z+
    1c26:	01 10       	cpse	r0, r1
    1c28:	d8 f7       	brcc	.-10     	; 0x1c20 <strnlen+0x2>
    1c2a:	80 95       	com	r24
    1c2c:	90 95       	com	r25
    1c2e:	8e 0f       	add	r24, r30
    1c30:	9f 1f       	adc	r25, r31
    1c32:	08 95       	ret

00001c34 <fputc>:
    1c34:	0f 93       	push	r16
    1c36:	1f 93       	push	r17
    1c38:	cf 93       	push	r28
    1c3a:	df 93       	push	r29
    1c3c:	fb 01       	movw	r30, r22
    1c3e:	23 81       	ldd	r18, Z+3	; 0x03
    1c40:	21 fd       	sbrc	r18, 1
    1c42:	03 c0       	rjmp	.+6      	; 0x1c4a <fputc+0x16>
    1c44:	8f ef       	ldi	r24, 0xFF	; 255
    1c46:	9f ef       	ldi	r25, 0xFF	; 255
    1c48:	28 c0       	rjmp	.+80     	; 0x1c9a <fputc+0x66>
    1c4a:	22 ff       	sbrs	r18, 2
    1c4c:	16 c0       	rjmp	.+44     	; 0x1c7a <fputc+0x46>
    1c4e:	46 81       	ldd	r20, Z+6	; 0x06
    1c50:	57 81       	ldd	r21, Z+7	; 0x07
    1c52:	24 81       	ldd	r18, Z+4	; 0x04
    1c54:	35 81       	ldd	r19, Z+5	; 0x05
    1c56:	42 17       	cp	r20, r18
    1c58:	53 07       	cpc	r21, r19
    1c5a:	44 f4       	brge	.+16     	; 0x1c6c <fputc+0x38>
    1c5c:	a0 81       	ld	r26, Z
    1c5e:	b1 81       	ldd	r27, Z+1	; 0x01
    1c60:	9d 01       	movw	r18, r26
    1c62:	2f 5f       	subi	r18, 0xFF	; 255
    1c64:	3f 4f       	sbci	r19, 0xFF	; 255
    1c66:	31 83       	std	Z+1, r19	; 0x01
    1c68:	20 83       	st	Z, r18
    1c6a:	8c 93       	st	X, r24
    1c6c:	26 81       	ldd	r18, Z+6	; 0x06
    1c6e:	37 81       	ldd	r19, Z+7	; 0x07
    1c70:	2f 5f       	subi	r18, 0xFF	; 255
    1c72:	3f 4f       	sbci	r19, 0xFF	; 255
    1c74:	37 83       	std	Z+7, r19	; 0x07
    1c76:	26 83       	std	Z+6, r18	; 0x06
    1c78:	10 c0       	rjmp	.+32     	; 0x1c9a <fputc+0x66>
    1c7a:	eb 01       	movw	r28, r22
    1c7c:	09 2f       	mov	r16, r25
    1c7e:	18 2f       	mov	r17, r24
    1c80:	00 84       	ldd	r0, Z+8	; 0x08
    1c82:	f1 85       	ldd	r31, Z+9	; 0x09
    1c84:	e0 2d       	mov	r30, r0
    1c86:	09 95       	icall
    1c88:	89 2b       	or	r24, r25
    1c8a:	e1 f6       	brne	.-72     	; 0x1c44 <fputc+0x10>
    1c8c:	8e 81       	ldd	r24, Y+6	; 0x06
    1c8e:	9f 81       	ldd	r25, Y+7	; 0x07
    1c90:	01 96       	adiw	r24, 0x01	; 1
    1c92:	9f 83       	std	Y+7, r25	; 0x07
    1c94:	8e 83       	std	Y+6, r24	; 0x06
    1c96:	81 2f       	mov	r24, r17
    1c98:	90 2f       	mov	r25, r16
    1c9a:	df 91       	pop	r29
    1c9c:	cf 91       	pop	r28
    1c9e:	1f 91       	pop	r17
    1ca0:	0f 91       	pop	r16
    1ca2:	08 95       	ret

00001ca4 <__ultoa_invert>:
    1ca4:	fa 01       	movw	r30, r20
    1ca6:	aa 27       	eor	r26, r26
    1ca8:	28 30       	cpi	r18, 0x08	; 8
    1caa:	51 f1       	breq	.+84     	; 0x1d00 <__ultoa_invert+0x5c>
    1cac:	20 31       	cpi	r18, 0x10	; 16
    1cae:	81 f1       	breq	.+96     	; 0x1d10 <__ultoa_invert+0x6c>
    1cb0:	e8 94       	clt
    1cb2:	6f 93       	push	r22
    1cb4:	6e 7f       	andi	r22, 0xFE	; 254
    1cb6:	6e 5f       	subi	r22, 0xFE	; 254
    1cb8:	7f 4f       	sbci	r23, 0xFF	; 255
    1cba:	8f 4f       	sbci	r24, 0xFF	; 255
    1cbc:	9f 4f       	sbci	r25, 0xFF	; 255
    1cbe:	af 4f       	sbci	r26, 0xFF	; 255
    1cc0:	b1 e0       	ldi	r27, 0x01	; 1
    1cc2:	3e d0       	rcall	.+124    	; 0x1d40 <__ultoa_invert+0x9c>
    1cc4:	b4 e0       	ldi	r27, 0x04	; 4
    1cc6:	3c d0       	rcall	.+120    	; 0x1d40 <__ultoa_invert+0x9c>
    1cc8:	67 0f       	add	r22, r23
    1cca:	78 1f       	adc	r23, r24
    1ccc:	89 1f       	adc	r24, r25
    1cce:	9a 1f       	adc	r25, r26
    1cd0:	a1 1d       	adc	r26, r1
    1cd2:	68 0f       	add	r22, r24
    1cd4:	79 1f       	adc	r23, r25
    1cd6:	8a 1f       	adc	r24, r26
    1cd8:	91 1d       	adc	r25, r1
    1cda:	a1 1d       	adc	r26, r1
    1cdc:	6a 0f       	add	r22, r26
    1cde:	71 1d       	adc	r23, r1
    1ce0:	81 1d       	adc	r24, r1
    1ce2:	91 1d       	adc	r25, r1
    1ce4:	a1 1d       	adc	r26, r1
    1ce6:	20 d0       	rcall	.+64     	; 0x1d28 <__ultoa_invert+0x84>
    1ce8:	09 f4       	brne	.+2      	; 0x1cec <__ultoa_invert+0x48>
    1cea:	68 94       	set
    1cec:	3f 91       	pop	r19
    1cee:	2a e0       	ldi	r18, 0x0A	; 10
    1cf0:	26 9f       	mul	r18, r22
    1cf2:	11 24       	eor	r1, r1
    1cf4:	30 19       	sub	r19, r0
    1cf6:	30 5d       	subi	r19, 0xD0	; 208
    1cf8:	31 93       	st	Z+, r19
    1cfa:	de f6       	brtc	.-74     	; 0x1cb2 <__ultoa_invert+0xe>
    1cfc:	cf 01       	movw	r24, r30
    1cfe:	08 95       	ret
    1d00:	46 2f       	mov	r20, r22
    1d02:	47 70       	andi	r20, 0x07	; 7
    1d04:	40 5d       	subi	r20, 0xD0	; 208
    1d06:	41 93       	st	Z+, r20
    1d08:	b3 e0       	ldi	r27, 0x03	; 3
    1d0a:	0f d0       	rcall	.+30     	; 0x1d2a <__ultoa_invert+0x86>
    1d0c:	c9 f7       	brne	.-14     	; 0x1d00 <__ultoa_invert+0x5c>
    1d0e:	f6 cf       	rjmp	.-20     	; 0x1cfc <__ultoa_invert+0x58>
    1d10:	46 2f       	mov	r20, r22
    1d12:	4f 70       	andi	r20, 0x0F	; 15
    1d14:	40 5d       	subi	r20, 0xD0	; 208
    1d16:	4a 33       	cpi	r20, 0x3A	; 58
    1d18:	18 f0       	brcs	.+6      	; 0x1d20 <__ultoa_invert+0x7c>
    1d1a:	49 5d       	subi	r20, 0xD9	; 217
    1d1c:	31 fd       	sbrc	r19, 1
    1d1e:	40 52       	subi	r20, 0x20	; 32
    1d20:	41 93       	st	Z+, r20
    1d22:	02 d0       	rcall	.+4      	; 0x1d28 <__ultoa_invert+0x84>
    1d24:	a9 f7       	brne	.-22     	; 0x1d10 <__ultoa_invert+0x6c>
    1d26:	ea cf       	rjmp	.-44     	; 0x1cfc <__ultoa_invert+0x58>
    1d28:	b4 e0       	ldi	r27, 0x04	; 4
    1d2a:	a6 95       	lsr	r26
    1d2c:	97 95       	ror	r25
    1d2e:	87 95       	ror	r24
    1d30:	77 95       	ror	r23
    1d32:	67 95       	ror	r22
    1d34:	ba 95       	dec	r27
    1d36:	c9 f7       	brne	.-14     	; 0x1d2a <__ultoa_invert+0x86>
    1d38:	00 97       	sbiw	r24, 0x00	; 0
    1d3a:	61 05       	cpc	r22, r1
    1d3c:	71 05       	cpc	r23, r1
    1d3e:	08 95       	ret
    1d40:	9b 01       	movw	r18, r22
    1d42:	ac 01       	movw	r20, r24
    1d44:	0a 2e       	mov	r0, r26
    1d46:	06 94       	lsr	r0
    1d48:	57 95       	ror	r21
    1d4a:	47 95       	ror	r20
    1d4c:	37 95       	ror	r19
    1d4e:	27 95       	ror	r18
    1d50:	ba 95       	dec	r27
    1d52:	c9 f7       	brne	.-14     	; 0x1d46 <__ultoa_invert+0xa2>
    1d54:	62 0f       	add	r22, r18
    1d56:	73 1f       	adc	r23, r19
    1d58:	84 1f       	adc	r24, r20
    1d5a:	95 1f       	adc	r25, r21
    1d5c:	a0 1d       	adc	r26, r0
    1d5e:	08 95       	ret

00001d60 <__divmodsi4>:
    1d60:	05 2e       	mov	r0, r21
    1d62:	97 fb       	bst	r25, 7
    1d64:	1e f4       	brtc	.+6      	; 0x1d6c <__divmodsi4+0xc>
    1d66:	00 94       	com	r0
    1d68:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <__negsi2>
    1d6c:	57 fd       	sbrc	r21, 7
    1d6e:	07 d0       	rcall	.+14     	; 0x1d7e <__divmodsi4_neg2>
    1d70:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <__udivmodsi4>
    1d74:	07 fc       	sbrc	r0, 7
    1d76:	03 d0       	rcall	.+6      	; 0x1d7e <__divmodsi4_neg2>
    1d78:	4e f4       	brtc	.+18     	; 0x1d8c <__divmodsi4_exit>
    1d7a:	0c 94 c7 0e 	jmp	0x1d8e	; 0x1d8e <__negsi2>

00001d7e <__divmodsi4_neg2>:
    1d7e:	50 95       	com	r21
    1d80:	40 95       	com	r20
    1d82:	30 95       	com	r19
    1d84:	21 95       	neg	r18
    1d86:	3f 4f       	sbci	r19, 0xFF	; 255
    1d88:	4f 4f       	sbci	r20, 0xFF	; 255
    1d8a:	5f 4f       	sbci	r21, 0xFF	; 255

00001d8c <__divmodsi4_exit>:
    1d8c:	08 95       	ret

00001d8e <__negsi2>:
    1d8e:	90 95       	com	r25
    1d90:	80 95       	com	r24
    1d92:	70 95       	com	r23
    1d94:	61 95       	neg	r22
    1d96:	7f 4f       	sbci	r23, 0xFF	; 255
    1d98:	8f 4f       	sbci	r24, 0xFF	; 255
    1d9a:	9f 4f       	sbci	r25, 0xFF	; 255
    1d9c:	08 95       	ret

00001d9e <__muluhisi3>:
    1d9e:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <__umulhisi3>
    1da2:	a5 9f       	mul	r26, r21
    1da4:	90 0d       	add	r25, r0
    1da6:	b4 9f       	mul	r27, r20
    1da8:	90 0d       	add	r25, r0
    1daa:	a4 9f       	mul	r26, r20
    1dac:	80 0d       	add	r24, r0
    1dae:	91 1d       	adc	r25, r1
    1db0:	11 24       	eor	r1, r1
    1db2:	08 95       	ret

00001db4 <__mulshisi3>:
    1db4:	b7 ff       	sbrs	r27, 7
    1db6:	0c 94 cf 0e 	jmp	0x1d9e	; 0x1d9e <__muluhisi3>

00001dba <__mulohisi3>:
    1dba:	0e 94 cf 0e 	call	0x1d9e	; 0x1d9e <__muluhisi3>
    1dbe:	82 1b       	sub	r24, r18
    1dc0:	93 0b       	sbc	r25, r19
    1dc2:	08 95       	ret

00001dc4 <__prologue_saves__>:
    1dc4:	2f 92       	push	r2
    1dc6:	3f 92       	push	r3
    1dc8:	4f 92       	push	r4
    1dca:	5f 92       	push	r5
    1dcc:	6f 92       	push	r6
    1dce:	7f 92       	push	r7
    1dd0:	8f 92       	push	r8
    1dd2:	9f 92       	push	r9
    1dd4:	af 92       	push	r10
    1dd6:	bf 92       	push	r11
    1dd8:	cf 92       	push	r12
    1dda:	df 92       	push	r13
    1ddc:	ef 92       	push	r14
    1dde:	ff 92       	push	r15
    1de0:	0f 93       	push	r16
    1de2:	1f 93       	push	r17
    1de4:	cf 93       	push	r28
    1de6:	df 93       	push	r29
    1de8:	cd b7       	in	r28, 0x3d	; 61
    1dea:	de b7       	in	r29, 0x3e	; 62
    1dec:	ca 1b       	sub	r28, r26
    1dee:	db 0b       	sbc	r29, r27
    1df0:	0f b6       	in	r0, 0x3f	; 63
    1df2:	f8 94       	cli
    1df4:	de bf       	out	0x3e, r29	; 62
    1df6:	0f be       	out	0x3f, r0	; 63
    1df8:	cd bf       	out	0x3d, r28	; 61
    1dfa:	09 94       	ijmp

00001dfc <__epilogue_restores__>:
    1dfc:	2a 88       	ldd	r2, Y+18	; 0x12
    1dfe:	39 88       	ldd	r3, Y+17	; 0x11
    1e00:	48 88       	ldd	r4, Y+16	; 0x10
    1e02:	5f 84       	ldd	r5, Y+15	; 0x0f
    1e04:	6e 84       	ldd	r6, Y+14	; 0x0e
    1e06:	7d 84       	ldd	r7, Y+13	; 0x0d
    1e08:	8c 84       	ldd	r8, Y+12	; 0x0c
    1e0a:	9b 84       	ldd	r9, Y+11	; 0x0b
    1e0c:	aa 84       	ldd	r10, Y+10	; 0x0a
    1e0e:	b9 84       	ldd	r11, Y+9	; 0x09
    1e10:	c8 84       	ldd	r12, Y+8	; 0x08
    1e12:	df 80       	ldd	r13, Y+7	; 0x07
    1e14:	ee 80       	ldd	r14, Y+6	; 0x06
    1e16:	fd 80       	ldd	r15, Y+5	; 0x05
    1e18:	0c 81       	ldd	r16, Y+4	; 0x04
    1e1a:	1b 81       	ldd	r17, Y+3	; 0x03
    1e1c:	aa 81       	ldd	r26, Y+2	; 0x02
    1e1e:	b9 81       	ldd	r27, Y+1	; 0x01
    1e20:	ce 0f       	add	r28, r30
    1e22:	d1 1d       	adc	r29, r1
    1e24:	0f b6       	in	r0, 0x3f	; 63
    1e26:	f8 94       	cli
    1e28:	de bf       	out	0x3e, r29	; 62
    1e2a:	0f be       	out	0x3f, r0	; 63
    1e2c:	cd bf       	out	0x3d, r28	; 61
    1e2e:	ed 01       	movw	r28, r26
    1e30:	08 95       	ret

00001e32 <__udivmodsi4>:
    1e32:	a1 e2       	ldi	r26, 0x21	; 33
    1e34:	1a 2e       	mov	r1, r26
    1e36:	aa 1b       	sub	r26, r26
    1e38:	bb 1b       	sub	r27, r27
    1e3a:	fd 01       	movw	r30, r26
    1e3c:	0d c0       	rjmp	.+26     	; 0x1e58 <__udivmodsi4_ep>

00001e3e <__udivmodsi4_loop>:
    1e3e:	aa 1f       	adc	r26, r26
    1e40:	bb 1f       	adc	r27, r27
    1e42:	ee 1f       	adc	r30, r30
    1e44:	ff 1f       	adc	r31, r31
    1e46:	a2 17       	cp	r26, r18
    1e48:	b3 07       	cpc	r27, r19
    1e4a:	e4 07       	cpc	r30, r20
    1e4c:	f5 07       	cpc	r31, r21
    1e4e:	20 f0       	brcs	.+8      	; 0x1e58 <__udivmodsi4_ep>
    1e50:	a2 1b       	sub	r26, r18
    1e52:	b3 0b       	sbc	r27, r19
    1e54:	e4 0b       	sbc	r30, r20
    1e56:	f5 0b       	sbc	r31, r21

00001e58 <__udivmodsi4_ep>:
    1e58:	66 1f       	adc	r22, r22
    1e5a:	77 1f       	adc	r23, r23
    1e5c:	88 1f       	adc	r24, r24
    1e5e:	99 1f       	adc	r25, r25
    1e60:	1a 94       	dec	r1
    1e62:	69 f7       	brne	.-38     	; 0x1e3e <__udivmodsi4_loop>
    1e64:	60 95       	com	r22
    1e66:	70 95       	com	r23
    1e68:	80 95       	com	r24
    1e6a:	90 95       	com	r25
    1e6c:	9b 01       	movw	r18, r22
    1e6e:	ac 01       	movw	r20, r24
    1e70:	bd 01       	movw	r22, r26
    1e72:	cf 01       	movw	r24, r30
    1e74:	08 95       	ret

00001e76 <__umulhisi3>:
    1e76:	a2 9f       	mul	r26, r18
    1e78:	b0 01       	movw	r22, r0
    1e7a:	b3 9f       	mul	r27, r19
    1e7c:	c0 01       	movw	r24, r0
    1e7e:	a3 9f       	mul	r26, r19
    1e80:	70 0d       	add	r23, r0
    1e82:	81 1d       	adc	r24, r1
    1e84:	11 24       	eor	r1, r1
    1e86:	91 1d       	adc	r25, r1
    1e88:	b2 9f       	mul	r27, r18
    1e8a:	70 0d       	add	r23, r0
    1e8c:	81 1d       	adc	r24, r1
    1e8e:	11 24       	eor	r1, r1
    1e90:	91 1d       	adc	r25, r1
    1e92:	08 95       	ret

00001e94 <_exit>:
    1e94:	f8 94       	cli

00001e96 <__stop_program>:
    1e96:	ff cf       	rjmp	.-2      	; 0x1e96 <__stop_program>


ArduinoUnoFreertos_6_1(2).elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000144  00800100  0000196c  00001a00  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000196c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000658  00800244  00800244  00001b44  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001b44  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001b74  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003b0  00000000  00000000  00001bb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000045e9  00000000  00000000  00001f64  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000daf  00000000  00000000  0000654d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001615  00000000  00000000  000072fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b50  00000000  00000000  00008914  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000014c9  00000000  00000000  00009464  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000461b  00000000  00000000  0000a92d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003a8  00000000  00000000  0000ef48  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 2e 0c 	jmp	0x185c	; 0x185c <__vector_1>
       8:	0c 94 5b 0c 	jmp	0x18b6	; 0x18b6 <__vector_2>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 37 03 	jmp	0x66e	; 0x66e <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	12 e0       	ldi	r17, 0x02	; 2
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	ec e6       	ldi	r30, 0x6C	; 108
      7c:	f9 e1       	ldi	r31, 0x19	; 25
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a4 34       	cpi	r26, 0x44	; 68
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	28 e0       	ldi	r18, 0x08	; 8
      8c:	a4 e4       	ldi	r26, 0x44	; 68
      8e:	b2 e0       	ldi	r27, 0x02	; 2
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	ac 39       	cpi	r26, 0x9C	; 156
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 0c 01 	call	0x218	; 0x218 <main>
      9e:	0c 94 b4 0c 	jmp	0x1968	; 0x1968 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vEvenTask>:
    }
}


static void vEvenTask( void *pvParameters )
{
      a6:	cf 93       	push	r28
      a8:	df 93       	push	r29
      aa:	00 d0       	rcall	.+0      	; 0xac <vEvenTask+0x6>
      ac:	cd b7       	in	r28, 0x3d	; 61
      ae:	de b7       	in	r29, 0x3e	; 62
	USART_sendstr("Start Even Task \r\n");
      b0:	84 e0       	ldi	r24, 0x04	; 4
      b2:	91 e0       	ldi	r25, 0x01	; 1
      b4:	0e 94 9c 0c 	call	0x1938	; 0x1938 <USART_sendstr>
	TickType_t xLastWakeTime = xTaskGetTickCount();
      b8:	0e 94 65 08 	call	0x10ca	; 0x10ca <xTaskGetTickCount>
      bc:	9a 83       	std	Y+2, r25	; 0x02
      be:	89 83       	std	Y+1, r24	; 0x01
	
	if( xSemaphoreGive(sem))
      c0:	20 e0       	ldi	r18, 0x00	; 0
      c2:	40 e0       	ldi	r20, 0x00	; 0
      c4:	50 e0       	ldi	r21, 0x00	; 0
      c6:	60 e0       	ldi	r22, 0x00	; 0
      c8:	70 e0       	ldi	r23, 0x00	; 0
      ca:	80 91 92 08 	lds	r24, 0x0892
      ce:	90 91 93 08 	lds	r25, 0x0893
      d2:	0e 94 38 05 	call	0xa70	; 0xa70 <xQueueGenericSend>
      d6:	88 23       	and	r24, r24
      d8:	31 f0       	breq	.+12     	; 0xe6 <vEvenTask+0x40>
	   USART_sendstr("Semaphore is released by Even Task \r\n");
      da:	87 e1       	ldi	r24, 0x17	; 23
      dc:	91 e0       	ldi	r25, 0x01	; 1
      de:	0e 94 9c 0c 	call	0x1938	; 0x1938 <USART_sendstr>
	{
		 USART_sendstr("Even \r\n");
		/* Block waiting for the semaphore to become available. */
		if( xSemaphoreTake(sem, LONG_TIME ) == pdTRUE )
		{
			PORTC = 0xAA;
      e2:	1a ea       	ldi	r17, 0xAA	; 170
      e4:	05 c0       	rjmp	.+10     	; 0xf0 <vEvenTask+0x4a>
	TickType_t xLastWakeTime = xTaskGetTickCount();
	
	if( xSemaphoreGive(sem))
	   USART_sendstr("Semaphore is released by Even Task \r\n");
	else
	   USART_sendstr("Semaphore can not release by Even Task \r\n");
      e6:	8d e3       	ldi	r24, 0x3D	; 61
      e8:	91 e0       	ldi	r25, 0x01	; 1
      ea:	0e 94 9c 0c 	call	0x1938	; 0x1938 <USART_sendstr>
      ee:	f9 cf       	rjmp	.-14     	; 0xe2 <vEvenTask+0x3c>
	   
	
	for( ;; )
	{
		 USART_sendstr("Even \r\n");
      f0:	87 e6       	ldi	r24, 0x67	; 103
      f2:	91 e0       	ldi	r25, 0x01	; 1
      f4:	0e 94 9c 0c 	call	0x1938	; 0x1938 <USART_sendstr>
		/* Block waiting for the semaphore to become available. */
		if( xSemaphoreTake(sem, LONG_TIME ) == pdTRUE )
      f8:	20 e0       	ldi	r18, 0x00	; 0
      fa:	4f ef       	ldi	r20, 0xFF	; 255
      fc:	5f ef       	ldi	r21, 0xFF	; 255
      fe:	60 e0       	ldi	r22, 0x00	; 0
     100:	70 e0       	ldi	r23, 0x00	; 0
     102:	80 91 92 08 	lds	r24, 0x0892
     106:	90 91 93 08 	lds	r25, 0x0893
     10a:	0e 94 04 06 	call	0xc08	; 0xc08 <xQueueGenericReceive>
     10e:	81 30       	cpi	r24, 0x01	; 1
     110:	79 f7       	brne	.-34     	; 0xf0 <vEvenTask+0x4a>
		{
			PORTC = 0xAA;
     112:	18 b9       	out	0x08, r17	; 8
			USART_sendstr("Semaphore is given to Even Task \r\n");
     114:	8f e6       	ldi	r24, 0x6F	; 111
     116:	91 e0       	ldi	r25, 0x01	; 1
     118:	0e 94 9c 0c 	call	0x1938	; 0x1938 <USART_sendstr>
			
			if( xSemaphoreGive( sem ) != pdTRUE )
     11c:	20 e0       	ldi	r18, 0x00	; 0
     11e:	40 e0       	ldi	r20, 0x00	; 0
     120:	50 e0       	ldi	r21, 0x00	; 0
     122:	60 e0       	ldi	r22, 0x00	; 0
     124:	70 e0       	ldi	r23, 0x00	; 0
     126:	80 91 92 08 	lds	r24, 0x0892
     12a:	90 91 93 08 	lds	r25, 0x0893
     12e:	0e 94 38 05 	call	0xa70	; 0xa70 <xQueueGenericSend>
     132:	81 30       	cpi	r24, 0x01	; 1
     134:	21 f0       	breq	.+8      	; 0x13e <vEvenTask+0x98>
				USART_sendstr("Semaphore can not release by Even Task \r\n");
     136:	8d e3       	ldi	r24, 0x3D	; 61
     138:	91 e0       	ldi	r25, 0x01	; 1
     13a:	0e 94 9c 0c 	call	0x1938	; 0x1938 <USART_sendstr>
				
			vTaskDelayUntil(&xLastWakeTime, (100 / portTICK_PERIOD_MS));
     13e:	64 e6       	ldi	r22, 0x64	; 100
     140:	70 e0       	ldi	r23, 0x00	; 0
     142:	ce 01       	movw	r24, r28
     144:	01 96       	adiw	r24, 0x01	; 1
     146:	0e 94 ae 09 	call	0x135c	; 0x135c <vTaskDelayUntil>
     14a:	d2 cf       	rjmp	.-92     	; 0xf0 <vEvenTask+0x4a>

0000014c <vOddTask>:




static void vOddTask( void *pvParameters )
{
     14c:	cf 93       	push	r28
     14e:	df 93       	push	r29
     150:	00 d0       	rcall	.+0      	; 0x152 <vOddTask+0x6>
     152:	cd b7       	in	r28, 0x3d	; 61
     154:	de b7       	in	r29, 0x3e	; 62
  USART_sendstr("Start Odd Task \r\n");
     156:	82 e9       	ldi	r24, 0x92	; 146
     158:	91 e0       	ldi	r25, 0x01	; 1
     15a:	0e 94 9c 0c 	call	0x1938	; 0x1938 <USART_sendstr>
  TickType_t xLastWakeTime = xTaskGetTickCount();
     15e:	0e 94 65 08 	call	0x10ca	; 0x10ca <xTaskGetTickCount>
     162:	9a 83       	std	Y+2, r25	; 0x02
     164:	89 83       	std	Y+1, r24	; 0x01
    {
       /* Block waiting for the semaphore to become available. */
	   USART_sendstr("Odd \r\n");
        if( xSemaphoreTake(sem, LONG_TIME ) == pdTRUE )
        {
			PORTC = 0x55;
     166:	15 e5       	ldi	r17, 0x55	; 85
  TickType_t xLastWakeTime = xTaskGetTickCount();
	 
  for( ;; )
    {
       /* Block waiting for the semaphore to become available. */
	   USART_sendstr("Odd \r\n");
     168:	84 ea       	ldi	r24, 0xA4	; 164
     16a:	91 e0       	ldi	r25, 0x01	; 1
     16c:	0e 94 9c 0c 	call	0x1938	; 0x1938 <USART_sendstr>
        if( xSemaphoreTake(sem, LONG_TIME ) == pdTRUE )
     170:	20 e0       	ldi	r18, 0x00	; 0
     172:	4f ef       	ldi	r20, 0xFF	; 255
     174:	5f ef       	ldi	r21, 0xFF	; 255
     176:	60 e0       	ldi	r22, 0x00	; 0
     178:	70 e0       	ldi	r23, 0x00	; 0
     17a:	80 91 92 08 	lds	r24, 0x0892
     17e:	90 91 93 08 	lds	r25, 0x0893
     182:	0e 94 04 06 	call	0xc08	; 0xc08 <xQueueGenericReceive>
     186:	81 30       	cpi	r24, 0x01	; 1
     188:	79 f7       	brne	.-34     	; 0x168 <vOddTask+0x1c>
        {
			PORTC = 0x55;
     18a:	18 b9       	out	0x08, r17	; 8
            USART_sendstr("Semaphore is given to Odd Task \r\n");
     18c:	8b ea       	ldi	r24, 0xAB	; 171
     18e:	91 e0       	ldi	r25, 0x01	; 1
     190:	0e 94 9c 0c 	call	0x1938	; 0x1938 <USART_sendstr>
		    vTaskDelayUntil(&xLastWakeTime, (2000 / portTICK_PERIOD_MS));
     194:	60 ed       	ldi	r22, 0xD0	; 208
     196:	77 e0       	ldi	r23, 0x07	; 7
     198:	ce 01       	movw	r24, r28
     19a:	01 96       	adiw	r24, 0x01	; 1
     19c:	0e 94 ae 09 	call	0x135c	; 0x135c <vTaskDelayUntil>
     1a0:	e3 cf       	rjmp	.-58     	; 0x168 <vOddTask+0x1c>

000001a2 <vTimerISR>:
unsigned long lastInterrupt;


static void vTimerISR()
{
	if(xTaskGetTickCount() - lastInterrupt > 500) // we set a 10ms no-interrupts window
     1a2:	0e 94 65 08 	call	0x10ca	; 0x10ca <xTaskGetTickCount>
     1a6:	a0 e0       	ldi	r26, 0x00	; 0
     1a8:	b0 e0       	ldi	r27, 0x00	; 0
     1aa:	40 91 96 08 	lds	r20, 0x0896
     1ae:	50 91 97 08 	lds	r21, 0x0897
     1b2:	60 91 98 08 	lds	r22, 0x0898
     1b6:	70 91 99 08 	lds	r23, 0x0899
     1ba:	84 1b       	sub	r24, r20
     1bc:	95 0b       	sbc	r25, r21
     1be:	a6 0b       	sbc	r26, r22
     1c0:	b7 0b       	sbc	r27, r23
     1c2:	85 3f       	cpi	r24, 0xF5	; 245
     1c4:	91 40       	sbci	r25, 0x01	; 1
     1c6:	a1 05       	cpc	r26, r1
     1c8:	b1 05       	cpc	r27, r1
     1ca:	28 f1       	brcs	.+74     	; 0x216 <vTimerISR+0x74>
	{
    USART_sendstr("interrupt Happened \r\n");
     1cc:	8d ec       	ldi	r24, 0xCD	; 205
     1ce:	91 e0       	ldi	r25, 0x01	; 1
     1d0:	0e 94 9c 0c 	call	0x1938	; 0x1938 <USART_sendstr>
    /* A timer tick has occurred. */

    /*..Do other time functions..*/ 

    /* Is it time for vATask() to run? */
    xHigherPriorityTaskWoken = pdFALSE;
     1d4:	10 92 44 02 	sts	0x0244, r1
  
        /* Unblock the task by releasing the semaphore. */
    xSemaphoreGiveFromISR( sem, &xHigherPriorityTaskWoken);
     1d8:	64 e4       	ldi	r22, 0x44	; 68
     1da:	72 e0       	ldi	r23, 0x02	; 2
     1dc:	80 91 92 08 	lds	r24, 0x0892
     1e0:	90 91 93 08 	lds	r25, 0x0893
     1e4:	0e 94 d9 05 	call	0xbb2	; 0xbb2 <xQueueGiveFromISR>

    /* If xHigherPriorityTaskWoken was set to true you
    we should yield.  The actual macro used here is
    port specific. */
	
	lastInterrupt = xTaskGetTickCount();
     1e8:	0e 94 65 08 	call	0x10ca	; 0x10ca <xTaskGetTickCount>
     1ec:	a0 e0       	ldi	r26, 0x00	; 0
     1ee:	b0 e0       	ldi	r27, 0x00	; 0
     1f0:	80 93 96 08 	sts	0x0896, r24
     1f4:	90 93 97 08 	sts	0x0897, r25
     1f8:	a0 93 98 08 	sts	0x0898, r26
     1fc:	b0 93 99 08 	sts	0x0899, r27
	if(xHigherPriorityTaskWoken)
     200:	80 91 44 02 	lds	r24, 0x0244
     204:	88 23       	and	r24, r24
     206:	19 f0       	breq	.+6      	; 0x20e <vTimerISR+0x6c>
       vPortYield();
     208:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
     20c:	08 95       	ret
	else
	   USART_sendstr("No Higher Priority Task is Woken \r\n");
     20e:	83 ee       	ldi	r24, 0xE3	; 227
     210:	91 e0       	ldi	r25, 0x01	; 1
     212:	0e 94 9c 0c 	call	0x1938	; 0x1938 <USART_sendstr>
     216:	08 95       	ret

00000218 <main>:
TaskHandle_t TaskHandle_2;

SemaphoreHandle_t sem;
int main(void)
{ 
  cli();
     218:	f8 94       	cli
  attachInterrupt(0, vTimerISR, 1); 
     21a:	41 e0       	ldi	r20, 0x01	; 1
     21c:	50 e0       	ldi	r21, 0x00	; 0
     21e:	61 ed       	ldi	r22, 0xD1	; 209
     220:	70 e0       	ldi	r23, 0x00	; 0
     222:	80 e0       	ldi	r24, 0x00	; 0
     224:	0e 94 0b 0c 	call	0x1816	; 0x1816 <attachInterrupt>
  USART_init();
     228:	0e 94 88 0c 	call	0x1910	; 0x1910 <USART_init>
  sem =  xSemaphoreCreateBinary();
     22c:	43 e0       	ldi	r20, 0x03	; 3
     22e:	60 e0       	ldi	r22, 0x00	; 0
     230:	81 e0       	ldi	r24, 0x01	; 1
     232:	0e 94 0c 05 	call	0xa18	; 0xa18 <xQueueGenericCreate>
     236:	90 93 93 08 	sts	0x0893, r25
     23a:	80 93 92 08 	sts	0x0892, r24
  if(sem != NULL){
     23e:	89 2b       	or	r24, r25
     240:	61 f1       	breq	.+88     	; 0x29a <main+0x82>
    DDRC = 0xff;
     242:	8f ef       	ldi	r24, 0xFF	; 255
     244:	87 b9       	out	0x07, r24	; 7
	xTaskCreate( vOddTask, "Odd", 256, NULL, 1, &TaskHandle_1 );
     246:	a1 2c       	mov	r10, r1
     248:	b1 2c       	mov	r11, r1
     24a:	c1 2c       	mov	r12, r1
     24c:	d1 2c       	mov	r13, r1
     24e:	0f 2e       	mov	r0, r31
     250:	fa e9       	ldi	r31, 0x9A	; 154
     252:	ef 2e       	mov	r14, r31
     254:	f8 e0       	ldi	r31, 0x08	; 8
     256:	ff 2e       	mov	r15, r31
     258:	f0 2d       	mov	r31, r0
     25a:	01 e0       	ldi	r16, 0x01	; 1
     25c:	20 e0       	ldi	r18, 0x00	; 0
     25e:	30 e0       	ldi	r19, 0x00	; 0
     260:	40 e0       	ldi	r20, 0x00	; 0
     262:	51 e0       	ldi	r21, 0x01	; 1
     264:	67 e0       	ldi	r22, 0x07	; 7
     266:	72 e0       	ldi	r23, 0x02	; 2
     268:	86 ea       	ldi	r24, 0xA6	; 166
     26a:	90 e0       	ldi	r25, 0x00	; 0
     26c:	0e 94 1d 07 	call	0xe3a	; 0xe3a <xTaskGenericCreate>
	xTaskCreate( vEvenTask, "Even", 256, NULL, 3, &TaskHandle_2 );
     270:	0f 2e       	mov	r0, r31
     272:	f4 e9       	ldi	r31, 0x94	; 148
     274:	ef 2e       	mov	r14, r31
     276:	f8 e0       	ldi	r31, 0x08	; 8
     278:	ff 2e       	mov	r15, r31
     27a:	f0 2d       	mov	r31, r0
     27c:	03 e0       	ldi	r16, 0x03	; 3
     27e:	20 e0       	ldi	r18, 0x00	; 0
     280:	30 e0       	ldi	r19, 0x00	; 0
     282:	40 e0       	ldi	r20, 0x00	; 0
     284:	51 e0       	ldi	r21, 0x01	; 1
     286:	6b e0       	ldi	r22, 0x0B	; 11
     288:	72 e0       	ldi	r23, 0x02	; 2
     28a:	83 e5       	ldi	r24, 0x53	; 83
     28c:	90 e0       	ldi	r25, 0x00	; 0
     28e:	0e 94 1d 07 	call	0xe3a	; 0xe3a <xTaskGenericCreate>
	sei();
     292:	78 94       	sei
	vTaskStartScheduler();
     294:	0e 94 30 08 	call	0x1060	; 0x1060 <vTaskStartScheduler>
     298:	04 c0       	rjmp	.+8      	; 0x2a2 <main+0x8a>
	 }
  else
	   USART_sendstr("Semaphore not Created Correctly !!");
     29a:	80 e1       	ldi	r24, 0x10	; 16
     29c:	92 e0       	ldi	r25, 0x02	; 2
     29e:	0e 94 9c 0c 	call	0x1938	; 0x1938 <USART_sendstr>
	 
	for( ;; );
     2a2:	ff cf       	rjmp	.-2      	; 0x2a2 <main+0x8a>

000002a4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     2a4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2a6:	03 96       	adiw	r24, 0x03	; 3
     2a8:	92 83       	std	Z+2, r25	; 0x02
     2aa:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     2ac:	2f ef       	ldi	r18, 0xFF	; 255
     2ae:	3f ef       	ldi	r19, 0xFF	; 255
     2b0:	34 83       	std	Z+4, r19	; 0x04
     2b2:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2b4:	96 83       	std	Z+6, r25	; 0x06
     2b6:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2b8:	90 87       	std	Z+8, r25	; 0x08
     2ba:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     2bc:	10 82       	st	Z, r1
     2be:	08 95       	ret

000002c0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     2c0:	fc 01       	movw	r30, r24
     2c2:	11 86       	std	Z+9, r1	; 0x09
     2c4:	10 86       	std	Z+8, r1	; 0x08
     2c6:	08 95       	ret

000002c8 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     2c8:	cf 93       	push	r28
     2ca:	df 93       	push	r29
     2cc:	9c 01       	movw	r18, r24
     2ce:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     2d0:	dc 01       	movw	r26, r24
     2d2:	11 96       	adiw	r26, 0x01	; 1
     2d4:	cd 91       	ld	r28, X+
     2d6:	dc 91       	ld	r29, X
     2d8:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     2da:	d3 83       	std	Z+3, r29	; 0x03
     2dc:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     2de:	8c 81       	ldd	r24, Y+4	; 0x04
     2e0:	9d 81       	ldd	r25, Y+5	; 0x05
     2e2:	95 83       	std	Z+5, r25	; 0x05
     2e4:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     2e6:	8c 81       	ldd	r24, Y+4	; 0x04
     2e8:	9d 81       	ldd	r25, Y+5	; 0x05
     2ea:	dc 01       	movw	r26, r24
     2ec:	13 96       	adiw	r26, 0x03	; 3
     2ee:	7c 93       	st	X, r23
     2f0:	6e 93       	st	-X, r22
     2f2:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     2f4:	7d 83       	std	Y+5, r23	; 0x05
     2f6:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2f8:	31 87       	std	Z+9, r19	; 0x09
     2fa:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     2fc:	f9 01       	movw	r30, r18
     2fe:	80 81       	ld	r24, Z
     300:	8f 5f       	subi	r24, 0xFF	; 255
     302:	80 83       	st	Z, r24
}
     304:	df 91       	pop	r29
     306:	cf 91       	pop	r28
     308:	08 95       	ret

0000030a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     30a:	cf 93       	push	r28
     30c:	df 93       	push	r29
     30e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     310:	48 81       	ld	r20, Y
     312:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     314:	4f 3f       	cpi	r20, 0xFF	; 255
     316:	2f ef       	ldi	r18, 0xFF	; 255
     318:	52 07       	cpc	r21, r18
     31a:	21 f4       	brne	.+8      	; 0x324 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     31c:	fc 01       	movw	r30, r24
     31e:	a7 81       	ldd	r26, Z+7	; 0x07
     320:	b0 85       	ldd	r27, Z+8	; 0x08
     322:	0d c0       	rjmp	.+26     	; 0x33e <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     324:	dc 01       	movw	r26, r24
     326:	13 96       	adiw	r26, 0x03	; 3
     328:	01 c0       	rjmp	.+2      	; 0x32c <vListInsert+0x22>
     32a:	df 01       	movw	r26, r30
     32c:	12 96       	adiw	r26, 0x02	; 2
     32e:	ed 91       	ld	r30, X+
     330:	fc 91       	ld	r31, X
     332:	13 97       	sbiw	r26, 0x03	; 3
     334:	20 81       	ld	r18, Z
     336:	31 81       	ldd	r19, Z+1	; 0x01
     338:	42 17       	cp	r20, r18
     33a:	53 07       	cpc	r21, r19
     33c:	b0 f7       	brcc	.-20     	; 0x32a <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     33e:	12 96       	adiw	r26, 0x02	; 2
     340:	ed 91       	ld	r30, X+
     342:	fc 91       	ld	r31, X
     344:	13 97       	sbiw	r26, 0x03	; 3
     346:	fb 83       	std	Y+3, r31	; 0x03
     348:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     34a:	d5 83       	std	Z+5, r29	; 0x05
     34c:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     34e:	bd 83       	std	Y+5, r27	; 0x05
     350:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     352:	13 96       	adiw	r26, 0x03	; 3
     354:	dc 93       	st	X, r29
     356:	ce 93       	st	-X, r28
     358:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     35a:	99 87       	std	Y+9, r25	; 0x09
     35c:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     35e:	fc 01       	movw	r30, r24
     360:	20 81       	ld	r18, Z
     362:	2f 5f       	subi	r18, 0xFF	; 255
     364:	20 83       	st	Z, r18
}
     366:	df 91       	pop	r29
     368:	cf 91       	pop	r28
     36a:	08 95       	ret

0000036c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     36c:	cf 93       	push	r28
     36e:	df 93       	push	r29
     370:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     372:	a0 85       	ldd	r26, Z+8	; 0x08
     374:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     376:	c2 81       	ldd	r28, Z+2	; 0x02
     378:	d3 81       	ldd	r29, Z+3	; 0x03
     37a:	84 81       	ldd	r24, Z+4	; 0x04
     37c:	95 81       	ldd	r25, Z+5	; 0x05
     37e:	9d 83       	std	Y+5, r25	; 0x05
     380:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     382:	c4 81       	ldd	r28, Z+4	; 0x04
     384:	d5 81       	ldd	r29, Z+5	; 0x05
     386:	82 81       	ldd	r24, Z+2	; 0x02
     388:	93 81       	ldd	r25, Z+3	; 0x03
     38a:	9b 83       	std	Y+3, r25	; 0x03
     38c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     38e:	11 96       	adiw	r26, 0x01	; 1
     390:	cd 91       	ld	r28, X+
     392:	dc 91       	ld	r29, X
     394:	12 97       	sbiw	r26, 0x02	; 2
     396:	ce 17       	cp	r28, r30
     398:	df 07       	cpc	r29, r31
     39a:	31 f4       	brne	.+12     	; 0x3a8 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     39c:	8c 81       	ldd	r24, Y+4	; 0x04
     39e:	9d 81       	ldd	r25, Y+5	; 0x05
     3a0:	12 96       	adiw	r26, 0x02	; 2
     3a2:	9c 93       	st	X, r25
     3a4:	8e 93       	st	-X, r24
     3a6:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     3a8:	11 86       	std	Z+9, r1	; 0x09
     3aa:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     3ac:	8c 91       	ld	r24, X
     3ae:	81 50       	subi	r24, 0x01	; 1
     3b0:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     3b2:	df 91       	pop	r29
     3b4:	cf 91       	pop	r28
     3b6:	08 95       	ret

000003b8 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     3b8:	31 e1       	ldi	r19, 0x11	; 17
     3ba:	fc 01       	movw	r30, r24
     3bc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     3be:	31 97       	sbiw	r30, 0x01	; 1
     3c0:	22 e2       	ldi	r18, 0x22	; 34
     3c2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     3c4:	31 97       	sbiw	r30, 0x01	; 1
     3c6:	a3 e3       	ldi	r26, 0x33	; 51
     3c8:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     3ca:	31 97       	sbiw	r30, 0x01	; 1
     3cc:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     3ce:	31 97       	sbiw	r30, 0x01	; 1
     3d0:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     3d2:	31 97       	sbiw	r30, 0x01	; 1
     3d4:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     3d6:	31 97       	sbiw	r30, 0x01	; 1
     3d8:	60 e8       	ldi	r22, 0x80	; 128
     3da:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     3dc:	31 97       	sbiw	r30, 0x01	; 1
     3de:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     3e0:	31 97       	sbiw	r30, 0x01	; 1
     3e2:	62 e0       	ldi	r22, 0x02	; 2
     3e4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     3e6:	31 97       	sbiw	r30, 0x01	; 1
     3e8:	63 e0       	ldi	r22, 0x03	; 3
     3ea:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     3ec:	31 97       	sbiw	r30, 0x01	; 1
     3ee:	64 e0       	ldi	r22, 0x04	; 4
     3f0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     3f2:	31 97       	sbiw	r30, 0x01	; 1
     3f4:	65 e0       	ldi	r22, 0x05	; 5
     3f6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     3f8:	31 97       	sbiw	r30, 0x01	; 1
     3fa:	66 e0       	ldi	r22, 0x06	; 6
     3fc:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     3fe:	31 97       	sbiw	r30, 0x01	; 1
     400:	67 e0       	ldi	r22, 0x07	; 7
     402:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     404:	31 97       	sbiw	r30, 0x01	; 1
     406:	68 e0       	ldi	r22, 0x08	; 8
     408:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     40a:	31 97       	sbiw	r30, 0x01	; 1
     40c:	69 e0       	ldi	r22, 0x09	; 9
     40e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     410:	31 97       	sbiw	r30, 0x01	; 1
     412:	60 e1       	ldi	r22, 0x10	; 16
     414:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     416:	31 97       	sbiw	r30, 0x01	; 1
     418:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     41a:	31 97       	sbiw	r30, 0x01	; 1
     41c:	32 e1       	ldi	r19, 0x12	; 18
     41e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     420:	31 97       	sbiw	r30, 0x01	; 1
     422:	33 e1       	ldi	r19, 0x13	; 19
     424:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     426:	31 97       	sbiw	r30, 0x01	; 1
     428:	34 e1       	ldi	r19, 0x14	; 20
     42a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     42c:	31 97       	sbiw	r30, 0x01	; 1
     42e:	35 e1       	ldi	r19, 0x15	; 21
     430:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     432:	31 97       	sbiw	r30, 0x01	; 1
     434:	36 e1       	ldi	r19, 0x16	; 22
     436:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     438:	31 97       	sbiw	r30, 0x01	; 1
     43a:	37 e1       	ldi	r19, 0x17	; 23
     43c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     43e:	31 97       	sbiw	r30, 0x01	; 1
     440:	38 e1       	ldi	r19, 0x18	; 24
     442:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     444:	31 97       	sbiw	r30, 0x01	; 1
     446:	39 e1       	ldi	r19, 0x19	; 25
     448:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     44a:	31 97       	sbiw	r30, 0x01	; 1
     44c:	30 e2       	ldi	r19, 0x20	; 32
     44e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     450:	31 97       	sbiw	r30, 0x01	; 1
     452:	31 e2       	ldi	r19, 0x21	; 33
     454:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     456:	31 97       	sbiw	r30, 0x01	; 1
     458:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     45a:	31 97       	sbiw	r30, 0x01	; 1
     45c:	23 e2       	ldi	r18, 0x23	; 35
     45e:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     460:	31 97       	sbiw	r30, 0x01	; 1
     462:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     464:	31 97       	sbiw	r30, 0x01	; 1
     466:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     468:	31 97       	sbiw	r30, 0x01	; 1
     46a:	26 e2       	ldi	r18, 0x26	; 38
     46c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     46e:	31 97       	sbiw	r30, 0x01	; 1
     470:	27 e2       	ldi	r18, 0x27	; 39
     472:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     474:	31 97       	sbiw	r30, 0x01	; 1
     476:	28 e2       	ldi	r18, 0x28	; 40
     478:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     47a:	31 97       	sbiw	r30, 0x01	; 1
     47c:	29 e2       	ldi	r18, 0x29	; 41
     47e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     480:	31 97       	sbiw	r30, 0x01	; 1
     482:	20 e3       	ldi	r18, 0x30	; 48
     484:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     486:	31 97       	sbiw	r30, 0x01	; 1
     488:	21 e3       	ldi	r18, 0x31	; 49
     48a:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     48c:	86 97       	sbiw	r24, 0x26	; 38
     48e:	08 95       	ret

00000490 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     490:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
     494:	8c e7       	ldi	r24, 0x7C	; 124
     496:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     49a:	8b e0       	ldi	r24, 0x0B	; 11
     49c:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     4a0:	ef e6       	ldi	r30, 0x6F	; 111
     4a2:	f0 e0       	ldi	r31, 0x00	; 0
     4a4:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     4a6:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
     4a8:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     4aa:	a0 91 8c 08 	lds	r26, 0x088C
     4ae:	b0 91 8d 08 	lds	r27, 0x088D
     4b2:	cd 91       	ld	r28, X+
     4b4:	cd bf       	out	0x3d, r28	; 61
     4b6:	dd 91       	ld	r29, X+
     4b8:	de bf       	out	0x3e, r29	; 62
     4ba:	ff 91       	pop	r31
     4bc:	ef 91       	pop	r30
     4be:	df 91       	pop	r29
     4c0:	cf 91       	pop	r28
     4c2:	bf 91       	pop	r27
     4c4:	af 91       	pop	r26
     4c6:	9f 91       	pop	r25
     4c8:	8f 91       	pop	r24
     4ca:	7f 91       	pop	r23
     4cc:	6f 91       	pop	r22
     4ce:	5f 91       	pop	r21
     4d0:	4f 91       	pop	r20
     4d2:	3f 91       	pop	r19
     4d4:	2f 91       	pop	r18
     4d6:	1f 91       	pop	r17
     4d8:	0f 91       	pop	r16
     4da:	ff 90       	pop	r15
     4dc:	ef 90       	pop	r14
     4de:	df 90       	pop	r13
     4e0:	cf 90       	pop	r12
     4e2:	bf 90       	pop	r11
     4e4:	af 90       	pop	r10
     4e6:	9f 90       	pop	r9
     4e8:	8f 90       	pop	r8
     4ea:	7f 90       	pop	r7
     4ec:	6f 90       	pop	r6
     4ee:	5f 90       	pop	r5
     4f0:	4f 90       	pop	r4
     4f2:	3f 90       	pop	r3
     4f4:	2f 90       	pop	r2
     4f6:	1f 90       	pop	r1
     4f8:	0f 90       	pop	r0
     4fa:	0f be       	out	0x3f, r0	; 63
     4fc:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     4fe:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     500:	81 e0       	ldi	r24, 0x01	; 1
     502:	08 95       	ret

00000504 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     504:	0f 92       	push	r0
     506:	0f b6       	in	r0, 0x3f	; 63
     508:	f8 94       	cli
     50a:	0f 92       	push	r0
     50c:	1f 92       	push	r1
     50e:	11 24       	eor	r1, r1
     510:	2f 92       	push	r2
     512:	3f 92       	push	r3
     514:	4f 92       	push	r4
     516:	5f 92       	push	r5
     518:	6f 92       	push	r6
     51a:	7f 92       	push	r7
     51c:	8f 92       	push	r8
     51e:	9f 92       	push	r9
     520:	af 92       	push	r10
     522:	bf 92       	push	r11
     524:	cf 92       	push	r12
     526:	df 92       	push	r13
     528:	ef 92       	push	r14
     52a:	ff 92       	push	r15
     52c:	0f 93       	push	r16
     52e:	1f 93       	push	r17
     530:	2f 93       	push	r18
     532:	3f 93       	push	r19
     534:	4f 93       	push	r20
     536:	5f 93       	push	r21
     538:	6f 93       	push	r22
     53a:	7f 93       	push	r23
     53c:	8f 93       	push	r24
     53e:	9f 93       	push	r25
     540:	af 93       	push	r26
     542:	bf 93       	push	r27
     544:	cf 93       	push	r28
     546:	df 93       	push	r29
     548:	ef 93       	push	r30
     54a:	ff 93       	push	r31
     54c:	a0 91 8c 08 	lds	r26, 0x088C
     550:	b0 91 8d 08 	lds	r27, 0x088D
     554:	0d b6       	in	r0, 0x3d	; 61
     556:	0d 92       	st	X+, r0
     558:	0e b6       	in	r0, 0x3e	; 62
     55a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     55c:	0e 94 2d 0a 	call	0x145a	; 0x145a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     560:	a0 91 8c 08 	lds	r26, 0x088C
     564:	b0 91 8d 08 	lds	r27, 0x088D
     568:	cd 91       	ld	r28, X+
     56a:	cd bf       	out	0x3d, r28	; 61
     56c:	dd 91       	ld	r29, X+
     56e:	de bf       	out	0x3e, r29	; 62
     570:	ff 91       	pop	r31
     572:	ef 91       	pop	r30
     574:	df 91       	pop	r29
     576:	cf 91       	pop	r28
     578:	bf 91       	pop	r27
     57a:	af 91       	pop	r26
     57c:	9f 91       	pop	r25
     57e:	8f 91       	pop	r24
     580:	7f 91       	pop	r23
     582:	6f 91       	pop	r22
     584:	5f 91       	pop	r21
     586:	4f 91       	pop	r20
     588:	3f 91       	pop	r19
     58a:	2f 91       	pop	r18
     58c:	1f 91       	pop	r17
     58e:	0f 91       	pop	r16
     590:	ff 90       	pop	r15
     592:	ef 90       	pop	r14
     594:	df 90       	pop	r13
     596:	cf 90       	pop	r12
     598:	bf 90       	pop	r11
     59a:	af 90       	pop	r10
     59c:	9f 90       	pop	r9
     59e:	8f 90       	pop	r8
     5a0:	7f 90       	pop	r7
     5a2:	6f 90       	pop	r6
     5a4:	5f 90       	pop	r5
     5a6:	4f 90       	pop	r4
     5a8:	3f 90       	pop	r3
     5aa:	2f 90       	pop	r2
     5ac:	1f 90       	pop	r1
     5ae:	0f 90       	pop	r0
     5b0:	0f be       	out	0x3f, r0	; 63
     5b2:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5b4:	08 95       	ret

000005b6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     5b6:	0f 92       	push	r0
     5b8:	0f b6       	in	r0, 0x3f	; 63
     5ba:	f8 94       	cli
     5bc:	0f 92       	push	r0
     5be:	1f 92       	push	r1
     5c0:	11 24       	eor	r1, r1
     5c2:	2f 92       	push	r2
     5c4:	3f 92       	push	r3
     5c6:	4f 92       	push	r4
     5c8:	5f 92       	push	r5
     5ca:	6f 92       	push	r6
     5cc:	7f 92       	push	r7
     5ce:	8f 92       	push	r8
     5d0:	9f 92       	push	r9
     5d2:	af 92       	push	r10
     5d4:	bf 92       	push	r11
     5d6:	cf 92       	push	r12
     5d8:	df 92       	push	r13
     5da:	ef 92       	push	r14
     5dc:	ff 92       	push	r15
     5de:	0f 93       	push	r16
     5e0:	1f 93       	push	r17
     5e2:	2f 93       	push	r18
     5e4:	3f 93       	push	r19
     5e6:	4f 93       	push	r20
     5e8:	5f 93       	push	r21
     5ea:	6f 93       	push	r22
     5ec:	7f 93       	push	r23
     5ee:	8f 93       	push	r24
     5f0:	9f 93       	push	r25
     5f2:	af 93       	push	r26
     5f4:	bf 93       	push	r27
     5f6:	cf 93       	push	r28
     5f8:	df 93       	push	r29
     5fa:	ef 93       	push	r30
     5fc:	ff 93       	push	r31
     5fe:	a0 91 8c 08 	lds	r26, 0x088C
     602:	b0 91 8d 08 	lds	r27, 0x088D
     606:	0d b6       	in	r0, 0x3d	; 61
     608:	0d 92       	st	X+, r0
     60a:	0e b6       	in	r0, 0x3e	; 62
     60c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     60e:	0e 94 6f 08 	call	0x10de	; 0x10de <xTaskIncrementTick>
     612:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     614:	0e 94 2d 0a 	call	0x145a	; 0x145a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     618:	a0 91 8c 08 	lds	r26, 0x088C
     61c:	b0 91 8d 08 	lds	r27, 0x088D
     620:	cd 91       	ld	r28, X+
     622:	cd bf       	out	0x3d, r28	; 61
     624:	dd 91       	ld	r29, X+
     626:	de bf       	out	0x3e, r29	; 62
     628:	ff 91       	pop	r31
     62a:	ef 91       	pop	r30
     62c:	df 91       	pop	r29
     62e:	cf 91       	pop	r28
     630:	bf 91       	pop	r27
     632:	af 91       	pop	r26
     634:	9f 91       	pop	r25
     636:	8f 91       	pop	r24
     638:	7f 91       	pop	r23
     63a:	6f 91       	pop	r22
     63c:	5f 91       	pop	r21
     63e:	4f 91       	pop	r20
     640:	3f 91       	pop	r19
     642:	2f 91       	pop	r18
     644:	1f 91       	pop	r17
     646:	0f 91       	pop	r16
     648:	ff 90       	pop	r15
     64a:	ef 90       	pop	r14
     64c:	df 90       	pop	r13
     64e:	cf 90       	pop	r12
     650:	bf 90       	pop	r11
     652:	af 90       	pop	r10
     654:	9f 90       	pop	r9
     656:	8f 90       	pop	r8
     658:	7f 90       	pop	r7
     65a:	6f 90       	pop	r6
     65c:	5f 90       	pop	r5
     65e:	4f 90       	pop	r4
     660:	3f 90       	pop	r3
     662:	2f 90       	pop	r2
     664:	1f 90       	pop	r1
     666:	0f 90       	pop	r0
     668:	0f be       	out	0x3f, r0	; 63
     66a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     66c:	08 95       	ret

0000066e <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect(void) __attribute__ ((signal, naked));
	void TIMER1_COMPA_vect(void)
	{
		vPortYieldFromTick();
     66e:	0e 94 db 02 	call	0x5b6	; 0x5b6 <vPortYieldFromTick>
		asm volatile ( "reti" );
     672:	18 95       	reti

00000674 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     674:	0f 93       	push	r16
     676:	1f 93       	push	r17
     678:	cf 93       	push	r28
     67a:	df 93       	push	r29
     67c:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     67e:	0e 94 5f 08 	call	0x10be	; 0x10be <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     682:	80 91 45 02 	lds	r24, 0x0245
     686:	81 11       	cpse	r24, r1
     688:	1d c0       	rjmp	.+58     	; 0x6c4 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     68a:	ea e4       	ldi	r30, 0x4A	; 74
     68c:	f2 e0       	ldi	r31, 0x02	; 2
     68e:	8f e4       	ldi	r24, 0x4F	; 79
     690:	92 e0       	ldi	r25, 0x02	; 2
     692:	91 83       	std	Z+1, r25	; 0x01
     694:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     696:	13 82       	std	Z+3, r1	; 0x03
     698:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     69a:	e6 e4       	ldi	r30, 0x46	; 70
     69c:	f2 e0       	ldi	r31, 0x02	; 2
     69e:	8b ed       	ldi	r24, 0xDB	; 219
     6a0:	95 e0       	ldi	r25, 0x05	; 5
     6a2:	93 83       	std	Z+3, r25	; 0x03
     6a4:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     6a6:	11 82       	std	Z+1, r1	; 0x01
     6a8:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     6aa:	ae e4       	ldi	r26, 0x4E	; 78
     6ac:	b2 e0       	ldi	r27, 0x02	; 2
     6ae:	14 96       	adiw	r26, 0x04	; 4
     6b0:	9c 93       	st	X, r25
     6b2:	8e 93       	st	-X, r24
     6b4:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     6b6:	12 96       	adiw	r26, 0x02	; 2
     6b8:	fc 93       	st	X, r31
     6ba:	ee 93       	st	-X, r30
     6bc:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     6be:	81 e0       	ldi	r24, 0x01	; 1
     6c0:	80 93 45 02 	sts	0x0245, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     6c4:	20 97       	sbiw	r28, 0x00	; 0
     6c6:	09 f4       	brne	.+2      	; 0x6ca <pvPortMalloc+0x56>
     6c8:	5f c0       	rjmp	.+190    	; 0x788 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
     6ca:	9e 01       	movw	r18, r28
     6cc:	2c 5f       	subi	r18, 0xFC	; 252
     6ce:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     6d0:	23 96       	adiw	r28, 0x03	; 3
     6d2:	ca 3d       	cpi	r28, 0xDA	; 218
     6d4:	d5 40       	sbci	r29, 0x05	; 5
     6d6:	08 f0       	brcs	.+2      	; 0x6da <pvPortMalloc+0x66>
     6d8:	5a c0       	rjmp	.+180    	; 0x78e <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     6da:	e0 91 4a 02 	lds	r30, 0x024A
     6de:	f0 91 4b 02 	lds	r31, 0x024B

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     6e2:	aa e4       	ldi	r26, 0x4A	; 74
     6e4:	b2 e0       	ldi	r27, 0x02	; 2
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     6e6:	02 c0       	rjmp	.+4      	; 0x6ec <pvPortMalloc+0x78>
     6e8:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     6ea:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     6ec:	82 81       	ldd	r24, Z+2	; 0x02
     6ee:	93 81       	ldd	r25, Z+3	; 0x03
     6f0:	82 17       	cp	r24, r18
     6f2:	93 07       	cpc	r25, r19
     6f4:	20 f4       	brcc	.+8      	; 0x6fe <pvPortMalloc+0x8a>
     6f6:	80 81       	ld	r24, Z
     6f8:	91 81       	ldd	r25, Z+1	; 0x01
     6fa:	00 97       	sbiw	r24, 0x00	; 0
     6fc:	a9 f7       	brne	.-22     	; 0x6e8 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     6fe:	c2 e0       	ldi	r28, 0x02	; 2
     700:	e6 34       	cpi	r30, 0x46	; 70
     702:	fc 07       	cpc	r31, r28
     704:	09 f4       	brne	.+2      	; 0x708 <pvPortMalloc+0x94>
     706:	46 c0       	rjmp	.+140    	; 0x794 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     708:	cd 91       	ld	r28, X+
     70a:	dc 91       	ld	r29, X
     70c:	11 97       	sbiw	r26, 0x01	; 1
     70e:	8e 01       	movw	r16, r28
     710:	0c 5f       	subi	r16, 0xFC	; 252
     712:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     714:	80 81       	ld	r24, Z
     716:	91 81       	ldd	r25, Z+1	; 0x01
     718:	8d 93       	st	X+, r24
     71a:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     71c:	82 81       	ldd	r24, Z+2	; 0x02
     71e:	93 81       	ldd	r25, Z+3	; 0x03
     720:	82 1b       	sub	r24, r18
     722:	93 0b       	sbc	r25, r19
     724:	89 30       	cpi	r24, 0x09	; 9
     726:	91 05       	cpc	r25, r1
     728:	10 f1       	brcs	.+68     	; 0x76e <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     72a:	bf 01       	movw	r22, r30
     72c:	62 0f       	add	r22, r18
     72e:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     730:	db 01       	movw	r26, r22
     732:	13 96       	adiw	r26, 0x03	; 3
     734:	9c 93       	st	X, r25
     736:	8e 93       	st	-X, r24
     738:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     73a:	33 83       	std	Z+3, r19	; 0x03
     73c:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     73e:	12 96       	adiw	r26, 0x02	; 2
     740:	4d 91       	ld	r20, X+
     742:	5c 91       	ld	r21, X
     744:	13 97       	sbiw	r26, 0x03	; 3
     746:	8a e4       	ldi	r24, 0x4A	; 74
     748:	92 e0       	ldi	r25, 0x02	; 2
     74a:	01 c0       	rjmp	.+2      	; 0x74e <pvPortMalloc+0xda>
     74c:	cd 01       	movw	r24, r26
     74e:	ec 01       	movw	r28, r24
     750:	a8 81       	ld	r26, Y
     752:	b9 81       	ldd	r27, Y+1	; 0x01
     754:	12 96       	adiw	r26, 0x02	; 2
     756:	2d 91       	ld	r18, X+
     758:	3c 91       	ld	r19, X
     75a:	13 97       	sbiw	r26, 0x03	; 3
     75c:	24 17       	cp	r18, r20
     75e:	35 07       	cpc	r19, r21
     760:	a8 f3       	brcs	.-22     	; 0x74c <pvPortMalloc+0xd8>
     762:	eb 01       	movw	r28, r22
     764:	b9 83       	std	Y+1, r27	; 0x01
     766:	a8 83       	st	Y, r26
     768:	dc 01       	movw	r26, r24
     76a:	6d 93       	st	X+, r22
     76c:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     76e:	80 91 00 01 	lds	r24, 0x0100
     772:	90 91 01 01 	lds	r25, 0x0101
     776:	22 81       	ldd	r18, Z+2	; 0x02
     778:	33 81       	ldd	r19, Z+3	; 0x03
     77a:	82 1b       	sub	r24, r18
     77c:	93 0b       	sbc	r25, r19
     77e:	90 93 01 01 	sts	0x0101, r25
     782:	80 93 00 01 	sts	0x0100, r24
     786:	08 c0       	rjmp	.+16     	; 0x798 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     788:	00 e0       	ldi	r16, 0x00	; 0
     78a:	10 e0       	ldi	r17, 0x00	; 0
     78c:	05 c0       	rjmp	.+10     	; 0x798 <pvPortMalloc+0x124>
     78e:	00 e0       	ldi	r16, 0x00	; 0
     790:	10 e0       	ldi	r17, 0x00	; 0
     792:	02 c0       	rjmp	.+4      	; 0x798 <pvPortMalloc+0x124>
     794:	00 e0       	ldi	r16, 0x00	; 0
     796:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     798:	0e 94 2c 09 	call	0x1258	; 0x1258 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     79c:	c8 01       	movw	r24, r16
     79e:	df 91       	pop	r29
     7a0:	cf 91       	pop	r28
     7a2:	1f 91       	pop	r17
     7a4:	0f 91       	pop	r16
     7a6:	08 95       	ret

000007a8 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     7a8:	0f 93       	push	r16
     7aa:	1f 93       	push	r17
     7ac:	cf 93       	push	r28
     7ae:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     7b0:	00 97       	sbiw	r24, 0x00	; 0
     7b2:	41 f1       	breq	.+80     	; 0x804 <vPortFree+0x5c>
     7b4:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     7b6:	8c 01       	movw	r16, r24
     7b8:	04 50       	subi	r16, 0x04	; 4
     7ba:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     7bc:	0e 94 5f 08 	call	0x10be	; 0x10be <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     7c0:	f8 01       	movw	r30, r16
     7c2:	42 81       	ldd	r20, Z+2	; 0x02
     7c4:	53 81       	ldd	r21, Z+3	; 0x03
     7c6:	aa e4       	ldi	r26, 0x4A	; 74
     7c8:	b2 e0       	ldi	r27, 0x02	; 2
     7ca:	01 c0       	rjmp	.+2      	; 0x7ce <vPortFree+0x26>
     7cc:	df 01       	movw	r26, r30
     7ce:	ed 91       	ld	r30, X+
     7d0:	fc 91       	ld	r31, X
     7d2:	11 97       	sbiw	r26, 0x01	; 1
     7d4:	22 81       	ldd	r18, Z+2	; 0x02
     7d6:	33 81       	ldd	r19, Z+3	; 0x03
     7d8:	24 17       	cp	r18, r20
     7da:	35 07       	cpc	r19, r21
     7dc:	b8 f3       	brcs	.-18     	; 0x7cc <vPortFree+0x24>
     7de:	24 97       	sbiw	r28, 0x04	; 4
     7e0:	f9 83       	std	Y+1, r31	; 0x01
     7e2:	e8 83       	st	Y, r30
     7e4:	0d 93       	st	X+, r16
     7e6:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     7e8:	20 91 00 01 	lds	r18, 0x0100
     7ec:	30 91 01 01 	lds	r19, 0x0101
     7f0:	8a 81       	ldd	r24, Y+2	; 0x02
     7f2:	9b 81       	ldd	r25, Y+3	; 0x03
     7f4:	82 0f       	add	r24, r18
     7f6:	93 1f       	adc	r25, r19
     7f8:	90 93 01 01 	sts	0x0101, r25
     7fc:	80 93 00 01 	sts	0x0100, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     800:	0e 94 2c 09 	call	0x1258	; 0x1258 <xTaskResumeAll>
	}
}
     804:	df 91       	pop	r29
     806:	cf 91       	pop	r28
     808:	1f 91       	pop	r17
     80a:	0f 91       	pop	r16
     80c:	08 95       	ret

0000080e <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     80e:	1f 93       	push	r17
     810:	cf 93       	push	r28
     812:	df 93       	push	r29
     814:	ec 01       	movw	r28, r24
     816:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     818:	8c 8d       	ldd	r24, Y+28	; 0x1c
     81a:	81 11       	cpse	r24, r1
     81c:	0c c0       	rjmp	.+24     	; 0x836 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     81e:	88 81       	ld	r24, Y
     820:	99 81       	ldd	r25, Y+1	; 0x01
     822:	89 2b       	or	r24, r25
     824:	09 f0       	breq	.+2      	; 0x828 <prvCopyDataToQueue+0x1a>
     826:	47 c0       	rjmp	.+142    	; 0x8b6 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     828:	8a 81       	ldd	r24, Y+2	; 0x02
     82a:	9b 81       	ldd	r25, Y+3	; 0x03
     82c:	0e 94 b9 0b 	call	0x1772	; 0x1772 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     830:	1b 82       	std	Y+3, r1	; 0x03
     832:	1a 82       	std	Y+2, r1	; 0x02
     834:	47 c0       	rjmp	.+142    	; 0x8c4 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     836:	41 11       	cpse	r20, r1
     838:	18 c0       	rjmp	.+48     	; 0x86a <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     83a:	48 2f       	mov	r20, r24
     83c:	50 e0       	ldi	r21, 0x00	; 0
     83e:	8c 81       	ldd	r24, Y+4	; 0x04
     840:	9d 81       	ldd	r25, Y+5	; 0x05
     842:	0e 94 ab 0c 	call	0x1956	; 0x1956 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     846:	2c 8d       	ldd	r18, Y+28	; 0x1c
     848:	8c 81       	ldd	r24, Y+4	; 0x04
     84a:	9d 81       	ldd	r25, Y+5	; 0x05
     84c:	82 0f       	add	r24, r18
     84e:	91 1d       	adc	r25, r1
     850:	9d 83       	std	Y+5, r25	; 0x05
     852:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     854:	2a 81       	ldd	r18, Y+2	; 0x02
     856:	3b 81       	ldd	r19, Y+3	; 0x03
     858:	82 17       	cp	r24, r18
     85a:	93 07       	cpc	r25, r19
     85c:	70 f1       	brcs	.+92     	; 0x8ba <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     85e:	88 81       	ld	r24, Y
     860:	99 81       	ldd	r25, Y+1	; 0x01
     862:	9d 83       	std	Y+5, r25	; 0x05
     864:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     866:	80 e0       	ldi	r24, 0x00	; 0
     868:	2d c0       	rjmp	.+90     	; 0x8c4 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     86a:	48 2f       	mov	r20, r24
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	8e 81       	ldd	r24, Y+6	; 0x06
     870:	9f 81       	ldd	r25, Y+7	; 0x07
     872:	0e 94 ab 0c 	call	0x1956	; 0x1956 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     876:	8c 8d       	ldd	r24, Y+28	; 0x1c
     878:	90 e0       	ldi	r25, 0x00	; 0
     87a:	91 95       	neg	r25
     87c:	81 95       	neg	r24
     87e:	91 09       	sbc	r25, r1
     880:	2e 81       	ldd	r18, Y+6	; 0x06
     882:	3f 81       	ldd	r19, Y+7	; 0x07
     884:	28 0f       	add	r18, r24
     886:	39 1f       	adc	r19, r25
     888:	3f 83       	std	Y+7, r19	; 0x07
     88a:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     88c:	48 81       	ld	r20, Y
     88e:	59 81       	ldd	r21, Y+1	; 0x01
     890:	24 17       	cp	r18, r20
     892:	35 07       	cpc	r19, r21
     894:	30 f4       	brcc	.+12     	; 0x8a2 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     896:	2a 81       	ldd	r18, Y+2	; 0x02
     898:	3b 81       	ldd	r19, Y+3	; 0x03
     89a:	82 0f       	add	r24, r18
     89c:	93 1f       	adc	r25, r19
     89e:	9f 83       	std	Y+7, r25	; 0x07
     8a0:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     8a2:	12 30       	cpi	r17, 0x02	; 2
     8a4:	61 f4       	brne	.+24     	; 0x8be <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     8a6:	8a 8d       	ldd	r24, Y+26	; 0x1a
     8a8:	88 23       	and	r24, r24
     8aa:	59 f0       	breq	.+22     	; 0x8c2 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
     8ac:	8a 8d       	ldd	r24, Y+26	; 0x1a
     8ae:	81 50       	subi	r24, 0x01	; 1
     8b0:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     8b2:	80 e0       	ldi	r24, 0x00	; 0
     8b4:	07 c0       	rjmp	.+14     	; 0x8c4 <prvCopyDataToQueue+0xb6>
     8b6:	80 e0       	ldi	r24, 0x00	; 0
     8b8:	05 c0       	rjmp	.+10     	; 0x8c4 <prvCopyDataToQueue+0xb6>
     8ba:	80 e0       	ldi	r24, 0x00	; 0
     8bc:	03 c0       	rjmp	.+6      	; 0x8c4 <prvCopyDataToQueue+0xb6>
     8be:	80 e0       	ldi	r24, 0x00	; 0
     8c0:	01 c0       	rjmp	.+2      	; 0x8c4 <prvCopyDataToQueue+0xb6>
     8c2:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
     8c4:	9a 8d       	ldd	r25, Y+26	; 0x1a
     8c6:	9f 5f       	subi	r25, 0xFF	; 255
     8c8:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
     8ca:	df 91       	pop	r29
     8cc:	cf 91       	pop	r28
     8ce:	1f 91       	pop	r17
     8d0:	08 95       	ret

000008d2 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     8d2:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     8d4:	44 8d       	ldd	r20, Z+28	; 0x1c
     8d6:	44 23       	and	r20, r20
     8d8:	a9 f0       	breq	.+42     	; 0x904 <__stack+0x5>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     8da:	50 e0       	ldi	r21, 0x00	; 0
     8dc:	26 81       	ldd	r18, Z+6	; 0x06
     8de:	37 81       	ldd	r19, Z+7	; 0x07
     8e0:	24 0f       	add	r18, r20
     8e2:	35 1f       	adc	r19, r21
     8e4:	37 83       	std	Z+7, r19	; 0x07
     8e6:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     8e8:	82 81       	ldd	r24, Z+2	; 0x02
     8ea:	93 81       	ldd	r25, Z+3	; 0x03
     8ec:	28 17       	cp	r18, r24
     8ee:	39 07       	cpc	r19, r25
     8f0:	20 f0       	brcs	.+8      	; 0x8fa <prvCopyDataFromQueue+0x28>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     8f2:	80 81       	ld	r24, Z
     8f4:	91 81       	ldd	r25, Z+1	; 0x01
     8f6:	97 83       	std	Z+7, r25	; 0x07
     8f8:	86 83       	std	Z+6, r24	; 0x06
     8fa:	cb 01       	movw	r24, r22
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     8fc:	66 81       	ldd	r22, Z+6	; 0x06
     8fe:	77 81       	ldd	r23, Z+7	; 0x07
     900:	0e 94 ab 0c 	call	0x1956	; 0x1956 <memcpy>
     904:	08 95       	ret

00000906 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     906:	0f 93       	push	r16
     908:	1f 93       	push	r17
     90a:	cf 93       	push	r28
     90c:	df 93       	push	r29
     90e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     910:	0f b6       	in	r0, 0x3f	; 63
     912:	f8 94       	cli
     914:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     916:	8e 8d       	ldd	r24, Y+30	; 0x1e
     918:	18 16       	cp	r1, r24
     91a:	bc f4       	brge	.+46     	; 0x94a <prvUnlockQueue+0x44>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     91c:	89 89       	ldd	r24, Y+17	; 0x11
     91e:	81 11       	cpse	r24, r1
     920:	05 c0       	rjmp	.+10     	; 0x92c <prvUnlockQueue+0x26>
     922:	13 c0       	rjmp	.+38     	; 0x94a <prvUnlockQueue+0x44>
     924:	99 89       	ldd	r25, Y+17	; 0x11
     926:	91 11       	cpse	r25, r1
     928:	04 c0       	rjmp	.+8      	; 0x932 <prvUnlockQueue+0x2c>
     92a:	0f c0       	rjmp	.+30     	; 0x94a <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     92c:	8e 01       	movw	r16, r28
     92e:	0f 5e       	subi	r16, 0xEF	; 239
     930:	1f 4f       	sbci	r17, 0xFF	; 255
     932:	c8 01       	movw	r24, r16
     934:	0e 94 c7 0a 	call	0x158e	; 0x158e <xTaskRemoveFromEventList>
     938:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
     93a:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
     93e:	9e 8d       	ldd	r25, Y+30	; 0x1e
     940:	91 50       	subi	r25, 0x01	; 1
     942:	9e 8f       	std	Y+30, r25	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     944:	9e 8d       	ldd	r25, Y+30	; 0x1e
     946:	19 16       	cp	r1, r25
     948:	6c f3       	brlt	.-38     	; 0x924 <prvUnlockQueue+0x1e>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
     94a:	8f ef       	ldi	r24, 0xFF	; 255
     94c:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     94e:	0f 90       	pop	r0
     950:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     952:	0f b6       	in	r0, 0x3f	; 63
     954:	f8 94       	cli
     956:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     958:	8d 8d       	ldd	r24, Y+29	; 0x1d
     95a:	18 16       	cp	r1, r24
     95c:	bc f4       	brge	.+46     	; 0x98c <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     95e:	88 85       	ldd	r24, Y+8	; 0x08
     960:	81 11       	cpse	r24, r1
     962:	05 c0       	rjmp	.+10     	; 0x96e <prvUnlockQueue+0x68>
     964:	13 c0       	rjmp	.+38     	; 0x98c <prvUnlockQueue+0x86>
     966:	98 85       	ldd	r25, Y+8	; 0x08
     968:	91 11       	cpse	r25, r1
     96a:	04 c0       	rjmp	.+8      	; 0x974 <prvUnlockQueue+0x6e>
     96c:	0f c0       	rjmp	.+30     	; 0x98c <prvUnlockQueue+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     96e:	8e 01       	movw	r16, r28
     970:	08 5f       	subi	r16, 0xF8	; 248
     972:	1f 4f       	sbci	r17, 0xFF	; 255
     974:	c8 01       	movw	r24, r16
     976:	0e 94 c7 0a 	call	0x158e	; 0x158e <xTaskRemoveFromEventList>
     97a:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     97c:	0e 94 53 0b 	call	0x16a6	; 0x16a6 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
     980:	9d 8d       	ldd	r25, Y+29	; 0x1d
     982:	91 50       	subi	r25, 0x01	; 1
     984:	9d 8f       	std	Y+29, r25	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     986:	9d 8d       	ldd	r25, Y+29	; 0x1d
     988:	19 16       	cp	r1, r25
     98a:	6c f3       	brlt	.-38     	; 0x966 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     98c:	8f ef       	ldi	r24, 0xFF	; 255
     98e:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     990:	0f 90       	pop	r0
     992:	0f be       	out	0x3f, r0	; 63
}
     994:	df 91       	pop	r29
     996:	cf 91       	pop	r28
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	08 95       	ret

0000099e <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     99e:	cf 93       	push	r28
     9a0:	df 93       	push	r29
     9a2:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     9a4:	0f b6       	in	r0, 0x3f	; 63
     9a6:	f8 94       	cli
     9a8:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     9aa:	48 81       	ld	r20, Y
     9ac:	59 81       	ldd	r21, Y+1	; 0x01
     9ae:	2c 8d       	ldd	r18, Y+28	; 0x1c
     9b0:	30 e0       	ldi	r19, 0x00	; 0
     9b2:	7b 8d       	ldd	r23, Y+27	; 0x1b
     9b4:	72 9f       	mul	r23, r18
     9b6:	c0 01       	movw	r24, r0
     9b8:	73 9f       	mul	r23, r19
     9ba:	90 0d       	add	r25, r0
     9bc:	11 24       	eor	r1, r1
     9be:	fa 01       	movw	r30, r20
     9c0:	e8 0f       	add	r30, r24
     9c2:	f9 1f       	adc	r31, r25
     9c4:	fb 83       	std	Y+3, r31	; 0x03
     9c6:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     9c8:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     9ca:	5d 83       	std	Y+5, r21	; 0x05
     9cc:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     9ce:	82 1b       	sub	r24, r18
     9d0:	93 0b       	sbc	r25, r19
     9d2:	84 0f       	add	r24, r20
     9d4:	95 1f       	adc	r25, r21
     9d6:	9f 83       	std	Y+7, r25	; 0x07
     9d8:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     9da:	8f ef       	ldi	r24, 0xFF	; 255
     9dc:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     9de:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     9e0:	61 11       	cpse	r22, r1
     9e2:	0c c0       	rjmp	.+24     	; 0x9fc <xQueueGenericReset+0x5e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     9e4:	88 85       	ldd	r24, Y+8	; 0x08
     9e6:	88 23       	and	r24, r24
     9e8:	89 f0       	breq	.+34     	; 0xa0c <xQueueGenericReset+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     9ea:	ce 01       	movw	r24, r28
     9ec:	08 96       	adiw	r24, 0x08	; 8
     9ee:	0e 94 c7 0a 	call	0x158e	; 0x158e <xTaskRemoveFromEventList>
     9f2:	81 30       	cpi	r24, 0x01	; 1
     9f4:	59 f4       	brne	.+22     	; 0xa0c <xQueueGenericReset+0x6e>
				{
					queueYIELD_IF_USING_PREEMPTION();
     9f6:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
     9fa:	08 c0       	rjmp	.+16     	; 0xa0c <xQueueGenericReset+0x6e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     9fc:	ce 01       	movw	r24, r28
     9fe:	08 96       	adiw	r24, 0x08	; 8
     a00:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     a04:	ce 01       	movw	r24, r28
     a06:	41 96       	adiw	r24, 0x11	; 17
     a08:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     a0c:	0f 90       	pop	r0
     a0e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     a10:	81 e0       	ldi	r24, 0x01	; 1
     a12:	df 91       	pop	r29
     a14:	cf 91       	pop	r28
     a16:	08 95       	ret

00000a18 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
     a18:	0f 93       	push	r16
     a1a:	1f 93       	push	r17
     a1c:	cf 93       	push	r28
     a1e:	df 93       	push	r29
     a20:	08 2f       	mov	r16, r24
     a22:	16 2f       	mov	r17, r22
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
     a24:	66 23       	and	r22, r22
     a26:	b9 f0       	breq	.+46     	; 0xa56 <xQueueGenericCreate+0x3e>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     a28:	86 9f       	mul	r24, r22
     a2a:	c0 01       	movw	r24, r0
     a2c:	11 24       	eor	r1, r1
	}

	/* Allocate the new queue structure and storage area. */
	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     a2e:	80 96       	adiw	r24, 0x20	; 32
     a30:	0e 94 3a 03 	call	0x674	; 0x674 <pvPortMalloc>
     a34:	ec 01       	movw	r28, r24

	if( pcAllocatedBuffer != NULL )
     a36:	00 97       	sbiw	r24, 0x00	; 0
     a38:	21 f4       	brne	.+8      	; 0xa42 <xQueueGenericCreate+0x2a>
     a3a:	14 c0       	rjmp	.+40     	; 0xa64 <xQueueGenericCreate+0x4c>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     a3c:	d9 83       	std	Y+1, r29	; 0x01
     a3e:	c8 83       	st	Y, r28
     a40:	03 c0       	rjmp	.+6      	; 0xa48 <xQueueGenericCreate+0x30>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area - adding the padding bytes to get a better alignment. */
			pxNewQueue->pcHead = pcAllocatedBuffer + sizeof( Queue_t );
     a42:	4f 96       	adiw	r24, 0x1f	; 31
     a44:	99 83       	std	Y+1, r25	; 0x01
     a46:	88 83       	st	Y, r24
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
     a48:	0b 8f       	std	Y+27, r16	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
     a4a:	1c 8f       	std	Y+28, r17	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     a4c:	61 e0       	ldi	r22, 0x01	; 1
     a4e:	ce 01       	movw	r24, r28
     a50:	0e 94 cf 04 	call	0x99e	; 0x99e <xQueueGenericReset>
     a54:	07 c0       	rjmp	.+14     	; 0xa64 <xQueueGenericCreate+0x4c>
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}

	/* Allocate the new queue structure and storage area. */
	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     a56:	8f e1       	ldi	r24, 0x1F	; 31
     a58:	90 e0       	ldi	r25, 0x00	; 0
     a5a:	0e 94 3a 03 	call	0x674	; 0x674 <pvPortMalloc>
     a5e:	ec 01       	movw	r28, r24

	if( pcAllocatedBuffer != NULL )
     a60:	89 2b       	or	r24, r25
     a62:	61 f7       	brne	.-40     	; 0xa3c <xQueueGenericCreate+0x24>
	}

	configASSERT( xReturn );

	return xReturn;
}
     a64:	ce 01       	movw	r24, r28
     a66:	df 91       	pop	r29
     a68:	cf 91       	pop	r28
     a6a:	1f 91       	pop	r17
     a6c:	0f 91       	pop	r16
     a6e:	08 95       	ret

00000a70 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     a70:	9f 92       	push	r9
     a72:	af 92       	push	r10
     a74:	bf 92       	push	r11
     a76:	cf 92       	push	r12
     a78:	df 92       	push	r13
     a7a:	ef 92       	push	r14
     a7c:	ff 92       	push	r15
     a7e:	0f 93       	push	r16
     a80:	1f 93       	push	r17
     a82:	cf 93       	push	r28
     a84:	df 93       	push	r29
     a86:	00 d0       	rcall	.+0      	; 0xa88 <xQueueGenericSend+0x18>
     a88:	00 d0       	rcall	.+0      	; 0xa8a <xQueueGenericSend+0x1a>
     a8a:	1f 92       	push	r1
     a8c:	cd b7       	in	r28, 0x3d	; 61
     a8e:	de b7       	in	r29, 0x3e	; 62
     a90:	8c 01       	movw	r16, r24
     a92:	6b 01       	movw	r12, r22
     a94:	5d 83       	std	Y+5, r21	; 0x05
     a96:	4c 83       	std	Y+4, r20	; 0x04
     a98:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
     a9a:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     a9c:	99 24       	eor	r9, r9
     a9e:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     aa0:	7c 01       	movw	r14, r24
     aa2:	88 e0       	ldi	r24, 0x08	; 8
     aa4:	e8 0e       	add	r14, r24
     aa6:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     aa8:	0f b6       	in	r0, 0x3f	; 63
     aaa:	f8 94       	cli
     aac:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     aae:	f8 01       	movw	r30, r16
     ab0:	32 8d       	ldd	r19, Z+26	; 0x1a
     ab2:	93 8d       	ldd	r25, Z+27	; 0x1b
     ab4:	39 17       	cp	r19, r25
     ab6:	18 f0       	brcs	.+6      	; 0xabe <xQueueGenericSend+0x4e>
     ab8:	f2 e0       	ldi	r31, 0x02	; 2
     aba:	af 12       	cpse	r10, r31
     abc:	19 c0       	rjmp	.+50     	; 0xaf0 <xQueueGenericSend+0x80>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     abe:	4a 2d       	mov	r20, r10
     ac0:	b6 01       	movw	r22, r12
     ac2:	c8 01       	movw	r24, r16
     ac4:	0e 94 07 04 	call	0x80e	; 0x80e <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ac8:	f8 01       	movw	r30, r16
     aca:	91 89       	ldd	r25, Z+17	; 0x11
     acc:	99 23       	and	r25, r25
     ace:	49 f0       	breq	.+18     	; 0xae2 <xQueueGenericSend+0x72>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     ad0:	c8 01       	movw	r24, r16
     ad2:	41 96       	adiw	r24, 0x11	; 17
     ad4:	0e 94 c7 0a 	call	0x158e	; 0x158e <xTaskRemoveFromEventList>
     ad8:	81 30       	cpi	r24, 0x01	; 1
     ada:	31 f4       	brne	.+12     	; 0xae8 <xQueueGenericSend+0x78>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
     adc:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
     ae0:	03 c0       	rjmp	.+6      	; 0xae8 <xQueueGenericSend+0x78>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
     ae2:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
     ae4:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     ae8:	0f 90       	pop	r0
     aea:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     aec:	81 e0       	ldi	r24, 0x01	; 1
     aee:	50 c0       	rjmp	.+160    	; 0xb90 <xQueueGenericSend+0x120>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     af0:	ec 81       	ldd	r30, Y+4	; 0x04
     af2:	fd 81       	ldd	r31, Y+5	; 0x05
     af4:	ef 2b       	or	r30, r31
     af6:	21 f4       	brne	.+8      	; 0xb00 <xQueueGenericSend+0x90>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     af8:	0f 90       	pop	r0
     afa:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     afc:	80 e0       	ldi	r24, 0x00	; 0
     afe:	48 c0       	rjmp	.+144    	; 0xb90 <xQueueGenericSend+0x120>
				}
				else if( xEntryTimeSet == pdFALSE )
     b00:	b1 10       	cpse	r11, r1
     b02:	05 c0       	rjmp	.+10     	; 0xb0e <xQueueGenericSend+0x9e>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     b04:	ce 01       	movw	r24, r28
     b06:	01 96       	adiw	r24, 0x01	; 1
     b08:	0e 94 0f 0b 	call	0x161e	; 0x161e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     b0c:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     b0e:	0f 90       	pop	r0
     b10:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     b12:	0e 94 5f 08 	call	0x10be	; 0x10be <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     b16:	0f b6       	in	r0, 0x3f	; 63
     b18:	f8 94       	cli
     b1a:	0f 92       	push	r0
     b1c:	f8 01       	movw	r30, r16
     b1e:	85 8d       	ldd	r24, Z+29	; 0x1d
     b20:	8f 3f       	cpi	r24, 0xFF	; 255
     b22:	09 f4       	brne	.+2      	; 0xb26 <xQueueGenericSend+0xb6>
     b24:	15 8e       	std	Z+29, r1	; 0x1d
     b26:	f8 01       	movw	r30, r16
     b28:	86 8d       	ldd	r24, Z+30	; 0x1e
     b2a:	8f 3f       	cpi	r24, 0xFF	; 255
     b2c:	09 f4       	brne	.+2      	; 0xb30 <xQueueGenericSend+0xc0>
     b2e:	16 8e       	std	Z+30, r1	; 0x1e
     b30:	0f 90       	pop	r0
     b32:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b34:	be 01       	movw	r22, r28
     b36:	6c 5f       	subi	r22, 0xFC	; 252
     b38:	7f 4f       	sbci	r23, 0xFF	; 255
     b3a:	ce 01       	movw	r24, r28
     b3c:	01 96       	adiw	r24, 0x01	; 1
     b3e:	0e 94 1a 0b 	call	0x1634	; 0x1634 <xTaskCheckForTimeOut>
     b42:	81 11       	cpse	r24, r1
     b44:	1f c0       	rjmp	.+62     	; 0xb84 <xQueueGenericSend+0x114>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     b46:	0f b6       	in	r0, 0x3f	; 63
     b48:	f8 94       	cli
     b4a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     b4c:	f8 01       	movw	r30, r16
     b4e:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     b50:	0f 90       	pop	r0
     b52:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     b54:	83 8d       	ldd	r24, Z+27	; 0x1b
     b56:	98 13       	cpse	r25, r24
     b58:	0f c0       	rjmp	.+30     	; 0xb78 <xQueueGenericSend+0x108>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     b5a:	6c 81       	ldd	r22, Y+4	; 0x04
     b5c:	7d 81       	ldd	r23, Y+5	; 0x05
     b5e:	c7 01       	movw	r24, r14
     b60:	0e 94 9a 0a 	call	0x1534	; 0x1534 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     b64:	c8 01       	movw	r24, r16
     b66:	0e 94 83 04 	call	0x906	; 0x906 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     b6a:	0e 94 2c 09 	call	0x1258	; 0x1258 <xTaskResumeAll>
     b6e:	81 11       	cpse	r24, r1
     b70:	9b cf       	rjmp	.-202    	; 0xaa8 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
     b72:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
     b76:	98 cf       	rjmp	.-208    	; 0xaa8 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     b78:	c8 01       	movw	r24, r16
     b7a:	0e 94 83 04 	call	0x906	; 0x906 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     b7e:	0e 94 2c 09 	call	0x1258	; 0x1258 <xTaskResumeAll>
     b82:	92 cf       	rjmp	.-220    	; 0xaa8 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     b84:	c8 01       	movw	r24, r16
     b86:	0e 94 83 04 	call	0x906	; 0x906 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     b8a:	0e 94 2c 09 	call	0x1258	; 0x1258 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     b8e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     b90:	0f 90       	pop	r0
     b92:	0f 90       	pop	r0
     b94:	0f 90       	pop	r0
     b96:	0f 90       	pop	r0
     b98:	0f 90       	pop	r0
     b9a:	df 91       	pop	r29
     b9c:	cf 91       	pop	r28
     b9e:	1f 91       	pop	r17
     ba0:	0f 91       	pop	r16
     ba2:	ff 90       	pop	r15
     ba4:	ef 90       	pop	r14
     ba6:	df 90       	pop	r13
     ba8:	cf 90       	pop	r12
     baa:	bf 90       	pop	r11
     bac:	af 90       	pop	r10
     bae:	9f 90       	pop	r9
     bb0:	08 95       	ret

00000bb2 <xQueueGiveFromISR>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
     bb2:	cf 93       	push	r28
     bb4:	df 93       	push	r29
     bb6:	fc 01       	movw	r30, r24
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
     bb8:	92 8d       	ldd	r25, Z+26	; 0x1a
     bba:	83 8d       	ldd	r24, Z+27	; 0x1b
     bbc:	98 17       	cp	r25, r24
     bbe:	d0 f4       	brcc	.+52     	; 0xbf4 <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
     bc0:	82 8d       	ldd	r24, Z+26	; 0x1a
     bc2:	8f 5f       	subi	r24, 0xFF	; 255
     bc4:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     bc6:	86 8d       	ldd	r24, Z+30	; 0x1e
     bc8:	8f 3f       	cpi	r24, 0xFF	; 255
     bca:	79 f4       	brne	.+30     	; 0xbea <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     bcc:	81 89       	ldd	r24, Z+17	; 0x11
     bce:	88 23       	and	r24, r24
     bd0:	99 f0       	breq	.+38     	; 0xbf8 <xQueueGiveFromISR+0x46>
     bd2:	eb 01       	movw	r28, r22
     bd4:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     bd6:	41 96       	adiw	r24, 0x11	; 17
     bd8:	0e 94 c7 0a 	call	0x158e	; 0x158e <xTaskRemoveFromEventList>
     bdc:	88 23       	and	r24, r24
     bde:	71 f0       	breq	.+28     	; 0xbfc <xQueueGiveFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     be0:	20 97       	sbiw	r28, 0x00	; 0
     be2:	71 f0       	breq	.+28     	; 0xc00 <xQueueGiveFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     be4:	81 e0       	ldi	r24, 0x01	; 1
     be6:	88 83       	st	Y, r24
     be8:	0c c0       	rjmp	.+24     	; 0xc02 <xQueueGiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     bea:	86 8d       	ldd	r24, Z+30	; 0x1e
     bec:	8f 5f       	subi	r24, 0xFF	; 255
     bee:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     bf0:	81 e0       	ldi	r24, 0x01	; 1
     bf2:	07 c0       	rjmp	.+14     	; 0xc02 <xQueueGiveFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     bf4:	80 e0       	ldi	r24, 0x00	; 0
     bf6:	05 c0       	rjmp	.+10     	; 0xc02 <xQueueGiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
     bf8:	81 e0       	ldi	r24, 0x01	; 1
     bfa:	03 c0       	rjmp	.+6      	; 0xc02 <xQueueGiveFromISR+0x50>
     bfc:	81 e0       	ldi	r24, 0x01	; 1
     bfe:	01 c0       	rjmp	.+2      	; 0xc02 <xQueueGiveFromISR+0x50>
     c00:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     c02:	df 91       	pop	r29
     c04:	cf 91       	pop	r28
     c06:	08 95       	ret

00000c08 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     c08:	9f 92       	push	r9
     c0a:	af 92       	push	r10
     c0c:	bf 92       	push	r11
     c0e:	cf 92       	push	r12
     c10:	df 92       	push	r13
     c12:	ef 92       	push	r14
     c14:	ff 92       	push	r15
     c16:	0f 93       	push	r16
     c18:	1f 93       	push	r17
     c1a:	cf 93       	push	r28
     c1c:	df 93       	push	r29
     c1e:	00 d0       	rcall	.+0      	; 0xc20 <xQueueGenericReceive+0x18>
     c20:	00 d0       	rcall	.+0      	; 0xc22 <xQueueGenericReceive+0x1a>
     c22:	1f 92       	push	r1
     c24:	cd b7       	in	r28, 0x3d	; 61
     c26:	de b7       	in	r29, 0x3e	; 62
     c28:	8c 01       	movw	r16, r24
     c2a:	6b 01       	movw	r12, r22
     c2c:	5d 83       	std	Y+5, r21	; 0x05
     c2e:	4c 83       	std	Y+4, r20	; 0x04
     c30:	92 2e       	mov	r9, r18
BaseType_t xEntryTimeSet = pdFALSE;
     c32:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     c34:	aa 24       	eor	r10, r10
     c36:	a3 94       	inc	r10
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     c38:	7c 01       	movw	r14, r24
     c3a:	81 e1       	ldi	r24, 0x11	; 17
     c3c:	e8 0e       	add	r14, r24
     c3e:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     c46:	f8 01       	movw	r30, r16
     c48:	92 8d       	ldd	r25, Z+26	; 0x1a
     c4a:	99 23       	and	r25, r25
     c4c:	99 f1       	breq	.+102    	; 0xcb4 <xQueueGenericReceive+0xac>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     c4e:	e6 80       	ldd	r14, Z+6	; 0x06
     c50:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     c52:	b6 01       	movw	r22, r12
     c54:	c8 01       	movw	r24, r16
     c56:	0e 94 69 04 	call	0x8d2	; 0x8d2 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     c5a:	91 10       	cpse	r9, r1
     c5c:	1a c0       	rjmp	.+52     	; 0xc92 <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     c5e:	f8 01       	movw	r30, r16
     c60:	82 8d       	ldd	r24, Z+26	; 0x1a
     c62:	81 50       	subi	r24, 0x01	; 1
     c64:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     c66:	80 81       	ld	r24, Z
     c68:	91 81       	ldd	r25, Z+1	; 0x01
     c6a:	89 2b       	or	r24, r25
     c6c:	29 f4       	brne	.+10     	; 0xc78 <xQueueGenericReceive+0x70>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     c6e:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <pvTaskIncrementMutexHeldCount>
     c72:	f8 01       	movw	r30, r16
     c74:	93 83       	std	Z+3, r25	; 0x03
     c76:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     c78:	f8 01       	movw	r30, r16
     c7a:	80 85       	ldd	r24, Z+8	; 0x08
     c7c:	88 23       	and	r24, r24
     c7e:	b1 f0       	breq	.+44     	; 0xcac <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     c80:	c8 01       	movw	r24, r16
     c82:	08 96       	adiw	r24, 0x08	; 8
     c84:	0e 94 c7 0a 	call	0x158e	; 0x158e <xTaskRemoveFromEventList>
     c88:	81 30       	cpi	r24, 0x01	; 1
     c8a:	81 f4       	brne	.+32     	; 0xcac <xQueueGenericReceive+0xa4>
						{
							queueYIELD_IF_USING_PREEMPTION();
     c8c:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
     c90:	0d c0       	rjmp	.+26     	; 0xcac <xQueueGenericReceive+0xa4>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     c92:	f8 01       	movw	r30, r16
     c94:	f7 82       	std	Z+7, r15	; 0x07
     c96:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     c98:	81 89       	ldd	r24, Z+17	; 0x11
     c9a:	88 23       	and	r24, r24
     c9c:	39 f0       	breq	.+14     	; 0xcac <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     c9e:	c8 01       	movw	r24, r16
     ca0:	41 96       	adiw	r24, 0x11	; 17
     ca2:	0e 94 c7 0a 	call	0x158e	; 0x158e <xTaskRemoveFromEventList>
     ca6:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     ca8:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     cac:	0f 90       	pop	r0
     cae:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     cb0:	81 e0       	ldi	r24, 0x01	; 1
     cb2:	5c c0       	rjmp	.+184    	; 0xd6c <xQueueGenericReceive+0x164>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     cb4:	4c 81       	ldd	r20, Y+4	; 0x04
     cb6:	5d 81       	ldd	r21, Y+5	; 0x05
     cb8:	45 2b       	or	r20, r21
     cba:	21 f4       	brne	.+8      	; 0xcc4 <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     cbc:	0f 90       	pop	r0
     cbe:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     cc0:	80 e0       	ldi	r24, 0x00	; 0
     cc2:	54 c0       	rjmp	.+168    	; 0xd6c <xQueueGenericReceive+0x164>
				}
				else if( xEntryTimeSet == pdFALSE )
     cc4:	b1 10       	cpse	r11, r1
     cc6:	05 c0       	rjmp	.+10     	; 0xcd2 <xQueueGenericReceive+0xca>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     cc8:	ce 01       	movw	r24, r28
     cca:	01 96       	adiw	r24, 0x01	; 1
     ccc:	0e 94 0f 0b 	call	0x161e	; 0x161e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     cd0:	ba 2c       	mov	r11, r10
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     cd2:	0f 90       	pop	r0
     cd4:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     cd6:	0e 94 5f 08 	call	0x10be	; 0x10be <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     cda:	0f b6       	in	r0, 0x3f	; 63
     cdc:	f8 94       	cli
     cde:	0f 92       	push	r0
     ce0:	f8 01       	movw	r30, r16
     ce2:	85 8d       	ldd	r24, Z+29	; 0x1d
     ce4:	8f 3f       	cpi	r24, 0xFF	; 255
     ce6:	09 f4       	brne	.+2      	; 0xcea <xQueueGenericReceive+0xe2>
     ce8:	15 8e       	std	Z+29, r1	; 0x1d
     cea:	f8 01       	movw	r30, r16
     cec:	96 8d       	ldd	r25, Z+30	; 0x1e
     cee:	9f 3f       	cpi	r25, 0xFF	; 255
     cf0:	09 f4       	brne	.+2      	; 0xcf4 <xQueueGenericReceive+0xec>
     cf2:	16 8e       	std	Z+30, r1	; 0x1e
     cf4:	0f 90       	pop	r0
     cf6:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     cf8:	be 01       	movw	r22, r28
     cfa:	6c 5f       	subi	r22, 0xFC	; 252
     cfc:	7f 4f       	sbci	r23, 0xFF	; 255
     cfe:	ce 01       	movw	r24, r28
     d00:	01 96       	adiw	r24, 0x01	; 1
     d02:	0e 94 1a 0b 	call	0x1634	; 0x1634 <xTaskCheckForTimeOut>
     d06:	81 11       	cpse	r24, r1
     d08:	2b c0       	rjmp	.+86     	; 0xd60 <xQueueGenericReceive+0x158>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     d0a:	0f b6       	in	r0, 0x3f	; 63
     d0c:	f8 94       	cli
     d0e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     d10:	f8 01       	movw	r30, r16
     d12:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     d14:	0f 90       	pop	r0
     d16:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     d18:	81 11       	cpse	r24, r1
     d1a:	1c c0       	rjmp	.+56     	; 0xd54 <xQueueGenericReceive+0x14c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     d1c:	80 81       	ld	r24, Z
     d1e:	91 81       	ldd	r25, Z+1	; 0x01
     d20:	89 2b       	or	r24, r25
     d22:	49 f4       	brne	.+18     	; 0xd36 <xQueueGenericReceive+0x12e>
					{
						taskENTER_CRITICAL();
     d24:	0f b6       	in	r0, 0x3f	; 63
     d26:	f8 94       	cli
     d28:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     d2a:	82 81       	ldd	r24, Z+2	; 0x02
     d2c:	93 81       	ldd	r25, Z+3	; 0x03
     d2e:	0e 94 57 0b 	call	0x16ae	; 0x16ae <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     d32:	0f 90       	pop	r0
     d34:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     d36:	6c 81       	ldd	r22, Y+4	; 0x04
     d38:	7d 81       	ldd	r23, Y+5	; 0x05
     d3a:	c7 01       	movw	r24, r14
     d3c:	0e 94 9a 0a 	call	0x1534	; 0x1534 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     d40:	c8 01       	movw	r24, r16
     d42:	0e 94 83 04 	call	0x906	; 0x906 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     d46:	0e 94 2c 09 	call	0x1258	; 0x1258 <xTaskResumeAll>
     d4a:	81 11       	cpse	r24, r1
     d4c:	79 cf       	rjmp	.-270    	; 0xc40 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
     d4e:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
     d52:	76 cf       	rjmp	.-276    	; 0xc40 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     d54:	c8 01       	movw	r24, r16
     d56:	0e 94 83 04 	call	0x906	; 0x906 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     d5a:	0e 94 2c 09 	call	0x1258	; 0x1258 <xTaskResumeAll>
     d5e:	70 cf       	rjmp	.-288    	; 0xc40 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     d60:	c8 01       	movw	r24, r16
     d62:	0e 94 83 04 	call	0x906	; 0x906 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     d66:	0e 94 2c 09 	call	0x1258	; 0x1258 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     d6a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     d6c:	0f 90       	pop	r0
     d6e:	0f 90       	pop	r0
     d70:	0f 90       	pop	r0
     d72:	0f 90       	pop	r0
     d74:	0f 90       	pop	r0
     d76:	df 91       	pop	r29
     d78:	cf 91       	pop	r28
     d7a:	1f 91       	pop	r17
     d7c:	0f 91       	pop	r16
     d7e:	ff 90       	pop	r15
     d80:	ef 90       	pop	r14
     d82:	df 90       	pop	r13
     d84:	cf 90       	pop	r12
     d86:	bf 90       	pop	r11
     d88:	af 90       	pop	r10
     d8a:	9f 90       	pop	r9
     d8c:	08 95       	ret

00000d8e <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     d8e:	e0 91 54 08 	lds	r30, 0x0854
     d92:	f0 91 55 08 	lds	r31, 0x0855
     d96:	80 81       	ld	r24, Z
     d98:	81 11       	cpse	r24, r1
     d9a:	07 c0       	rjmp	.+14     	; 0xdaa <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     d9c:	8f ef       	ldi	r24, 0xFF	; 255
     d9e:	9f ef       	ldi	r25, 0xFF	; 255
     da0:	90 93 03 01 	sts	0x0103, r25
     da4:	80 93 02 01 	sts	0x0102, r24
     da8:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     daa:	e0 91 54 08 	lds	r30, 0x0854
     dae:	f0 91 55 08 	lds	r31, 0x0855
     db2:	05 80       	ldd	r0, Z+5	; 0x05
     db4:	f6 81       	ldd	r31, Z+6	; 0x06
     db6:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
     db8:	06 80       	ldd	r0, Z+6	; 0x06
     dba:	f7 81       	ldd	r31, Z+7	; 0x07
     dbc:	e0 2d       	mov	r30, r0
     dbe:	82 81       	ldd	r24, Z+2	; 0x02
     dc0:	93 81       	ldd	r25, Z+3	; 0x03
     dc2:	90 93 03 01 	sts	0x0103, r25
     dc6:	80 93 02 01 	sts	0x0102, r24
     dca:	08 95       	ret

00000dcc <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
     dcc:	cf 93       	push	r28
     dce:	df 93       	push	r29
     dd0:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     dd2:	e0 91 8c 08 	lds	r30, 0x088C
     dd6:	f0 91 8d 08 	lds	r31, 0x088D
     dda:	93 83       	std	Z+3, r25	; 0x03
     ddc:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
     dde:	80 91 31 08 	lds	r24, 0x0831
     de2:	90 91 32 08 	lds	r25, 0x0832
     de6:	c8 17       	cp	r28, r24
     de8:	d9 07       	cpc	r29, r25
     dea:	68 f4       	brcc	.+26     	; 0xe06 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     dec:	60 91 8c 08 	lds	r22, 0x088C
     df0:	70 91 8d 08 	lds	r23, 0x088D
     df4:	80 91 52 08 	lds	r24, 0x0852
     df8:	90 91 53 08 	lds	r25, 0x0853
     dfc:	6e 5f       	subi	r22, 0xFE	; 254
     dfe:	7f 4f       	sbci	r23, 0xFF	; 255
     e00:	0e 94 85 01 	call	0x30a	; 0x30a <vListInsert>
     e04:	17 c0       	rjmp	.+46     	; 0xe34 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     e06:	60 91 8c 08 	lds	r22, 0x088C
     e0a:	70 91 8d 08 	lds	r23, 0x088D
     e0e:	80 91 54 08 	lds	r24, 0x0854
     e12:	90 91 55 08 	lds	r25, 0x0855
     e16:	6e 5f       	subi	r22, 0xFE	; 254
     e18:	7f 4f       	sbci	r23, 0xFF	; 255
     e1a:	0e 94 85 01 	call	0x30a	; 0x30a <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     e1e:	80 91 02 01 	lds	r24, 0x0102
     e22:	90 91 03 01 	lds	r25, 0x0103
     e26:	c8 17       	cp	r28, r24
     e28:	d9 07       	cpc	r29, r25
     e2a:	20 f4       	brcc	.+8      	; 0xe34 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
     e2c:	d0 93 03 01 	sts	0x0103, r29
     e30:	c0 93 02 01 	sts	0x0102, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     e34:	df 91       	pop	r29
     e36:	cf 91       	pop	r28
     e38:	08 95       	ret

00000e3a <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
     e3a:	4f 92       	push	r4
     e3c:	5f 92       	push	r5
     e3e:	6f 92       	push	r6
     e40:	7f 92       	push	r7
     e42:	8f 92       	push	r8
     e44:	9f 92       	push	r9
     e46:	af 92       	push	r10
     e48:	bf 92       	push	r11
     e4a:	cf 92       	push	r12
     e4c:	df 92       	push	r13
     e4e:	ef 92       	push	r14
     e50:	ff 92       	push	r15
     e52:	0f 93       	push	r16
     e54:	1f 93       	push	r17
     e56:	cf 93       	push	r28
     e58:	df 93       	push	r29
     e5a:	4c 01       	movw	r8, r24
     e5c:	eb 01       	movw	r28, r22
     e5e:	5a 01       	movw	r10, r20
     e60:	29 01       	movw	r4, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     e62:	c1 14       	cp	r12, r1
     e64:	d1 04       	cpc	r13, r1
     e66:	39 f4       	brne	.+14     	; 0xe76 <xTaskGenericCreate+0x3c>
     e68:	ca 01       	movw	r24, r20
     e6a:	0e 94 3a 03 	call	0x674	; 0x674 <pvPortMalloc>
     e6e:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
     e70:	89 2b       	or	r24, r25
     e72:	09 f4       	brne	.+2      	; 0xe76 <xTaskGenericCreate+0x3c>
     e74:	e3 c0       	rjmp	.+454    	; 0x103c <xTaskGenericCreate+0x202>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     e76:	88 e2       	ldi	r24, 0x28	; 40
     e78:	90 e0       	ldi	r25, 0x00	; 0
     e7a:	0e 94 3a 03 	call	0x674	; 0x674 <pvPortMalloc>
     e7e:	3c 01       	movw	r6, r24

			if( pxNewTCB != NULL )
     e80:	00 97       	sbiw	r24, 0x00	; 0
     e82:	79 f0       	breq	.+30     	; 0xea2 <xTaskGenericCreate+0x68>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
     e84:	fc 01       	movw	r30, r24
     e86:	d0 8e       	std	Z+24, r13	; 0x18
     e88:	c7 8a       	std	Z+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
     e8a:	f1 e0       	ldi	r31, 0x01	; 1
     e8c:	af 1a       	sub	r10, r31
     e8e:	b1 08       	sbc	r11, r1
     e90:	ca 0c       	add	r12, r10
     e92:	db 1c       	adc	r13, r11
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     e94:	88 81       	ld	r24, Y
     e96:	f3 01       	movw	r30, r6
     e98:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     e9a:	88 81       	ld	r24, Y
     e9c:	81 11       	cpse	r24, r1
     e9e:	05 c0       	rjmp	.+10     	; 0xeaa <xTaskGenericCreate+0x70>
     ea0:	14 c0       	rjmp	.+40     	; 0xeca <xTaskGenericCreate+0x90>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
     ea2:	c6 01       	movw	r24, r12
     ea4:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <vPortFree>
     ea8:	c9 c0       	rjmp	.+402    	; 0x103c <xTaskGenericCreate+0x202>
     eaa:	d3 01       	movw	r26, r6
     eac:	5a 96       	adiw	r26, 0x1a	; 26
     eae:	fe 01       	movw	r30, r28
     eb0:	31 96       	adiw	r30, 0x01	; 1
     eb2:	9e 01       	movw	r18, r28
     eb4:	28 5f       	subi	r18, 0xF8	; 248
     eb6:	3f 4f       	sbci	r19, 0xFF	; 255
     eb8:	ef 01       	movw	r28, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     eba:	81 91       	ld	r24, Z+
     ebc:	8d 93       	st	X+, r24

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     ebe:	88 81       	ld	r24, Y
     ec0:	88 23       	and	r24, r24
     ec2:	19 f0       	breq	.+6      	; 0xeca <xTaskGenericCreate+0x90>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     ec4:	e2 17       	cp	r30, r18
     ec6:	f3 07       	cpc	r31, r19
     ec8:	b9 f7       	brne	.-18     	; 0xeb8 <xTaskGenericCreate+0x7e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     eca:	f3 01       	movw	r30, r6
     ecc:	10 a2       	std	Z+32, r1	; 0x20
     ece:	10 2f       	mov	r17, r16
     ed0:	04 30       	cpi	r16, 0x04	; 4
     ed2:	08 f0       	brcs	.+2      	; 0xed6 <xTaskGenericCreate+0x9c>
     ed4:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
     ed6:	f3 01       	movw	r30, r6
     ed8:	16 8b       	std	Z+22, r17	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
     eda:	11 a3       	std	Z+33, r17	; 0x21
		pxTCB->uxMutexesHeld = 0;
     edc:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     ede:	e3 01       	movw	r28, r6
     ee0:	22 96       	adiw	r28, 0x02	; 2
     ee2:	ce 01       	movw	r24, r28
     ee4:	0e 94 60 01 	call	0x2c0	; 0x2c0 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     ee8:	c3 01       	movw	r24, r6
     eea:	0c 96       	adiw	r24, 0x0c	; 12
     eec:	0e 94 60 01 	call	0x2c0	; 0x2c0 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     ef0:	f3 01       	movw	r30, r6
     ef2:	71 86       	std	Z+9, r7	; 0x09
     ef4:	60 86       	std	Z+8, r6	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     ef6:	84 e0       	ldi	r24, 0x04	; 4
     ef8:	90 e0       	ldi	r25, 0x00	; 0
     efa:	81 1b       	sub	r24, r17
     efc:	91 09       	sbc	r25, r1
     efe:	95 87       	std	Z+13, r25	; 0x0d
     f00:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     f02:	73 8a       	std	Z+19, r7	; 0x13
     f04:	62 8a       	std	Z+18, r6	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
     f06:	13 a2       	std	Z+35, r1	; 0x23
     f08:	14 a2       	std	Z+36, r1	; 0x24
     f0a:	15 a2       	std	Z+37, r1	; 0x25
     f0c:	16 a2       	std	Z+38, r1	; 0x26
		pxTCB->eNotifyState = eNotWaitingNotification;
     f0e:	17 a2       	std	Z+39, r1	; 0x27
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     f10:	a2 01       	movw	r20, r4
     f12:	b4 01       	movw	r22, r8
     f14:	c6 01       	movw	r24, r12
     f16:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <pxPortInitialiseStack>
     f1a:	f3 01       	movw	r30, r6
     f1c:	91 83       	std	Z+1, r25	; 0x01
     f1e:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     f20:	e1 14       	cp	r14, r1
     f22:	f1 04       	cpc	r15, r1
     f24:	19 f0       	breq	.+6      	; 0xf2c <xTaskGenericCreate+0xf2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     f26:	f7 01       	movw	r30, r14
     f28:	71 82       	std	Z+1, r7	; 0x01
     f2a:	60 82       	st	Z, r6
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     f2c:	0f b6       	in	r0, 0x3f	; 63
     f2e:	f8 94       	cli
     f30:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     f32:	80 91 33 08 	lds	r24, 0x0833
     f36:	8f 5f       	subi	r24, 0xFF	; 255
     f38:	80 93 33 08 	sts	0x0833, r24
			if( pxCurrentTCB == NULL )
     f3c:	80 91 8c 08 	lds	r24, 0x088C
     f40:	90 91 8d 08 	lds	r25, 0x088D
     f44:	89 2b       	or	r24, r25
     f46:	d1 f5       	brne	.+116    	; 0xfbc <xTaskGenericCreate+0x182>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     f48:	70 92 8d 08 	sts	0x088D, r7
     f4c:	60 92 8c 08 	sts	0x088C, r6

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     f50:	80 91 33 08 	lds	r24, 0x0833
     f54:	81 30       	cpi	r24, 0x01	; 1
     f56:	09 f0       	breq	.+2      	; 0xf5a <xTaskGenericCreate+0x120>
     f58:	40 c0       	rjmp	.+128    	; 0xfda <xTaskGenericCreate+0x1a0>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     f5a:	88 e6       	ldi	r24, 0x68	; 104
     f5c:	98 e0       	ldi	r25, 0x08	; 8
     f5e:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
     f62:	81 e7       	ldi	r24, 0x71	; 113
     f64:	98 e0       	ldi	r25, 0x08	; 8
     f66:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
     f6a:	8a e7       	ldi	r24, 0x7A	; 122
     f6c:	98 e0       	ldi	r25, 0x08	; 8
     f6e:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
     f72:	83 e8       	ldi	r24, 0x83	; 131
     f74:	98 e0       	ldi	r25, 0x08	; 8
     f76:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     f7a:	8f e5       	ldi	r24, 0x5F	; 95
     f7c:	98 e0       	ldi	r25, 0x08	; 8
     f7e:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     f82:	86 e5       	ldi	r24, 0x56	; 86
     f84:	98 e0       	ldi	r25, 0x08	; 8
     f86:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     f8a:	89 e4       	ldi	r24, 0x49	; 73
     f8c:	98 e0       	ldi	r25, 0x08	; 8
     f8e:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     f92:	80 e4       	ldi	r24, 0x40	; 64
     f94:	98 e0       	ldi	r25, 0x08	; 8
     f96:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     f9a:	86 e3       	ldi	r24, 0x36	; 54
     f9c:	98 e0       	ldi	r25, 0x08	; 8
     f9e:	0e 94 52 01 	call	0x2a4	; 0x2a4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     fa2:	8f e5       	ldi	r24, 0x5F	; 95
     fa4:	98 e0       	ldi	r25, 0x08	; 8
     fa6:	90 93 55 08 	sts	0x0855, r25
     faa:	80 93 54 08 	sts	0x0854, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     fae:	86 e5       	ldi	r24, 0x56	; 86
     fb0:	98 e0       	ldi	r25, 0x08	; 8
     fb2:	90 93 53 08 	sts	0x0853, r25
     fb6:	80 93 52 08 	sts	0x0852, r24
     fba:	0f c0       	rjmp	.+30     	; 0xfda <xTaskGenericCreate+0x1a0>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     fbc:	80 91 2f 08 	lds	r24, 0x082F
     fc0:	81 11       	cpse	r24, r1
     fc2:	0b c0       	rjmp	.+22     	; 0xfda <xTaskGenericCreate+0x1a0>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     fc4:	e0 91 8c 08 	lds	r30, 0x088C
     fc8:	f0 91 8d 08 	lds	r31, 0x088D
     fcc:	86 89       	ldd	r24, Z+22	; 0x16
     fce:	08 17       	cp	r16, r24
     fd0:	20 f0       	brcs	.+8      	; 0xfda <xTaskGenericCreate+0x1a0>
					{
						pxCurrentTCB = pxNewTCB;
     fd2:	70 92 8d 08 	sts	0x088D, r7
     fd6:	60 92 8c 08 	sts	0x088C, r6
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
     fda:	80 91 2b 08 	lds	r24, 0x082B
     fde:	8f 5f       	subi	r24, 0xFF	; 255
     fe0:	80 93 2b 08 	sts	0x082B, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     fe4:	f3 01       	movw	r30, r6
     fe6:	86 89       	ldd	r24, Z+22	; 0x16
     fe8:	90 91 30 08 	lds	r25, 0x0830
     fec:	98 17       	cp	r25, r24
     fee:	10 f4       	brcc	.+4      	; 0xff4 <xTaskGenericCreate+0x1ba>
     ff0:	80 93 30 08 	sts	0x0830, r24
     ff4:	90 e0       	ldi	r25, 0x00	; 0
     ff6:	9c 01       	movw	r18, r24
     ff8:	22 0f       	add	r18, r18
     ffa:	33 1f       	adc	r19, r19
     ffc:	22 0f       	add	r18, r18
     ffe:	33 1f       	adc	r19, r19
    1000:	22 0f       	add	r18, r18
    1002:	33 1f       	adc	r19, r19
    1004:	82 0f       	add	r24, r18
    1006:	93 1f       	adc	r25, r19
    1008:	be 01       	movw	r22, r28
    100a:	88 59       	subi	r24, 0x98	; 152
    100c:	97 4f       	sbci	r25, 0xF7	; 247
    100e:	0e 94 64 01 	call	0x2c8	; 0x2c8 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    1012:	0f 90       	pop	r0
    1014:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
    1016:	80 91 2f 08 	lds	r24, 0x082F
    101a:	88 23       	and	r24, r24
    101c:	59 f0       	breq	.+22     	; 0x1034 <xTaskGenericCreate+0x1fa>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    101e:	e0 91 8c 08 	lds	r30, 0x088C
    1022:	f0 91 8d 08 	lds	r31, 0x088D
    1026:	86 89       	ldd	r24, Z+22	; 0x16
    1028:	80 17       	cp	r24, r16
    102a:	30 f4       	brcc	.+12     	; 0x1038 <xTaskGenericCreate+0x1fe>
			{
				taskYIELD_IF_USING_PREEMPTION();
    102c:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
    1030:	81 e0       	ldi	r24, 0x01	; 1
    1032:	05 c0       	rjmp	.+10     	; 0x103e <xTaskGenericCreate+0x204>
    1034:	81 e0       	ldi	r24, 0x01	; 1
    1036:	03 c0       	rjmp	.+6      	; 0x103e <xTaskGenericCreate+0x204>
    1038:	81 e0       	ldi	r24, 0x01	; 1
    103a:	01 c0       	rjmp	.+2      	; 0x103e <xTaskGenericCreate+0x204>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    103c:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
    103e:	df 91       	pop	r29
    1040:	cf 91       	pop	r28
    1042:	1f 91       	pop	r17
    1044:	0f 91       	pop	r16
    1046:	ff 90       	pop	r15
    1048:	ef 90       	pop	r14
    104a:	df 90       	pop	r13
    104c:	cf 90       	pop	r12
    104e:	bf 90       	pop	r11
    1050:	af 90       	pop	r10
    1052:	9f 90       	pop	r9
    1054:	8f 90       	pop	r8
    1056:	7f 90       	pop	r7
    1058:	6f 90       	pop	r6
    105a:	5f 90       	pop	r5
    105c:	4f 90       	pop	r4
    105e:	08 95       	ret

00001060 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    1060:	af 92       	push	r10
    1062:	bf 92       	push	r11
    1064:	cf 92       	push	r12
    1066:	df 92       	push	r13
    1068:	ef 92       	push	r14
    106a:	ff 92       	push	r15
    106c:	0f 93       	push	r16
	/* Add the idle task at the lowest priority. */
	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
	{
		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
		be returned by the xTaskGetIdleTaskHandle() function. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
    106e:	a1 2c       	mov	r10, r1
    1070:	b1 2c       	mov	r11, r1
    1072:	c1 2c       	mov	r12, r1
    1074:	d1 2c       	mov	r13, r1
    1076:	0f 2e       	mov	r0, r31
    1078:	f4 e3       	ldi	r31, 0x34	; 52
    107a:	ef 2e       	mov	r14, r31
    107c:	f8 e0       	ldi	r31, 0x08	; 8
    107e:	ff 2e       	mov	r15, r31
    1080:	f0 2d       	mov	r31, r0
    1082:	00 e0       	ldi	r16, 0x00	; 0
    1084:	20 e0       	ldi	r18, 0x00	; 0
    1086:	30 e0       	ldi	r19, 0x00	; 0
    1088:	45 e5       	ldi	r20, 0x55	; 85
    108a:	50 e0       	ldi	r21, 0x00	; 0
    108c:	6e e3       	ldi	r22, 0x3E	; 62
    108e:	72 e0       	ldi	r23, 0x02	; 2
    1090:	80 ef       	ldi	r24, 0xF0	; 240
    1092:	99 e0       	ldi	r25, 0x09	; 9
    1094:	0e 94 1d 07 	call	0xe3a	; 0xe3a <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1098:	81 30       	cpi	r24, 0x01	; 1
    109a:	49 f4       	brne	.+18     	; 0x10ae <vTaskStartScheduler+0x4e>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
    109c:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
    109e:	80 93 2f 08 	sts	0x082F, r24
		xTickCount = ( TickType_t ) 0U;
    10a2:	10 92 32 08 	sts	0x0832, r1
    10a6:	10 92 31 08 	sts	0x0831, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    10aa:	0e 94 48 02 	call	0x490	; 0x490 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    10ae:	0f 91       	pop	r16
    10b0:	ff 90       	pop	r15
    10b2:	ef 90       	pop	r14
    10b4:	df 90       	pop	r13
    10b6:	cf 90       	pop	r12
    10b8:	bf 90       	pop	r11
    10ba:	af 90       	pop	r10
    10bc:	08 95       	ret

000010be <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
    10be:	80 91 2a 08 	lds	r24, 0x082A
    10c2:	8f 5f       	subi	r24, 0xFF	; 255
    10c4:	80 93 2a 08 	sts	0x082A, r24
    10c8:	08 95       	ret

000010ca <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
    10ca:	0f b6       	in	r0, 0x3f	; 63
    10cc:	f8 94       	cli
    10ce:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    10d0:	80 91 31 08 	lds	r24, 0x0831
    10d4:	90 91 32 08 	lds	r25, 0x0832
	}
	portTICK_TYPE_EXIT_CRITICAL();
    10d8:	0f 90       	pop	r0
    10da:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
    10dc:	08 95       	ret

000010de <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    10de:	cf 92       	push	r12
    10e0:	df 92       	push	r13
    10e2:	ef 92       	push	r14
    10e4:	ff 92       	push	r15
    10e6:	0f 93       	push	r16
    10e8:	1f 93       	push	r17
    10ea:	cf 93       	push	r28
    10ec:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    10ee:	80 91 2a 08 	lds	r24, 0x082A
    10f2:	81 11       	cpse	r24, r1
    10f4:	9b c0       	rjmp	.+310    	; 0x122c <xTaskIncrementTick+0x14e>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
    10f6:	80 91 31 08 	lds	r24, 0x0831
    10fa:	90 91 32 08 	lds	r25, 0x0832
    10fe:	01 96       	adiw	r24, 0x01	; 1
    1100:	90 93 32 08 	sts	0x0832, r25
    1104:	80 93 31 08 	sts	0x0831, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    1108:	e0 90 31 08 	lds	r14, 0x0831
    110c:	f0 90 32 08 	lds	r15, 0x0832

			if( xConstTickCount == ( TickType_t ) 0U )
    1110:	e1 14       	cp	r14, r1
    1112:	f1 04       	cpc	r15, r1
    1114:	b9 f4       	brne	.+46     	; 0x1144 <xTaskIncrementTick+0x66>
			{
				taskSWITCH_DELAYED_LISTS();
    1116:	80 91 54 08 	lds	r24, 0x0854
    111a:	90 91 55 08 	lds	r25, 0x0855
    111e:	20 91 52 08 	lds	r18, 0x0852
    1122:	30 91 53 08 	lds	r19, 0x0853
    1126:	30 93 55 08 	sts	0x0855, r19
    112a:	20 93 54 08 	sts	0x0854, r18
    112e:	90 93 53 08 	sts	0x0853, r25
    1132:	80 93 52 08 	sts	0x0852, r24
    1136:	80 91 2c 08 	lds	r24, 0x082C
    113a:	8f 5f       	subi	r24, 0xFF	; 255
    113c:	80 93 2c 08 	sts	0x082C, r24
    1140:	0e 94 c7 06 	call	0xd8e	; 0xd8e <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
    1144:	80 91 02 01 	lds	r24, 0x0102
    1148:	90 91 03 01 	lds	r25, 0x0103
    114c:	e8 16       	cp	r14, r24
    114e:	f9 06       	cpc	r15, r25
    1150:	10 f4       	brcc	.+4      	; 0x1156 <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1152:	d1 2c       	mov	r13, r1
    1154:	53 c0       	rjmp	.+166    	; 0x11fc <xTaskIncrementTick+0x11e>
    1156:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
    1158:	cc 24       	eor	r12, r12
    115a:	c3 94       	inc	r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    115c:	e0 91 54 08 	lds	r30, 0x0854
    1160:	f0 91 55 08 	lds	r31, 0x0855
    1164:	90 81       	ld	r25, Z
    1166:	91 11       	cpse	r25, r1
    1168:	07 c0       	rjmp	.+14     	; 0x1178 <xTaskIncrementTick+0x9a>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
    116a:	8f ef       	ldi	r24, 0xFF	; 255
    116c:	9f ef       	ldi	r25, 0xFF	; 255
    116e:	90 93 03 01 	sts	0x0103, r25
    1172:	80 93 02 01 	sts	0x0102, r24
						break;
    1176:	42 c0       	rjmp	.+132    	; 0x11fc <xTaskIncrementTick+0x11e>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    1178:	e0 91 54 08 	lds	r30, 0x0854
    117c:	f0 91 55 08 	lds	r31, 0x0855
    1180:	05 80       	ldd	r0, Z+5	; 0x05
    1182:	f6 81       	ldd	r31, Z+6	; 0x06
    1184:	e0 2d       	mov	r30, r0
    1186:	c6 81       	ldd	r28, Z+6	; 0x06
    1188:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    118a:	2a 81       	ldd	r18, Y+2	; 0x02
    118c:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
    118e:	e2 16       	cp	r14, r18
    1190:	f3 06       	cpc	r15, r19
    1192:	28 f4       	brcc	.+10     	; 0x119e <xTaskIncrementTick+0xc0>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
    1194:	30 93 03 01 	sts	0x0103, r19
    1198:	20 93 02 01 	sts	0x0102, r18
							break;
    119c:	2f c0       	rjmp	.+94     	; 0x11fc <xTaskIncrementTick+0x11e>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    119e:	8e 01       	movw	r16, r28
    11a0:	0e 5f       	subi	r16, 0xFE	; 254
    11a2:	1f 4f       	sbci	r17, 0xFF	; 255
    11a4:	c8 01       	movw	r24, r16
    11a6:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    11aa:	8c 89       	ldd	r24, Y+20	; 0x14
    11ac:	9d 89       	ldd	r25, Y+21	; 0x15
    11ae:	89 2b       	or	r24, r25
    11b0:	21 f0       	breq	.+8      	; 0x11ba <xTaskIncrementTick+0xdc>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    11b2:	ce 01       	movw	r24, r28
    11b4:	0c 96       	adiw	r24, 0x0c	; 12
    11b6:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    11ba:	2e 89       	ldd	r18, Y+22	; 0x16
    11bc:	80 91 30 08 	lds	r24, 0x0830
    11c0:	82 17       	cp	r24, r18
    11c2:	10 f4       	brcc	.+4      	; 0x11c8 <xTaskIncrementTick+0xea>
    11c4:	20 93 30 08 	sts	0x0830, r18
    11c8:	30 e0       	ldi	r19, 0x00	; 0
    11ca:	c9 01       	movw	r24, r18
    11cc:	88 0f       	add	r24, r24
    11ce:	99 1f       	adc	r25, r25
    11d0:	88 0f       	add	r24, r24
    11d2:	99 1f       	adc	r25, r25
    11d4:	88 0f       	add	r24, r24
    11d6:	99 1f       	adc	r25, r25
    11d8:	82 0f       	add	r24, r18
    11da:	93 1f       	adc	r25, r19
    11dc:	b8 01       	movw	r22, r16
    11de:	88 59       	subi	r24, 0x98	; 152
    11e0:	97 4f       	sbci	r25, 0xF7	; 247
    11e2:	0e 94 64 01 	call	0x2c8	; 0x2c8 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    11e6:	e0 91 8c 08 	lds	r30, 0x088C
    11ea:	f0 91 8d 08 	lds	r31, 0x088D
    11ee:	9e 89       	ldd	r25, Y+22	; 0x16
    11f0:	86 89       	ldd	r24, Z+22	; 0x16
    11f2:	98 17       	cp	r25, r24
    11f4:	08 f4       	brcc	.+2      	; 0x11f8 <xTaskIncrementTick+0x11a>
    11f6:	b2 cf       	rjmp	.-156    	; 0x115c <xTaskIncrementTick+0x7e>
							{
								xSwitchRequired = pdTRUE;
    11f8:	dc 2c       	mov	r13, r12
    11fa:	b0 cf       	rjmp	.-160    	; 0x115c <xTaskIncrementTick+0x7e>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    11fc:	e0 91 8c 08 	lds	r30, 0x088C
    1200:	f0 91 8d 08 	lds	r31, 0x088D
    1204:	86 89       	ldd	r24, Z+22	; 0x16
    1206:	90 e0       	ldi	r25, 0x00	; 0
    1208:	fc 01       	movw	r30, r24
    120a:	ee 0f       	add	r30, r30
    120c:	ff 1f       	adc	r31, r31
    120e:	ee 0f       	add	r30, r30
    1210:	ff 1f       	adc	r31, r31
    1212:	ee 0f       	add	r30, r30
    1214:	ff 1f       	adc	r31, r31
    1216:	8e 0f       	add	r24, r30
    1218:	9f 1f       	adc	r25, r31
    121a:	fc 01       	movw	r30, r24
    121c:	e8 59       	subi	r30, 0x98	; 152
    121e:	f7 4f       	sbci	r31, 0xF7	; 247
    1220:	80 81       	ld	r24, Z
    1222:	82 30       	cpi	r24, 0x02	; 2
    1224:	48 f0       	brcs	.+18     	; 0x1238 <xTaskIncrementTick+0x15a>
			{
				xSwitchRequired = pdTRUE;
    1226:	dd 24       	eor	r13, r13
    1228:	d3 94       	inc	r13
    122a:	06 c0       	rjmp	.+12     	; 0x1238 <xTaskIncrementTick+0x15a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    122c:	80 91 2e 08 	lds	r24, 0x082E
    1230:	8f 5f       	subi	r24, 0xFF	; 255
    1232:	80 93 2e 08 	sts	0x082E, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1236:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    1238:	80 91 2d 08 	lds	r24, 0x082D
    123c:	88 23       	and	r24, r24
    123e:	11 f0       	breq	.+4      	; 0x1244 <xTaskIncrementTick+0x166>
		{
			xSwitchRequired = pdTRUE;
    1240:	dd 24       	eor	r13, r13
    1242:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    1244:	8d 2d       	mov	r24, r13
    1246:	df 91       	pop	r29
    1248:	cf 91       	pop	r28
    124a:	1f 91       	pop	r17
    124c:	0f 91       	pop	r16
    124e:	ff 90       	pop	r15
    1250:	ef 90       	pop	r14
    1252:	df 90       	pop	r13
    1254:	cf 90       	pop	r12
    1256:	08 95       	ret

00001258 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    1258:	df 92       	push	r13
    125a:	ef 92       	push	r14
    125c:	ff 92       	push	r15
    125e:	0f 93       	push	r16
    1260:	1f 93       	push	r17
    1262:	cf 93       	push	r28
    1264:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1266:	0f b6       	in	r0, 0x3f	; 63
    1268:	f8 94       	cli
    126a:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    126c:	80 91 2a 08 	lds	r24, 0x082A
    1270:	81 50       	subi	r24, 0x01	; 1
    1272:	80 93 2a 08 	sts	0x082A, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1276:	80 91 2a 08 	lds	r24, 0x082A
    127a:	81 11       	cpse	r24, r1
    127c:	62 c0       	rjmp	.+196    	; 0x1342 <xTaskResumeAll+0xea>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    127e:	80 91 33 08 	lds	r24, 0x0833
    1282:	81 11       	cpse	r24, r1
    1284:	33 c0       	rjmp	.+102    	; 0x12ec <xTaskResumeAll+0x94>
    1286:	60 c0       	rjmp	.+192    	; 0x1348 <xTaskResumeAll+0xf0>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    1288:	d7 01       	movw	r26, r14
    128a:	15 96       	adiw	r26, 0x05	; 5
    128c:	ed 91       	ld	r30, X+
    128e:	fc 91       	ld	r31, X
    1290:	16 97       	sbiw	r26, 0x06	; 6
    1292:	c6 81       	ldd	r28, Z+6	; 0x06
    1294:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1296:	ce 01       	movw	r24, r28
    1298:	0c 96       	adiw	r24, 0x0c	; 12
    129a:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    129e:	8e 01       	movw	r16, r28
    12a0:	0e 5f       	subi	r16, 0xFE	; 254
    12a2:	1f 4f       	sbci	r17, 0xFF	; 255
    12a4:	c8 01       	movw	r24, r16
    12a6:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    12aa:	2e 89       	ldd	r18, Y+22	; 0x16
    12ac:	80 91 30 08 	lds	r24, 0x0830
    12b0:	82 17       	cp	r24, r18
    12b2:	10 f4       	brcc	.+4      	; 0x12b8 <xTaskResumeAll+0x60>
    12b4:	20 93 30 08 	sts	0x0830, r18
    12b8:	30 e0       	ldi	r19, 0x00	; 0
    12ba:	c9 01       	movw	r24, r18
    12bc:	88 0f       	add	r24, r24
    12be:	99 1f       	adc	r25, r25
    12c0:	88 0f       	add	r24, r24
    12c2:	99 1f       	adc	r25, r25
    12c4:	88 0f       	add	r24, r24
    12c6:	99 1f       	adc	r25, r25
    12c8:	82 0f       	add	r24, r18
    12ca:	93 1f       	adc	r25, r19
    12cc:	b8 01       	movw	r22, r16
    12ce:	88 59       	subi	r24, 0x98	; 152
    12d0:	97 4f       	sbci	r25, 0xF7	; 247
    12d2:	0e 94 64 01 	call	0x2c8	; 0x2c8 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    12d6:	e0 91 8c 08 	lds	r30, 0x088C
    12da:	f0 91 8d 08 	lds	r31, 0x088D
    12de:	9e 89       	ldd	r25, Y+22	; 0x16
    12e0:	86 89       	ldd	r24, Z+22	; 0x16
    12e2:	98 17       	cp	r25, r24
    12e4:	58 f0       	brcs	.+22     	; 0x12fc <xTaskResumeAll+0xa4>
					{
						xYieldPending = pdTRUE;
    12e6:	d0 92 2d 08 	sts	0x082D, r13
    12ea:	08 c0       	rjmp	.+16     	; 0x12fc <xTaskResumeAll+0xa4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    12ec:	0f 2e       	mov	r0, r31
    12ee:	f9 e4       	ldi	r31, 0x49	; 73
    12f0:	ef 2e       	mov	r14, r31
    12f2:	f8 e0       	ldi	r31, 0x08	; 8
    12f4:	ff 2e       	mov	r15, r31
    12f6:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    12f8:	dd 24       	eor	r13, r13
    12fa:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    12fc:	f7 01       	movw	r30, r14
    12fe:	80 81       	ld	r24, Z
    1300:	81 11       	cpse	r24, r1
    1302:	c2 cf       	rjmp	.-124    	; 0x1288 <xTaskResumeAll+0x30>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    1304:	80 91 2e 08 	lds	r24, 0x082E
    1308:	88 23       	and	r24, r24
    130a:	99 f0       	breq	.+38     	; 0x1332 <xTaskResumeAll+0xda>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    130c:	80 91 2e 08 	lds	r24, 0x082E
    1310:	88 23       	and	r24, r24
    1312:	79 f0       	breq	.+30     	; 0x1332 <xTaskResumeAll+0xda>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
    1314:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    1316:	0e 94 6f 08 	call	0x10de	; 0x10de <xTaskIncrementTick>
    131a:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
    131c:	c0 93 2d 08 	sts	0x082D, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    1320:	80 91 2e 08 	lds	r24, 0x082E
    1324:	81 50       	subi	r24, 0x01	; 1
    1326:	80 93 2e 08 	sts	0x082E, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    132a:	80 91 2e 08 	lds	r24, 0x082E
    132e:	81 11       	cpse	r24, r1
    1330:	f2 cf       	rjmp	.-28     	; 0x1316 <xTaskResumeAll+0xbe>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    1332:	80 91 2d 08 	lds	r24, 0x082D
    1336:	81 30       	cpi	r24, 0x01	; 1
    1338:	31 f4       	brne	.+12     	; 0x1346 <xTaskResumeAll+0xee>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    133a:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    133e:	81 e0       	ldi	r24, 0x01	; 1
    1340:	03 c0       	rjmp	.+6      	; 0x1348 <xTaskResumeAll+0xf0>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    1342:	80 e0       	ldi	r24, 0x00	; 0
    1344:	01 c0       	rjmp	.+2      	; 0x1348 <xTaskResumeAll+0xf0>
    1346:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    1348:	0f 90       	pop	r0
    134a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    134c:	df 91       	pop	r29
    134e:	cf 91       	pop	r28
    1350:	1f 91       	pop	r17
    1352:	0f 91       	pop	r16
    1354:	ff 90       	pop	r15
    1356:	ef 90       	pop	r14
    1358:	df 90       	pop	r13
    135a:	08 95       	ret

0000135c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    135c:	0f 93       	push	r16
    135e:	1f 93       	push	r17
    1360:	cf 93       	push	r28
    1362:	df 93       	push	r29
    1364:	8c 01       	movw	r16, r24
    1366:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    1368:	0e 94 5f 08 	call	0x10be	; 0x10be <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    136c:	80 91 31 08 	lds	r24, 0x0831
    1370:	90 91 32 08 	lds	r25, 0x0832

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    1374:	f8 01       	movw	r30, r16
    1376:	20 81       	ld	r18, Z
    1378:	31 81       	ldd	r19, Z+1	; 0x01
    137a:	c2 0f       	add	r28, r18
    137c:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
    137e:	82 17       	cp	r24, r18
    1380:	93 07       	cpc	r25, r19
    1382:	48 f4       	brcc	.+18     	; 0x1396 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    1384:	c2 17       	cp	r28, r18
    1386:	d3 07       	cpc	r29, r19
    1388:	10 f5       	brcc	.+68     	; 0x13ce <vTaskDelayUntil+0x72>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    138a:	d1 83       	std	Z+1, r29	; 0x01
    138c:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    138e:	8c 17       	cp	r24, r28
    1390:	9d 07       	cpc	r25, r29
    1392:	90 f4       	brcc	.+36     	; 0x13b8 <vTaskDelayUntil+0x5c>
    1394:	07 c0       	rjmp	.+14     	; 0x13a4 <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    1396:	c2 17       	cp	r28, r18
    1398:	d3 07       	cpc	r29, r19
    139a:	a8 f0       	brcs	.+42     	; 0x13c6 <vTaskDelayUntil+0x6a>
    139c:	8c 17       	cp	r24, r28
    139e:	9d 07       	cpc	r25, r29
    13a0:	90 f0       	brcs	.+36     	; 0x13c6 <vTaskDelayUntil+0x6a>
    13a2:	15 c0       	rjmp	.+42     	; 0x13ce <vTaskDelayUntil+0x72>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    13a4:	80 91 8c 08 	lds	r24, 0x088C
    13a8:	90 91 8d 08 	lds	r25, 0x088D
    13ac:	02 96       	adiw	r24, 0x02	; 2
    13ae:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    13b2:	ce 01       	movw	r24, r28
    13b4:	0e 94 e6 06 	call	0xdcc	; 0xdcc <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    13b8:	0e 94 2c 09 	call	0x1258	; 0x1258 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    13bc:	81 11       	cpse	r24, r1
    13be:	0b c0       	rjmp	.+22     	; 0x13d6 <vTaskDelayUntil+0x7a>
		{
			portYIELD_WITHIN_API();
    13c0:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
    13c4:	08 c0       	rjmp	.+16     	; 0x13d6 <vTaskDelayUntil+0x7a>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    13c6:	f8 01       	movw	r30, r16
    13c8:	d1 83       	std	Z+1, r29	; 0x01
    13ca:	c0 83       	st	Z, r28
    13cc:	eb cf       	rjmp	.-42     	; 0x13a4 <vTaskDelayUntil+0x48>
    13ce:	f8 01       	movw	r30, r16
    13d0:	d1 83       	std	Z+1, r29	; 0x01
    13d2:	c0 83       	st	Z, r28
    13d4:	f1 cf       	rjmp	.-30     	; 0x13b8 <vTaskDelayUntil+0x5c>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    13d6:	df 91       	pop	r29
    13d8:	cf 91       	pop	r28
    13da:	1f 91       	pop	r17
    13dc:	0f 91       	pop	r16
    13de:	08 95       	ret

000013e0 <prvIdleTask>:
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    13e0:	00 e4       	ldi	r16, 0x40	; 64
    13e2:	18 e0       	ldi	r17, 0x08	; 8

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    13e4:	0f 2e       	mov	r0, r31
    13e6:	f8 e6       	ldi	r31, 0x68	; 104
    13e8:	ef 2e       	mov	r14, r31
    13ea:	f8 e0       	ldi	r31, 0x08	; 8
    13ec:	ff 2e       	mov	r15, r31
    13ee:	f0 2d       	mov	r31, r0
    13f0:	29 c0       	rjmp	.+82     	; 0x1444 <prvIdleTask+0x64>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    13f2:	0e 94 5f 08 	call	0x10be	; 0x10be <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    13f6:	d8 01       	movw	r26, r16
    13f8:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
    13fa:	0e 94 2c 09 	call	0x1258	; 0x1258 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    13fe:	cc 23       	and	r28, r28
    1400:	09 f1       	breq	.+66     	; 0x1444 <prvIdleTask+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    1402:	0f b6       	in	r0, 0x3f	; 63
    1404:	f8 94       	cli
    1406:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    1408:	d8 01       	movw	r26, r16
    140a:	15 96       	adiw	r26, 0x05	; 5
    140c:	ed 91       	ld	r30, X+
    140e:	fc 91       	ld	r31, X
    1410:	16 97       	sbiw	r26, 0x06	; 6
    1412:	c6 81       	ldd	r28, Z+6	; 0x06
    1414:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1416:	ce 01       	movw	r24, r28
    1418:	02 96       	adiw	r24, 0x02	; 2
    141a:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
					--uxCurrentNumberOfTasks;
    141e:	80 91 33 08 	lds	r24, 0x0833
    1422:	81 50       	subi	r24, 0x01	; 1
    1424:	80 93 33 08 	sts	0x0833, r24
					--uxTasksDeleted;
    1428:	80 91 3f 08 	lds	r24, 0x083F
    142c:	81 50       	subi	r24, 0x01	; 1
    142e:	80 93 3f 08 	sts	0x083F, r24
				}
				taskEXIT_CRITICAL();
    1432:	0f 90       	pop	r0
    1434:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    1436:	8f 89       	ldd	r24, Y+23	; 0x17
    1438:	98 8d       	ldd	r25, Y+24	; 0x18
    143a:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    143e:	ce 01       	movw	r24, r28
    1440:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    1444:	80 91 3f 08 	lds	r24, 0x083F
    1448:	81 11       	cpse	r24, r1
    144a:	d3 cf       	rjmp	.-90     	; 0x13f2 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    144c:	f7 01       	movw	r30, r14
    144e:	80 81       	ld	r24, Z
    1450:	82 30       	cpi	r24, 0x02	; 2
    1452:	c0 f3       	brcs	.-16     	; 0x1444 <prvIdleTask+0x64>
			{
				taskYIELD();
    1454:	0e 94 82 02 	call	0x504	; 0x504 <vPortYield>
    1458:	f5 cf       	rjmp	.-22     	; 0x1444 <prvIdleTask+0x64>

0000145a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    145a:	80 91 2a 08 	lds	r24, 0x082A
    145e:	88 23       	and	r24, r24
    1460:	21 f0       	breq	.+8      	; 0x146a <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    1462:	81 e0       	ldi	r24, 0x01	; 1
    1464:	80 93 2d 08 	sts	0x082D, r24
    1468:	08 95       	ret
	//	USART_sendstr("uxSchedulerSuspended");
	}
	else
	{
		xYieldPending = pdFALSE;
    146a:	10 92 2d 08 	sts	0x082D, r1
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
	//	USART_sendstr("HIGHEST_PRIORITY_TASK\n");
		taskSELECT_HIGHEST_PRIORITY_TASK();
    146e:	80 91 30 08 	lds	r24, 0x0830
    1472:	90 e0       	ldi	r25, 0x00	; 0
    1474:	fc 01       	movw	r30, r24
    1476:	ee 0f       	add	r30, r30
    1478:	ff 1f       	adc	r31, r31
    147a:	ee 0f       	add	r30, r30
    147c:	ff 1f       	adc	r31, r31
    147e:	ee 0f       	add	r30, r30
    1480:	ff 1f       	adc	r31, r31
    1482:	8e 0f       	add	r24, r30
    1484:	9f 1f       	adc	r25, r31
    1486:	fc 01       	movw	r30, r24
    1488:	e8 59       	subi	r30, 0x98	; 152
    148a:	f7 4f       	sbci	r31, 0xF7	; 247
    148c:	80 81       	ld	r24, Z
    148e:	81 11       	cpse	r24, r1
    1490:	17 c0       	rjmp	.+46     	; 0x14c0 <vTaskSwitchContext+0x66>
    1492:	80 91 30 08 	lds	r24, 0x0830
    1496:	81 50       	subi	r24, 0x01	; 1
    1498:	80 93 30 08 	sts	0x0830, r24
    149c:	80 91 30 08 	lds	r24, 0x0830
    14a0:	90 e0       	ldi	r25, 0x00	; 0
    14a2:	fc 01       	movw	r30, r24
    14a4:	ee 0f       	add	r30, r30
    14a6:	ff 1f       	adc	r31, r31
    14a8:	ee 0f       	add	r30, r30
    14aa:	ff 1f       	adc	r31, r31
    14ac:	ee 0f       	add	r30, r30
    14ae:	ff 1f       	adc	r31, r31
    14b0:	8e 0f       	add	r24, r30
    14b2:	9f 1f       	adc	r25, r31
    14b4:	fc 01       	movw	r30, r24
    14b6:	e8 59       	subi	r30, 0x98	; 152
    14b8:	f7 4f       	sbci	r31, 0xF7	; 247
    14ba:	80 81       	ld	r24, Z
    14bc:	88 23       	and	r24, r24
    14be:	49 f3       	breq	.-46     	; 0x1492 <vTaskSwitchContext+0x38>
    14c0:	80 91 30 08 	lds	r24, 0x0830
    14c4:	90 e0       	ldi	r25, 0x00	; 0
    14c6:	9c 01       	movw	r18, r24
    14c8:	22 0f       	add	r18, r18
    14ca:	33 1f       	adc	r19, r19
    14cc:	22 0f       	add	r18, r18
    14ce:	33 1f       	adc	r19, r19
    14d0:	22 0f       	add	r18, r18
    14d2:	33 1f       	adc	r19, r19
    14d4:	28 0f       	add	r18, r24
    14d6:	39 1f       	adc	r19, r25
    14d8:	d9 01       	movw	r26, r18
    14da:	a8 59       	subi	r26, 0x98	; 152
    14dc:	b7 4f       	sbci	r27, 0xF7	; 247
    14de:	11 96       	adiw	r26, 0x01	; 1
    14e0:	ed 91       	ld	r30, X+
    14e2:	fc 91       	ld	r31, X
    14e4:	12 97       	sbiw	r26, 0x02	; 2
    14e6:	02 80       	ldd	r0, Z+2	; 0x02
    14e8:	f3 81       	ldd	r31, Z+3	; 0x03
    14ea:	e0 2d       	mov	r30, r0
    14ec:	12 96       	adiw	r26, 0x02	; 2
    14ee:	fc 93       	st	X, r31
    14f0:	ee 93       	st	-X, r30
    14f2:	11 97       	sbiw	r26, 0x01	; 1
    14f4:	25 59       	subi	r18, 0x95	; 149
    14f6:	37 4f       	sbci	r19, 0xF7	; 247
    14f8:	e2 17       	cp	r30, r18
    14fa:	f3 07       	cpc	r31, r19
    14fc:	29 f4       	brne	.+10     	; 0x1508 <vTaskSwitchContext+0xae>
    14fe:	22 81       	ldd	r18, Z+2	; 0x02
    1500:	33 81       	ldd	r19, Z+3	; 0x03
    1502:	fd 01       	movw	r30, r26
    1504:	32 83       	std	Z+2, r19	; 0x02
    1506:	21 83       	std	Z+1, r18	; 0x01
    1508:	fc 01       	movw	r30, r24
    150a:	ee 0f       	add	r30, r30
    150c:	ff 1f       	adc	r31, r31
    150e:	ee 0f       	add	r30, r30
    1510:	ff 1f       	adc	r31, r31
    1512:	ee 0f       	add	r30, r30
    1514:	ff 1f       	adc	r31, r31
    1516:	8e 0f       	add	r24, r30
    1518:	9f 1f       	adc	r25, r31
    151a:	fc 01       	movw	r30, r24
    151c:	e8 59       	subi	r30, 0x98	; 152
    151e:	f7 4f       	sbci	r31, 0xF7	; 247
    1520:	01 80       	ldd	r0, Z+1	; 0x01
    1522:	f2 81       	ldd	r31, Z+2	; 0x02
    1524:	e0 2d       	mov	r30, r0
    1526:	86 81       	ldd	r24, Z+6	; 0x06
    1528:	97 81       	ldd	r25, Z+7	; 0x07
    152a:	90 93 8d 08 	sts	0x088D, r25
    152e:	80 93 8c 08 	sts	0x088C, r24
    1532:	08 95       	ret

00001534 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    1534:	cf 93       	push	r28
    1536:	df 93       	push	r29
    1538:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    153a:	20 91 8c 08 	lds	r18, 0x088C
    153e:	30 91 8d 08 	lds	r19, 0x088D
    1542:	b9 01       	movw	r22, r18
    1544:	64 5f       	subi	r22, 0xF4	; 244
    1546:	7f 4f       	sbci	r23, 0xFF	; 255
    1548:	0e 94 85 01 	call	0x30a	; 0x30a <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    154c:	80 91 8c 08 	lds	r24, 0x088C
    1550:	90 91 8d 08 	lds	r25, 0x088D
    1554:	02 96       	adiw	r24, 0x02	; 2
    1556:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    155a:	cf 3f       	cpi	r28, 0xFF	; 255
    155c:	8f ef       	ldi	r24, 0xFF	; 255
    155e:	d8 07       	cpc	r29, r24
    1560:	59 f4       	brne	.+22     	; 0x1578 <vTaskPlaceOnEventList+0x44>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1562:	60 91 8c 08 	lds	r22, 0x088C
    1566:	70 91 8d 08 	lds	r23, 0x088D
    156a:	6e 5f       	subi	r22, 0xFE	; 254
    156c:	7f 4f       	sbci	r23, 0xFF	; 255
    156e:	86 e3       	ldi	r24, 0x36	; 54
    1570:	98 e0       	ldi	r25, 0x08	; 8
    1572:	0e 94 64 01 	call	0x2c8	; 0x2c8 <vListInsertEnd>
    1576:	08 c0       	rjmp	.+16     	; 0x1588 <vTaskPlaceOnEventList+0x54>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    1578:	80 91 31 08 	lds	r24, 0x0831
    157c:	90 91 32 08 	lds	r25, 0x0832
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1580:	8c 0f       	add	r24, r28
    1582:	9d 1f       	adc	r25, r29
    1584:	0e 94 e6 06 	call	0xdcc	; 0xdcc <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1588:	df 91       	pop	r29
    158a:	cf 91       	pop	r28
    158c:	08 95       	ret

0000158e <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    158e:	0f 93       	push	r16
    1590:	1f 93       	push	r17
    1592:	cf 93       	push	r28
    1594:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1596:	dc 01       	movw	r26, r24
    1598:	15 96       	adiw	r26, 0x05	; 5
    159a:	ed 91       	ld	r30, X+
    159c:	fc 91       	ld	r31, X
    159e:	16 97       	sbiw	r26, 0x06	; 6
    15a0:	c6 81       	ldd	r28, Z+6	; 0x06
    15a2:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    15a4:	8e 01       	movw	r16, r28
    15a6:	04 5f       	subi	r16, 0xF4	; 244
    15a8:	1f 4f       	sbci	r17, 0xFF	; 255
    15aa:	c8 01       	movw	r24, r16
    15ac:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    15b0:	80 91 2a 08 	lds	r24, 0x082A
    15b4:	81 11       	cpse	r24, r1
    15b6:	1c c0       	rjmp	.+56     	; 0x15f0 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    15b8:	0a 50       	subi	r16, 0x0A	; 10
    15ba:	11 09       	sbc	r17, r1
    15bc:	c8 01       	movw	r24, r16
    15be:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    15c2:	2e 89       	ldd	r18, Y+22	; 0x16
    15c4:	80 91 30 08 	lds	r24, 0x0830
    15c8:	82 17       	cp	r24, r18
    15ca:	10 f4       	brcc	.+4      	; 0x15d0 <xTaskRemoveFromEventList+0x42>
    15cc:	20 93 30 08 	sts	0x0830, r18
    15d0:	30 e0       	ldi	r19, 0x00	; 0
    15d2:	c9 01       	movw	r24, r18
    15d4:	88 0f       	add	r24, r24
    15d6:	99 1f       	adc	r25, r25
    15d8:	88 0f       	add	r24, r24
    15da:	99 1f       	adc	r25, r25
    15dc:	88 0f       	add	r24, r24
    15de:	99 1f       	adc	r25, r25
    15e0:	82 0f       	add	r24, r18
    15e2:	93 1f       	adc	r25, r19
    15e4:	b8 01       	movw	r22, r16
    15e6:	88 59       	subi	r24, 0x98	; 152
    15e8:	97 4f       	sbci	r25, 0xF7	; 247
    15ea:	0e 94 64 01 	call	0x2c8	; 0x2c8 <vListInsertEnd>
    15ee:	05 c0       	rjmp	.+10     	; 0x15fa <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    15f0:	b8 01       	movw	r22, r16
    15f2:	89 e4       	ldi	r24, 0x49	; 73
    15f4:	98 e0       	ldi	r25, 0x08	; 8
    15f6:	0e 94 64 01 	call	0x2c8	; 0x2c8 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    15fa:	e0 91 8c 08 	lds	r30, 0x088C
    15fe:	f0 91 8d 08 	lds	r31, 0x088D
    1602:	9e 89       	ldd	r25, Y+22	; 0x16
    1604:	86 89       	ldd	r24, Z+22	; 0x16
    1606:	89 17       	cp	r24, r25
    1608:	20 f4       	brcc	.+8      	; 0x1612 <xTaskRemoveFromEventList+0x84>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    160a:	81 e0       	ldi	r24, 0x01	; 1
    160c:	80 93 2d 08 	sts	0x082D, r24
    1610:	01 c0       	rjmp	.+2      	; 0x1614 <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		xReturn = pdFALSE;
    1612:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    1614:	df 91       	pop	r29
    1616:	cf 91       	pop	r28
    1618:	1f 91       	pop	r17
    161a:	0f 91       	pop	r16
    161c:	08 95       	ret

0000161e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    161e:	20 91 2c 08 	lds	r18, 0x082C
    1622:	fc 01       	movw	r30, r24
    1624:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1626:	20 91 31 08 	lds	r18, 0x0831
    162a:	30 91 32 08 	lds	r19, 0x0832
    162e:	32 83       	std	Z+2, r19	; 0x02
    1630:	21 83       	std	Z+1, r18	; 0x01
    1632:	08 95       	ret

00001634 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1634:	0f b6       	in	r0, 0x3f	; 63
    1636:	f8 94       	cli
    1638:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    163a:	40 91 31 08 	lds	r20, 0x0831
    163e:	50 91 32 08 	lds	r21, 0x0832

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    1642:	db 01       	movw	r26, r22
    1644:	2d 91       	ld	r18, X+
    1646:	3c 91       	ld	r19, X
    1648:	2f 3f       	cpi	r18, 0xFF	; 255
    164a:	bf ef       	ldi	r27, 0xFF	; 255
    164c:	3b 07       	cpc	r19, r27
    164e:	19 f1       	breq	.+70     	; 0x1696 <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1650:	e0 91 2c 08 	lds	r30, 0x082C
    1654:	dc 01       	movw	r26, r24
    1656:	fc 91       	ld	r31, X
    1658:	fe 17       	cp	r31, r30
    165a:	39 f0       	breq	.+14     	; 0x166a <xTaskCheckForTimeOut+0x36>
    165c:	11 96       	adiw	r26, 0x01	; 1
    165e:	ed 91       	ld	r30, X+
    1660:	fc 91       	ld	r31, X
    1662:	12 97       	sbiw	r26, 0x02	; 2
    1664:	4e 17       	cp	r20, r30
    1666:	5f 07       	cpc	r21, r31
    1668:	c0 f4       	brcc	.+48     	; 0x169a <xTaskCheckForTimeOut+0x66>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    166a:	dc 01       	movw	r26, r24
    166c:	11 96       	adiw	r26, 0x01	; 1
    166e:	ed 91       	ld	r30, X+
    1670:	fc 91       	ld	r31, X
    1672:	12 97       	sbiw	r26, 0x02	; 2
    1674:	da 01       	movw	r26, r20
    1676:	ae 1b       	sub	r26, r30
    1678:	bf 0b       	sbc	r27, r31
    167a:	a2 17       	cp	r26, r18
    167c:	b3 07       	cpc	r27, r19
    167e:	78 f4       	brcc	.+30     	; 0x169e <xTaskCheckForTimeOut+0x6a>
    1680:	db 01       	movw	r26, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    1682:	e4 1b       	sub	r30, r20
    1684:	f5 0b       	sbc	r31, r21
    1686:	2e 0f       	add	r18, r30
    1688:	3f 1f       	adc	r19, r31
    168a:	2d 93       	st	X+, r18
    168c:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    168e:	0e 94 0f 0b 	call	0x161e	; 0x161e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1692:	80 e0       	ldi	r24, 0x00	; 0
    1694:	05 c0       	rjmp	.+10     	; 0x16a0 <xTaskCheckForTimeOut+0x6c>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    1696:	80 e0       	ldi	r24, 0x00	; 0
    1698:	03 c0       	rjmp	.+6      	; 0x16a0 <xTaskCheckForTimeOut+0x6c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    169a:	81 e0       	ldi	r24, 0x01	; 1
    169c:	01 c0       	rjmp	.+2      	; 0x16a0 <xTaskCheckForTimeOut+0x6c>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    169e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    16a0:	0f 90       	pop	r0
    16a2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    16a4:	08 95       	ret

000016a6 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    16a6:	81 e0       	ldi	r24, 0x01	; 1
    16a8:	80 93 2d 08 	sts	0x082D, r24
    16ac:	08 95       	ret

000016ae <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    16ae:	0f 93       	push	r16
    16b0:	1f 93       	push	r17
    16b2:	cf 93       	push	r28
    16b4:	df 93       	push	r29
    16b6:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    16b8:	89 2b       	or	r24, r25
    16ba:	09 f4       	brne	.+2      	; 0x16be <vTaskPriorityInherit+0x10>
    16bc:	55 c0       	rjmp	.+170    	; 0x1768 <vTaskPriorityInherit+0xba>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    16be:	26 89       	ldd	r18, Z+22	; 0x16
    16c0:	a0 91 8c 08 	lds	r26, 0x088C
    16c4:	b0 91 8d 08 	lds	r27, 0x088D
    16c8:	56 96       	adiw	r26, 0x16	; 22
    16ca:	8c 91       	ld	r24, X
    16cc:	28 17       	cp	r18, r24
    16ce:	08 f0       	brcs	.+2      	; 0x16d2 <vTaskPriorityInherit+0x24>
    16d0:	4b c0       	rjmp	.+150    	; 0x1768 <vTaskPriorityInherit+0xba>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    16d2:	84 85       	ldd	r24, Z+12	; 0x0c
    16d4:	95 85       	ldd	r25, Z+13	; 0x0d
    16d6:	99 23       	and	r25, r25
    16d8:	64 f0       	brlt	.+24     	; 0x16f2 <vTaskPriorityInherit+0x44>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    16da:	a0 91 8c 08 	lds	r26, 0x088C
    16de:	b0 91 8d 08 	lds	r27, 0x088D
    16e2:	56 96       	adiw	r26, 0x16	; 22
    16e4:	3c 91       	ld	r19, X
    16e6:	84 e0       	ldi	r24, 0x04	; 4
    16e8:	90 e0       	ldi	r25, 0x00	; 0
    16ea:	83 1b       	sub	r24, r19
    16ec:	91 09       	sbc	r25, r1
    16ee:	95 87       	std	Z+13, r25	; 0x0d
    16f0:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    16f2:	30 e0       	ldi	r19, 0x00	; 0
    16f4:	c9 01       	movw	r24, r18
    16f6:	88 0f       	add	r24, r24
    16f8:	99 1f       	adc	r25, r25
    16fa:	88 0f       	add	r24, r24
    16fc:	99 1f       	adc	r25, r25
    16fe:	88 0f       	add	r24, r24
    1700:	99 1f       	adc	r25, r25
    1702:	28 0f       	add	r18, r24
    1704:	39 1f       	adc	r19, r25
    1706:	28 59       	subi	r18, 0x98	; 152
    1708:	37 4f       	sbci	r19, 0xF7	; 247
    170a:	82 85       	ldd	r24, Z+10	; 0x0a
    170c:	93 85       	ldd	r25, Z+11	; 0x0b
    170e:	82 17       	cp	r24, r18
    1710:	93 07       	cpc	r25, r19
    1712:	19 f5       	brne	.+70     	; 0x175a <vTaskPriorityInherit+0xac>
    1714:	8f 01       	movw	r16, r30
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1716:	ef 01       	movw	r28, r30
    1718:	22 96       	adiw	r28, 0x02	; 2
    171a:	ce 01       	movw	r24, r28
    171c:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1720:	e0 91 8c 08 	lds	r30, 0x088C
    1724:	f0 91 8d 08 	lds	r31, 0x088D
    1728:	26 89       	ldd	r18, Z+22	; 0x16
    172a:	f8 01       	movw	r30, r16
    172c:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyList( pxTCB );
    172e:	80 91 30 08 	lds	r24, 0x0830
    1732:	82 17       	cp	r24, r18
    1734:	10 f4       	brcc	.+4      	; 0x173a <vTaskPriorityInherit+0x8c>
    1736:	20 93 30 08 	sts	0x0830, r18
    173a:	30 e0       	ldi	r19, 0x00	; 0
    173c:	c9 01       	movw	r24, r18
    173e:	88 0f       	add	r24, r24
    1740:	99 1f       	adc	r25, r25
    1742:	88 0f       	add	r24, r24
    1744:	99 1f       	adc	r25, r25
    1746:	88 0f       	add	r24, r24
    1748:	99 1f       	adc	r25, r25
    174a:	82 0f       	add	r24, r18
    174c:	93 1f       	adc	r25, r19
    174e:	be 01       	movw	r22, r28
    1750:	88 59       	subi	r24, 0x98	; 152
    1752:	97 4f       	sbci	r25, 0xF7	; 247
    1754:	0e 94 64 01 	call	0x2c8	; 0x2c8 <vListInsertEnd>
    1758:	07 c0       	rjmp	.+14     	; 0x1768 <vTaskPriorityInherit+0xba>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    175a:	a0 91 8c 08 	lds	r26, 0x088C
    175e:	b0 91 8d 08 	lds	r27, 0x088D
    1762:	56 96       	adiw	r26, 0x16	; 22
    1764:	8c 91       	ld	r24, X
    1766:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1768:	df 91       	pop	r29
    176a:	cf 91       	pop	r28
    176c:	1f 91       	pop	r17
    176e:	0f 91       	pop	r16
    1770:	08 95       	ret

00001772 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    1772:	0f 93       	push	r16
    1774:	1f 93       	push	r17
    1776:	cf 93       	push	r28
    1778:	df 93       	push	r29
    177a:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    177c:	89 2b       	or	r24, r25
    177e:	79 f1       	breq	.+94     	; 0x17de <xTaskPriorityDisinherit+0x6c>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    1780:	82 a1       	ldd	r24, Z+34	; 0x22
    1782:	81 50       	subi	r24, 0x01	; 1
    1784:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    1786:	26 89       	ldd	r18, Z+22	; 0x16
    1788:	91 a1       	ldd	r25, Z+33	; 0x21
    178a:	29 17       	cp	r18, r25
    178c:	51 f1       	breq	.+84     	; 0x17e2 <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    178e:	81 11       	cpse	r24, r1
    1790:	2a c0       	rjmp	.+84     	; 0x17e6 <xTaskPriorityDisinherit+0x74>
    1792:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1794:	8f 01       	movw	r16, r30
    1796:	0e 5f       	subi	r16, 0xFE	; 254
    1798:	1f 4f       	sbci	r17, 0xFF	; 255
    179a:	c8 01       	movw	r24, r16
    179c:	0e 94 b6 01 	call	0x36c	; 0x36c <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    17a0:	29 a1       	ldd	r18, Y+33	; 0x21
    17a2:	2e 8b       	std	Y+22, r18	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    17a4:	44 e0       	ldi	r20, 0x04	; 4
    17a6:	50 e0       	ldi	r21, 0x00	; 0
    17a8:	42 1b       	sub	r20, r18
    17aa:	51 09       	sbc	r21, r1
    17ac:	5d 87       	std	Y+13, r21	; 0x0d
    17ae:	4c 87       	std	Y+12, r20	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    17b0:	80 91 30 08 	lds	r24, 0x0830
    17b4:	82 17       	cp	r24, r18
    17b6:	10 f4       	brcc	.+4      	; 0x17bc <xTaskPriorityDisinherit+0x4a>
    17b8:	20 93 30 08 	sts	0x0830, r18
    17bc:	30 e0       	ldi	r19, 0x00	; 0
    17be:	c9 01       	movw	r24, r18
    17c0:	88 0f       	add	r24, r24
    17c2:	99 1f       	adc	r25, r25
    17c4:	88 0f       	add	r24, r24
    17c6:	99 1f       	adc	r25, r25
    17c8:	88 0f       	add	r24, r24
    17ca:	99 1f       	adc	r25, r25
    17cc:	82 0f       	add	r24, r18
    17ce:	93 1f       	adc	r25, r19
    17d0:	b8 01       	movw	r22, r16
    17d2:	88 59       	subi	r24, 0x98	; 152
    17d4:	97 4f       	sbci	r25, 0xF7	; 247
    17d6:	0e 94 64 01 	call	0x2c8	; 0x2c8 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    17da:	81 e0       	ldi	r24, 0x01	; 1
    17dc:	05 c0       	rjmp	.+10     	; 0x17e8 <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    17de:	80 e0       	ldi	r24, 0x00	; 0
    17e0:	03 c0       	rjmp	.+6      	; 0x17e8 <xTaskPriorityDisinherit+0x76>
    17e2:	80 e0       	ldi	r24, 0x00	; 0
    17e4:	01 c0       	rjmp	.+2      	; 0x17e8 <xTaskPriorityDisinherit+0x76>
    17e6:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    17e8:	df 91       	pop	r29
    17ea:	cf 91       	pop	r28
    17ec:	1f 91       	pop	r17
    17ee:	0f 91       	pop	r16
    17f0:	08 95       	ret

000017f2 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    17f2:	80 91 8c 08 	lds	r24, 0x088C
    17f6:	90 91 8d 08 	lds	r25, 0x088D
    17fa:	89 2b       	or	r24, r25
    17fc:	39 f0       	breq	.+14     	; 0x180c <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    17fe:	e0 91 8c 08 	lds	r30, 0x088C
    1802:	f0 91 8d 08 	lds	r31, 0x088D
    1806:	82 a1       	ldd	r24, Z+34	; 0x22
    1808:	8f 5f       	subi	r24, 0xFF	; 255
    180a:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    180c:	80 91 8c 08 	lds	r24, 0x088C
    1810:	90 91 8d 08 	lds	r25, 0x088D
	}
    1814:	08 95       	ret

00001816 <attachInterrupt>:

static volatile voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
// volatile static voidFuncPtr twiIntFunc;

void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode) {
  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
    1816:	82 30       	cpi	r24, 0x02	; 2
    1818:	00 f5       	brcc	.+64     	; 0x185a <attachInterrupt+0x44>
    intFunc[interruptNum] = userFunc;
    181a:	e8 2f       	mov	r30, r24
    181c:	f0 e0       	ldi	r31, 0x00	; 0
    181e:	ee 0f       	add	r30, r30
    1820:	ff 1f       	adc	r31, r31
    1822:	e2 57       	subi	r30, 0x72	; 114
    1824:	f7 4f       	sbci	r31, 0xF7	; 247
    1826:	71 83       	std	Z+1, r23	; 0x01
    1828:	60 83       	st	Z, r22
    // to the configuration bits in the hardware register, so we simply shift
    // the mode into place.
      
    // Enable the interrupt.
      
    switch (interruptNum) {
    182a:	88 23       	and	r24, r24
    182c:	19 f0       	breq	.+6      	; 0x1834 <attachInterrupt+0x1e>
    182e:	81 30       	cpi	r24, 0x01	; 1
    1830:	49 f0       	breq	.+18     	; 0x1844 <attachInterrupt+0x2e>
    1832:	08 95       	ret
      EIMSK |= (1 << INT7);
      break;
#else		
    case 0:
    #if defined(EICRA) && defined(ISC00) && defined(EIMSK)
      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
    1834:	e9 e6       	ldi	r30, 0x69	; 105
    1836:	f0 e0       	ldi	r31, 0x00	; 0
    1838:	80 81       	ld	r24, Z
    183a:	8c 7f       	andi	r24, 0xFC	; 252
    183c:	48 2b       	or	r20, r24
    183e:	40 83       	st	Z, r20
      EIMSK |= (1 << INT0);
    1840:	e8 9a       	sbi	0x1d, 0	; 29
      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
      GIMSK |= (1 << INT0);
    #else
      #error attachInterrupt not finished for this CPU (case 0)
    #endif
      break;
    1842:	08 95       	ret

    case 1:
    #if defined(EICRA) && defined(ISC10) && defined(ISC11) && defined(EIMSK)
      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
    1844:	e9 e6       	ldi	r30, 0x69	; 105
    1846:	f0 e0       	ldi	r31, 0x00	; 0
    1848:	80 81       	ld	r24, Z
    184a:	44 0f       	add	r20, r20
    184c:	55 1f       	adc	r21, r21
    184e:	44 0f       	add	r20, r20
    1850:	55 1f       	adc	r21, r21
    1852:	83 7f       	andi	r24, 0xF3	; 243
    1854:	48 2b       	or	r20, r24
    1856:	40 83       	st	Z, r20
      EIMSK |= (1 << INT1);
    1858:	e9 9a       	sbi	0x1d, 1	; 29
    185a:	08 95       	ret

0000185c <__vector_1>:
    intFunc[EXTERNAL_INT_7]();
}

#else

ISR(INT0_vect) {
    185c:	1f 92       	push	r1
    185e:	0f 92       	push	r0
    1860:	0f b6       	in	r0, 0x3f	; 63
    1862:	0f 92       	push	r0
    1864:	11 24       	eor	r1, r1
    1866:	2f 93       	push	r18
    1868:	3f 93       	push	r19
    186a:	4f 93       	push	r20
    186c:	5f 93       	push	r21
    186e:	6f 93       	push	r22
    1870:	7f 93       	push	r23
    1872:	8f 93       	push	r24
    1874:	9f 93       	push	r25
    1876:	af 93       	push	r26
    1878:	bf 93       	push	r27
    187a:	ef 93       	push	r30
    187c:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_0])
    187e:	80 91 8e 08 	lds	r24, 0x088E
    1882:	90 91 8f 08 	lds	r25, 0x088F
    1886:	89 2b       	or	r24, r25
    1888:	29 f0       	breq	.+10     	; 0x1894 <__vector_1+0x38>
    intFunc[EXTERNAL_INT_0]();
    188a:	e0 91 8e 08 	lds	r30, 0x088E
    188e:	f0 91 8f 08 	lds	r31, 0x088F
    1892:	09 95       	icall
}
    1894:	ff 91       	pop	r31
    1896:	ef 91       	pop	r30
    1898:	bf 91       	pop	r27
    189a:	af 91       	pop	r26
    189c:	9f 91       	pop	r25
    189e:	8f 91       	pop	r24
    18a0:	7f 91       	pop	r23
    18a2:	6f 91       	pop	r22
    18a4:	5f 91       	pop	r21
    18a6:	4f 91       	pop	r20
    18a8:	3f 91       	pop	r19
    18aa:	2f 91       	pop	r18
    18ac:	0f 90       	pop	r0
    18ae:	0f be       	out	0x3f, r0	; 63
    18b0:	0f 90       	pop	r0
    18b2:	1f 90       	pop	r1
    18b4:	18 95       	reti

000018b6 <__vector_2>:

ISR(INT1_vect) {
    18b6:	1f 92       	push	r1
    18b8:	0f 92       	push	r0
    18ba:	0f b6       	in	r0, 0x3f	; 63
    18bc:	0f 92       	push	r0
    18be:	11 24       	eor	r1, r1
    18c0:	2f 93       	push	r18
    18c2:	3f 93       	push	r19
    18c4:	4f 93       	push	r20
    18c6:	5f 93       	push	r21
    18c8:	6f 93       	push	r22
    18ca:	7f 93       	push	r23
    18cc:	8f 93       	push	r24
    18ce:	9f 93       	push	r25
    18d0:	af 93       	push	r26
    18d2:	bf 93       	push	r27
    18d4:	ef 93       	push	r30
    18d6:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_1])
    18d8:	80 91 90 08 	lds	r24, 0x0890
    18dc:	90 91 91 08 	lds	r25, 0x0891
    18e0:	89 2b       	or	r24, r25
    18e2:	29 f0       	breq	.+10     	; 0x18ee <__vector_2+0x38>
    intFunc[EXTERNAL_INT_1]();
    18e4:	e0 91 90 08 	lds	r30, 0x0890
    18e8:	f0 91 91 08 	lds	r31, 0x0891
    18ec:	09 95       	icall
}
    18ee:	ff 91       	pop	r31
    18f0:	ef 91       	pop	r30
    18f2:	bf 91       	pop	r27
    18f4:	af 91       	pop	r26
    18f6:	9f 91       	pop	r25
    18f8:	8f 91       	pop	r24
    18fa:	7f 91       	pop	r23
    18fc:	6f 91       	pop	r22
    18fe:	5f 91       	pop	r21
    1900:	4f 91       	pop	r20
    1902:	3f 91       	pop	r19
    1904:	2f 91       	pop	r18
    1906:	0f 90       	pop	r0
    1908:	0f be       	out	0x3f, r0	; 63
    190a:	0f 90       	pop	r0
    190c:	1f 90       	pop	r1
    190e:	18 95       	reti

00001910 <USART_init>:



void USART_init(void){
	
	UBRR0H = (uint8_t)(BAUD_PRESCALLER>>8);
    1910:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = (uint8_t)(BAUD_PRESCALLER);
    1914:	87 e6       	ldi	r24, 0x67	; 103
    1916:	80 93 c4 00 	sts	0x00C4, r24
	UCSR0B = (1<<RXEN0)|(1<<TXEN0)|(1<<UCSZ02);
    191a:	8c e1       	ldi	r24, 0x1C	; 28
    191c:	80 93 c1 00 	sts	0x00C1, r24
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));
    1920:	86 e0       	ldi	r24, 0x06	; 6
    1922:	80 93 c2 00 	sts	0x00C2, r24
    1926:	08 95       	ret

00001928 <USART_send>:
	}
}

void USART_send( unsigned char data){
	
	while(!(UCSR0A & (1<<UDRE0)));
    1928:	e0 ec       	ldi	r30, 0xC0	; 192
    192a:	f0 e0       	ldi	r31, 0x00	; 0
    192c:	90 81       	ld	r25, Z
    192e:	95 ff       	sbrs	r25, 5
    1930:	fd cf       	rjmp	.-6      	; 0x192c <USART_send+0x4>
	UDR0 = data;
    1932:	80 93 c6 00 	sts	0x00C6, r24
    1936:	08 95       	ret

00001938 <USART_sendstr>:
	UCSR0B = (1<<RXEN0)|(1<<TXEN0)|(1<<UCSZ02);
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));
}


void USART_sendstr( unsigned char* str){
    1938:	cf 93       	push	r28
    193a:	df 93       	push	r29
    193c:	ec 01       	movw	r28, r24
	int i =0;
	
	while (str[i] != 0x00)
    193e:	88 81       	ld	r24, Y
    1940:	88 23       	and	r24, r24
    1942:	31 f0       	breq	.+12     	; 0x1950 <USART_sendstr+0x18>
    1944:	21 96       	adiw	r28, 0x01	; 1
	{
		USART_send(str[i]);
    1946:	0e 94 94 0c 	call	0x1928	; 0x1928 <USART_send>


void USART_sendstr( unsigned char* str){
	int i =0;
	
	while (str[i] != 0x00)
    194a:	89 91       	ld	r24, Y+
    194c:	81 11       	cpse	r24, r1
    194e:	fb cf       	rjmp	.-10     	; 0x1946 <USART_sendstr+0xe>
	{
		USART_send(str[i]);
		i++;
	}
}
    1950:	df 91       	pop	r29
    1952:	cf 91       	pop	r28
    1954:	08 95       	ret

00001956 <memcpy>:
    1956:	fb 01       	movw	r30, r22
    1958:	dc 01       	movw	r26, r24
    195a:	02 c0       	rjmp	.+4      	; 0x1960 <memcpy+0xa>
    195c:	01 90       	ld	r0, Z+
    195e:	0d 92       	st	X+, r0
    1960:	41 50       	subi	r20, 0x01	; 1
    1962:	50 40       	sbci	r21, 0x00	; 0
    1964:	d8 f7       	brcc	.-10     	; 0x195c <memcpy+0x6>
    1966:	08 95       	ret

00001968 <_exit>:
    1968:	f8 94       	cli

0000196a <__stop_program>:
    196a:	ff cf       	rjmp	.-2      	; 0x196a <__stop_program>

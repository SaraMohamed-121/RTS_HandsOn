
ArduinoUnoFreertos_6_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000f8  00800100  00001026  000010ba  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001026  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000663  008001f8  008001f8  000011b2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000011b2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000011e4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000438  00000000  00000000  00001224  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000528a  00000000  00000000  0000165c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000158d  00000000  00000000  000068e6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002cab  00000000  00000000  00007e73  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000de8  00000000  00000000  0000ab20  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000019e8  00000000  00000000  0000b908  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00004bd3  00000000  00000000  0000d2f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000438  00000000  00000000  00011ec3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 99 07 	jmp	0xf32	; 0xf32 <__vector_1>
       8:	0c 94 c6 07 	jmp	0xf8c	; 0xf8c <__vector_2>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 6e 02 	jmp	0x4dc	; 0x4dc <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 08 02 	jmp	0x410	; 0x410 <__vector_16>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e6 e2       	ldi	r30, 0x26	; 38
      7c:	f0 e1       	ldi	r31, 0x10	; 16
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a8 3f       	cpi	r26, 0xF8	; 248
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	28 e0       	ldi	r18, 0x08	; 8
      8c:	a8 ef       	ldi	r26, 0xF8	; 248
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	ab 35       	cpi	r26, 0x5B	; 91
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 69 00 	call	0xd2	; 0xd2 <main>
      9e:	0c 94 11 08 	jmp	0x1022	; 0x1022 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vReceiverTask>:
const TickType_t xTicksToWait = pdMS_TO_TICKS( 100UL );

	/* This task is also defined within an infinite loop. */
	for( ;; )
	{
		USART_sendstr( "end\r\n" );
      a6:	86 e0       	ldi	r24, 0x06	; 6
      a8:	91 e0       	ldi	r25, 0x01	; 1
      aa:	0e 94 fb 07 	call	0xff6	; 0xff6 <USART_sendstr>
		/* As this task unblocks immediately that data is written to the queue this
		call should always find the queue empty. */
	//	if( uxQueueMessagesWaiting( xQueue ) != 0 )
		{
			USART_sendstr( "Queue should have been empty!\r\n" );
      ae:	8c e0       	ldi	r24, 0x0C	; 12
      b0:	91 e0       	ldi	r25, 0x01	; 1
      b2:	0e 94 fb 07 	call	0xff6	; 0xff6 <USART_sendstr>
		else
		{
			/* We did not receive anything from the queue even after waiting for 100ms.
			This must be an error as the sending tasks are free running and will be
			continuously writing to the queue. */
			USART_sendstr("Could not receive from the queue.\r\n" );
      b6:	89 e3       	ldi	r24, 0x39	; 57
      b8:	91 e0       	ldi	r25, 0x01	; 1
      ba:	0e 94 fb 07 	call	0xff6	; 0xff6 <USART_sendstr>
      be:	f3 cf       	rjmp	.-26     	; 0xa6 <vReceiverTask>

000000c0 <vSenderTask>:
	lValueToSend = ( int32_t ) pvParameters;

	/* As per most tasks, this task is implemented within an infinite loop. */
	for( ;; )
	{
		USART_sendstr( "start\r\n" );
      c0:	8d e5       	ldi	r24, 0x5D	; 93
      c2:	91 e0       	ldi	r25, 0x01	; 1
      c4:	0e 94 fb 07 	call	0xff6	; 0xff6 <USART_sendstr>

	//	if( xStatus != pdPASS )
		{
			/* We could not write to the queue because it was full – this must
			be an error as the queue should never contain more than one item! */
			USART_sendstr( "Could not send to the queue.\r\n" );
      c8:	85 e6       	ldi	r24, 0x65	; 101
      ca:	91 e0       	ldi	r25, 0x01	; 1
      cc:	0e 94 fb 07 	call	0xff6	; 0xff6 <USART_sendstr>
		}
	}
      d0:	f7 cf       	rjmp	.-18     	; 0xc0 <vSenderTask>

000000d2 <main>:


int main( void )
{
    /* The queue is created to hold a maximum of 5 long values. */
   	USART_sendstr( "before\r\n" );
      d2:	84 e8       	ldi	r24, 0x84	; 132
      d4:	91 e0       	ldi	r25, 0x01	; 1
      d6:	0e 94 fb 07 	call	0xff6	; 0xff6 <USART_sendstr>
    xQueue = xQueueCreate( 5, sizeof( int32_t ) );
      da:	40 e0       	ldi	r20, 0x00	; 0
      dc:	64 e0       	ldi	r22, 0x04	; 4
      de:	85 e0       	ldi	r24, 0x05	; 5
      e0:	0e 94 80 03 	call	0x700	; 0x700 <xQueueGenericCreate>
      e4:	90 93 5a 08 	sts	0x085A, r25	; 0x80085a <xQueue+0x1>
      e8:	80 93 59 08 	sts	0x0859, r24	; 0x800859 <xQueue>
	USART_sendstr( "skj\r\n" );
      ec:	8d e8       	ldi	r24, 0x8D	; 141
      ee:	91 e0       	ldi	r25, 0x01	; 1
      f0:	0e 94 fb 07 	call	0xff6	; 0xff6 <USART_sendstr>
	if( xQueue != NULL )
      f4:	80 91 59 08 	lds	r24, 0x0859	; 0x800859 <xQueue>
      f8:	90 91 5a 08 	lds	r25, 0x085A	; 0x80085a <xQueue+0x1>
      fc:	89 2b       	or	r24, r25
      fe:	61 f1       	breq	.+88     	; 0x158 <main+0x86>
	{
			USART_sendstr( "ed\r\n" );
     100:	83 e9       	ldi	r24, 0x93	; 147
     102:	91 e0       	ldi	r25, 0x01	; 1
     104:	0e 94 fb 07 	call	0xff6	; 0xff6 <USART_sendstr>
		/* Create two instances of the task that will write to the queue.  The
		parameter is used to pass the value that the task should write to the queue,
		so one task will continuously write 100 to the queue while the other task
		will continuously write 200 to the queue.  Both tasks are created at
		priority 1. */
		xTaskCreate( vSenderTask, "Sender1", 1000, ( void * ) 100, 1, NULL );
     108:	a1 2c       	mov	r10, r1
     10a:	b1 2c       	mov	r11, r1
     10c:	c1 2c       	mov	r12, r1
     10e:	d1 2c       	mov	r13, r1
     110:	e1 2c       	mov	r14, r1
     112:	f1 2c       	mov	r15, r1
     114:	01 e0       	ldi	r16, 0x01	; 1
     116:	24 e6       	ldi	r18, 0x64	; 100
     118:	30 e0       	ldi	r19, 0x00	; 0
     11a:	48 ee       	ldi	r20, 0xE8	; 232
     11c:	53 e0       	ldi	r21, 0x03	; 3
     11e:	68 e9       	ldi	r22, 0x98	; 152
     120:	71 e0       	ldi	r23, 0x01	; 1
     122:	80 e6       	ldi	r24, 0x60	; 96
     124:	90 e0       	ldi	r25, 0x00	; 0
     126:	0e 94 0b 04 	call	0x816	; 0x816 <xTaskGenericCreate>
		xTaskCreate( vSenderTask, "Sender2", 1000, ( void * ) 200, 1, NULL );
     12a:	28 ec       	ldi	r18, 0xC8	; 200
     12c:	30 e0       	ldi	r19, 0x00	; 0
     12e:	48 ee       	ldi	r20, 0xE8	; 232
     130:	53 e0       	ldi	r21, 0x03	; 3
     132:	60 ea       	ldi	r22, 0xA0	; 160
     134:	71 e0       	ldi	r23, 0x01	; 1
     136:	80 e6       	ldi	r24, 0x60	; 96
     138:	90 e0       	ldi	r25, 0x00	; 0
     13a:	0e 94 0b 04 	call	0x816	; 0x816 <xTaskGenericCreate>

		/* Create the task that will read from the queue.  The task is created with
		priority 2, so above the priority of the sender tasks. */
		xTaskCreate( vReceiverTask, "Receiver", 1000, NULL, 2, NULL );
     13e:	02 e0       	ldi	r16, 0x02	; 2
     140:	20 e0       	ldi	r18, 0x00	; 0
     142:	30 e0       	ldi	r19, 0x00	; 0
     144:	48 ee       	ldi	r20, 0xE8	; 232
     146:	53 e0       	ldi	r21, 0x03	; 3
     148:	68 ea       	ldi	r22, 0xA8	; 168
     14a:	71 e0       	ldi	r23, 0x01	; 1
     14c:	83 e5       	ldi	r24, 0x53	; 83
     14e:	90 e0       	ldi	r25, 0x00	; 0
     150:	0e 94 0b 04 	call	0x816	; 0x816 <xTaskGenericCreate>

		/* Start the scheduler so the created tasks start executing. */
		vTaskStartScheduler();
     154:	0e 94 26 05 	call	0xa4c	; 0xa4c <vTaskStartScheduler>

	/* The following line should never be reached because vTaskStartScheduler()
	will only return if there was not enough FreeRTOS heap memory available to
	create the Idle and (if configured) Timer tasks.  Heap management, and
	techniques for trapping heap exhaustion, are described in the book text. */
	for( ;; );
     158:	ff cf       	rjmp	.-2      	; 0x158 <main+0x86>

0000015a <vListInitialise>:
	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
}
     15a:	fc 01       	movw	r30, r24
     15c:	03 96       	adiw	r24, 0x03	; 3
     15e:	92 83       	std	Z+2, r25	; 0x02
     160:	81 83       	std	Z+1, r24	; 0x01
     162:	4f ef       	ldi	r20, 0xFF	; 255
     164:	5f ef       	ldi	r21, 0xFF	; 255
     166:	ba 01       	movw	r22, r20
     168:	43 83       	std	Z+3, r20	; 0x03
     16a:	54 83       	std	Z+4, r21	; 0x04
     16c:	65 83       	std	Z+5, r22	; 0x05
     16e:	76 83       	std	Z+6, r23	; 0x06
     170:	90 87       	std	Z+8, r25	; 0x08
     172:	87 83       	std	Z+7, r24	; 0x07
     174:	92 87       	std	Z+10, r25	; 0x0a
     176:	81 87       	std	Z+9, r24	; 0x09
     178:	10 82       	st	Z, r1
     17a:	08 95       	ret

0000017c <vListInitialiseItem>:
     17c:	fc 01       	movw	r30, r24
     17e:	13 86       	std	Z+11, r1	; 0x0b
     180:	12 86       	std	Z+10, r1	; 0x0a
     182:	08 95       	ret

00000184 <vListInsertEnd>:
     184:	cf 93       	push	r28
     186:	df 93       	push	r29
     188:	9c 01       	movw	r18, r24
     18a:	fb 01       	movw	r30, r22
     18c:	dc 01       	movw	r26, r24
     18e:	11 96       	adiw	r26, 0x01	; 1
     190:	cd 91       	ld	r28, X+
     192:	dc 91       	ld	r29, X
     194:	12 97       	sbiw	r26, 0x02	; 2
     196:	d5 83       	std	Z+5, r29	; 0x05
     198:	c4 83       	std	Z+4, r28	; 0x04
     19a:	8e 81       	ldd	r24, Y+6	; 0x06
     19c:	9f 81       	ldd	r25, Y+7	; 0x07
     19e:	97 83       	std	Z+7, r25	; 0x07
     1a0:	86 83       	std	Z+6, r24	; 0x06
     1a2:	8e 81       	ldd	r24, Y+6	; 0x06
     1a4:	9f 81       	ldd	r25, Y+7	; 0x07
     1a6:	dc 01       	movw	r26, r24
     1a8:	15 96       	adiw	r26, 0x05	; 5
     1aa:	7c 93       	st	X, r23
     1ac:	6e 93       	st	-X, r22
     1ae:	14 97       	sbiw	r26, 0x04	; 4
     1b0:	7f 83       	std	Y+7, r23	; 0x07
     1b2:	6e 83       	std	Y+6, r22	; 0x06
     1b4:	33 87       	std	Z+11, r19	; 0x0b
     1b6:	22 87       	std	Z+10, r18	; 0x0a
     1b8:	f9 01       	movw	r30, r18
     1ba:	80 81       	ld	r24, Z
     1bc:	8f 5f       	subi	r24, 0xFF	; 255
     1be:	80 83       	st	Z, r24
     1c0:	df 91       	pop	r29
     1c2:	cf 91       	pop	r28
     1c4:	08 95       	ret

000001c6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     1c6:	cf 93       	push	r28
     1c8:	df 93       	push	r29
     1ca:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     1cc:	a2 85       	ldd	r26, Z+10	; 0x0a
     1ce:	b3 85       	ldd	r27, Z+11	; 0x0b

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     1d0:	c4 81       	ldd	r28, Z+4	; 0x04
     1d2:	d5 81       	ldd	r29, Z+5	; 0x05
     1d4:	86 81       	ldd	r24, Z+6	; 0x06
     1d6:	97 81       	ldd	r25, Z+7	; 0x07
     1d8:	9f 83       	std	Y+7, r25	; 0x07
     1da:	8e 83       	std	Y+6, r24	; 0x06
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     1dc:	c6 81       	ldd	r28, Z+6	; 0x06
     1de:	d7 81       	ldd	r29, Z+7	; 0x07
     1e0:	84 81       	ldd	r24, Z+4	; 0x04
     1e2:	95 81       	ldd	r25, Z+5	; 0x05
     1e4:	9d 83       	std	Y+5, r25	; 0x05
     1e6:	8c 83       	std	Y+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     1e8:	11 96       	adiw	r26, 0x01	; 1
     1ea:	cd 91       	ld	r28, X+
     1ec:	dc 91       	ld	r29, X
     1ee:	12 97       	sbiw	r26, 0x02	; 2
     1f0:	ce 17       	cp	r28, r30
     1f2:	df 07       	cpc	r29, r31
     1f4:	31 f4       	brne	.+12     	; 0x202 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     1f6:	8e 81       	ldd	r24, Y+6	; 0x06
     1f8:	9f 81       	ldd	r25, Y+7	; 0x07
     1fa:	12 96       	adiw	r26, 0x02	; 2
     1fc:	9c 93       	st	X, r25
     1fe:	8e 93       	st	-X, r24
     200:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     202:	13 86       	std	Z+11, r1	; 0x0b
     204:	12 86       	std	Z+10, r1	; 0x0a
	( pxList->uxNumberOfItems )--;
     206:	8c 91       	ld	r24, X
     208:	81 50       	subi	r24, 0x01	; 1
     20a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     20c:	df 91       	pop	r29
     20e:	cf 91       	pop	r28
     210:	08 95       	ret

00000212 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     212:	31 e1       	ldi	r19, 0x11	; 17
     214:	fc 01       	movw	r30, r24
     216:	30 83       	st	Z, r19
     218:	31 97       	sbiw	r30, 0x01	; 1
     21a:	22 e2       	ldi	r18, 0x22	; 34
     21c:	20 83       	st	Z, r18
     21e:	31 97       	sbiw	r30, 0x01	; 1
     220:	a3 e3       	ldi	r26, 0x33	; 51
     222:	a0 83       	st	Z, r26
     224:	31 97       	sbiw	r30, 0x01	; 1
     226:	60 83       	st	Z, r22
     228:	31 97       	sbiw	r30, 0x01	; 1
     22a:	70 83       	st	Z, r23
     22c:	31 97       	sbiw	r30, 0x01	; 1
     22e:	10 82       	st	Z, r1
     230:	31 97       	sbiw	r30, 0x01	; 1
     232:	60 e8       	ldi	r22, 0x80	; 128
     234:	60 83       	st	Z, r22
     236:	31 97       	sbiw	r30, 0x01	; 1
     238:	10 82       	st	Z, r1
     23a:	31 97       	sbiw	r30, 0x01	; 1
     23c:	62 e0       	ldi	r22, 0x02	; 2
     23e:	60 83       	st	Z, r22
     240:	31 97       	sbiw	r30, 0x01	; 1
     242:	63 e0       	ldi	r22, 0x03	; 3
     244:	60 83       	st	Z, r22
     246:	31 97       	sbiw	r30, 0x01	; 1
     248:	64 e0       	ldi	r22, 0x04	; 4
     24a:	60 83       	st	Z, r22
     24c:	31 97       	sbiw	r30, 0x01	; 1
     24e:	65 e0       	ldi	r22, 0x05	; 5
     250:	60 83       	st	Z, r22
     252:	31 97       	sbiw	r30, 0x01	; 1
     254:	66 e0       	ldi	r22, 0x06	; 6
     256:	60 83       	st	Z, r22
     258:	31 97       	sbiw	r30, 0x01	; 1
     25a:	67 e0       	ldi	r22, 0x07	; 7
     25c:	60 83       	st	Z, r22
     25e:	31 97       	sbiw	r30, 0x01	; 1
     260:	68 e0       	ldi	r22, 0x08	; 8
     262:	60 83       	st	Z, r22
     264:	31 97       	sbiw	r30, 0x01	; 1
     266:	69 e0       	ldi	r22, 0x09	; 9
     268:	60 83       	st	Z, r22
     26a:	31 97       	sbiw	r30, 0x01	; 1
     26c:	60 e1       	ldi	r22, 0x10	; 16
     26e:	60 83       	st	Z, r22
     270:	31 97       	sbiw	r30, 0x01	; 1
     272:	30 83       	st	Z, r19
     274:	31 97       	sbiw	r30, 0x01	; 1
     276:	32 e1       	ldi	r19, 0x12	; 18
     278:	30 83       	st	Z, r19
     27a:	31 97       	sbiw	r30, 0x01	; 1
     27c:	33 e1       	ldi	r19, 0x13	; 19
     27e:	30 83       	st	Z, r19
     280:	31 97       	sbiw	r30, 0x01	; 1
     282:	34 e1       	ldi	r19, 0x14	; 20
     284:	30 83       	st	Z, r19
     286:	31 97       	sbiw	r30, 0x01	; 1
     288:	35 e1       	ldi	r19, 0x15	; 21
     28a:	30 83       	st	Z, r19
     28c:	31 97       	sbiw	r30, 0x01	; 1
     28e:	36 e1       	ldi	r19, 0x16	; 22
     290:	30 83       	st	Z, r19
     292:	31 97       	sbiw	r30, 0x01	; 1
     294:	37 e1       	ldi	r19, 0x17	; 23
     296:	30 83       	st	Z, r19
     298:	31 97       	sbiw	r30, 0x01	; 1
     29a:	38 e1       	ldi	r19, 0x18	; 24
     29c:	30 83       	st	Z, r19
     29e:	31 97       	sbiw	r30, 0x01	; 1
     2a0:	39 e1       	ldi	r19, 0x19	; 25
     2a2:	30 83       	st	Z, r19
     2a4:	31 97       	sbiw	r30, 0x01	; 1
     2a6:	30 e2       	ldi	r19, 0x20	; 32
     2a8:	30 83       	st	Z, r19
     2aa:	31 97       	sbiw	r30, 0x01	; 1
     2ac:	31 e2       	ldi	r19, 0x21	; 33
     2ae:	30 83       	st	Z, r19
     2b0:	31 97       	sbiw	r30, 0x01	; 1
     2b2:	20 83       	st	Z, r18
     2b4:	31 97       	sbiw	r30, 0x01	; 1
     2b6:	23 e2       	ldi	r18, 0x23	; 35
     2b8:	20 83       	st	Z, r18
     2ba:	31 97       	sbiw	r30, 0x01	; 1
     2bc:	40 83       	st	Z, r20
     2be:	31 97       	sbiw	r30, 0x01	; 1
     2c0:	50 83       	st	Z, r21
     2c2:	31 97       	sbiw	r30, 0x01	; 1
     2c4:	26 e2       	ldi	r18, 0x26	; 38
     2c6:	20 83       	st	Z, r18
     2c8:	31 97       	sbiw	r30, 0x01	; 1
     2ca:	27 e2       	ldi	r18, 0x27	; 39
     2cc:	20 83       	st	Z, r18
     2ce:	31 97       	sbiw	r30, 0x01	; 1
     2d0:	28 e2       	ldi	r18, 0x28	; 40
     2d2:	20 83       	st	Z, r18
     2d4:	31 97       	sbiw	r30, 0x01	; 1
     2d6:	29 e2       	ldi	r18, 0x29	; 41
     2d8:	20 83       	st	Z, r18
     2da:	31 97       	sbiw	r30, 0x01	; 1
     2dc:	20 e3       	ldi	r18, 0x30	; 48
     2de:	20 83       	st	Z, r18
     2e0:	31 97       	sbiw	r30, 0x01	; 1
     2e2:	21 e3       	ldi	r18, 0x31	; 49
     2e4:	20 83       	st	Z, r18
     2e6:	86 97       	sbiw	r24, 0x26	; 38
     2e8:	08 95       	ret

000002ea <xPortStartScheduler>:
     2ea:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     2ee:	8c e7       	ldi	r24, 0x7C	; 124
     2f0:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     2f4:	8b e0       	ldi	r24, 0x0B	; 11
     2f6:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     2fa:	ef e6       	ldi	r30, 0x6F	; 111
     2fc:	f0 e0       	ldi	r31, 0x00	; 0
     2fe:	80 81       	ld	r24, Z
     300:	82 60       	ori	r24, 0x02	; 2
     302:	80 83       	st	Z, r24
     304:	a0 91 53 08 	lds	r26, 0x0853	; 0x800853 <pxCurrentTCB>
     308:	b0 91 54 08 	lds	r27, 0x0854	; 0x800854 <pxCurrentTCB+0x1>
     30c:	cd 91       	ld	r28, X+
     30e:	cd bf       	out	0x3d, r28	; 61
     310:	dd 91       	ld	r29, X+
     312:	de bf       	out	0x3e, r29	; 62
     314:	ff 91       	pop	r31
     316:	ef 91       	pop	r30
     318:	df 91       	pop	r29
     31a:	cf 91       	pop	r28
     31c:	bf 91       	pop	r27
     31e:	af 91       	pop	r26
     320:	9f 91       	pop	r25
     322:	8f 91       	pop	r24
     324:	7f 91       	pop	r23
     326:	6f 91       	pop	r22
     328:	5f 91       	pop	r21
     32a:	4f 91       	pop	r20
     32c:	3f 91       	pop	r19
     32e:	2f 91       	pop	r18
     330:	1f 91       	pop	r17
     332:	0f 91       	pop	r16
     334:	ff 90       	pop	r15
     336:	ef 90       	pop	r14
     338:	df 90       	pop	r13
     33a:	cf 90       	pop	r12
     33c:	bf 90       	pop	r11
     33e:	af 90       	pop	r10
     340:	9f 90       	pop	r9
     342:	8f 90       	pop	r8
     344:	7f 90       	pop	r7
     346:	6f 90       	pop	r6
     348:	5f 90       	pop	r5
     34a:	4f 90       	pop	r4
     34c:	3f 90       	pop	r3
     34e:	2f 90       	pop	r2
     350:	1f 90       	pop	r1
     352:	0f 90       	pop	r0
     354:	0f be       	out	0x3f, r0	; 63
     356:	0f 90       	pop	r0
     358:	08 95       	ret
     35a:	81 e0       	ldi	r24, 0x01	; 1
     35c:	08 95       	ret

0000035e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     35e:	0f 92       	push	r0
     360:	0f b6       	in	r0, 0x3f	; 63
     362:	f8 94       	cli
     364:	0f 92       	push	r0
     366:	1f 92       	push	r1
     368:	11 24       	eor	r1, r1
     36a:	2f 92       	push	r2
     36c:	3f 92       	push	r3
     36e:	4f 92       	push	r4
     370:	5f 92       	push	r5
     372:	6f 92       	push	r6
     374:	7f 92       	push	r7
     376:	8f 92       	push	r8
     378:	9f 92       	push	r9
     37a:	af 92       	push	r10
     37c:	bf 92       	push	r11
     37e:	cf 92       	push	r12
     380:	df 92       	push	r13
     382:	ef 92       	push	r14
     384:	ff 92       	push	r15
     386:	0f 93       	push	r16
     388:	1f 93       	push	r17
     38a:	2f 93       	push	r18
     38c:	3f 93       	push	r19
     38e:	4f 93       	push	r20
     390:	5f 93       	push	r21
     392:	6f 93       	push	r22
     394:	7f 93       	push	r23
     396:	8f 93       	push	r24
     398:	9f 93       	push	r25
     39a:	af 93       	push	r26
     39c:	bf 93       	push	r27
     39e:	cf 93       	push	r28
     3a0:	df 93       	push	r29
     3a2:	ef 93       	push	r30
     3a4:	ff 93       	push	r31
     3a6:	a0 91 53 08 	lds	r26, 0x0853	; 0x800853 <pxCurrentTCB>
     3aa:	b0 91 54 08 	lds	r27, 0x0854	; 0x800854 <pxCurrentTCB+0x1>
     3ae:	0d b6       	in	r0, 0x3d	; 61
     3b0:	0d 92       	st	X+, r0
     3b2:	0e b6       	in	r0, 0x3e	; 62
     3b4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     3b6:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     3ba:	a0 91 53 08 	lds	r26, 0x0853	; 0x800853 <pxCurrentTCB>
     3be:	b0 91 54 08 	lds	r27, 0x0854	; 0x800854 <pxCurrentTCB+0x1>
     3c2:	cd 91       	ld	r28, X+
     3c4:	cd bf       	out	0x3d, r28	; 61
     3c6:	dd 91       	ld	r29, X+
     3c8:	de bf       	out	0x3e, r29	; 62
     3ca:	ff 91       	pop	r31
     3cc:	ef 91       	pop	r30
     3ce:	df 91       	pop	r29
     3d0:	cf 91       	pop	r28
     3d2:	bf 91       	pop	r27
     3d4:	af 91       	pop	r26
     3d6:	9f 91       	pop	r25
     3d8:	8f 91       	pop	r24
     3da:	7f 91       	pop	r23
     3dc:	6f 91       	pop	r22
     3de:	5f 91       	pop	r21
     3e0:	4f 91       	pop	r20
     3e2:	3f 91       	pop	r19
     3e4:	2f 91       	pop	r18
     3e6:	1f 91       	pop	r17
     3e8:	0f 91       	pop	r16
     3ea:	ff 90       	pop	r15
     3ec:	ef 90       	pop	r14
     3ee:	df 90       	pop	r13
     3f0:	cf 90       	pop	r12
     3f2:	bf 90       	pop	r11
     3f4:	af 90       	pop	r10
     3f6:	9f 90       	pop	r9
     3f8:	8f 90       	pop	r8
     3fa:	7f 90       	pop	r7
     3fc:	6f 90       	pop	r6
     3fe:	5f 90       	pop	r5
     400:	4f 90       	pop	r4
     402:	3f 90       	pop	r3
     404:	2f 90       	pop	r2
     406:	1f 90       	pop	r1
     408:	0f 90       	pop	r0
     40a:	0f be       	out	0x3f, r0	; 63
     40c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     40e:	08 95       	ret

00000410 <__vector_16>:
}


ISR(TIMER0_OVF_vect)				//ISR for timer0 overflow
{
     410:	1f 92       	push	r1
     412:	0f 92       	push	r0
     414:	0f b6       	in	r0, 0x3f	; 63
     416:	0f 92       	push	r0
     418:	11 24       	eor	r1, r1
  ulIsrHandler[0];	
}
     41a:	0f 90       	pop	r0
     41c:	0f be       	out	0x3f, r0	; 63
     41e:	0f 90       	pop	r0
     420:	1f 90       	pop	r1
     422:	18 95       	reti

00000424 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     424:	0f 92       	push	r0
     426:	0f b6       	in	r0, 0x3f	; 63
     428:	f8 94       	cli
     42a:	0f 92       	push	r0
     42c:	1f 92       	push	r1
     42e:	11 24       	eor	r1, r1
     430:	2f 92       	push	r2
     432:	3f 92       	push	r3
     434:	4f 92       	push	r4
     436:	5f 92       	push	r5
     438:	6f 92       	push	r6
     43a:	7f 92       	push	r7
     43c:	8f 92       	push	r8
     43e:	9f 92       	push	r9
     440:	af 92       	push	r10
     442:	bf 92       	push	r11
     444:	cf 92       	push	r12
     446:	df 92       	push	r13
     448:	ef 92       	push	r14
     44a:	ff 92       	push	r15
     44c:	0f 93       	push	r16
     44e:	1f 93       	push	r17
     450:	2f 93       	push	r18
     452:	3f 93       	push	r19
     454:	4f 93       	push	r20
     456:	5f 93       	push	r21
     458:	6f 93       	push	r22
     45a:	7f 93       	push	r23
     45c:	8f 93       	push	r24
     45e:	9f 93       	push	r25
     460:	af 93       	push	r26
     462:	bf 93       	push	r27
     464:	cf 93       	push	r28
     466:	df 93       	push	r29
     468:	ef 93       	push	r30
     46a:	ff 93       	push	r31
     46c:	a0 91 53 08 	lds	r26, 0x0853	; 0x800853 <pxCurrentTCB>
     470:	b0 91 54 08 	lds	r27, 0x0854	; 0x800854 <pxCurrentTCB+0x1>
     474:	0d b6       	in	r0, 0x3d	; 61
     476:	0d 92       	st	X+, r0
     478:	0e b6       	in	r0, 0x3e	; 62
     47a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     47c:	0e 94 5f 05 	call	0xabe	; 0xabe <xTaskIncrementTick>
     480:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     482:	0e 94 f9 06 	call	0xdf2	; 0xdf2 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     486:	a0 91 53 08 	lds	r26, 0x0853	; 0x800853 <pxCurrentTCB>
     48a:	b0 91 54 08 	lds	r27, 0x0854	; 0x800854 <pxCurrentTCB+0x1>
     48e:	cd 91       	ld	r28, X+
     490:	cd bf       	out	0x3d, r28	; 61
     492:	dd 91       	ld	r29, X+
     494:	de bf       	out	0x3e, r29	; 62
     496:	ff 91       	pop	r31
     498:	ef 91       	pop	r30
     49a:	df 91       	pop	r29
     49c:	cf 91       	pop	r28
     49e:	bf 91       	pop	r27
     4a0:	af 91       	pop	r26
     4a2:	9f 91       	pop	r25
     4a4:	8f 91       	pop	r24
     4a6:	7f 91       	pop	r23
     4a8:	6f 91       	pop	r22
     4aa:	5f 91       	pop	r21
     4ac:	4f 91       	pop	r20
     4ae:	3f 91       	pop	r19
     4b0:	2f 91       	pop	r18
     4b2:	1f 91       	pop	r17
     4b4:	0f 91       	pop	r16
     4b6:	ff 90       	pop	r15
     4b8:	ef 90       	pop	r14
     4ba:	df 90       	pop	r13
     4bc:	cf 90       	pop	r12
     4be:	bf 90       	pop	r11
     4c0:	af 90       	pop	r10
     4c2:	9f 90       	pop	r9
     4c4:	8f 90       	pop	r8
     4c6:	7f 90       	pop	r7
     4c8:	6f 90       	pop	r6
     4ca:	5f 90       	pop	r5
     4cc:	4f 90       	pop	r4
     4ce:	3f 90       	pop	r3
     4d0:	2f 90       	pop	r2
     4d2:	1f 90       	pop	r1
     4d4:	0f 90       	pop	r0
     4d6:	0f be       	out	0x3f, r0	; 63
     4d8:	0f 90       	pop	r0

	asm volatile ( "ret" );
     4da:	08 95       	ret

000004dc <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect(void) __attribute__ ((signal, naked));
	void TIMER1_COMPA_vect(void)
	{
		vPortYieldFromTick();
     4dc:	0e 94 12 02 	call	0x424	; 0x424 <vPortYieldFromTick>
		asm volatile ( "reti" );
     4e0:	18 95       	reti

000004e2 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     4e2:	0f 93       	push	r16
     4e4:	1f 93       	push	r17
     4e6:	cf 93       	push	r28
     4e8:	df 93       	push	r29
     4ea:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     4ec:	0e 94 59 05 	call	0xab2	; 0xab2 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     4f0:	80 91 f8 01 	lds	r24, 0x01F8	; 0x8001f8 <__data_end>
     4f4:	81 11       	cpse	r24, r1
     4f6:	1d c0       	rjmp	.+58     	; 0x532 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     4f8:	ed ef       	ldi	r30, 0xFD	; 253
     4fa:	f1 e0       	ldi	r31, 0x01	; 1
     4fc:	82 e0       	ldi	r24, 0x02	; 2
     4fe:	92 e0       	ldi	r25, 0x02	; 2
     500:	91 83       	std	Z+1, r25	; 0x01
     502:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     504:	13 82       	std	Z+3, r1	; 0x03
     506:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     508:	e9 ef       	ldi	r30, 0xF9	; 249
     50a:	f1 e0       	ldi	r31, 0x01	; 1
     50c:	8b ed       	ldi	r24, 0xDB	; 219
     50e:	95 e0       	ldi	r25, 0x05	; 5
     510:	93 83       	std	Z+3, r25	; 0x03
     512:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     514:	11 82       	std	Z+1, r1	; 0x01
     516:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     518:	a1 e0       	ldi	r26, 0x01	; 1
     51a:	b2 e0       	ldi	r27, 0x02	; 2
     51c:	14 96       	adiw	r26, 0x04	; 4
     51e:	9c 93       	st	X, r25
     520:	8e 93       	st	-X, r24
     522:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     524:	12 96       	adiw	r26, 0x02	; 2
     526:	fc 93       	st	X, r31
     528:	ee 93       	st	-X, r30
     52a:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     52c:	81 e0       	ldi	r24, 0x01	; 1
     52e:	80 93 f8 01 	sts	0x01F8, r24	; 0x8001f8 <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     532:	20 97       	sbiw	r28, 0x00	; 0
     534:	09 f4       	brne	.+2      	; 0x538 <pvPortMalloc+0x56>
     536:	6b c0       	rjmp	.+214    	; 0x60e <pvPortMalloc+0x12c>
		{
			xWantedSize += heapSTRUCT_SIZE;
     538:	9e 01       	movw	r18, r28
     53a:	2c 5f       	subi	r18, 0xFC	; 252
     53c:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     53e:	23 96       	adiw	r28, 0x03	; 3
     540:	ca 3d       	cpi	r28, 0xDA	; 218
     542:	d5 40       	sbci	r29, 0x05	; 5
     544:	08 f0       	brcs	.+2      	; 0x548 <pvPortMalloc+0x66>
     546:	60 c0       	rjmp	.+192    	; 0x608 <pvPortMalloc+0x126>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     548:	e0 91 fd 01 	lds	r30, 0x01FD	; 0x8001fd <xStart>
     54c:	f0 91 fe 01 	lds	r31, 0x01FE	; 0x8001fe <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     550:	ad ef       	ldi	r26, 0xFD	; 253
     552:	b1 e0       	ldi	r27, 0x01	; 1
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     554:	02 c0       	rjmp	.+4      	; 0x55a <pvPortMalloc+0x78>
     556:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     558:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     55a:	82 81       	ldd	r24, Z+2	; 0x02
     55c:	93 81       	ldd	r25, Z+3	; 0x03
     55e:	82 17       	cp	r24, r18
     560:	93 07       	cpc	r25, r19
     562:	20 f4       	brcc	.+8      	; 0x56c <pvPortMalloc+0x8a>
     564:	80 81       	ld	r24, Z
     566:	91 81       	ldd	r25, Z+1	; 0x01
     568:	00 97       	sbiw	r24, 0x00	; 0
     56a:	a9 f7       	brne	.-22     	; 0x556 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     56c:	c1 e0       	ldi	r28, 0x01	; 1
     56e:	e9 3f       	cpi	r30, 0xF9	; 249
     570:	fc 07       	cpc	r31, r28
     572:	09 f4       	brne	.+2      	; 0x576 <pvPortMalloc+0x94>
     574:	49 c0       	rjmp	.+146    	; 0x608 <pvPortMalloc+0x126>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     576:	cd 91       	ld	r28, X+
     578:	dc 91       	ld	r29, X
     57a:	11 97       	sbiw	r26, 0x01	; 1
     57c:	8e 01       	movw	r16, r28
     57e:	0c 5f       	subi	r16, 0xFC	; 252
     580:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     582:	80 81       	ld	r24, Z
     584:	91 81       	ldd	r25, Z+1	; 0x01
     586:	8d 93       	st	X+, r24
     588:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     58a:	82 81       	ldd	r24, Z+2	; 0x02
     58c:	93 81       	ldd	r25, Z+3	; 0x03
     58e:	82 1b       	sub	r24, r18
     590:	93 0b       	sbc	r25, r19
     592:	89 30       	cpi	r24, 0x09	; 9
     594:	91 05       	cpc	r25, r1
     596:	10 f1       	brcs	.+68     	; 0x5dc <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     598:	bf 01       	movw	r22, r30
     59a:	62 0f       	add	r22, r18
     59c:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     59e:	db 01       	movw	r26, r22
     5a0:	13 96       	adiw	r26, 0x03	; 3
     5a2:	9c 93       	st	X, r25
     5a4:	8e 93       	st	-X, r24
     5a6:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     5a8:	33 83       	std	Z+3, r19	; 0x03
     5aa:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     5ac:	12 96       	adiw	r26, 0x02	; 2
     5ae:	4d 91       	ld	r20, X+
     5b0:	5c 91       	ld	r21, X
     5b2:	13 97       	sbiw	r26, 0x03	; 3
     5b4:	8d ef       	ldi	r24, 0xFD	; 253
     5b6:	91 e0       	ldi	r25, 0x01	; 1
     5b8:	01 c0       	rjmp	.+2      	; 0x5bc <pvPortMalloc+0xda>
     5ba:	cd 01       	movw	r24, r26
     5bc:	ec 01       	movw	r28, r24
     5be:	a8 81       	ld	r26, Y
     5c0:	b9 81       	ldd	r27, Y+1	; 0x01
     5c2:	12 96       	adiw	r26, 0x02	; 2
     5c4:	2d 91       	ld	r18, X+
     5c6:	3c 91       	ld	r19, X
     5c8:	13 97       	sbiw	r26, 0x03	; 3
     5ca:	24 17       	cp	r18, r20
     5cc:	35 07       	cpc	r19, r21
     5ce:	a8 f3       	brcs	.-22     	; 0x5ba <pvPortMalloc+0xd8>
     5d0:	eb 01       	movw	r28, r22
     5d2:	b9 83       	std	Y+1, r27	; 0x01
     5d4:	a8 83       	st	Y, r26
     5d6:	dc 01       	movw	r26, r24
     5d8:	6d 93       	st	X+, r22
     5da:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     5dc:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
     5e0:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
     5e4:	22 81       	ldd	r18, Z+2	; 0x02
     5e6:	33 81       	ldd	r19, Z+3	; 0x03
     5e8:	82 1b       	sub	r24, r18
     5ea:	93 0b       	sbc	r25, r19
     5ec:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     5f0:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     5f4:	0e 94 3b 06 	call	0xc76	; 0xc76 <xTaskResumeAll>

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
     5f8:	01 15       	cp	r16, r1
     5fa:	11 05       	cpc	r17, r1
     5fc:	59 f4       	brne	.+22     	; 0x614 <pvPortMalloc+0x132>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
     5fe:	0e 94 da 03 	call	0x7b4	; 0x7b4 <vApplicationMallocFailedHook>
     602:	00 e0       	ldi	r16, 0x00	; 0
     604:	10 e0       	ldi	r17, 0x00	; 0
     606:	06 c0       	rjmp	.+12     	; 0x614 <pvPortMalloc+0x132>
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     608:	0e 94 3b 06 	call	0xc76	; 0xc76 <xTaskResumeAll>
     60c:	f8 cf       	rjmp	.-16     	; 0x5fe <pvPortMalloc+0x11c>
     60e:	0e 94 3b 06 	call	0xc76	; 0xc76 <xTaskResumeAll>
     612:	f5 cf       	rjmp	.-22     	; 0x5fe <pvPortMalloc+0x11c>
		}
	}
	#endif

	return pvReturn;
}
     614:	c8 01       	movw	r24, r16
     616:	df 91       	pop	r29
     618:	cf 91       	pop	r28
     61a:	1f 91       	pop	r17
     61c:	0f 91       	pop	r16
     61e:	08 95       	ret

00000620 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     620:	0f 93       	push	r16
     622:	1f 93       	push	r17
     624:	cf 93       	push	r28
     626:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     628:	00 97       	sbiw	r24, 0x00	; 0
     62a:	41 f1       	breq	.+80     	; 0x67c <vPortFree+0x5c>
     62c:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     62e:	8c 01       	movw	r16, r24
     630:	04 50       	subi	r16, 0x04	; 4
     632:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     634:	0e 94 59 05 	call	0xab2	; 0xab2 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     638:	f8 01       	movw	r30, r16
     63a:	42 81       	ldd	r20, Z+2	; 0x02
     63c:	53 81       	ldd	r21, Z+3	; 0x03
     63e:	ad ef       	ldi	r26, 0xFD	; 253
     640:	b1 e0       	ldi	r27, 0x01	; 1
     642:	01 c0       	rjmp	.+2      	; 0x646 <vPortFree+0x26>
     644:	df 01       	movw	r26, r30
     646:	ed 91       	ld	r30, X+
     648:	fc 91       	ld	r31, X
     64a:	11 97       	sbiw	r26, 0x01	; 1
     64c:	22 81       	ldd	r18, Z+2	; 0x02
     64e:	33 81       	ldd	r19, Z+3	; 0x03
     650:	24 17       	cp	r18, r20
     652:	35 07       	cpc	r19, r21
     654:	b8 f3       	brcs	.-18     	; 0x644 <vPortFree+0x24>
     656:	24 97       	sbiw	r28, 0x04	; 4
     658:	f9 83       	std	Y+1, r31	; 0x01
     65a:	e8 83       	st	Y, r30
     65c:	0d 93       	st	X+, r16
     65e:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     660:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
     664:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
     668:	8a 81       	ldd	r24, Y+2	; 0x02
     66a:	9b 81       	ldd	r25, Y+3	; 0x03
     66c:	82 0f       	add	r24, r18
     66e:	93 1f       	adc	r25, r19
     670:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
     674:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     678:	0e 94 3b 06 	call	0xc76	; 0xc76 <xTaskResumeAll>
	}
}
     67c:	df 91       	pop	r29
     67e:	cf 91       	pop	r28
     680:	1f 91       	pop	r17
     682:	0f 91       	pop	r16
     684:	08 95       	ret

00000686 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     686:	cf 93       	push	r28
     688:	df 93       	push	r29
     68a:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     68c:	0f b6       	in	r0, 0x3f	; 63
     68e:	f8 94       	cli
     690:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     692:	48 81       	ld	r20, Y
     694:	59 81       	ldd	r21, Y+1	; 0x01
     696:	28 a1       	ldd	r18, Y+32	; 0x20
     698:	30 e0       	ldi	r19, 0x00	; 0
     69a:	7f 8d       	ldd	r23, Y+31	; 0x1f
     69c:	72 9f       	mul	r23, r18
     69e:	c0 01       	movw	r24, r0
     6a0:	73 9f       	mul	r23, r19
     6a2:	90 0d       	add	r25, r0
     6a4:	11 24       	eor	r1, r1
     6a6:	fa 01       	movw	r30, r20
     6a8:	e8 0f       	add	r30, r24
     6aa:	f9 1f       	adc	r31, r25
     6ac:	fb 83       	std	Y+3, r31	; 0x03
     6ae:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     6b0:	1e 8e       	std	Y+30, r1	; 0x1e
		pxQueue->pcWriteTo = pxQueue->pcHead;
     6b2:	5d 83       	std	Y+5, r21	; 0x05
     6b4:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     6b6:	82 1b       	sub	r24, r18
     6b8:	93 0b       	sbc	r25, r19
     6ba:	84 0f       	add	r24, r20
     6bc:	95 1f       	adc	r25, r21
     6be:	9f 83       	std	Y+7, r25	; 0x07
     6c0:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     6c2:	8f ef       	ldi	r24, 0xFF	; 255
     6c4:	89 a3       	std	Y+33, r24	; 0x21
		pxQueue->xTxLock = queueUNLOCKED;
     6c6:	8a a3       	std	Y+34, r24	; 0x22

		if( xNewQueue == pdFALSE )
     6c8:	61 11       	cpse	r22, r1
     6ca:	0c c0       	rjmp	.+24     	; 0x6e4 <xQueueGenericReset+0x5e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     6cc:	88 85       	ldd	r24, Y+8	; 0x08
     6ce:	88 23       	and	r24, r24
     6d0:	89 f0       	breq	.+34     	; 0x6f4 <xQueueGenericReset+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     6d2:	ce 01       	movw	r24, r28
     6d4:	08 96       	adiw	r24, 0x08	; 8
     6d6:	0e 94 57 07 	call	0xeae	; 0xeae <xTaskRemoveFromEventList>
     6da:	81 30       	cpi	r24, 0x01	; 1
     6dc:	59 f4       	brne	.+22     	; 0x6f4 <xQueueGenericReset+0x6e>
				{
					queueYIELD_IF_USING_PREEMPTION();
     6de:	0e 94 af 01 	call	0x35e	; 0x35e <vPortYield>
     6e2:	08 c0       	rjmp	.+16     	; 0x6f4 <xQueueGenericReset+0x6e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     6e4:	ce 01       	movw	r24, r28
     6e6:	08 96       	adiw	r24, 0x08	; 8
     6e8:	0e 94 ad 00 	call	0x15a	; 0x15a <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     6ec:	ce 01       	movw	r24, r28
     6ee:	43 96       	adiw	r24, 0x13	; 19
     6f0:	0e 94 ad 00 	call	0x15a	; 0x15a <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     6f4:	0f 90       	pop	r0
     6f6:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     6f8:	81 e0       	ldi	r24, 0x01	; 1
     6fa:	df 91       	pop	r29
     6fc:	cf 91       	pop	r28
     6fe:	08 95       	ret

00000700 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
     700:	0f 93       	push	r16
     702:	1f 93       	push	r17
     704:	cf 93       	push	r28
     706:	df 93       	push	r29
     708:	08 2f       	mov	r16, r24
     70a:	16 2f       	mov	r17, r22
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
     70c:	66 23       	and	r22, r22
     70e:	c9 f0       	breq	.+50     	; 0x742 <xQueueGenericCreate+0x42>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     710:	86 9f       	mul	r24, r22
     712:	c0 01       	movw	r24, r0
     714:	11 24       	eor	r1, r1
	}

	/* Allocate the new queue structure and storage area. */
	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     716:	86 96       	adiw	r24, 0x26	; 38
     718:	0e 94 71 02 	call	0x4e2	; 0x4e2 <pvPortMalloc>
     71c:	ec 01       	movw	r28, r24

	if( pcAllocatedBuffer != NULL )
     71e:	00 97       	sbiw	r24, 0x00	; 0
     720:	21 f4       	brne	.+8      	; 0x72a <xQueueGenericCreate+0x2a>
     722:	16 c0       	rjmp	.+44     	; 0x750 <xQueueGenericCreate+0x50>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     724:	d9 83       	std	Y+1, r29	; 0x01
     726:	c8 83       	st	Y, r28
     728:	03 c0       	rjmp	.+6      	; 0x730 <xQueueGenericCreate+0x30>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area - adding the padding bytes to get a better alignment. */
			pxNewQueue->pcHead = pcAllocatedBuffer + sizeof( Queue_t );
     72a:	85 96       	adiw	r24, 0x25	; 37
     72c:	99 83       	std	Y+1, r25	; 0x01
     72e:	88 83       	st	Y, r24
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
     730:	0f 8f       	std	Y+31, r16	; 0x1f
		pxNewQueue->uxItemSize = uxItemSize;
     732:	18 a3       	std	Y+32, r17	; 0x20
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     734:	61 e0       	ldi	r22, 0x01	; 1
     736:	ce 01       	movw	r24, r28
     738:	0e 94 43 03 	call	0x686	; 0x686 <xQueueGenericReset>
		}
		#endif /* configUSE_TRACE_FACILITY */

		#if( configUSE_QUEUE_SETS == 1 )
		{
			pxNewQueue->pxQueueSetContainer = NULL;
     73c:	1c a2       	std	Y+36, r1	; 0x24
     73e:	1b a2       	std	Y+35, r1	; 0x23
     740:	07 c0       	rjmp	.+14     	; 0x750 <xQueueGenericCreate+0x50>
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}

	/* Allocate the new queue structure and storage area. */
	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     742:	85 e2       	ldi	r24, 0x25	; 37
     744:	90 e0       	ldi	r25, 0x00	; 0
     746:	0e 94 71 02 	call	0x4e2	; 0x4e2 <pvPortMalloc>
     74a:	ec 01       	movw	r28, r24

	if( pcAllocatedBuffer != NULL )
     74c:	89 2b       	or	r24, r25
     74e:	51 f7       	brne	.-44     	; 0x724 <xQueueGenericCreate+0x24>
	}

	configASSERT( xReturn );

	return xReturn;
}
     750:	ce 01       	movw	r24, r28
     752:	df 91       	pop	r29
     754:	cf 91       	pop	r28
     756:	1f 91       	pop	r17
     758:	0f 91       	pop	r16
     75a:	08 95       	ret

0000075c <vAssertCalled>:
	functions can be used (those that end in FromISR()). */
}
/*-----------------------------------------------------------*/

void vAssertCalled( uint32_t ulLine, const char * const pcFile )
{
     75c:	cf 93       	push	r28
     75e:	df 93       	push	r29
     760:	cd b7       	in	r28, 0x3d	; 61
     762:	de b7       	in	r29, 0x3e	; 62
     764:	28 97       	sbiw	r28, 0x08	; 8
     766:	0f b6       	in	r0, 0x3f	; 63
     768:	f8 94       	cli
     76a:	de bf       	out	0x3e, r29	; 62
     76c:	0f be       	out	0x3f, r0	; 63
     76e:	cd bf       	out	0x3d, r28	; 61
/* The following two variables are just to ensure the parameters are not
optimised away and therefore unavailable when viewed in the debugger. */
volatile uint32_t ulLineNumber = ulLine, ulSetNonZeroInDebuggerToReturn = 0;
     770:	69 83       	std	Y+1, r22	; 0x01
     772:	7a 83       	std	Y+2, r23	; 0x02
     774:	8b 83       	std	Y+3, r24	; 0x03
     776:	9c 83       	std	Y+4, r25	; 0x04
     778:	1d 82       	std	Y+5, r1	; 0x05
     77a:	1e 82       	std	Y+6, r1	; 0x06
     77c:	1f 82       	std	Y+7, r1	; 0x07
     77e:	18 86       	std	Y+8, r1	; 0x08
volatile const char * const pcFileName = pcFile;

	taskENTER_CRITICAL();
     780:	0f b6       	in	r0, 0x3f	; 63
     782:	f8 94       	cli
     784:	0f 92       	push	r0
	{
		while( ulSetNonZeroInDebuggerToReturn == 0 )
     786:	8d 81       	ldd	r24, Y+5	; 0x05
     788:	9e 81       	ldd	r25, Y+6	; 0x06
     78a:	af 81       	ldd	r26, Y+7	; 0x07
     78c:	b8 85       	ldd	r27, Y+8	; 0x08
     78e:	89 2b       	or	r24, r25
     790:	8a 2b       	or	r24, r26
     792:	8b 2b       	or	r24, r27
     794:	c1 f3       	breq	.-16     	; 0x786 <vAssertCalled+0x2a>
			/* If you want to set out of this function in the debugger to see
			the	assert() location then set ulSetNonZeroInDebuggerToReturn to a
			non-zero value. */
		}
	}
	taskEXIT_CRITICAL();
     796:	0f 90       	pop	r0
     798:	0f be       	out	0x3f, r0	; 63

	/* Remove the potential for compiler warnings issued because the variables
	are set but not subsequently referenced. */
	( void ) pcFileName;
	( void ) ulLineNumber;
     79a:	89 81       	ldd	r24, Y+1	; 0x01
     79c:	9a 81       	ldd	r25, Y+2	; 0x02
     79e:	ab 81       	ldd	r26, Y+3	; 0x03
     7a0:	bc 81       	ldd	r27, Y+4	; 0x04
}
     7a2:	28 96       	adiw	r28, 0x08	; 8
     7a4:	0f b6       	in	r0, 0x3f	; 63
     7a6:	f8 94       	cli
     7a8:	de bf       	out	0x3e, r29	; 62
     7aa:	0f be       	out	0x3f, r0	; 63
     7ac:	cd bf       	out	0x3d, r28	; 61
     7ae:	df 91       	pop	r29
     7b0:	cf 91       	pop	r28
     7b2:	08 95       	ret

000007b4 <vApplicationMallocFailedHook>:
	parts of the demo application.  If heap_1.c, heap_2.c or heap_4.c are used,
	then the size of the heap available to pvPortMalloc() is defined by
	configTOTAL_HEAP_SIZE in FreeRTOSConfig.h, and the xPortGetFreeHeapSize()
	API function can be used to query the size of free heap space that remains.
	More information is provided in the book text. */
	vAssertCalled( __LINE__, __FILE__ );
     7b4:	62 ed       	ldi	r22, 0xD2	; 210
     7b6:	71 e0       	ldi	r23, 0x01	; 1
     7b8:	80 ec       	ldi	r24, 0xC0	; 192
     7ba:	90 e0       	ldi	r25, 0x00	; 0
     7bc:	0e 94 ae 03 	call	0x75c	; 0x75c <vAssertCalled>
     7c0:	08 95       	ret

000007c2 <prvResetNextTaskUnblockTime>:
			will manage it correctly. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     7c2:	e0 91 0f 08 	lds	r30, 0x080F	; 0x80080f <pxDelayedTaskList>
     7c6:	f0 91 10 08 	lds	r31, 0x0810	; 0x800810 <pxDelayedTaskList+0x1>
     7ca:	80 81       	ld	r24, Z
     7cc:	81 11       	cpse	r24, r1
     7ce:	0c c0       	rjmp	.+24     	; 0x7e8 <prvResetNextTaskUnblockTime+0x26>
     7d0:	8f ef       	ldi	r24, 0xFF	; 255
     7d2:	9f ef       	ldi	r25, 0xFF	; 255
     7d4:	dc 01       	movw	r26, r24
     7d6:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
     7da:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
     7de:	a0 93 04 01 	sts	0x0104, r26	; 0x800104 <xNextTaskUnblockTime+0x2>
     7e2:	b0 93 05 01 	sts	0x0105, r27	; 0x800105 <xNextTaskUnblockTime+0x3>
     7e6:	08 95       	ret
     7e8:	e0 91 0f 08 	lds	r30, 0x080F	; 0x80080f <pxDelayedTaskList>
     7ec:	f0 91 10 08 	lds	r31, 0x0810	; 0x800810 <pxDelayedTaskList+0x1>
     7f0:	07 80       	ldd	r0, Z+7	; 0x07
     7f2:	f0 85       	ldd	r31, Z+8	; 0x08
     7f4:	e0 2d       	mov	r30, r0
     7f6:	00 84       	ldd	r0, Z+8	; 0x08
     7f8:	f1 85       	ldd	r31, Z+9	; 0x09
     7fa:	e0 2d       	mov	r30, r0
     7fc:	82 81       	ldd	r24, Z+2	; 0x02
     7fe:	93 81       	ldd	r25, Z+3	; 0x03
     800:	a4 81       	ldd	r26, Z+4	; 0x04
     802:	b5 81       	ldd	r27, Z+5	; 0x05
     804:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
     808:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
     80c:	a0 93 04 01 	sts	0x0104, r26	; 0x800104 <xNextTaskUnblockTime+0x2>
     810:	b0 93 05 01 	sts	0x0105, r27	; 0x800105 <xNextTaskUnblockTime+0x3>
     814:	08 95       	ret

00000816 <xTaskGenericCreate>:
     816:	4f 92       	push	r4
     818:	5f 92       	push	r5
     81a:	6f 92       	push	r6
     81c:	7f 92       	push	r7
     81e:	8f 92       	push	r8
     820:	9f 92       	push	r9
     822:	af 92       	push	r10
     824:	bf 92       	push	r11
     826:	cf 92       	push	r12
     828:	df 92       	push	r13
     82a:	ef 92       	push	r14
     82c:	ff 92       	push	r15
     82e:	0f 93       	push	r16
     830:	1f 93       	push	r17
     832:	cf 93       	push	r28
     834:	df 93       	push	r29
     836:	4c 01       	movw	r8, r24
     838:	eb 01       	movw	r28, r22
     83a:	5a 01       	movw	r10, r20
     83c:	29 01       	movw	r4, r18
     83e:	c1 14       	cp	r12, r1
     840:	d1 04       	cpc	r13, r1
     842:	39 f4       	brne	.+14     	; 0x852 <xTaskGenericCreate+0x3c>
     844:	ca 01       	movw	r24, r20
     846:	0e 94 71 02 	call	0x4e2	; 0x4e2 <pvPortMalloc>
     84a:	6c 01       	movw	r12, r24
     84c:	89 2b       	or	r24, r25
     84e:	09 f4       	brne	.+2      	; 0x852 <xTaskGenericCreate+0x3c>
     850:	eb c0       	rjmp	.+470    	; 0xa28 <__stack+0x129>
     852:	80 e3       	ldi	r24, 0x30	; 48
     854:	90 e0       	ldi	r25, 0x00	; 0
     856:	0e 94 71 02 	call	0x4e2	; 0x4e2 <pvPortMalloc>
     85a:	3c 01       	movw	r6, r24
     85c:	00 97       	sbiw	r24, 0x00	; 0
     85e:	b9 f0       	breq	.+46     	; 0x88e <xTaskGenericCreate+0x78>
     860:	fc 01       	movw	r30, r24
     862:	d4 8e       	std	Z+28, r13	; 0x1c
     864:	c3 8e       	std	Z+27, r12	; 0x1b
     866:	a5 01       	movw	r20, r10
     868:	65 ea       	ldi	r22, 0xA5	; 165
     86a:	70 e0       	ldi	r23, 0x00	; 0
     86c:	c6 01       	movw	r24, r12
     86e:	0e 94 0a 08 	call	0x1014	; 0x1014 <memset>
     872:	f1 e0       	ldi	r31, 0x01	; 1
     874:	af 1a       	sub	r10, r31
     876:	b1 08       	sbc	r11, r1
     878:	f3 01       	movw	r30, r6
     87a:	83 8d       	ldd	r24, Z+27	; 0x1b
     87c:	94 8d       	ldd	r25, Z+28	; 0x1c
     87e:	a8 0e       	add	r10, r24
     880:	b9 1e       	adc	r11, r25
     882:	88 81       	ld	r24, Y
     884:	85 8f       	std	Z+29, r24	; 0x1d
     886:	88 81       	ld	r24, Y
     888:	81 11       	cpse	r24, r1
     88a:	05 c0       	rjmp	.+10     	; 0x896 <xTaskGenericCreate+0x80>
     88c:	14 c0       	rjmp	.+40     	; 0x8b6 <xTaskGenericCreate+0xa0>
     88e:	c6 01       	movw	r24, r12
     890:	0e 94 10 03 	call	0x620	; 0x620 <vPortFree>
     894:	c9 c0       	rjmp	.+402    	; 0xa28 <__stack+0x129>
     896:	d3 01       	movw	r26, r6
     898:	5e 96       	adiw	r26, 0x1e	; 30
     89a:	fe 01       	movw	r30, r28
     89c:	31 96       	adiw	r30, 0x01	; 1
     89e:	9e 01       	movw	r18, r28
     8a0:	24 5f       	subi	r18, 0xF4	; 244
     8a2:	3f 4f       	sbci	r19, 0xFF	; 255
     8a4:	ef 01       	movw	r28, r30
     8a6:	81 91       	ld	r24, Z+
     8a8:	8d 93       	st	X+, r24
     8aa:	88 81       	ld	r24, Y
     8ac:	88 23       	and	r24, r24
     8ae:	19 f0       	breq	.+6      	; 0x8b6 <xTaskGenericCreate+0xa0>
     8b0:	e2 17       	cp	r30, r18
     8b2:	f3 07       	cpc	r31, r19
     8b4:	b9 f7       	brne	.-18     	; 0x8a4 <xTaskGenericCreate+0x8e>
     8b6:	f3 01       	movw	r30, r6
     8b8:	10 a6       	std	Z+40, r1	; 0x28
     8ba:	10 2f       	mov	r17, r16
     8bc:	04 30       	cpi	r16, 0x04	; 4
     8be:	08 f0       	brcs	.+2      	; 0x8c2 <xTaskGenericCreate+0xac>
     8c0:	13 e0       	ldi	r17, 0x03	; 3
     8c2:	f3 01       	movw	r30, r6
     8c4:	12 8f       	std	Z+26, r17	; 0x1a
     8c6:	11 a7       	std	Z+41, r17	; 0x29
     8c8:	12 a6       	std	Z+42, r1	; 0x2a
     8ca:	e3 01       	movw	r28, r6
     8cc:	22 96       	adiw	r28, 0x02	; 2
     8ce:	ce 01       	movw	r24, r28
     8d0:	0e 94 be 00 	call	0x17c	; 0x17c <vListInitialiseItem>
     8d4:	c3 01       	movw	r24, r6
     8d6:	0e 96       	adiw	r24, 0x0e	; 14
     8d8:	0e 94 be 00 	call	0x17c	; 0x17c <vListInitialiseItem>
     8dc:	f3 01       	movw	r30, r6
     8de:	73 86       	std	Z+11, r7	; 0x0b
     8e0:	62 86       	std	Z+10, r6	; 0x0a
     8e2:	84 e0       	ldi	r24, 0x04	; 4
     8e4:	90 e0       	ldi	r25, 0x00	; 0
     8e6:	a0 e0       	ldi	r26, 0x00	; 0
     8e8:	b0 e0       	ldi	r27, 0x00	; 0
     8ea:	81 1b       	sub	r24, r17
     8ec:	91 09       	sbc	r25, r1
     8ee:	a1 09       	sbc	r26, r1
     8f0:	b1 09       	sbc	r27, r1
     8f2:	86 87       	std	Z+14, r24	; 0x0e
     8f4:	97 87       	std	Z+15, r25	; 0x0f
     8f6:	a0 8b       	std	Z+16, r26	; 0x10
     8f8:	b1 8b       	std	Z+17, r27	; 0x11
     8fa:	77 8a       	std	Z+23, r7	; 0x17
     8fc:	66 8a       	std	Z+22, r6	; 0x16
     8fe:	13 a6       	std	Z+43, r1	; 0x2b
     900:	14 a6       	std	Z+44, r1	; 0x2c
     902:	15 a6       	std	Z+45, r1	; 0x2d
     904:	16 a6       	std	Z+46, r1	; 0x2e
     906:	17 a6       	std	Z+47, r1	; 0x2f
     908:	a2 01       	movw	r20, r4
     90a:	b4 01       	movw	r22, r8
     90c:	c5 01       	movw	r24, r10
     90e:	0e 94 09 01 	call	0x212	; 0x212 <pxPortInitialiseStack>
     912:	f3 01       	movw	r30, r6
     914:	91 83       	std	Z+1, r25	; 0x01
     916:	80 83       	st	Z, r24
     918:	e1 14       	cp	r14, r1
     91a:	f1 04       	cpc	r15, r1
     91c:	19 f0       	breq	.+6      	; 0x924 <__stack+0x25>
     91e:	f7 01       	movw	r30, r14
     920:	71 82       	std	Z+1, r7	; 0x01
     922:	60 82       	st	Z, r6
     924:	0f b6       	in	r0, 0x3f	; 63
     926:	f8 94       	cli
     928:	0f 92       	push	r0
     92a:	80 91 e8 07 	lds	r24, 0x07E8	; 0x8007e8 <uxCurrentNumberOfTasks>
     92e:	8f 5f       	subi	r24, 0xFF	; 255
     930:	80 93 e8 07 	sts	0x07E8, r24	; 0x8007e8 <uxCurrentNumberOfTasks>
     934:	80 91 53 08 	lds	r24, 0x0853	; 0x800853 <pxCurrentTCB>
     938:	90 91 54 08 	lds	r25, 0x0854	; 0x800854 <pxCurrentTCB+0x1>
     93c:	89 2b       	or	r24, r25
     93e:	d1 f5       	brne	.+116    	; 0x9b4 <__stack+0xb5>
     940:	70 92 54 08 	sts	0x0854, r7	; 0x800854 <pxCurrentTCB+0x1>
     944:	60 92 53 08 	sts	0x0853, r6	; 0x800853 <pxCurrentTCB>
     948:	80 91 e8 07 	lds	r24, 0x07E8	; 0x8007e8 <uxCurrentNumberOfTasks>
     94c:	81 30       	cpi	r24, 0x01	; 1
     94e:	09 f0       	breq	.+2      	; 0x952 <__stack+0x53>
     950:	40 c0       	rjmp	.+128    	; 0x9d2 <__stack+0xd3>
     952:	87 e2       	ldi	r24, 0x27	; 39
     954:	98 e0       	ldi	r25, 0x08	; 8
     956:	0e 94 ad 00 	call	0x15a	; 0x15a <vListInitialise>
     95a:	82 e3       	ldi	r24, 0x32	; 50
     95c:	98 e0       	ldi	r25, 0x08	; 8
     95e:	0e 94 ad 00 	call	0x15a	; 0x15a <vListInitialise>
     962:	8d e3       	ldi	r24, 0x3D	; 61
     964:	98 e0       	ldi	r25, 0x08	; 8
     966:	0e 94 ad 00 	call	0x15a	; 0x15a <vListInitialise>
     96a:	88 e4       	ldi	r24, 0x48	; 72
     96c:	98 e0       	ldi	r25, 0x08	; 8
     96e:	0e 94 ad 00 	call	0x15a	; 0x15a <vListInitialise>
     972:	8c e1       	ldi	r24, 0x1C	; 28
     974:	98 e0       	ldi	r25, 0x08	; 8
     976:	0e 94 ad 00 	call	0x15a	; 0x15a <vListInitialise>
     97a:	81 e1       	ldi	r24, 0x11	; 17
     97c:	98 e0       	ldi	r25, 0x08	; 8
     97e:	0e 94 ad 00 	call	0x15a	; 0x15a <vListInitialise>
     982:	82 e0       	ldi	r24, 0x02	; 2
     984:	98 e0       	ldi	r25, 0x08	; 8
     986:	0e 94 ad 00 	call	0x15a	; 0x15a <vListInitialise>
     98a:	87 ef       	ldi	r24, 0xF7	; 247
     98c:	97 e0       	ldi	r25, 0x07	; 7
     98e:	0e 94 ad 00 	call	0x15a	; 0x15a <vListInitialise>
     992:	8b ee       	ldi	r24, 0xEB	; 235
     994:	97 e0       	ldi	r25, 0x07	; 7
     996:	0e 94 ad 00 	call	0x15a	; 0x15a <vListInitialise>
     99a:	8c e1       	ldi	r24, 0x1C	; 28
     99c:	98 e0       	ldi	r25, 0x08	; 8
     99e:	90 93 10 08 	sts	0x0810, r25	; 0x800810 <pxDelayedTaskList+0x1>
     9a2:	80 93 0f 08 	sts	0x080F, r24	; 0x80080f <pxDelayedTaskList>
     9a6:	81 e1       	ldi	r24, 0x11	; 17
     9a8:	98 e0       	ldi	r25, 0x08	; 8
     9aa:	90 93 0e 08 	sts	0x080E, r25	; 0x80080e <pxOverflowDelayedTaskList+0x1>
     9ae:	80 93 0d 08 	sts	0x080D, r24	; 0x80080d <pxOverflowDelayedTaskList>
     9b2:	0f c0       	rjmp	.+30     	; 0x9d2 <__stack+0xd3>
     9b4:	80 91 e2 07 	lds	r24, 0x07E2	; 0x8007e2 <xSchedulerRunning>
     9b8:	81 11       	cpse	r24, r1
     9ba:	0b c0       	rjmp	.+22     	; 0x9d2 <__stack+0xd3>
     9bc:	e0 91 53 08 	lds	r30, 0x0853	; 0x800853 <pxCurrentTCB>
     9c0:	f0 91 54 08 	lds	r31, 0x0854	; 0x800854 <pxCurrentTCB+0x1>
     9c4:	82 8d       	ldd	r24, Z+26	; 0x1a
     9c6:	08 17       	cp	r16, r24
     9c8:	20 f0       	brcs	.+8      	; 0x9d2 <__stack+0xd3>
     9ca:	70 92 54 08 	sts	0x0854, r7	; 0x800854 <pxCurrentTCB+0x1>
     9ce:	60 92 53 08 	sts	0x0853, r6	; 0x800853 <pxCurrentTCB>
     9d2:	80 91 de 07 	lds	r24, 0x07DE	; 0x8007de <uxTaskNumber>
     9d6:	8f 5f       	subi	r24, 0xFF	; 255
     9d8:	80 93 de 07 	sts	0x07DE, r24	; 0x8007de <uxTaskNumber>
     9dc:	f3 01       	movw	r30, r6
     9de:	82 8d       	ldd	r24, Z+26	; 0x1a
     9e0:	90 91 e3 07 	lds	r25, 0x07E3	; 0x8007e3 <uxTopReadyPriority>
     9e4:	98 17       	cp	r25, r24
     9e6:	10 f4       	brcc	.+4      	; 0x9ec <__stack+0xed>
     9e8:	80 93 e3 07 	sts	0x07E3, r24	; 0x8007e3 <uxTopReadyPriority>
     9ec:	fb e0       	ldi	r31, 0x0B	; 11
     9ee:	8f 9f       	mul	r24, r31
     9f0:	c0 01       	movw	r24, r0
     9f2:	11 24       	eor	r1, r1
     9f4:	be 01       	movw	r22, r28
     9f6:	89 5d       	subi	r24, 0xD9	; 217
     9f8:	97 4f       	sbci	r25, 0xF7	; 247
     9fa:	0e 94 c2 00 	call	0x184	; 0x184 <vListInsertEnd>
     9fe:	0f 90       	pop	r0
     a00:	0f be       	out	0x3f, r0	; 63
     a02:	80 91 e2 07 	lds	r24, 0x07E2	; 0x8007e2 <xSchedulerRunning>
     a06:	88 23       	and	r24, r24
     a08:	59 f0       	breq	.+22     	; 0xa20 <__stack+0x121>
     a0a:	e0 91 53 08 	lds	r30, 0x0853	; 0x800853 <pxCurrentTCB>
     a0e:	f0 91 54 08 	lds	r31, 0x0854	; 0x800854 <pxCurrentTCB+0x1>
     a12:	82 8d       	ldd	r24, Z+26	; 0x1a
     a14:	80 17       	cp	r24, r16
     a16:	30 f4       	brcc	.+12     	; 0xa24 <__stack+0x125>
     a18:	0e 94 af 01 	call	0x35e	; 0x35e <vPortYield>
     a1c:	81 e0       	ldi	r24, 0x01	; 1
     a1e:	05 c0       	rjmp	.+10     	; 0xa2a <__stack+0x12b>
     a20:	81 e0       	ldi	r24, 0x01	; 1
     a22:	03 c0       	rjmp	.+6      	; 0xa2a <__stack+0x12b>
     a24:	81 e0       	ldi	r24, 0x01	; 1
     a26:	01 c0       	rjmp	.+2      	; 0xa2a <__stack+0x12b>
     a28:	8f ef       	ldi	r24, 0xFF	; 255
     a2a:	df 91       	pop	r29
     a2c:	cf 91       	pop	r28
     a2e:	1f 91       	pop	r17
     a30:	0f 91       	pop	r16
     a32:	ff 90       	pop	r15
     a34:	ef 90       	pop	r14
     a36:	df 90       	pop	r13
     a38:	cf 90       	pop	r12
     a3a:	bf 90       	pop	r11
     a3c:	af 90       	pop	r10
     a3e:	9f 90       	pop	r9
     a40:	8f 90       	pop	r8
     a42:	7f 90       	pop	r7
     a44:	6f 90       	pop	r6
     a46:	5f 90       	pop	r5
     a48:	4f 90       	pop	r4
     a4a:	08 95       	ret

00000a4c <vTaskStartScheduler>:
     a4c:	af 92       	push	r10
     a4e:	bf 92       	push	r11
     a50:	cf 92       	push	r12
     a52:	df 92       	push	r13
     a54:	ef 92       	push	r14
     a56:	ff 92       	push	r15
     a58:	0f 93       	push	r16
     a5a:	a1 2c       	mov	r10, r1
     a5c:	b1 2c       	mov	r11, r1
     a5e:	c1 2c       	mov	r12, r1
     a60:	d1 2c       	mov	r13, r1
     a62:	0f 2e       	mov	r0, r31
     a64:	f9 ee       	ldi	r31, 0xE9	; 233
     a66:	ef 2e       	mov	r14, r31
     a68:	f7 e0       	ldi	r31, 0x07	; 7
     a6a:	ff 2e       	mov	r15, r31
     a6c:	f0 2d       	mov	r31, r0
     a6e:	00 e0       	ldi	r16, 0x00	; 0
     a70:	20 e0       	ldi	r18, 0x00	; 0
     a72:	30 e0       	ldi	r19, 0x00	; 0
     a74:	45 e5       	ldi	r20, 0x55	; 85
     a76:	50 e0       	ldi	r21, 0x00	; 0
     a78:	63 ef       	ldi	r22, 0xF3	; 243
     a7a:	71 e0       	ldi	r23, 0x01	; 1
     a7c:	8c eb       	ldi	r24, 0xBC	; 188
     a7e:	96 e0       	ldi	r25, 0x06	; 6
     a80:	0e 94 0b 04 	call	0x816	; 0x816 <xTaskGenericCreate>
     a84:	81 30       	cpi	r24, 0x01	; 1
     a86:	69 f4       	brne	.+26     	; 0xaa2 <vTaskStartScheduler+0x56>
     a88:	f8 94       	cli
     a8a:	80 93 e2 07 	sts	0x07E2, r24	; 0x8007e2 <xSchedulerRunning>
     a8e:	10 92 e4 07 	sts	0x07E4, r1	; 0x8007e4 <xTickCount>
     a92:	10 92 e5 07 	sts	0x07E5, r1	; 0x8007e5 <xTickCount+0x1>
     a96:	10 92 e6 07 	sts	0x07E6, r1	; 0x8007e6 <xTickCount+0x2>
     a9a:	10 92 e7 07 	sts	0x07E7, r1	; 0x8007e7 <xTickCount+0x3>
     a9e:	0e 94 75 01 	call	0x2ea	; 0x2ea <xPortStartScheduler>
     aa2:	0f 91       	pop	r16
     aa4:	ff 90       	pop	r15
     aa6:	ef 90       	pop	r14
     aa8:	df 90       	pop	r13
     aaa:	cf 90       	pop	r12
     aac:	bf 90       	pop	r11
     aae:	af 90       	pop	r10
     ab0:	08 95       	ret

00000ab2 <vTaskSuspendAll>:
     ab2:	80 91 dd 07 	lds	r24, 0x07DD	; 0x8007dd <uxSchedulerSuspended>
     ab6:	8f 5f       	subi	r24, 0xFF	; 255
     ab8:	80 93 dd 07 	sts	0x07DD, r24	; 0x8007dd <uxSchedulerSuspended>
     abc:	08 95       	ret

00000abe <xTaskIncrementTick>:
     abe:	9f 92       	push	r9
     ac0:	af 92       	push	r10
     ac2:	bf 92       	push	r11
     ac4:	cf 92       	push	r12
     ac6:	df 92       	push	r13
     ac8:	ef 92       	push	r14
     aca:	ff 92       	push	r15
     acc:	0f 93       	push	r16
     ace:	1f 93       	push	r17
     ad0:	cf 93       	push	r28
     ad2:	df 93       	push	r29
     ad4:	80 91 dd 07 	lds	r24, 0x07DD	; 0x8007dd <uxSchedulerSuspended>
     ad8:	81 11       	cpse	r24, r1
     ada:	b4 c0       	rjmp	.+360    	; 0xc44 <xTaskIncrementTick+0x186>
     adc:	80 91 e4 07 	lds	r24, 0x07E4	; 0x8007e4 <xTickCount>
     ae0:	90 91 e5 07 	lds	r25, 0x07E5	; 0x8007e5 <xTickCount+0x1>
     ae4:	a0 91 e6 07 	lds	r26, 0x07E6	; 0x8007e6 <xTickCount+0x2>
     ae8:	b0 91 e7 07 	lds	r27, 0x07E7	; 0x8007e7 <xTickCount+0x3>
     aec:	01 96       	adiw	r24, 0x01	; 1
     aee:	a1 1d       	adc	r26, r1
     af0:	b1 1d       	adc	r27, r1
     af2:	80 93 e4 07 	sts	0x07E4, r24	; 0x8007e4 <xTickCount>
     af6:	90 93 e5 07 	sts	0x07E5, r25	; 0x8007e5 <xTickCount+0x1>
     afa:	a0 93 e6 07 	sts	0x07E6, r26	; 0x8007e6 <xTickCount+0x2>
     afe:	b0 93 e7 07 	sts	0x07E7, r27	; 0x8007e7 <xTickCount+0x3>
     b02:	c0 90 e4 07 	lds	r12, 0x07E4	; 0x8007e4 <xTickCount>
     b06:	d0 90 e5 07 	lds	r13, 0x07E5	; 0x8007e5 <xTickCount+0x1>
     b0a:	e0 90 e6 07 	lds	r14, 0x07E6	; 0x8007e6 <xTickCount+0x2>
     b0e:	f0 90 e7 07 	lds	r15, 0x07E7	; 0x8007e7 <xTickCount+0x3>
     b12:	c1 14       	cp	r12, r1
     b14:	d1 04       	cpc	r13, r1
     b16:	e1 04       	cpc	r14, r1
     b18:	f1 04       	cpc	r15, r1
     b1a:	b9 f4       	brne	.+46     	; 0xb4a <xTaskIncrementTick+0x8c>
     b1c:	80 91 0f 08 	lds	r24, 0x080F	; 0x80080f <pxDelayedTaskList>
     b20:	90 91 10 08 	lds	r25, 0x0810	; 0x800810 <pxDelayedTaskList+0x1>
     b24:	20 91 0d 08 	lds	r18, 0x080D	; 0x80080d <pxOverflowDelayedTaskList>
     b28:	30 91 0e 08 	lds	r19, 0x080E	; 0x80080e <pxOverflowDelayedTaskList+0x1>
     b2c:	30 93 10 08 	sts	0x0810, r19	; 0x800810 <pxDelayedTaskList+0x1>
     b30:	20 93 0f 08 	sts	0x080F, r18	; 0x80080f <pxDelayedTaskList>
     b34:	90 93 0e 08 	sts	0x080E, r25	; 0x80080e <pxOverflowDelayedTaskList+0x1>
     b38:	80 93 0d 08 	sts	0x080D, r24	; 0x80080d <pxOverflowDelayedTaskList>
     b3c:	80 91 df 07 	lds	r24, 0x07DF	; 0x8007df <xNumOfOverflows>
     b40:	8f 5f       	subi	r24, 0xFF	; 255
     b42:	80 93 df 07 	sts	0x07DF, r24	; 0x8007df <xNumOfOverflows>
     b46:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <prvResetNextTaskUnblockTime>
     b4a:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xNextTaskUnblockTime>
     b4e:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <xNextTaskUnblockTime+0x1>
     b52:	a0 91 04 01 	lds	r26, 0x0104	; 0x800104 <xNextTaskUnblockTime+0x2>
     b56:	b0 91 05 01 	lds	r27, 0x0105	; 0x800105 <xNextTaskUnblockTime+0x3>
     b5a:	c8 16       	cp	r12, r24
     b5c:	d9 06       	cpc	r13, r25
     b5e:	ea 06       	cpc	r14, r26
     b60:	fb 06       	cpc	r15, r27
     b62:	10 f4       	brcc	.+4      	; 0xb68 <xTaskIncrementTick+0xaa>
     b64:	b1 2c       	mov	r11, r1
     b66:	5d c0       	rjmp	.+186    	; 0xc22 <xTaskIncrementTick+0x164>
     b68:	b1 2c       	mov	r11, r1
     b6a:	0f 2e       	mov	r0, r31
     b6c:	fb e0       	ldi	r31, 0x0B	; 11
     b6e:	af 2e       	mov	r10, r31
     b70:	f0 2d       	mov	r31, r0
     b72:	99 24       	eor	r9, r9
     b74:	93 94       	inc	r9
     b76:	e0 91 0f 08 	lds	r30, 0x080F	; 0x80080f <pxDelayedTaskList>
     b7a:	f0 91 10 08 	lds	r31, 0x0810	; 0x800810 <pxDelayedTaskList+0x1>
     b7e:	90 81       	ld	r25, Z
     b80:	91 11       	cpse	r25, r1
     b82:	0c c0       	rjmp	.+24     	; 0xb9c <xTaskIncrementTick+0xde>
     b84:	8f ef       	ldi	r24, 0xFF	; 255
     b86:	9f ef       	ldi	r25, 0xFF	; 255
     b88:	dc 01       	movw	r26, r24
     b8a:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
     b8e:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
     b92:	a0 93 04 01 	sts	0x0104, r26	; 0x800104 <xNextTaskUnblockTime+0x2>
     b96:	b0 93 05 01 	sts	0x0105, r27	; 0x800105 <xNextTaskUnblockTime+0x3>
     b9a:	43 c0       	rjmp	.+134    	; 0xc22 <xTaskIncrementTick+0x164>
     b9c:	e0 91 0f 08 	lds	r30, 0x080F	; 0x80080f <pxDelayedTaskList>
     ba0:	f0 91 10 08 	lds	r31, 0x0810	; 0x800810 <pxDelayedTaskList+0x1>
     ba4:	07 80       	ldd	r0, Z+7	; 0x07
     ba6:	f0 85       	ldd	r31, Z+8	; 0x08
     ba8:	e0 2d       	mov	r30, r0
     baa:	c0 85       	ldd	r28, Z+8	; 0x08
     bac:	d1 85       	ldd	r29, Z+9	; 0x09
     bae:	8a 81       	ldd	r24, Y+2	; 0x02
     bb0:	9b 81       	ldd	r25, Y+3	; 0x03
     bb2:	ac 81       	ldd	r26, Y+4	; 0x04
     bb4:	bd 81       	ldd	r27, Y+5	; 0x05
     bb6:	c8 16       	cp	r12, r24
     bb8:	d9 06       	cpc	r13, r25
     bba:	ea 06       	cpc	r14, r26
     bbc:	fb 06       	cpc	r15, r27
     bbe:	48 f4       	brcc	.+18     	; 0xbd2 <xTaskIncrementTick+0x114>
     bc0:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
     bc4:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
     bc8:	a0 93 04 01 	sts	0x0104, r26	; 0x800104 <xNextTaskUnblockTime+0x2>
     bcc:	b0 93 05 01 	sts	0x0105, r27	; 0x800105 <xNextTaskUnblockTime+0x3>
     bd0:	28 c0       	rjmp	.+80     	; 0xc22 <xTaskIncrementTick+0x164>
     bd2:	8e 01       	movw	r16, r28
     bd4:	0e 5f       	subi	r16, 0xFE	; 254
     bd6:	1f 4f       	sbci	r17, 0xFF	; 255
     bd8:	c8 01       	movw	r24, r16
     bda:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
     bde:	88 8d       	ldd	r24, Y+24	; 0x18
     be0:	99 8d       	ldd	r25, Y+25	; 0x19
     be2:	89 2b       	or	r24, r25
     be4:	21 f0       	breq	.+8      	; 0xbee <xTaskIncrementTick+0x130>
     be6:	ce 01       	movw	r24, r28
     be8:	0e 96       	adiw	r24, 0x0e	; 14
     bea:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
     bee:	2a 8d       	ldd	r18, Y+26	; 0x1a
     bf0:	80 91 e3 07 	lds	r24, 0x07E3	; 0x8007e3 <uxTopReadyPriority>
     bf4:	82 17       	cp	r24, r18
     bf6:	10 f4       	brcc	.+4      	; 0xbfc <xTaskIncrementTick+0x13e>
     bf8:	20 93 e3 07 	sts	0x07E3, r18	; 0x8007e3 <uxTopReadyPriority>
     bfc:	a2 9e       	mul	r10, r18
     bfe:	c0 01       	movw	r24, r0
     c00:	11 24       	eor	r1, r1
     c02:	b8 01       	movw	r22, r16
     c04:	89 5d       	subi	r24, 0xD9	; 217
     c06:	97 4f       	sbci	r25, 0xF7	; 247
     c08:	0e 94 c2 00 	call	0x184	; 0x184 <vListInsertEnd>
     c0c:	e0 91 53 08 	lds	r30, 0x0853	; 0x800853 <pxCurrentTCB>
     c10:	f0 91 54 08 	lds	r31, 0x0854	; 0x800854 <pxCurrentTCB+0x1>
     c14:	9a 8d       	ldd	r25, Y+26	; 0x1a
     c16:	82 8d       	ldd	r24, Z+26	; 0x1a
     c18:	98 17       	cp	r25, r24
     c1a:	08 f4       	brcc	.+2      	; 0xc1e <xTaskIncrementTick+0x160>
     c1c:	ac cf       	rjmp	.-168    	; 0xb76 <xTaskIncrementTick+0xb8>
     c1e:	b9 2c       	mov	r11, r9
     c20:	aa cf       	rjmp	.-172    	; 0xb76 <xTaskIncrementTick+0xb8>
     c22:	e0 91 53 08 	lds	r30, 0x0853	; 0x800853 <pxCurrentTCB>
     c26:	f0 91 54 08 	lds	r31, 0x0854	; 0x800854 <pxCurrentTCB+0x1>
     c2a:	e2 8d       	ldd	r30, Z+26	; 0x1a
     c2c:	8b e0       	ldi	r24, 0x0B	; 11
     c2e:	e8 9f       	mul	r30, r24
     c30:	f0 01       	movw	r30, r0
     c32:	11 24       	eor	r1, r1
     c34:	e9 5d       	subi	r30, 0xD9	; 217
     c36:	f7 4f       	sbci	r31, 0xF7	; 247
     c38:	80 81       	ld	r24, Z
     c3a:	82 30       	cpi	r24, 0x02	; 2
     c3c:	48 f0       	brcs	.+18     	; 0xc50 <xTaskIncrementTick+0x192>
     c3e:	bb 24       	eor	r11, r11
     c40:	b3 94       	inc	r11
     c42:	06 c0       	rjmp	.+12     	; 0xc50 <xTaskIncrementTick+0x192>
     c44:	80 91 e1 07 	lds	r24, 0x07E1	; 0x8007e1 <uxPendedTicks>
     c48:	8f 5f       	subi	r24, 0xFF	; 255
     c4a:	80 93 e1 07 	sts	0x07E1, r24	; 0x8007e1 <uxPendedTicks>
     c4e:	b1 2c       	mov	r11, r1
     c50:	80 91 e0 07 	lds	r24, 0x07E0	; 0x8007e0 <xYieldPending>
     c54:	88 23       	and	r24, r24
     c56:	11 f0       	breq	.+4      	; 0xc5c <xTaskIncrementTick+0x19e>
     c58:	bb 24       	eor	r11, r11
     c5a:	b3 94       	inc	r11
     c5c:	8b 2d       	mov	r24, r11
     c5e:	df 91       	pop	r29
     c60:	cf 91       	pop	r28
     c62:	1f 91       	pop	r17
     c64:	0f 91       	pop	r16
     c66:	ff 90       	pop	r15
     c68:	ef 90       	pop	r14
     c6a:	df 90       	pop	r13
     c6c:	cf 90       	pop	r12
     c6e:	bf 90       	pop	r11
     c70:	af 90       	pop	r10
     c72:	9f 90       	pop	r9
     c74:	08 95       	ret

00000c76 <xTaskResumeAll>:
     c76:	cf 92       	push	r12
     c78:	df 92       	push	r13
     c7a:	ef 92       	push	r14
     c7c:	ff 92       	push	r15
     c7e:	0f 93       	push	r16
     c80:	1f 93       	push	r17
     c82:	cf 93       	push	r28
     c84:	df 93       	push	r29
     c86:	0f b6       	in	r0, 0x3f	; 63
     c88:	f8 94       	cli
     c8a:	0f 92       	push	r0
     c8c:	80 91 dd 07 	lds	r24, 0x07DD	; 0x8007dd <uxSchedulerSuspended>
     c90:	81 50       	subi	r24, 0x01	; 1
     c92:	80 93 dd 07 	sts	0x07DD, r24	; 0x8007dd <uxSchedulerSuspended>
     c96:	80 91 dd 07 	lds	r24, 0x07DD	; 0x8007dd <uxSchedulerSuspended>
     c9a:	81 11       	cpse	r24, r1
     c9c:	5f c0       	rjmp	.+190    	; 0xd5c <xTaskResumeAll+0xe6>
     c9e:	80 91 e8 07 	lds	r24, 0x07E8	; 0x8007e8 <uxCurrentNumberOfTasks>
     ca2:	81 11       	cpse	r24, r1
     ca4:	2c c0       	rjmp	.+88     	; 0xcfe <xTaskResumeAll+0x88>
     ca6:	5d c0       	rjmp	.+186    	; 0xd62 <xTaskResumeAll+0xec>
     ca8:	d7 01       	movw	r26, r14
     caa:	17 96       	adiw	r26, 0x07	; 7
     cac:	ed 91       	ld	r30, X+
     cae:	fc 91       	ld	r31, X
     cb0:	18 97       	sbiw	r26, 0x08	; 8
     cb2:	c0 85       	ldd	r28, Z+8	; 0x08
     cb4:	d1 85       	ldd	r29, Z+9	; 0x09
     cb6:	ce 01       	movw	r24, r28
     cb8:	0e 96       	adiw	r24, 0x0e	; 14
     cba:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
     cbe:	8e 01       	movw	r16, r28
     cc0:	0e 5f       	subi	r16, 0xFE	; 254
     cc2:	1f 4f       	sbci	r17, 0xFF	; 255
     cc4:	c8 01       	movw	r24, r16
     cc6:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
     cca:	9a 8d       	ldd	r25, Y+26	; 0x1a
     ccc:	80 91 e3 07 	lds	r24, 0x07E3	; 0x8007e3 <uxTopReadyPriority>
     cd0:	89 17       	cp	r24, r25
     cd2:	10 f4       	brcc	.+4      	; 0xcd8 <xTaskResumeAll+0x62>
     cd4:	90 93 e3 07 	sts	0x07E3, r25	; 0x8007e3 <uxTopReadyPriority>
     cd8:	d9 9e       	mul	r13, r25
     cda:	c0 01       	movw	r24, r0
     cdc:	11 24       	eor	r1, r1
     cde:	b8 01       	movw	r22, r16
     ce0:	89 5d       	subi	r24, 0xD9	; 217
     ce2:	97 4f       	sbci	r25, 0xF7	; 247
     ce4:	0e 94 c2 00 	call	0x184	; 0x184 <vListInsertEnd>
     ce8:	e0 91 53 08 	lds	r30, 0x0853	; 0x800853 <pxCurrentTCB>
     cec:	f0 91 54 08 	lds	r31, 0x0854	; 0x800854 <pxCurrentTCB+0x1>
     cf0:	9a 8d       	ldd	r25, Y+26	; 0x1a
     cf2:	82 8d       	ldd	r24, Z+26	; 0x1a
     cf4:	98 17       	cp	r25, r24
     cf6:	78 f0       	brcs	.+30     	; 0xd16 <xTaskResumeAll+0xa0>
     cf8:	c0 92 e0 07 	sts	0x07E0, r12	; 0x8007e0 <xYieldPending>
     cfc:	0c c0       	rjmp	.+24     	; 0xd16 <xTaskResumeAll+0xa0>
     cfe:	0f 2e       	mov	r0, r31
     d00:	f2 e0       	ldi	r31, 0x02	; 2
     d02:	ef 2e       	mov	r14, r31
     d04:	f8 e0       	ldi	r31, 0x08	; 8
     d06:	ff 2e       	mov	r15, r31
     d08:	f0 2d       	mov	r31, r0
     d0a:	0f 2e       	mov	r0, r31
     d0c:	fb e0       	ldi	r31, 0x0B	; 11
     d0e:	df 2e       	mov	r13, r31
     d10:	f0 2d       	mov	r31, r0
     d12:	cc 24       	eor	r12, r12
     d14:	c3 94       	inc	r12
     d16:	f7 01       	movw	r30, r14
     d18:	80 81       	ld	r24, Z
     d1a:	81 11       	cpse	r24, r1
     d1c:	c5 cf       	rjmp	.-118    	; 0xca8 <xTaskResumeAll+0x32>
     d1e:	80 91 e1 07 	lds	r24, 0x07E1	; 0x8007e1 <uxPendedTicks>
     d22:	88 23       	and	r24, r24
     d24:	99 f0       	breq	.+38     	; 0xd4c <xTaskResumeAll+0xd6>
     d26:	80 91 e1 07 	lds	r24, 0x07E1	; 0x8007e1 <uxPendedTicks>
     d2a:	88 23       	and	r24, r24
     d2c:	79 f0       	breq	.+30     	; 0xd4c <xTaskResumeAll+0xd6>
     d2e:	c1 e0       	ldi	r28, 0x01	; 1
     d30:	0e 94 5f 05 	call	0xabe	; 0xabe <xTaskIncrementTick>
     d34:	81 11       	cpse	r24, r1
     d36:	c0 93 e0 07 	sts	0x07E0, r28	; 0x8007e0 <xYieldPending>
     d3a:	80 91 e1 07 	lds	r24, 0x07E1	; 0x8007e1 <uxPendedTicks>
     d3e:	81 50       	subi	r24, 0x01	; 1
     d40:	80 93 e1 07 	sts	0x07E1, r24	; 0x8007e1 <uxPendedTicks>
     d44:	80 91 e1 07 	lds	r24, 0x07E1	; 0x8007e1 <uxPendedTicks>
     d48:	81 11       	cpse	r24, r1
     d4a:	f2 cf       	rjmp	.-28     	; 0xd30 <xTaskResumeAll+0xba>
     d4c:	80 91 e0 07 	lds	r24, 0x07E0	; 0x8007e0 <xYieldPending>
     d50:	81 30       	cpi	r24, 0x01	; 1
     d52:	31 f4       	brne	.+12     	; 0xd60 <xTaskResumeAll+0xea>
     d54:	0e 94 af 01 	call	0x35e	; 0x35e <vPortYield>
     d58:	81 e0       	ldi	r24, 0x01	; 1
     d5a:	03 c0       	rjmp	.+6      	; 0xd62 <xTaskResumeAll+0xec>
     d5c:	80 e0       	ldi	r24, 0x00	; 0
     d5e:	01 c0       	rjmp	.+2      	; 0xd62 <xTaskResumeAll+0xec>
     d60:	80 e0       	ldi	r24, 0x00	; 0
     d62:	0f 90       	pop	r0
     d64:	0f be       	out	0x3f, r0	; 63
     d66:	df 91       	pop	r29
     d68:	cf 91       	pop	r28
     d6a:	1f 91       	pop	r17
     d6c:	0f 91       	pop	r16
     d6e:	ff 90       	pop	r15
     d70:	ef 90       	pop	r14
     d72:	df 90       	pop	r13
     d74:	cf 90       	pop	r12
     d76:	08 95       	ret

00000d78 <prvIdleTask>:
     d78:	07 ef       	ldi	r16, 0xF7	; 247
     d7a:	17 e0       	ldi	r17, 0x07	; 7
     d7c:	0f 2e       	mov	r0, r31
     d7e:	f7 e2       	ldi	r31, 0x27	; 39
     d80:	ef 2e       	mov	r14, r31
     d82:	f8 e0       	ldi	r31, 0x08	; 8
     d84:	ff 2e       	mov	r15, r31
     d86:	f0 2d       	mov	r31, r0
     d88:	29 c0       	rjmp	.+82     	; 0xddc <prvIdleTask+0x64>
     d8a:	0e 94 59 05 	call	0xab2	; 0xab2 <vTaskSuspendAll>
     d8e:	d8 01       	movw	r26, r16
     d90:	cc 91       	ld	r28, X
     d92:	0e 94 3b 06 	call	0xc76	; 0xc76 <xTaskResumeAll>
     d96:	cc 23       	and	r28, r28
     d98:	09 f1       	breq	.+66     	; 0xddc <prvIdleTask+0x64>
     d9a:	0f b6       	in	r0, 0x3f	; 63
     d9c:	f8 94       	cli
     d9e:	0f 92       	push	r0
     da0:	d8 01       	movw	r26, r16
     da2:	17 96       	adiw	r26, 0x07	; 7
     da4:	ed 91       	ld	r30, X+
     da6:	fc 91       	ld	r31, X
     da8:	18 97       	sbiw	r26, 0x08	; 8
     daa:	c0 85       	ldd	r28, Z+8	; 0x08
     dac:	d1 85       	ldd	r29, Z+9	; 0x09
     dae:	ce 01       	movw	r24, r28
     db0:	02 96       	adiw	r24, 0x02	; 2
     db2:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
     db6:	80 91 e8 07 	lds	r24, 0x07E8	; 0x8007e8 <uxCurrentNumberOfTasks>
     dba:	81 50       	subi	r24, 0x01	; 1
     dbc:	80 93 e8 07 	sts	0x07E8, r24	; 0x8007e8 <uxCurrentNumberOfTasks>
     dc0:	80 91 f6 07 	lds	r24, 0x07F6	; 0x8007f6 <uxTasksDeleted>
     dc4:	81 50       	subi	r24, 0x01	; 1
     dc6:	80 93 f6 07 	sts	0x07F6, r24	; 0x8007f6 <uxTasksDeleted>
     dca:	0f 90       	pop	r0
     dcc:	0f be       	out	0x3f, r0	; 63
     dce:	8b 8d       	ldd	r24, Y+27	; 0x1b
     dd0:	9c 8d       	ldd	r25, Y+28	; 0x1c
     dd2:	0e 94 10 03 	call	0x620	; 0x620 <vPortFree>
     dd6:	ce 01       	movw	r24, r28
     dd8:	0e 94 10 03 	call	0x620	; 0x620 <vPortFree>
     ddc:	80 91 f6 07 	lds	r24, 0x07F6	; 0x8007f6 <uxTasksDeleted>
     de0:	81 11       	cpse	r24, r1
     de2:	d3 cf       	rjmp	.-90     	; 0xd8a <prvIdleTask+0x12>
     de4:	f7 01       	movw	r30, r14
     de6:	80 81       	ld	r24, Z
     de8:	82 30       	cpi	r24, 0x02	; 2
     dea:	c0 f3       	brcs	.-16     	; 0xddc <prvIdleTask+0x64>
     dec:	0e 94 af 01 	call	0x35e	; 0x35e <vPortYield>
     df0:	f5 cf       	rjmp	.-22     	; 0xddc <prvIdleTask+0x64>

00000df2 <vTaskSwitchContext>:
     df2:	80 91 dd 07 	lds	r24, 0x07DD	; 0x8007dd <uxSchedulerSuspended>
     df6:	88 23       	and	r24, r24
     df8:	21 f0       	breq	.+8      	; 0xe02 <vTaskSwitchContext+0x10>
     dfa:	81 e0       	ldi	r24, 0x01	; 1
     dfc:	80 93 e0 07 	sts	0x07E0, r24	; 0x8007e0 <xYieldPending>
     e00:	08 95       	ret
     e02:	10 92 e0 07 	sts	0x07E0, r1	; 0x8007e0 <xYieldPending>
     e06:	e0 91 e3 07 	lds	r30, 0x07E3	; 0x8007e3 <uxTopReadyPriority>
     e0a:	4b e0       	ldi	r20, 0x0B	; 11
     e0c:	e4 9f       	mul	r30, r20
     e0e:	f0 01       	movw	r30, r0
     e10:	11 24       	eor	r1, r1
     e12:	e9 5d       	subi	r30, 0xD9	; 217
     e14:	f7 4f       	sbci	r31, 0xF7	; 247
     e16:	80 81       	ld	r24, Z
     e18:	81 11       	cpse	r24, r1
     e1a:	10 c0       	rjmp	.+32     	; 0xe3c <vTaskSwitchContext+0x4a>
     e1c:	9b e0       	ldi	r25, 0x0B	; 11
     e1e:	80 91 e3 07 	lds	r24, 0x07E3	; 0x8007e3 <uxTopReadyPriority>
     e22:	81 50       	subi	r24, 0x01	; 1
     e24:	80 93 e3 07 	sts	0x07E3, r24	; 0x8007e3 <uxTopReadyPriority>
     e28:	e0 91 e3 07 	lds	r30, 0x07E3	; 0x8007e3 <uxTopReadyPriority>
     e2c:	9e 9f       	mul	r25, r30
     e2e:	f0 01       	movw	r30, r0
     e30:	11 24       	eor	r1, r1
     e32:	e9 5d       	subi	r30, 0xD9	; 217
     e34:	f7 4f       	sbci	r31, 0xF7	; 247
     e36:	80 81       	ld	r24, Z
     e38:	88 23       	and	r24, r24
     e3a:	89 f3       	breq	.-30     	; 0xe1e <vTaskSwitchContext+0x2c>
     e3c:	80 91 e3 07 	lds	r24, 0x07E3	; 0x8007e3 <uxTopReadyPriority>
     e40:	28 2f       	mov	r18, r24
     e42:	30 e0       	ldi	r19, 0x00	; 0
     e44:	4b e0       	ldi	r20, 0x0B	; 11
     e46:	84 9f       	mul	r24, r20
     e48:	c0 01       	movw	r24, r0
     e4a:	11 24       	eor	r1, r1
     e4c:	dc 01       	movw	r26, r24
     e4e:	a9 5d       	subi	r26, 0xD9	; 217
     e50:	b7 4f       	sbci	r27, 0xF7	; 247
     e52:	11 96       	adiw	r26, 0x01	; 1
     e54:	ed 91       	ld	r30, X+
     e56:	fc 91       	ld	r31, X
     e58:	12 97       	sbiw	r26, 0x02	; 2
     e5a:	04 80       	ldd	r0, Z+4	; 0x04
     e5c:	f5 81       	ldd	r31, Z+5	; 0x05
     e5e:	e0 2d       	mov	r30, r0
     e60:	12 96       	adiw	r26, 0x02	; 2
     e62:	fc 93       	st	X, r31
     e64:	ee 93       	st	-X, r30
     e66:	11 97       	sbiw	r26, 0x01	; 1
     e68:	86 5d       	subi	r24, 0xD6	; 214
     e6a:	97 4f       	sbci	r25, 0xF7	; 247
     e6c:	e8 17       	cp	r30, r24
     e6e:	f9 07       	cpc	r31, r25
     e70:	61 f4       	brne	.+24     	; 0xe8a <vTaskSwitchContext+0x98>
     e72:	84 81       	ldd	r24, Z+4	; 0x04
     e74:	95 81       	ldd	r25, Z+5	; 0x05
     e76:	4b e0       	ldi	r20, 0x0B	; 11
     e78:	42 9f       	mul	r20, r18
     e7a:	f0 01       	movw	r30, r0
     e7c:	43 9f       	mul	r20, r19
     e7e:	f0 0d       	add	r31, r0
     e80:	11 24       	eor	r1, r1
     e82:	e9 5d       	subi	r30, 0xD9	; 217
     e84:	f7 4f       	sbci	r31, 0xF7	; 247
     e86:	92 83       	std	Z+2, r25	; 0x02
     e88:	81 83       	std	Z+1, r24	; 0x01
     e8a:	8b e0       	ldi	r24, 0x0B	; 11
     e8c:	82 9f       	mul	r24, r18
     e8e:	f0 01       	movw	r30, r0
     e90:	83 9f       	mul	r24, r19
     e92:	f0 0d       	add	r31, r0
     e94:	11 24       	eor	r1, r1
     e96:	e9 5d       	subi	r30, 0xD9	; 217
     e98:	f7 4f       	sbci	r31, 0xF7	; 247
     e9a:	01 80       	ldd	r0, Z+1	; 0x01
     e9c:	f2 81       	ldd	r31, Z+2	; 0x02
     e9e:	e0 2d       	mov	r30, r0
     ea0:	80 85       	ldd	r24, Z+8	; 0x08
     ea2:	91 85       	ldd	r25, Z+9	; 0x09
     ea4:	90 93 54 08 	sts	0x0854, r25	; 0x800854 <pxCurrentTCB+0x1>
     ea8:	80 93 53 08 	sts	0x0853, r24	; 0x800853 <pxCurrentTCB>
     eac:	08 95       	ret

00000eae <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
     eae:	0f 93       	push	r16
     eb0:	1f 93       	push	r17
     eb2:	cf 93       	push	r28
     eb4:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     eb6:	dc 01       	movw	r26, r24
     eb8:	17 96       	adiw	r26, 0x07	; 7
     eba:	ed 91       	ld	r30, X+
     ebc:	fc 91       	ld	r31, X
     ebe:	18 97       	sbiw	r26, 0x08	; 8
     ec0:	c0 85       	ldd	r28, Z+8	; 0x08
     ec2:	d1 85       	ldd	r29, Z+9	; 0x09
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     ec4:	8e 01       	movw	r16, r28
     ec6:	02 5f       	subi	r16, 0xF2	; 242
     ec8:	1f 4f       	sbci	r17, 0xFF	; 255
     eca:	c8 01       	movw	r24, r16
     ecc:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     ed0:	80 91 dd 07 	lds	r24, 0x07DD	; 0x8007dd <uxSchedulerSuspended>
     ed4:	81 11       	cpse	r24, r1
     ed6:	16 c0       	rjmp	.+44     	; 0xf04 <xTaskRemoveFromEventList+0x56>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
     ed8:	0c 50       	subi	r16, 0x0C	; 12
     eda:	11 09       	sbc	r17, r1
     edc:	c8 01       	movw	r24, r16
     ede:	0e 94 e3 00 	call	0x1c6	; 0x1c6 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
     ee2:	9a 8d       	ldd	r25, Y+26	; 0x1a
     ee4:	80 91 e3 07 	lds	r24, 0x07E3	; 0x8007e3 <uxTopReadyPriority>
     ee8:	89 17       	cp	r24, r25
     eea:	10 f4       	brcc	.+4      	; 0xef0 <xTaskRemoveFromEventList+0x42>
     eec:	90 93 e3 07 	sts	0x07E3, r25	; 0x8007e3 <uxTopReadyPriority>
     ef0:	bb e0       	ldi	r27, 0x0B	; 11
     ef2:	9b 9f       	mul	r25, r27
     ef4:	c0 01       	movw	r24, r0
     ef6:	11 24       	eor	r1, r1
     ef8:	b8 01       	movw	r22, r16
     efa:	89 5d       	subi	r24, 0xD9	; 217
     efc:	97 4f       	sbci	r25, 0xF7	; 247
     efe:	0e 94 c2 00 	call	0x184	; 0x184 <vListInsertEnd>
     f02:	05 c0       	rjmp	.+10     	; 0xf0e <xTaskRemoveFromEventList+0x60>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     f04:	b8 01       	movw	r22, r16
     f06:	82 e0       	ldi	r24, 0x02	; 2
     f08:	98 e0       	ldi	r25, 0x08	; 8
     f0a:	0e 94 c2 00 	call	0x184	; 0x184 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
     f0e:	e0 91 53 08 	lds	r30, 0x0853	; 0x800853 <pxCurrentTCB>
     f12:	f0 91 54 08 	lds	r31, 0x0854	; 0x800854 <pxCurrentTCB+0x1>
     f16:	9a 8d       	ldd	r25, Y+26	; 0x1a
     f18:	82 8d       	ldd	r24, Z+26	; 0x1a
     f1a:	89 17       	cp	r24, r25
     f1c:	20 f4       	brcc	.+8      	; 0xf26 <xTaskRemoveFromEventList+0x78>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
     f1e:	81 e0       	ldi	r24, 0x01	; 1
     f20:	80 93 e0 07 	sts	0x07E0, r24	; 0x8007e0 <xYieldPending>
     f24:	01 c0       	rjmp	.+2      	; 0xf28 <xTaskRemoveFromEventList+0x7a>
	}
	else
	{
		xReturn = pdFALSE;
     f26:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
     f28:	df 91       	pop	r29
     f2a:	cf 91       	pop	r28
     f2c:	1f 91       	pop	r17
     f2e:	0f 91       	pop	r16
     f30:	08 95       	ret

00000f32 <__vector_1>:
    intFunc[EXTERNAL_INT_7]();
}

#else

ISR(INT0_vect) {
     f32:	1f 92       	push	r1
     f34:	0f 92       	push	r0
     f36:	0f b6       	in	r0, 0x3f	; 63
     f38:	0f 92       	push	r0
     f3a:	11 24       	eor	r1, r1
     f3c:	2f 93       	push	r18
     f3e:	3f 93       	push	r19
     f40:	4f 93       	push	r20
     f42:	5f 93       	push	r21
     f44:	6f 93       	push	r22
     f46:	7f 93       	push	r23
     f48:	8f 93       	push	r24
     f4a:	9f 93       	push	r25
     f4c:	af 93       	push	r26
     f4e:	bf 93       	push	r27
     f50:	ef 93       	push	r30
     f52:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_0])
     f54:	80 91 55 08 	lds	r24, 0x0855	; 0x800855 <intFunc>
     f58:	90 91 56 08 	lds	r25, 0x0856	; 0x800856 <intFunc+0x1>
     f5c:	89 2b       	or	r24, r25
     f5e:	29 f0       	breq	.+10     	; 0xf6a <__vector_1+0x38>
    intFunc[EXTERNAL_INT_0]();
     f60:	e0 91 55 08 	lds	r30, 0x0855	; 0x800855 <intFunc>
     f64:	f0 91 56 08 	lds	r31, 0x0856	; 0x800856 <intFunc+0x1>
     f68:	09 95       	icall
}
     f6a:	ff 91       	pop	r31
     f6c:	ef 91       	pop	r30
     f6e:	bf 91       	pop	r27
     f70:	af 91       	pop	r26
     f72:	9f 91       	pop	r25
     f74:	8f 91       	pop	r24
     f76:	7f 91       	pop	r23
     f78:	6f 91       	pop	r22
     f7a:	5f 91       	pop	r21
     f7c:	4f 91       	pop	r20
     f7e:	3f 91       	pop	r19
     f80:	2f 91       	pop	r18
     f82:	0f 90       	pop	r0
     f84:	0f be       	out	0x3f, r0	; 63
     f86:	0f 90       	pop	r0
     f88:	1f 90       	pop	r1
     f8a:	18 95       	reti

00000f8c <__vector_2>:

ISR(INT1_vect) {
     f8c:	1f 92       	push	r1
     f8e:	0f 92       	push	r0
     f90:	0f b6       	in	r0, 0x3f	; 63
     f92:	0f 92       	push	r0
     f94:	11 24       	eor	r1, r1
     f96:	2f 93       	push	r18
     f98:	3f 93       	push	r19
     f9a:	4f 93       	push	r20
     f9c:	5f 93       	push	r21
     f9e:	6f 93       	push	r22
     fa0:	7f 93       	push	r23
     fa2:	8f 93       	push	r24
     fa4:	9f 93       	push	r25
     fa6:	af 93       	push	r26
     fa8:	bf 93       	push	r27
     faa:	ef 93       	push	r30
     fac:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_1])
     fae:	80 91 57 08 	lds	r24, 0x0857	; 0x800857 <intFunc+0x2>
     fb2:	90 91 58 08 	lds	r25, 0x0858	; 0x800858 <intFunc+0x3>
     fb6:	89 2b       	or	r24, r25
     fb8:	29 f0       	breq	.+10     	; 0xfc4 <__vector_2+0x38>
    intFunc[EXTERNAL_INT_1]();
     fba:	e0 91 57 08 	lds	r30, 0x0857	; 0x800857 <intFunc+0x2>
     fbe:	f0 91 58 08 	lds	r31, 0x0858	; 0x800858 <intFunc+0x3>
     fc2:	09 95       	icall
}
     fc4:	ff 91       	pop	r31
     fc6:	ef 91       	pop	r30
     fc8:	bf 91       	pop	r27
     fca:	af 91       	pop	r26
     fcc:	9f 91       	pop	r25
     fce:	8f 91       	pop	r24
     fd0:	7f 91       	pop	r23
     fd2:	6f 91       	pop	r22
     fd4:	5f 91       	pop	r21
     fd6:	4f 91       	pop	r20
     fd8:	3f 91       	pop	r19
     fda:	2f 91       	pop	r18
     fdc:	0f 90       	pop	r0
     fde:	0f be       	out	0x3f, r0	; 63
     fe0:	0f 90       	pop	r0
     fe2:	1f 90       	pop	r1
     fe4:	18 95       	reti

00000fe6 <USART_send>:
	}
}

void USART_send( unsigned char data){
	
	while(!(UCSR0A & (1<<UDRE0)));
     fe6:	e0 ec       	ldi	r30, 0xC0	; 192
     fe8:	f0 e0       	ldi	r31, 0x00	; 0
     fea:	90 81       	ld	r25, Z
     fec:	95 ff       	sbrs	r25, 5
     fee:	fd cf       	rjmp	.-6      	; 0xfea <USART_send+0x4>
	UDR0 = data;
     ff0:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     ff4:	08 95       	ret

00000ff6 <USART_sendstr>:
	UCSR0B = (1<<RXEN0)|(1<<TXEN0)|(1<<UCSZ02);
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));
}


void USART_sendstr( unsigned char* str){
     ff6:	cf 93       	push	r28
     ff8:	df 93       	push	r29
     ffa:	ec 01       	movw	r28, r24
	int i =0;
	
	while (str[i] != 0x00)
     ffc:	88 81       	ld	r24, Y
     ffe:	88 23       	and	r24, r24
    1000:	31 f0       	breq	.+12     	; 0x100e <USART_sendstr+0x18>
    1002:	21 96       	adiw	r28, 0x01	; 1
	{
		USART_send(str[i]);
    1004:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <USART_send>


void USART_sendstr( unsigned char* str){
	int i =0;
	
	while (str[i] != 0x00)
    1008:	89 91       	ld	r24, Y+
    100a:	81 11       	cpse	r24, r1
    100c:	fb cf       	rjmp	.-10     	; 0x1004 <USART_sendstr+0xe>
	{
		USART_send(str[i]);
		i++;
	}
}
    100e:	df 91       	pop	r29
    1010:	cf 91       	pop	r28
    1012:	08 95       	ret

00001014 <memset>:
    1014:	dc 01       	movw	r26, r24
    1016:	01 c0       	rjmp	.+2      	; 0x101a <memset+0x6>
    1018:	6d 93       	st	X+, r22
    101a:	41 50       	subi	r20, 0x01	; 1
    101c:	50 40       	sbci	r21, 0x00	; 0
    101e:	e0 f7       	brcc	.-8      	; 0x1018 <memset+0x4>
    1020:	08 95       	ret

00001022 <_exit>:
    1022:	f8 94       	cli

00001024 <__stop_program>:
    1024:	ff cf       	rjmp	.-2      	; 0x1024 <__stop_program>


ArduinoUnoFreertos_6_1(2).elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000e2  00800100  000017e4  00001878  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000017e4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000064c  008001e2  008001e2  0000195a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000195a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000198c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000398  00000000  00000000  000019cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000046cb  00000000  00000000  00001d64  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001229  00000000  00000000  0000642f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000027f3  00000000  00000000  00007658  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b20  00000000  00000000  00009e4c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001621  00000000  00000000  0000a96c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000442b  00000000  00000000  0000bf8d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003a8  00000000  00000000  000103b8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 6a 0b 	jmp	0x16d4	; 0x16d4 <__vector_1>
       8:	0c 94 97 0b 	jmp	0x172e	; 0x172e <__vector_2>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 02 03 	jmp	0x604	; 0x604 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e4 ee       	ldi	r30, 0xE4	; 228
      7c:	f7 e1       	ldi	r31, 0x17	; 23
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a2 3e       	cpi	r26, 0xE2	; 226
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	28 e0       	ldi	r18, 0x08	; 8
      8c:	a2 ee       	ldi	r26, 0xE2	; 226
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	ae 32       	cpi	r26, 0x2E	; 46
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 ed 00 	call	0x1da	; 0x1da <main>
      9e:	0c 94 f0 0b 	jmp	0x17e0	; 0x17e0 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vReceiverTask>:
  }
}


static void vReceiverTask( void *pvParameters )
{
      a6:	cf 93       	push	r28
      a8:	df 93       	push	r29
      aa:	00 d0       	rcall	.+0      	; 0xac <vReceiverTask+0x6>
      ac:	00 d0       	rcall	.+0      	; 0xae <vReceiverTask+0x8>
      ae:	cd b7       	in	r28, 0x3d	; 61
      b0:	de b7       	in	r29, 0x3e	; 62
/* Declare the variable that will hold the values received from the queue. */
    char * lReceivedValue;
    BaseType_t xStatus;
    const TickType_t xTicksToWait = pdMS_TO_TICKS( 99UL );
   	TickType_t xLastWakeTime = xTaskGetTickCount();
      b2:	0e 94 9d 07 	call	0xf3a	; 0xf3a <xTaskGetTickCount>
      b6:	9c 83       	std	Y+4, r25	; 0x04
      b8:	8b 83       	std	Y+3, r24	; 0x03
	for( ;; )
	{
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
      ba:	80 91 2c 08 	lds	r24, 0x082C	; 0x80082c <xQueue>
      be:	90 91 2d 08 	lds	r25, 0x082D	; 0x80082d <xQueue+0x1>
      c2:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <uxQueueMessagesWaiting>
      c6:	88 23       	and	r24, r24
      c8:	21 f0       	breq	.+8      	; 0xd2 <vReceiverTask+0x2c>
			USART_sendstr("Queue should have been empty!\r\n");
      ca:	8e e0       	ldi	r24, 0x0E	; 14
      cc:	91 e0       	ldi	r25, 0x01	; 1
      ce:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <USART_sendstr>
			
		xStatus = xQueueReceive( xQueue, &lReceivedValue, xTicksToWait );
      d2:	20 e0       	ldi	r18, 0x00	; 0
      d4:	41 e2       	ldi	r20, 0x21	; 33
      d6:	50 e0       	ldi	r21, 0x00	; 0
      d8:	be 01       	movw	r22, r28
      da:	6f 5f       	subi	r22, 0xFF	; 255
      dc:	7f 4f       	sbci	r23, 0xFF	; 255
      de:	80 91 2c 08 	lds	r24, 0x082C	; 0x80082c <xQueue>
      e2:	90 91 2d 08 	lds	r25, 0x082D	; 0x80082d <xQueue+0x1>
      e6:	0e 94 39 05 	call	0xa72	; 0xa72 <xQueueGenericReceive>
		if( xStatus == pdPASS )
      ea:	81 30       	cpi	r24, 0x01	; 1
      ec:	69 f4       	brne	.+26     	; 0x108 <vReceiverTask+0x62>
		{
			USART_sendstr("Received= system runs ");
      ee:	8e e2       	ldi	r24, 0x2E	; 46
      f0:	91 e0       	ldi	r25, 0x01	; 1
      f2:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <USART_sendstr>
			USART_sendstr(lReceivedValue);
      f6:	89 81       	ldd	r24, Y+1	; 0x01
      f8:	9a 81       	ldd	r25, Y+2	; 0x02
      fa:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <USART_sendstr>
			USART_sendstr( "\r\n");
      fe:	8b e2       	ldi	r24, 0x2B	; 43
     100:	91 e0       	ldi	r25, 0x01	; 1
     102:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <USART_sendstr>
     106:	04 c0       	rjmp	.+8      	; 0x110 <vReceiverTask+0x6a>
		}
		else
			USART_sendstr("Could not receive from the queue.\r\n" );
     108:	85 e4       	ldi	r24, 0x45	; 69
     10a:	91 e0       	ldi	r25, 0x01	; 1
     10c:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <USART_sendstr>
		
		vTaskDelayUntil(&xLastWakeTime, (1000 / portTICK_PERIOD_MS));
     110:	68 ee       	ldi	r22, 0xE8	; 232
     112:	73 e0       	ldi	r23, 0x03	; 3
     114:	ce 01       	movw	r24, r28
     116:	03 96       	adiw	r24, 0x03	; 3
     118:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <vTaskDelayUntil>
	}
     11c:	ce cf       	rjmp	.-100    	; 0xba <vReceiverTask+0x14>

0000011e <vGetNextTrack>:
	
}


static void vGetNextTrack()
{
     11e:	cf 93       	push	r28
     120:	df 93       	push	r29
     122:	00 d0       	rcall	.+0      	; 0x124 <vGetNextTrack+0x6>
     124:	cd b7       	in	r28, 0x3d	; 61
     126:	de b7       	in	r29, 0x3e	; 62
  char *lValueToSend = NULL;
     128:	1a 82       	std	Y+2, r1	; 0x02
     12a:	19 82       	std	Y+1, r1	; 0x01
  
  if(xTaskGetTickCountFromISR() - lastInterrupt > 500) // we set a 10ms no-interrupts window
     12c:	0e 94 a7 07 	call	0xf4e	; 0xf4e <xTaskGetTickCountFromISR>
     130:	40 91 28 08 	lds	r20, 0x0828	; 0x800828 <lastInterrupt>
     134:	50 91 29 08 	lds	r21, 0x0829	; 0x800829 <lastInterrupt+0x1>
     138:	60 91 2a 08 	lds	r22, 0x082A	; 0x80082a <lastInterrupt+0x2>
     13c:	70 91 2b 08 	lds	r23, 0x082B	; 0x80082b <lastInterrupt+0x3>
     140:	a0 e0       	ldi	r26, 0x00	; 0
     142:	b0 e0       	ldi	r27, 0x00	; 0
     144:	84 1b       	sub	r24, r20
     146:	95 0b       	sbc	r25, r21
     148:	a6 0b       	sbc	r26, r22
     14a:	b7 0b       	sbc	r27, r23
     14c:	85 3f       	cpi	r24, 0xF5	; 245
     14e:	91 40       	sbci	r25, 0x01	; 1
     150:	a1 05       	cpc	r26, r1
     152:	b1 05       	cpc	r27, r1
     154:	e8 f1       	brcs	.+122    	; 0x1d0 <vGetNextTrack+0xb2>
  {
    lValueToSend = *(playList + playListIndex);
     156:	e0 91 e2 01 	lds	r30, 0x01E2	; 0x8001e2 <__data_end>
     15a:	f0 91 e3 01 	lds	r31, 0x01E3	; 0x8001e3 <__data_end+0x1>
     15e:	ee 0f       	add	r30, r30
     160:	ff 1f       	adc	r31, r31
     162:	e0 50       	subi	r30, 0x00	; 0
     164:	ff 4f       	sbci	r31, 0xFF	; 255
     166:	80 81       	ld	r24, Z
     168:	91 81       	ldd	r25, Z+1	; 0x01
     16a:	9a 83       	std	Y+2, r25	; 0x02
     16c:	89 83       	std	Y+1, r24	; 0x01
  
    BaseType_t xStatus = xQueueSendToBackFromISR(xQueue, &lValueToSend, 0 );
     16e:	20 e0       	ldi	r18, 0x00	; 0
     170:	40 e0       	ldi	r20, 0x00	; 0
     172:	50 e0       	ldi	r21, 0x00	; 0
     174:	be 01       	movw	r22, r28
     176:	6f 5f       	subi	r22, 0xFF	; 255
     178:	7f 4f       	sbci	r23, 0xFF	; 255
     17a:	80 91 2c 08 	lds	r24, 0x082C	; 0x80082c <xQueue>
     17e:	90 91 2d 08 	lds	r25, 0x082D	; 0x80082d <xQueue+0x1>
     182:	0e 94 01 05 	call	0xa02	; 0xa02 <xQueueGenericSendFromISR>
    if( xStatus != pdPASS )
     186:	81 30       	cpi	r24, 0x01	; 1
     188:	21 f0       	breq	.+8      	; 0x192 <vGetNextTrack+0x74>
      USART_sendstr("Could not send to the queue.");
     18a:	89 e6       	ldi	r24, 0x69	; 105
     18c:	91 e0       	ldi	r25, 0x01	; 1
     18e:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <USART_sendstr>
	 		
    lastInterrupt = xTaskGetTickCountFromISR();
     192:	0e 94 a7 07 	call	0xf4e	; 0xf4e <xTaskGetTickCountFromISR>
     196:	a0 e0       	ldi	r26, 0x00	; 0
     198:	b0 e0       	ldi	r27, 0x00	; 0
     19a:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <lastInterrupt>
     19e:	90 93 29 08 	sts	0x0829, r25	; 0x800829 <lastInterrupt+0x1>
     1a2:	a0 93 2a 08 	sts	0x082A, r26	; 0x80082a <lastInterrupt+0x2>
     1a6:	b0 93 2b 08 	sts	0x082B, r27	; 0x80082b <lastInterrupt+0x3>
    playListIndex++;
     1aa:	80 91 e2 01 	lds	r24, 0x01E2	; 0x8001e2 <__data_end>
     1ae:	90 91 e3 01 	lds	r25, 0x01E3	; 0x8001e3 <__data_end+0x1>
     1b2:	01 96       	adiw	r24, 0x01	; 1
     1b4:	90 93 e3 01 	sts	0x01E3, r25	; 0x8001e3 <__data_end+0x1>
     1b8:	80 93 e2 01 	sts	0x01E2, r24	; 0x8001e2 <__data_end>
	if(playListIndex >= TrackSize)
     1bc:	80 91 e2 01 	lds	r24, 0x01E2	; 0x8001e2 <__data_end>
     1c0:	90 91 e3 01 	lds	r25, 0x01E3	; 0x8001e3 <__data_end+0x1>
     1c4:	05 97       	sbiw	r24, 0x05	; 5
     1c6:	24 f0       	brlt	.+8      	; 0x1d0 <vGetNextTrack+0xb2>
	  playListIndex = 0;
     1c8:	10 92 e3 01 	sts	0x01E3, r1	; 0x8001e3 <__data_end+0x1>
     1cc:	10 92 e2 01 	sts	0x01E2, r1	; 0x8001e2 <__data_end>
  }
}
     1d0:	0f 90       	pop	r0
     1d2:	0f 90       	pop	r0
     1d4:	df 91       	pop	r29
     1d6:	cf 91       	pop	r28
     1d8:	08 95       	ret

000001da <main>:

//-----------------------------------------------------------

int main(void)
{ 
  cli();
     1da:	f8 94       	cli
  attachInterrupt(0, vGetNextTrack, 1); 
     1dc:	41 e0       	ldi	r20, 0x01	; 1
     1de:	50 e0       	ldi	r21, 0x00	; 0
     1e0:	6f e8       	ldi	r22, 0x8F	; 143
     1e2:	70 e0       	ldi	r23, 0x00	; 0
     1e4:	80 e0       	ldi	r24, 0x00	; 0
     1e6:	90 e0       	ldi	r25, 0x00	; 0
     1e8:	0e 94 47 0b 	call	0x168e	; 0x168e <attachInterrupt>
  USART_init();
     1ec:	0e 94 c4 0b 	call	0x1788	; 0x1788 <USART_init>
    /* The queue is created to hold a maximum of 5 long values. */
    xQueue = xQueueCreate( 5, sizeof(char *));
     1f0:	40 e0       	ldi	r20, 0x00	; 0
     1f2:	62 e0       	ldi	r22, 0x02	; 2
     1f4:	85 e0       	ldi	r24, 0x05	; 5
     1f6:	0e 94 d5 04 	call	0x9aa	; 0x9aa <xQueueGenericCreate>
     1fa:	90 93 2d 08 	sts	0x082D, r25	; 0x80082d <xQueue+0x1>
     1fe:	80 93 2c 08 	sts	0x082C, r24	; 0x80082c <xQueue>
	if( xQueue != NULL )
     202:	89 2b       	or	r24, r25
     204:	a9 f0       	breq	.+42     	; 0x230 <main+0x56>
	{
	//	xTaskCreate( vSenderTask, "Sender", 256, "system runs ", 1, NULL );
		xTaskCreate( vReceiverTask, "Receiver", 256, NULL, 2, NULL );
     206:	a1 2c       	mov	r10, r1
     208:	b1 2c       	mov	r11, r1
     20a:	c1 2c       	mov	r12, r1
     20c:	d1 2c       	mov	r13, r1
     20e:	e1 2c       	mov	r14, r1
     210:	f1 2c       	mov	r15, r1
     212:	02 e0       	ldi	r16, 0x02	; 2
     214:	20 e0       	ldi	r18, 0x00	; 0
     216:	30 e0       	ldi	r19, 0x00	; 0
     218:	40 e0       	ldi	r20, 0x00	; 0
     21a:	51 e0       	ldi	r21, 0x01	; 1
     21c:	66 e8       	ldi	r22, 0x86	; 134
     21e:	71 e0       	ldi	r23, 0x01	; 1
     220:	83 e5       	ldi	r24, 0x53	; 83
     222:	90 e0       	ldi	r25, 0x00	; 0
     224:	0e 94 5a 06 	call	0xcb4	; 0xcb4 <xTaskGenericCreate>

		/* Start the scheduler so the created tasks start executing. */
		sei();
     228:	78 94       	sei
		vTaskStartScheduler();
     22a:	0e 94 68 07 	call	0xed0	; 0xed0 <vTaskStartScheduler>
     22e:	04 c0       	rjmp	.+8      	; 0x238 <main+0x5e>
	}
	else
		USART_sendstr("The queue could not be created");
     230:	8f e8       	ldi	r24, 0x8F	; 143
     232:	91 e0       	ldi	r25, 0x01	; 1
     234:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <USART_sendstr>
     238:	ff cf       	rjmp	.-2      	; 0x238 <main+0x5e>

0000023a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     23a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     23c:	03 96       	adiw	r24, 0x03	; 3
     23e:	92 83       	std	Z+2, r25	; 0x02
     240:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     242:	2f ef       	ldi	r18, 0xFF	; 255
     244:	3f ef       	ldi	r19, 0xFF	; 255
     246:	34 83       	std	Z+4, r19	; 0x04
     248:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     24a:	96 83       	std	Z+6, r25	; 0x06
     24c:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     24e:	90 87       	std	Z+8, r25	; 0x08
     250:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     252:	10 82       	st	Z, r1
     254:	08 95       	ret

00000256 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     256:	fc 01       	movw	r30, r24
     258:	11 86       	std	Z+9, r1	; 0x09
     25a:	10 86       	std	Z+8, r1	; 0x08
     25c:	08 95       	ret

0000025e <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     25e:	cf 93       	push	r28
     260:	df 93       	push	r29
     262:	9c 01       	movw	r18, r24
     264:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     266:	dc 01       	movw	r26, r24
     268:	11 96       	adiw	r26, 0x01	; 1
     26a:	cd 91       	ld	r28, X+
     26c:	dc 91       	ld	r29, X
     26e:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     270:	d3 83       	std	Z+3, r29	; 0x03
     272:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     274:	8c 81       	ldd	r24, Y+4	; 0x04
     276:	9d 81       	ldd	r25, Y+5	; 0x05
     278:	95 83       	std	Z+5, r25	; 0x05
     27a:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     27c:	8c 81       	ldd	r24, Y+4	; 0x04
     27e:	9d 81       	ldd	r25, Y+5	; 0x05
     280:	dc 01       	movw	r26, r24
     282:	13 96       	adiw	r26, 0x03	; 3
     284:	7c 93       	st	X, r23
     286:	6e 93       	st	-X, r22
     288:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     28a:	7d 83       	std	Y+5, r23	; 0x05
     28c:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     28e:	31 87       	std	Z+9, r19	; 0x09
     290:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     292:	f9 01       	movw	r30, r18
     294:	80 81       	ld	r24, Z
     296:	8f 5f       	subi	r24, 0xFF	; 255
     298:	80 83       	st	Z, r24
}
     29a:	df 91       	pop	r29
     29c:	cf 91       	pop	r28
     29e:	08 95       	ret

000002a0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     2a0:	cf 93       	push	r28
     2a2:	df 93       	push	r29
     2a4:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     2a6:	48 81       	ld	r20, Y
     2a8:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     2aa:	4f 3f       	cpi	r20, 0xFF	; 255
     2ac:	2f ef       	ldi	r18, 0xFF	; 255
     2ae:	52 07       	cpc	r21, r18
     2b0:	21 f4       	brne	.+8      	; 0x2ba <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     2b2:	fc 01       	movw	r30, r24
     2b4:	a7 81       	ldd	r26, Z+7	; 0x07
     2b6:	b0 85       	ldd	r27, Z+8	; 0x08
     2b8:	0d c0       	rjmp	.+26     	; 0x2d4 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2ba:	dc 01       	movw	r26, r24
     2bc:	13 96       	adiw	r26, 0x03	; 3
     2be:	01 c0       	rjmp	.+2      	; 0x2c2 <vListInsert+0x22>
     2c0:	df 01       	movw	r26, r30
     2c2:	12 96       	adiw	r26, 0x02	; 2
     2c4:	ed 91       	ld	r30, X+
     2c6:	fc 91       	ld	r31, X
     2c8:	13 97       	sbiw	r26, 0x03	; 3
     2ca:	20 81       	ld	r18, Z
     2cc:	31 81       	ldd	r19, Z+1	; 0x01
     2ce:	42 17       	cp	r20, r18
     2d0:	53 07       	cpc	r21, r19
     2d2:	b0 f7       	brcc	.-20     	; 0x2c0 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     2d4:	12 96       	adiw	r26, 0x02	; 2
     2d6:	ed 91       	ld	r30, X+
     2d8:	fc 91       	ld	r31, X
     2da:	13 97       	sbiw	r26, 0x03	; 3
     2dc:	fb 83       	std	Y+3, r31	; 0x03
     2de:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     2e0:	d5 83       	std	Z+5, r29	; 0x05
     2e2:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     2e4:	bd 83       	std	Y+5, r27	; 0x05
     2e6:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     2e8:	13 96       	adiw	r26, 0x03	; 3
     2ea:	dc 93       	st	X, r29
     2ec:	ce 93       	st	-X, r28
     2ee:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2f0:	99 87       	std	Y+9, r25	; 0x09
     2f2:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     2f4:	fc 01       	movw	r30, r24
     2f6:	20 81       	ld	r18, Z
     2f8:	2f 5f       	subi	r18, 0xFF	; 255
     2fa:	20 83       	st	Z, r18
}
     2fc:	df 91       	pop	r29
     2fe:	cf 91       	pop	r28
     300:	08 95       	ret

00000302 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     302:	cf 93       	push	r28
     304:	df 93       	push	r29
     306:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     308:	a0 85       	ldd	r26, Z+8	; 0x08
     30a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     30c:	c2 81       	ldd	r28, Z+2	; 0x02
     30e:	d3 81       	ldd	r29, Z+3	; 0x03
     310:	84 81       	ldd	r24, Z+4	; 0x04
     312:	95 81       	ldd	r25, Z+5	; 0x05
     314:	9d 83       	std	Y+5, r25	; 0x05
     316:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     318:	c4 81       	ldd	r28, Z+4	; 0x04
     31a:	d5 81       	ldd	r29, Z+5	; 0x05
     31c:	82 81       	ldd	r24, Z+2	; 0x02
     31e:	93 81       	ldd	r25, Z+3	; 0x03
     320:	9b 83       	std	Y+3, r25	; 0x03
     322:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     324:	11 96       	adiw	r26, 0x01	; 1
     326:	8d 91       	ld	r24, X+
     328:	9c 91       	ld	r25, X
     32a:	12 97       	sbiw	r26, 0x02	; 2
     32c:	e8 17       	cp	r30, r24
     32e:	f9 07       	cpc	r31, r25
     330:	31 f4       	brne	.+12     	; 0x33e <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     332:	84 81       	ldd	r24, Z+4	; 0x04
     334:	95 81       	ldd	r25, Z+5	; 0x05
     336:	12 96       	adiw	r26, 0x02	; 2
     338:	9c 93       	st	X, r25
     33a:	8e 93       	st	-X, r24
     33c:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     33e:	11 86       	std	Z+9, r1	; 0x09
     340:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     342:	8c 91       	ld	r24, X
     344:	81 50       	subi	r24, 0x01	; 1
     346:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     348:	df 91       	pop	r29
     34a:	cf 91       	pop	r28
     34c:	08 95       	ret

0000034e <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     34e:	31 e1       	ldi	r19, 0x11	; 17
     350:	fc 01       	movw	r30, r24
     352:	30 83       	st	Z, r19
     354:	31 97       	sbiw	r30, 0x01	; 1
     356:	22 e2       	ldi	r18, 0x22	; 34
     358:	20 83       	st	Z, r18
     35a:	31 97       	sbiw	r30, 0x01	; 1
     35c:	a3 e3       	ldi	r26, 0x33	; 51
     35e:	a0 83       	st	Z, r26
     360:	31 97       	sbiw	r30, 0x01	; 1
     362:	60 83       	st	Z, r22
     364:	31 97       	sbiw	r30, 0x01	; 1
     366:	70 83       	st	Z, r23
     368:	31 97       	sbiw	r30, 0x01	; 1
     36a:	10 82       	st	Z, r1
     36c:	31 97       	sbiw	r30, 0x01	; 1
     36e:	60 e8       	ldi	r22, 0x80	; 128
     370:	60 83       	st	Z, r22
     372:	31 97       	sbiw	r30, 0x01	; 1
     374:	10 82       	st	Z, r1
     376:	31 97       	sbiw	r30, 0x01	; 1
     378:	62 e0       	ldi	r22, 0x02	; 2
     37a:	60 83       	st	Z, r22
     37c:	31 97       	sbiw	r30, 0x01	; 1
     37e:	63 e0       	ldi	r22, 0x03	; 3
     380:	60 83       	st	Z, r22
     382:	31 97       	sbiw	r30, 0x01	; 1
     384:	64 e0       	ldi	r22, 0x04	; 4
     386:	60 83       	st	Z, r22
     388:	31 97       	sbiw	r30, 0x01	; 1
     38a:	65 e0       	ldi	r22, 0x05	; 5
     38c:	60 83       	st	Z, r22
     38e:	31 97       	sbiw	r30, 0x01	; 1
     390:	66 e0       	ldi	r22, 0x06	; 6
     392:	60 83       	st	Z, r22
     394:	31 97       	sbiw	r30, 0x01	; 1
     396:	67 e0       	ldi	r22, 0x07	; 7
     398:	60 83       	st	Z, r22
     39a:	31 97       	sbiw	r30, 0x01	; 1
     39c:	68 e0       	ldi	r22, 0x08	; 8
     39e:	60 83       	st	Z, r22
     3a0:	31 97       	sbiw	r30, 0x01	; 1
     3a2:	69 e0       	ldi	r22, 0x09	; 9
     3a4:	60 83       	st	Z, r22
     3a6:	31 97       	sbiw	r30, 0x01	; 1
     3a8:	60 e1       	ldi	r22, 0x10	; 16
     3aa:	60 83       	st	Z, r22
     3ac:	31 97       	sbiw	r30, 0x01	; 1
     3ae:	30 83       	st	Z, r19
     3b0:	31 97       	sbiw	r30, 0x01	; 1
     3b2:	32 e1       	ldi	r19, 0x12	; 18
     3b4:	30 83       	st	Z, r19
     3b6:	31 97       	sbiw	r30, 0x01	; 1
     3b8:	33 e1       	ldi	r19, 0x13	; 19
     3ba:	30 83       	st	Z, r19
     3bc:	31 97       	sbiw	r30, 0x01	; 1
     3be:	34 e1       	ldi	r19, 0x14	; 20
     3c0:	30 83       	st	Z, r19
     3c2:	31 97       	sbiw	r30, 0x01	; 1
     3c4:	35 e1       	ldi	r19, 0x15	; 21
     3c6:	30 83       	st	Z, r19
     3c8:	31 97       	sbiw	r30, 0x01	; 1
     3ca:	36 e1       	ldi	r19, 0x16	; 22
     3cc:	30 83       	st	Z, r19
     3ce:	31 97       	sbiw	r30, 0x01	; 1
     3d0:	37 e1       	ldi	r19, 0x17	; 23
     3d2:	30 83       	st	Z, r19
     3d4:	31 97       	sbiw	r30, 0x01	; 1
     3d6:	38 e1       	ldi	r19, 0x18	; 24
     3d8:	30 83       	st	Z, r19
     3da:	31 97       	sbiw	r30, 0x01	; 1
     3dc:	39 e1       	ldi	r19, 0x19	; 25
     3de:	30 83       	st	Z, r19
     3e0:	31 97       	sbiw	r30, 0x01	; 1
     3e2:	30 e2       	ldi	r19, 0x20	; 32
     3e4:	30 83       	st	Z, r19
     3e6:	31 97       	sbiw	r30, 0x01	; 1
     3e8:	31 e2       	ldi	r19, 0x21	; 33
     3ea:	30 83       	st	Z, r19
     3ec:	31 97       	sbiw	r30, 0x01	; 1
     3ee:	20 83       	st	Z, r18
     3f0:	31 97       	sbiw	r30, 0x01	; 1
     3f2:	23 e2       	ldi	r18, 0x23	; 35
     3f4:	20 83       	st	Z, r18
     3f6:	31 97       	sbiw	r30, 0x01	; 1
     3f8:	40 83       	st	Z, r20
     3fa:	31 97       	sbiw	r30, 0x01	; 1
     3fc:	50 83       	st	Z, r21
     3fe:	31 97       	sbiw	r30, 0x01	; 1
     400:	26 e2       	ldi	r18, 0x26	; 38
     402:	20 83       	st	Z, r18
     404:	31 97       	sbiw	r30, 0x01	; 1
     406:	27 e2       	ldi	r18, 0x27	; 39
     408:	20 83       	st	Z, r18
     40a:	31 97       	sbiw	r30, 0x01	; 1
     40c:	28 e2       	ldi	r18, 0x28	; 40
     40e:	20 83       	st	Z, r18
     410:	31 97       	sbiw	r30, 0x01	; 1
     412:	29 e2       	ldi	r18, 0x29	; 41
     414:	20 83       	st	Z, r18
     416:	31 97       	sbiw	r30, 0x01	; 1
     418:	20 e3       	ldi	r18, 0x30	; 48
     41a:	20 83       	st	Z, r18
     41c:	31 97       	sbiw	r30, 0x01	; 1
     41e:	21 e3       	ldi	r18, 0x31	; 49
     420:	20 83       	st	Z, r18
     422:	86 97       	sbiw	r24, 0x26	; 38
     424:	08 95       	ret

00000426 <xPortStartScheduler>:
     426:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7f8089>
     42a:	8c e7       	ldi	r24, 0x7C	; 124
     42c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7f8088>
     430:	8b e0       	ldi	r24, 0x0B	; 11
     432:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7f8081>
     436:	ef e6       	ldi	r30, 0x6F	; 111
     438:	f0 e0       	ldi	r31, 0x00	; 0
     43a:	80 81       	ld	r24, Z
     43c:	82 60       	ori	r24, 0x02	; 2
     43e:	80 83       	st	Z, r24
     440:	a0 91 22 08 	lds	r26, 0x0822	; 0x800822 <pxCurrentTCB>
     444:	b0 91 23 08 	lds	r27, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
     448:	cd 91       	ld	r28, X+
     44a:	cd bf       	out	0x3d, r28	; 61
     44c:	dd 91       	ld	r29, X+
     44e:	de bf       	out	0x3e, r29	; 62
     450:	ff 91       	pop	r31
     452:	ef 91       	pop	r30
     454:	df 91       	pop	r29
     456:	cf 91       	pop	r28
     458:	bf 91       	pop	r27
     45a:	af 91       	pop	r26
     45c:	9f 91       	pop	r25
     45e:	8f 91       	pop	r24
     460:	7f 91       	pop	r23
     462:	6f 91       	pop	r22
     464:	5f 91       	pop	r21
     466:	4f 91       	pop	r20
     468:	3f 91       	pop	r19
     46a:	2f 91       	pop	r18
     46c:	1f 91       	pop	r17
     46e:	0f 91       	pop	r16
     470:	ff 90       	pop	r15
     472:	ef 90       	pop	r14
     474:	df 90       	pop	r13
     476:	cf 90       	pop	r12
     478:	bf 90       	pop	r11
     47a:	af 90       	pop	r10
     47c:	9f 90       	pop	r9
     47e:	8f 90       	pop	r8
     480:	7f 90       	pop	r7
     482:	6f 90       	pop	r6
     484:	5f 90       	pop	r5
     486:	4f 90       	pop	r4
     488:	3f 90       	pop	r3
     48a:	2f 90       	pop	r2
     48c:	1f 90       	pop	r1
     48e:	0f 90       	pop	r0
     490:	0f be       	out	0x3f, r0	; 63
     492:	0f 90       	pop	r0
     494:	08 95       	ret
     496:	81 e0       	ldi	r24, 0x01	; 1
     498:	08 95       	ret

0000049a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     49a:	0f 92       	push	r0
     49c:	0f b6       	in	r0, 0x3f	; 63
     49e:	f8 94       	cli
     4a0:	0f 92       	push	r0
     4a2:	1f 92       	push	r1
     4a4:	11 24       	eor	r1, r1
     4a6:	2f 92       	push	r2
     4a8:	3f 92       	push	r3
     4aa:	4f 92       	push	r4
     4ac:	5f 92       	push	r5
     4ae:	6f 92       	push	r6
     4b0:	7f 92       	push	r7
     4b2:	8f 92       	push	r8
     4b4:	9f 92       	push	r9
     4b6:	af 92       	push	r10
     4b8:	bf 92       	push	r11
     4ba:	cf 92       	push	r12
     4bc:	df 92       	push	r13
     4be:	ef 92       	push	r14
     4c0:	ff 92       	push	r15
     4c2:	0f 93       	push	r16
     4c4:	1f 93       	push	r17
     4c6:	2f 93       	push	r18
     4c8:	3f 93       	push	r19
     4ca:	4f 93       	push	r20
     4cc:	5f 93       	push	r21
     4ce:	6f 93       	push	r22
     4d0:	7f 93       	push	r23
     4d2:	8f 93       	push	r24
     4d4:	9f 93       	push	r25
     4d6:	af 93       	push	r26
     4d8:	bf 93       	push	r27
     4da:	cf 93       	push	r28
     4dc:	df 93       	push	r29
     4de:	ef 93       	push	r30
     4e0:	ff 93       	push	r31
     4e2:	a0 91 22 08 	lds	r26, 0x0822	; 0x800822 <pxCurrentTCB>
     4e6:	b0 91 23 08 	lds	r27, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
     4ea:	0d b6       	in	r0, 0x3d	; 61
     4ec:	0d 92       	st	X+, r0
     4ee:	0e b6       	in	r0, 0x3e	; 62
     4f0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     4f2:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     4f6:	a0 91 22 08 	lds	r26, 0x0822	; 0x800822 <pxCurrentTCB>
     4fa:	b0 91 23 08 	lds	r27, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
     4fe:	cd 91       	ld	r28, X+
     500:	cd bf       	out	0x3d, r28	; 61
     502:	dd 91       	ld	r29, X+
     504:	de bf       	out	0x3e, r29	; 62
     506:	ff 91       	pop	r31
     508:	ef 91       	pop	r30
     50a:	df 91       	pop	r29
     50c:	cf 91       	pop	r28
     50e:	bf 91       	pop	r27
     510:	af 91       	pop	r26
     512:	9f 91       	pop	r25
     514:	8f 91       	pop	r24
     516:	7f 91       	pop	r23
     518:	6f 91       	pop	r22
     51a:	5f 91       	pop	r21
     51c:	4f 91       	pop	r20
     51e:	3f 91       	pop	r19
     520:	2f 91       	pop	r18
     522:	1f 91       	pop	r17
     524:	0f 91       	pop	r16
     526:	ff 90       	pop	r15
     528:	ef 90       	pop	r14
     52a:	df 90       	pop	r13
     52c:	cf 90       	pop	r12
     52e:	bf 90       	pop	r11
     530:	af 90       	pop	r10
     532:	9f 90       	pop	r9
     534:	8f 90       	pop	r8
     536:	7f 90       	pop	r7
     538:	6f 90       	pop	r6
     53a:	5f 90       	pop	r5
     53c:	4f 90       	pop	r4
     53e:	3f 90       	pop	r3
     540:	2f 90       	pop	r2
     542:	1f 90       	pop	r1
     544:	0f 90       	pop	r0
     546:	0f be       	out	0x3f, r0	; 63
     548:	0f 90       	pop	r0

	asm volatile ( "ret" );
     54a:	08 95       	ret

0000054c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     54c:	0f 92       	push	r0
     54e:	0f b6       	in	r0, 0x3f	; 63
     550:	f8 94       	cli
     552:	0f 92       	push	r0
     554:	1f 92       	push	r1
     556:	11 24       	eor	r1, r1
     558:	2f 92       	push	r2
     55a:	3f 92       	push	r3
     55c:	4f 92       	push	r4
     55e:	5f 92       	push	r5
     560:	6f 92       	push	r6
     562:	7f 92       	push	r7
     564:	8f 92       	push	r8
     566:	9f 92       	push	r9
     568:	af 92       	push	r10
     56a:	bf 92       	push	r11
     56c:	cf 92       	push	r12
     56e:	df 92       	push	r13
     570:	ef 92       	push	r14
     572:	ff 92       	push	r15
     574:	0f 93       	push	r16
     576:	1f 93       	push	r17
     578:	2f 93       	push	r18
     57a:	3f 93       	push	r19
     57c:	4f 93       	push	r20
     57e:	5f 93       	push	r21
     580:	6f 93       	push	r22
     582:	7f 93       	push	r23
     584:	8f 93       	push	r24
     586:	9f 93       	push	r25
     588:	af 93       	push	r26
     58a:	bf 93       	push	r27
     58c:	cf 93       	push	r28
     58e:	df 93       	push	r29
     590:	ef 93       	push	r30
     592:	ff 93       	push	r31
     594:	a0 91 22 08 	lds	r26, 0x0822	; 0x800822 <pxCurrentTCB>
     598:	b0 91 23 08 	lds	r27, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
     59c:	0d b6       	in	r0, 0x3d	; 61
     59e:	0d 92       	st	X+, r0
     5a0:	0e b6       	in	r0, 0x3e	; 62
     5a2:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     5a4:	0e 94 ac 07 	call	0xf58	; 0xf58 <xTaskIncrementTick>
     5a8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     5aa:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     5ae:	a0 91 22 08 	lds	r26, 0x0822	; 0x800822 <pxCurrentTCB>
     5b2:	b0 91 23 08 	lds	r27, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
     5b6:	cd 91       	ld	r28, X+
     5b8:	cd bf       	out	0x3d, r28	; 61
     5ba:	dd 91       	ld	r29, X+
     5bc:	de bf       	out	0x3e, r29	; 62
     5be:	ff 91       	pop	r31
     5c0:	ef 91       	pop	r30
     5c2:	df 91       	pop	r29
     5c4:	cf 91       	pop	r28
     5c6:	bf 91       	pop	r27
     5c8:	af 91       	pop	r26
     5ca:	9f 91       	pop	r25
     5cc:	8f 91       	pop	r24
     5ce:	7f 91       	pop	r23
     5d0:	6f 91       	pop	r22
     5d2:	5f 91       	pop	r21
     5d4:	4f 91       	pop	r20
     5d6:	3f 91       	pop	r19
     5d8:	2f 91       	pop	r18
     5da:	1f 91       	pop	r17
     5dc:	0f 91       	pop	r16
     5de:	ff 90       	pop	r15
     5e0:	ef 90       	pop	r14
     5e2:	df 90       	pop	r13
     5e4:	cf 90       	pop	r12
     5e6:	bf 90       	pop	r11
     5e8:	af 90       	pop	r10
     5ea:	9f 90       	pop	r9
     5ec:	8f 90       	pop	r8
     5ee:	7f 90       	pop	r7
     5f0:	6f 90       	pop	r6
     5f2:	5f 90       	pop	r5
     5f4:	4f 90       	pop	r4
     5f6:	3f 90       	pop	r3
     5f8:	2f 90       	pop	r2
     5fa:	1f 90       	pop	r1
     5fc:	0f 90       	pop	r0
     5fe:	0f be       	out	0x3f, r0	; 63
     600:	0f 90       	pop	r0

	asm volatile ( "ret" );
     602:	08 95       	ret

00000604 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect(void) __attribute__ ((signal, naked));
	void TIMER1_COMPA_vect(void)
	{
		vPortYieldFromTick();
     604:	0e 94 a6 02 	call	0x54c	; 0x54c <vPortYieldFromTick>
		asm volatile ( "reti" );
     608:	18 95       	reti

0000060a <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     60a:	0f 93       	push	r16
     60c:	1f 93       	push	r17
     60e:	cf 93       	push	r28
     610:	df 93       	push	r29
     612:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     614:	0e 94 97 07 	call	0xf2e	; 0xf2e <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     618:	80 91 e4 01 	lds	r24, 0x01E4	; 0x8001e4 <xHeapHasBeenInitialised.2023>
     61c:	81 11       	cpse	r24, r1
     61e:	1d c0       	rjmp	.+58     	; 0x65a <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     620:	e9 ee       	ldi	r30, 0xE9	; 233
     622:	f1 e0       	ldi	r31, 0x01	; 1
     624:	8e ee       	ldi	r24, 0xEE	; 238
     626:	91 e0       	ldi	r25, 0x01	; 1
     628:	91 83       	std	Z+1, r25	; 0x01
     62a:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     62c:	13 82       	std	Z+3, r1	; 0x03
     62e:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     630:	e5 ee       	ldi	r30, 0xE5	; 229
     632:	f1 e0       	ldi	r31, 0x01	; 1
     634:	8b ed       	ldi	r24, 0xDB	; 219
     636:	95 e0       	ldi	r25, 0x05	; 5
     638:	93 83       	std	Z+3, r25	; 0x03
     63a:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     63c:	11 82       	std	Z+1, r1	; 0x01
     63e:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     640:	ad ee       	ldi	r26, 0xED	; 237
     642:	b1 e0       	ldi	r27, 0x01	; 1
     644:	14 96       	adiw	r26, 0x04	; 4
     646:	9c 93       	st	X, r25
     648:	8e 93       	st	-X, r24
     64a:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     64c:	12 96       	adiw	r26, 0x02	; 2
     64e:	fc 93       	st	X, r31
     650:	ee 93       	st	-X, r30
     652:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     654:	81 e0       	ldi	r24, 0x01	; 1
     656:	80 93 e4 01 	sts	0x01E4, r24	; 0x8001e4 <xHeapHasBeenInitialised.2023>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     65a:	20 97       	sbiw	r28, 0x00	; 0
     65c:	09 f4       	brne	.+2      	; 0x660 <pvPortMalloc+0x56>
     65e:	5f c0       	rjmp	.+190    	; 0x71e <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
     660:	9e 01       	movw	r18, r28
     662:	2c 5f       	subi	r18, 0xFC	; 252
     664:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     666:	23 96       	adiw	r28, 0x03	; 3
     668:	ca 3d       	cpi	r28, 0xDA	; 218
     66a:	d5 40       	sbci	r29, 0x05	; 5
     66c:	08 f0       	brcs	.+2      	; 0x670 <pvPortMalloc+0x66>
     66e:	5a c0       	rjmp	.+180    	; 0x724 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     670:	e0 91 e9 01 	lds	r30, 0x01E9	; 0x8001e9 <xStart>
     674:	f0 91 ea 01 	lds	r31, 0x01EA	; 0x8001ea <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     678:	a9 ee       	ldi	r26, 0xE9	; 233
     67a:	b1 e0       	ldi	r27, 0x01	; 1
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     67c:	02 c0       	rjmp	.+4      	; 0x682 <pvPortMalloc+0x78>
     67e:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     680:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     682:	82 81       	ldd	r24, Z+2	; 0x02
     684:	93 81       	ldd	r25, Z+3	; 0x03
     686:	82 17       	cp	r24, r18
     688:	93 07       	cpc	r25, r19
     68a:	20 f4       	brcc	.+8      	; 0x694 <pvPortMalloc+0x8a>
     68c:	80 81       	ld	r24, Z
     68e:	91 81       	ldd	r25, Z+1	; 0x01
     690:	00 97       	sbiw	r24, 0x00	; 0
     692:	a9 f7       	brne	.-22     	; 0x67e <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     694:	c1 e0       	ldi	r28, 0x01	; 1
     696:	e5 3e       	cpi	r30, 0xE5	; 229
     698:	fc 07       	cpc	r31, r28
     69a:	09 f4       	brne	.+2      	; 0x69e <pvPortMalloc+0x94>
     69c:	46 c0       	rjmp	.+140    	; 0x72a <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     69e:	cd 91       	ld	r28, X+
     6a0:	dc 91       	ld	r29, X
     6a2:	11 97       	sbiw	r26, 0x01	; 1
     6a4:	8e 01       	movw	r16, r28
     6a6:	0c 5f       	subi	r16, 0xFC	; 252
     6a8:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     6aa:	80 81       	ld	r24, Z
     6ac:	91 81       	ldd	r25, Z+1	; 0x01
     6ae:	8d 93       	st	X+, r24
     6b0:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     6b2:	82 81       	ldd	r24, Z+2	; 0x02
     6b4:	93 81       	ldd	r25, Z+3	; 0x03
     6b6:	82 1b       	sub	r24, r18
     6b8:	93 0b       	sbc	r25, r19
     6ba:	89 30       	cpi	r24, 0x09	; 9
     6bc:	91 05       	cpc	r25, r1
     6be:	10 f1       	brcs	.+68     	; 0x704 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     6c0:	bf 01       	movw	r22, r30
     6c2:	62 0f       	add	r22, r18
     6c4:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     6c6:	db 01       	movw	r26, r22
     6c8:	13 96       	adiw	r26, 0x03	; 3
     6ca:	9c 93       	st	X, r25
     6cc:	8e 93       	st	-X, r24
     6ce:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     6d0:	33 83       	std	Z+3, r19	; 0x03
     6d2:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     6d4:	12 96       	adiw	r26, 0x02	; 2
     6d6:	4d 91       	ld	r20, X+
     6d8:	5c 91       	ld	r21, X
     6da:	13 97       	sbiw	r26, 0x03	; 3
     6dc:	89 ee       	ldi	r24, 0xE9	; 233
     6de:	91 e0       	ldi	r25, 0x01	; 1
     6e0:	01 c0       	rjmp	.+2      	; 0x6e4 <pvPortMalloc+0xda>
     6e2:	cd 01       	movw	r24, r26
     6e4:	ec 01       	movw	r28, r24
     6e6:	a8 81       	ld	r26, Y
     6e8:	b9 81       	ldd	r27, Y+1	; 0x01
     6ea:	12 96       	adiw	r26, 0x02	; 2
     6ec:	2d 91       	ld	r18, X+
     6ee:	3c 91       	ld	r19, X
     6f0:	13 97       	sbiw	r26, 0x03	; 3
     6f2:	24 17       	cp	r18, r20
     6f4:	35 07       	cpc	r19, r21
     6f6:	a8 f3       	brcs	.-22     	; 0x6e2 <pvPortMalloc+0xd8>
     6f8:	eb 01       	movw	r28, r22
     6fa:	b9 83       	std	Y+1, r27	; 0x01
     6fc:	a8 83       	st	Y, r26
     6fe:	dc 01       	movw	r26, r24
     700:	6d 93       	st	X+, r22
     702:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     704:	80 91 0a 01 	lds	r24, 0x010A	; 0x80010a <xFreeBytesRemaining>
     708:	90 91 0b 01 	lds	r25, 0x010B	; 0x80010b <xFreeBytesRemaining+0x1>
     70c:	22 81       	ldd	r18, Z+2	; 0x02
     70e:	33 81       	ldd	r19, Z+3	; 0x03
     710:	82 1b       	sub	r24, r18
     712:	93 0b       	sbc	r25, r19
     714:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <xFreeBytesRemaining+0x1>
     718:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <xFreeBytesRemaining>
     71c:	08 c0       	rjmp	.+16     	; 0x72e <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     71e:	00 e0       	ldi	r16, 0x00	; 0
     720:	10 e0       	ldi	r17, 0x00	; 0
     722:	05 c0       	rjmp	.+10     	; 0x72e <pvPortMalloc+0x124>
     724:	00 e0       	ldi	r16, 0x00	; 0
     726:	10 e0       	ldi	r17, 0x00	; 0
     728:	02 c0       	rjmp	.+4      	; 0x72e <pvPortMalloc+0x124>
     72a:	00 e0       	ldi	r16, 0x00	; 0
     72c:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     72e:	0e 94 69 08 	call	0x10d2	; 0x10d2 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     732:	c8 01       	movw	r24, r16
     734:	df 91       	pop	r29
     736:	cf 91       	pop	r28
     738:	1f 91       	pop	r17
     73a:	0f 91       	pop	r16
     73c:	08 95       	ret

0000073e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     73e:	0f 93       	push	r16
     740:	1f 93       	push	r17
     742:	cf 93       	push	r28
     744:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     746:	00 97       	sbiw	r24, 0x00	; 0
     748:	41 f1       	breq	.+80     	; 0x79a <vPortFree+0x5c>
     74a:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     74c:	8c 01       	movw	r16, r24
     74e:	04 50       	subi	r16, 0x04	; 4
     750:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     752:	0e 94 97 07 	call	0xf2e	; 0xf2e <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     756:	f8 01       	movw	r30, r16
     758:	42 81       	ldd	r20, Z+2	; 0x02
     75a:	53 81       	ldd	r21, Z+3	; 0x03
     75c:	a9 ee       	ldi	r26, 0xE9	; 233
     75e:	b1 e0       	ldi	r27, 0x01	; 1
     760:	01 c0       	rjmp	.+2      	; 0x764 <vPortFree+0x26>
     762:	df 01       	movw	r26, r30
     764:	ed 91       	ld	r30, X+
     766:	fc 91       	ld	r31, X
     768:	11 97       	sbiw	r26, 0x01	; 1
     76a:	22 81       	ldd	r18, Z+2	; 0x02
     76c:	33 81       	ldd	r19, Z+3	; 0x03
     76e:	24 17       	cp	r18, r20
     770:	35 07       	cpc	r19, r21
     772:	b8 f3       	brcs	.-18     	; 0x762 <vPortFree+0x24>
     774:	24 97       	sbiw	r28, 0x04	; 4
     776:	f9 83       	std	Y+1, r31	; 0x01
     778:	e8 83       	st	Y, r30
     77a:	0d 93       	st	X+, r16
     77c:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     77e:	20 91 0a 01 	lds	r18, 0x010A	; 0x80010a <xFreeBytesRemaining>
     782:	30 91 0b 01 	lds	r19, 0x010B	; 0x80010b <xFreeBytesRemaining+0x1>
     786:	8a 81       	ldd	r24, Y+2	; 0x02
     788:	9b 81       	ldd	r25, Y+3	; 0x03
     78a:	82 0f       	add	r24, r18
     78c:	93 1f       	adc	r25, r19
     78e:	90 93 0b 01 	sts	0x010B, r25	; 0x80010b <xFreeBytesRemaining+0x1>
     792:	80 93 0a 01 	sts	0x010A, r24	; 0x80010a <xFreeBytesRemaining>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     796:	0e 94 69 08 	call	0x10d2	; 0x10d2 <xTaskResumeAll>
	}
}
     79a:	df 91       	pop	r29
     79c:	cf 91       	pop	r28
     79e:	1f 91       	pop	r17
     7a0:	0f 91       	pop	r16
     7a2:	08 95       	ret

000007a4 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     7a4:	1f 93       	push	r17
     7a6:	cf 93       	push	r28
     7a8:	df 93       	push	r29
     7aa:	ec 01       	movw	r28, r24
     7ac:	14 2f       	mov	r17, r20
     7ae:	4c 8d       	ldd	r20, Y+28	; 0x1c
     7b0:	41 11       	cpse	r20, r1
     7b2:	0c c0       	rjmp	.+24     	; 0x7cc <prvCopyDataToQueue+0x28>
     7b4:	88 81       	ld	r24, Y
     7b6:	99 81       	ldd	r25, Y+1	; 0x01
     7b8:	89 2b       	or	r24, r25
     7ba:	09 f0       	breq	.+2      	; 0x7be <prvCopyDataToQueue+0x1a>
     7bc:	45 c0       	rjmp	.+138    	; 0x848 <__DATA_REGION_LENGTH__+0x48>
     7be:	8a 81       	ldd	r24, Y+2	; 0x02
     7c0:	9b 81       	ldd	r25, Y+3	; 0x03
     7c2:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <xTaskPriorityDisinherit>
     7c6:	1b 82       	std	Y+3, r1	; 0x03
     7c8:	1a 82       	std	Y+2, r1	; 0x02
     7ca:	45 c0       	rjmp	.+138    	; 0x856 <__DATA_REGION_LENGTH__+0x56>
     7cc:	11 11       	cpse	r17, r1
     7ce:	17 c0       	rjmp	.+46     	; 0x7fe <prvCopyDataToQueue+0x5a>
     7d0:	50 e0       	ldi	r21, 0x00	; 0
     7d2:	8c 81       	ldd	r24, Y+4	; 0x04
     7d4:	9d 81       	ldd	r25, Y+5	; 0x05
     7d6:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <memcpy>
     7da:	2c 8d       	ldd	r18, Y+28	; 0x1c
     7dc:	8c 81       	ldd	r24, Y+4	; 0x04
     7de:	9d 81       	ldd	r25, Y+5	; 0x05
     7e0:	82 0f       	add	r24, r18
     7e2:	91 1d       	adc	r25, r1
     7e4:	9d 83       	std	Y+5, r25	; 0x05
     7e6:	8c 83       	std	Y+4, r24	; 0x04
     7e8:	2a 81       	ldd	r18, Y+2	; 0x02
     7ea:	3b 81       	ldd	r19, Y+3	; 0x03
     7ec:	82 17       	cp	r24, r18
     7ee:	93 07       	cpc	r25, r19
     7f0:	68 f1       	brcs	.+90     	; 0x84c <__DATA_REGION_LENGTH__+0x4c>
     7f2:	88 81       	ld	r24, Y
     7f4:	99 81       	ldd	r25, Y+1	; 0x01
     7f6:	9d 83       	std	Y+5, r25	; 0x05
     7f8:	8c 83       	std	Y+4, r24	; 0x04
     7fa:	80 e0       	ldi	r24, 0x00	; 0
     7fc:	2c c0       	rjmp	.+88     	; 0x856 <__DATA_REGION_LENGTH__+0x56>
     7fe:	50 e0       	ldi	r21, 0x00	; 0
     800:	8e 81       	ldd	r24, Y+6	; 0x06
     802:	9f 81       	ldd	r25, Y+7	; 0x07
     804:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <memcpy>
     808:	8c 8d       	ldd	r24, Y+28	; 0x1c
     80a:	90 e0       	ldi	r25, 0x00	; 0
     80c:	91 95       	neg	r25
     80e:	81 95       	neg	r24
     810:	91 09       	sbc	r25, r1
     812:	2e 81       	ldd	r18, Y+6	; 0x06
     814:	3f 81       	ldd	r19, Y+7	; 0x07
     816:	28 0f       	add	r18, r24
     818:	39 1f       	adc	r19, r25
     81a:	3f 83       	std	Y+7, r19	; 0x07
     81c:	2e 83       	std	Y+6, r18	; 0x06
     81e:	48 81       	ld	r20, Y
     820:	59 81       	ldd	r21, Y+1	; 0x01
     822:	24 17       	cp	r18, r20
     824:	35 07       	cpc	r19, r21
     826:	30 f4       	brcc	.+12     	; 0x834 <__DATA_REGION_LENGTH__+0x34>
     828:	2a 81       	ldd	r18, Y+2	; 0x02
     82a:	3b 81       	ldd	r19, Y+3	; 0x03
     82c:	82 0f       	add	r24, r18
     82e:	93 1f       	adc	r25, r19
     830:	9f 83       	std	Y+7, r25	; 0x07
     832:	8e 83       	std	Y+6, r24	; 0x06
     834:	12 30       	cpi	r17, 0x02	; 2
     836:	61 f4       	brne	.+24     	; 0x850 <__DATA_REGION_LENGTH__+0x50>
     838:	8a 8d       	ldd	r24, Y+26	; 0x1a
     83a:	88 23       	and	r24, r24
     83c:	59 f0       	breq	.+22     	; 0x854 <__DATA_REGION_LENGTH__+0x54>
     83e:	8a 8d       	ldd	r24, Y+26	; 0x1a
     840:	81 50       	subi	r24, 0x01	; 1
     842:	8a 8f       	std	Y+26, r24	; 0x1a
     844:	80 e0       	ldi	r24, 0x00	; 0
     846:	07 c0       	rjmp	.+14     	; 0x856 <__DATA_REGION_LENGTH__+0x56>
     848:	80 e0       	ldi	r24, 0x00	; 0
     84a:	05 c0       	rjmp	.+10     	; 0x856 <__DATA_REGION_LENGTH__+0x56>
     84c:	80 e0       	ldi	r24, 0x00	; 0
     84e:	03 c0       	rjmp	.+6      	; 0x856 <__DATA_REGION_LENGTH__+0x56>
     850:	80 e0       	ldi	r24, 0x00	; 0
     852:	01 c0       	rjmp	.+2      	; 0x856 <__DATA_REGION_LENGTH__+0x56>
     854:	80 e0       	ldi	r24, 0x00	; 0
     856:	9a 8d       	ldd	r25, Y+26	; 0x1a
     858:	9f 5f       	subi	r25, 0xFF	; 255
     85a:	9a 8f       	std	Y+26, r25	; 0x1a
     85c:	df 91       	pop	r29
     85e:	cf 91       	pop	r28
     860:	1f 91       	pop	r17
     862:	08 95       	ret

00000864 <prvCopyDataFromQueue>:
     864:	fc 01       	movw	r30, r24
     866:	44 8d       	ldd	r20, Z+28	; 0x1c
     868:	44 23       	and	r20, r20
     86a:	a9 f0       	breq	.+42     	; 0x896 <prvCopyDataFromQueue+0x32>
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	26 81       	ldd	r18, Z+6	; 0x06
     870:	37 81       	ldd	r19, Z+7	; 0x07
     872:	24 0f       	add	r18, r20
     874:	35 1f       	adc	r19, r21
     876:	37 83       	std	Z+7, r19	; 0x07
     878:	26 83       	std	Z+6, r18	; 0x06
     87a:	82 81       	ldd	r24, Z+2	; 0x02
     87c:	93 81       	ldd	r25, Z+3	; 0x03
     87e:	28 17       	cp	r18, r24
     880:	39 07       	cpc	r19, r25
     882:	20 f0       	brcs	.+8      	; 0x88c <prvCopyDataFromQueue+0x28>
     884:	80 81       	ld	r24, Z
     886:	91 81       	ldd	r25, Z+1	; 0x01
     888:	97 83       	std	Z+7, r25	; 0x07
     88a:	86 83       	std	Z+6, r24	; 0x06
     88c:	cb 01       	movw	r24, r22
     88e:	66 81       	ldd	r22, Z+6	; 0x06
     890:	77 81       	ldd	r23, Z+7	; 0x07
     892:	0e 94 e7 0b 	call	0x17ce	; 0x17ce <memcpy>
     896:	08 95       	ret

00000898 <prvUnlockQueue>:
     898:	0f 93       	push	r16
     89a:	1f 93       	push	r17
     89c:	cf 93       	push	r28
     89e:	df 93       	push	r29
     8a0:	ec 01       	movw	r28, r24
     8a2:	0f b6       	in	r0, 0x3f	; 63
     8a4:	f8 94       	cli
     8a6:	0f 92       	push	r0
     8a8:	8e 8d       	ldd	r24, Y+30	; 0x1e
     8aa:	18 16       	cp	r1, r24
     8ac:	bc f4       	brge	.+46     	; 0x8dc <prvUnlockQueue+0x44>
     8ae:	89 89       	ldd	r24, Y+17	; 0x11
     8b0:	81 11       	cpse	r24, r1
     8b2:	05 c0       	rjmp	.+10     	; 0x8be <prvUnlockQueue+0x26>
     8b4:	13 c0       	rjmp	.+38     	; 0x8dc <prvUnlockQueue+0x44>
     8b6:	89 89       	ldd	r24, Y+17	; 0x11
     8b8:	81 11       	cpse	r24, r1
     8ba:	04 c0       	rjmp	.+8      	; 0x8c4 <prvUnlockQueue+0x2c>
     8bc:	0f c0       	rjmp	.+30     	; 0x8dc <prvUnlockQueue+0x44>
     8be:	8e 01       	movw	r16, r28
     8c0:	0f 5e       	subi	r16, 0xEF	; 239
     8c2:	1f 4f       	sbci	r17, 0xFF	; 255
     8c4:	c8 01       	movw	r24, r16
     8c6:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskRemoveFromEventList>
     8ca:	81 11       	cpse	r24, r1
     8cc:	0e 94 8f 0a 	call	0x151e	; 0x151e <vTaskMissedYield>
     8d0:	8e 8d       	ldd	r24, Y+30	; 0x1e
     8d2:	81 50       	subi	r24, 0x01	; 1
     8d4:	8e 8f       	std	Y+30, r24	; 0x1e
     8d6:	8e 8d       	ldd	r24, Y+30	; 0x1e
     8d8:	18 16       	cp	r1, r24
     8da:	6c f3       	brlt	.-38     	; 0x8b6 <prvUnlockQueue+0x1e>
     8dc:	8f ef       	ldi	r24, 0xFF	; 255
     8de:	8e 8f       	std	Y+30, r24	; 0x1e
     8e0:	0f 90       	pop	r0
     8e2:	0f be       	out	0x3f, r0	; 63
     8e4:	0f b6       	in	r0, 0x3f	; 63
     8e6:	f8 94       	cli
     8e8:	0f 92       	push	r0
     8ea:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8ec:	18 16       	cp	r1, r24
     8ee:	bc f4       	brge	.+46     	; 0x91e <__stack+0x1f>
     8f0:	88 85       	ldd	r24, Y+8	; 0x08
     8f2:	81 11       	cpse	r24, r1
     8f4:	05 c0       	rjmp	.+10     	; 0x900 <__stack+0x1>
     8f6:	13 c0       	rjmp	.+38     	; 0x91e <__stack+0x1f>
     8f8:	88 85       	ldd	r24, Y+8	; 0x08
     8fa:	81 11       	cpse	r24, r1
     8fc:	04 c0       	rjmp	.+8      	; 0x906 <__stack+0x7>
     8fe:	0f c0       	rjmp	.+30     	; 0x91e <__stack+0x1f>
     900:	8e 01       	movw	r16, r28
     902:	08 5f       	subi	r16, 0xF8	; 248
     904:	1f 4f       	sbci	r17, 0xFF	; 255
     906:	c8 01       	movw	r24, r16
     908:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskRemoveFromEventList>
     90c:	81 11       	cpse	r24, r1
     90e:	0e 94 8f 0a 	call	0x151e	; 0x151e <vTaskMissedYield>
     912:	8d 8d       	ldd	r24, Y+29	; 0x1d
     914:	81 50       	subi	r24, 0x01	; 1
     916:	8d 8f       	std	Y+29, r24	; 0x1d
     918:	8d 8d       	ldd	r24, Y+29	; 0x1d
     91a:	18 16       	cp	r1, r24
     91c:	6c f3       	brlt	.-38     	; 0x8f8 <prvUnlockQueue+0x60>
     91e:	8f ef       	ldi	r24, 0xFF	; 255
     920:	8d 8f       	std	Y+29, r24	; 0x1d
     922:	0f 90       	pop	r0
     924:	0f be       	out	0x3f, r0	; 63
     926:	df 91       	pop	r29
     928:	cf 91       	pop	r28
     92a:	1f 91       	pop	r17
     92c:	0f 91       	pop	r16
     92e:	08 95       	ret

00000930 <xQueueGenericReset>:
     930:	cf 93       	push	r28
     932:	df 93       	push	r29
     934:	ec 01       	movw	r28, r24
     936:	0f b6       	in	r0, 0x3f	; 63
     938:	f8 94       	cli
     93a:	0f 92       	push	r0
     93c:	48 81       	ld	r20, Y
     93e:	59 81       	ldd	r21, Y+1	; 0x01
     940:	2c 8d       	ldd	r18, Y+28	; 0x1c
     942:	30 e0       	ldi	r19, 0x00	; 0
     944:	7b 8d       	ldd	r23, Y+27	; 0x1b
     946:	72 9f       	mul	r23, r18
     948:	c0 01       	movw	r24, r0
     94a:	73 9f       	mul	r23, r19
     94c:	90 0d       	add	r25, r0
     94e:	11 24       	eor	r1, r1
     950:	fa 01       	movw	r30, r20
     952:	e8 0f       	add	r30, r24
     954:	f9 1f       	adc	r31, r25
     956:	fb 83       	std	Y+3, r31	; 0x03
     958:	ea 83       	std	Y+2, r30	; 0x02
     95a:	1a 8e       	std	Y+26, r1	; 0x1a
     95c:	5d 83       	std	Y+5, r21	; 0x05
     95e:	4c 83       	std	Y+4, r20	; 0x04
     960:	82 1b       	sub	r24, r18
     962:	93 0b       	sbc	r25, r19
     964:	84 0f       	add	r24, r20
     966:	95 1f       	adc	r25, r21
     968:	9f 83       	std	Y+7, r25	; 0x07
     96a:	8e 83       	std	Y+6, r24	; 0x06
     96c:	8f ef       	ldi	r24, 0xFF	; 255
     96e:	8d 8f       	std	Y+29, r24	; 0x1d
     970:	8e 8f       	std	Y+30, r24	; 0x1e
     972:	61 11       	cpse	r22, r1
     974:	0c c0       	rjmp	.+24     	; 0x98e <xQueueGenericReset+0x5e>
     976:	88 85       	ldd	r24, Y+8	; 0x08
     978:	88 23       	and	r24, r24
     97a:	89 f0       	breq	.+34     	; 0x99e <xQueueGenericReset+0x6e>
     97c:	ce 01       	movw	r24, r28
     97e:	08 96       	adiw	r24, 0x08	; 8
     980:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskRemoveFromEventList>
     984:	81 30       	cpi	r24, 0x01	; 1
     986:	59 f4       	brne	.+22     	; 0x99e <xQueueGenericReset+0x6e>
     988:	0e 94 4d 02 	call	0x49a	; 0x49a <vPortYield>
     98c:	08 c0       	rjmp	.+16     	; 0x99e <xQueueGenericReset+0x6e>
     98e:	ce 01       	movw	r24, r28
     990:	08 96       	adiw	r24, 0x08	; 8
     992:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInitialise>
     996:	ce 01       	movw	r24, r28
     998:	41 96       	adiw	r24, 0x11	; 17
     99a:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInitialise>
     99e:	0f 90       	pop	r0
     9a0:	0f be       	out	0x3f, r0	; 63
     9a2:	81 e0       	ldi	r24, 0x01	; 1
     9a4:	df 91       	pop	r29
     9a6:	cf 91       	pop	r28
     9a8:	08 95       	ret

000009aa <xQueueGenericCreate>:
     9aa:	0f 93       	push	r16
     9ac:	1f 93       	push	r17
     9ae:	cf 93       	push	r28
     9b0:	df 93       	push	r29
     9b2:	08 2f       	mov	r16, r24
     9b4:	16 2f       	mov	r17, r22
     9b6:	66 23       	and	r22, r22
     9b8:	b9 f0       	breq	.+46     	; 0x9e8 <xQueueGenericCreate+0x3e>
     9ba:	86 9f       	mul	r24, r22
     9bc:	c0 01       	movw	r24, r0
     9be:	11 24       	eor	r1, r1
     9c0:	80 96       	adiw	r24, 0x20	; 32
     9c2:	0e 94 05 03 	call	0x60a	; 0x60a <pvPortMalloc>
     9c6:	ec 01       	movw	r28, r24
     9c8:	00 97       	sbiw	r24, 0x00	; 0
     9ca:	21 f4       	brne	.+8      	; 0x9d4 <xQueueGenericCreate+0x2a>
     9cc:	14 c0       	rjmp	.+40     	; 0x9f6 <xQueueGenericCreate+0x4c>
     9ce:	d9 83       	std	Y+1, r29	; 0x01
     9d0:	c8 83       	st	Y, r28
     9d2:	03 c0       	rjmp	.+6      	; 0x9da <xQueueGenericCreate+0x30>
     9d4:	4f 96       	adiw	r24, 0x1f	; 31
     9d6:	99 83       	std	Y+1, r25	; 0x01
     9d8:	88 83       	st	Y, r24
     9da:	0b 8f       	std	Y+27, r16	; 0x1b
     9dc:	1c 8f       	std	Y+28, r17	; 0x1c
     9de:	61 e0       	ldi	r22, 0x01	; 1
     9e0:	ce 01       	movw	r24, r28
     9e2:	0e 94 98 04 	call	0x930	; 0x930 <xQueueGenericReset>
     9e6:	07 c0       	rjmp	.+14     	; 0x9f6 <xQueueGenericCreate+0x4c>
     9e8:	8f e1       	ldi	r24, 0x1F	; 31
     9ea:	90 e0       	ldi	r25, 0x00	; 0
     9ec:	0e 94 05 03 	call	0x60a	; 0x60a <pvPortMalloc>
     9f0:	ec 01       	movw	r28, r24
     9f2:	89 2b       	or	r24, r25
     9f4:	61 f7       	brne	.-40     	; 0x9ce <xQueueGenericCreate+0x24>
     9f6:	ce 01       	movw	r24, r28
     9f8:	df 91       	pop	r29
     9fa:	cf 91       	pop	r28
     9fc:	1f 91       	pop	r17
     9fe:	0f 91       	pop	r16
     a00:	08 95       	ret

00000a02 <xQueueGenericSendFromISR>:
     a02:	0f 93       	push	r16
     a04:	1f 93       	push	r17
     a06:	cf 93       	push	r28
     a08:	df 93       	push	r29
     a0a:	fa 01       	movw	r30, r20
     a0c:	dc 01       	movw	r26, r24
     a0e:	5a 96       	adiw	r26, 0x1a	; 26
     a10:	5c 91       	ld	r21, X
     a12:	5a 97       	sbiw	r26, 0x1a	; 26
     a14:	5b 96       	adiw	r26, 0x1b	; 27
     a16:	3c 91       	ld	r19, X
     a18:	53 17       	cp	r21, r19
     a1a:	10 f0       	brcs	.+4      	; 0xa20 <xQueueGenericSendFromISR+0x1e>
     a1c:	22 30       	cpi	r18, 0x02	; 2
     a1e:	e9 f4       	brne	.+58     	; 0xa5a <xQueueGenericSendFromISR+0x58>
     a20:	42 2f       	mov	r20, r18
     a22:	8f 01       	movw	r16, r30
     a24:	ec 01       	movw	r28, r24
     a26:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <prvCopyDataToQueue>
     a2a:	8e 8d       	ldd	r24, Y+30	; 0x1e
     a2c:	8f 3f       	cpi	r24, 0xFF	; 255
     a2e:	81 f4       	brne	.+32     	; 0xa50 <xQueueGenericSendFromISR+0x4e>
     a30:	89 89       	ldd	r24, Y+17	; 0x11
     a32:	88 23       	and	r24, r24
     a34:	a1 f0       	breq	.+40     	; 0xa5e <xQueueGenericSendFromISR+0x5c>
     a36:	ce 01       	movw	r24, r28
     a38:	41 96       	adiw	r24, 0x11	; 17
     a3a:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskRemoveFromEventList>
     a3e:	88 23       	and	r24, r24
     a40:	81 f0       	breq	.+32     	; 0xa62 <xQueueGenericSendFromISR+0x60>
     a42:	01 15       	cp	r16, r1
     a44:	11 05       	cpc	r17, r1
     a46:	79 f0       	breq	.+30     	; 0xa66 <xQueueGenericSendFromISR+0x64>
     a48:	81 e0       	ldi	r24, 0x01	; 1
     a4a:	f8 01       	movw	r30, r16
     a4c:	80 83       	st	Z, r24
     a4e:	0c c0       	rjmp	.+24     	; 0xa68 <xQueueGenericSendFromISR+0x66>
     a50:	8e 8d       	ldd	r24, Y+30	; 0x1e
     a52:	8f 5f       	subi	r24, 0xFF	; 255
     a54:	8e 8f       	std	Y+30, r24	; 0x1e
     a56:	81 e0       	ldi	r24, 0x01	; 1
     a58:	07 c0       	rjmp	.+14     	; 0xa68 <xQueueGenericSendFromISR+0x66>
     a5a:	80 e0       	ldi	r24, 0x00	; 0
     a5c:	05 c0       	rjmp	.+10     	; 0xa68 <xQueueGenericSendFromISR+0x66>
     a5e:	81 e0       	ldi	r24, 0x01	; 1
     a60:	03 c0       	rjmp	.+6      	; 0xa68 <xQueueGenericSendFromISR+0x66>
     a62:	81 e0       	ldi	r24, 0x01	; 1
     a64:	01 c0       	rjmp	.+2      	; 0xa68 <xQueueGenericSendFromISR+0x66>
     a66:	81 e0       	ldi	r24, 0x01	; 1
     a68:	df 91       	pop	r29
     a6a:	cf 91       	pop	r28
     a6c:	1f 91       	pop	r17
     a6e:	0f 91       	pop	r16
     a70:	08 95       	ret

00000a72 <xQueueGenericReceive>:
     a72:	9f 92       	push	r9
     a74:	af 92       	push	r10
     a76:	bf 92       	push	r11
     a78:	cf 92       	push	r12
     a7a:	df 92       	push	r13
     a7c:	ef 92       	push	r14
     a7e:	ff 92       	push	r15
     a80:	0f 93       	push	r16
     a82:	1f 93       	push	r17
     a84:	cf 93       	push	r28
     a86:	df 93       	push	r29
     a88:	00 d0       	rcall	.+0      	; 0xa8a <xQueueGenericReceive+0x18>
     a8a:	00 d0       	rcall	.+0      	; 0xa8c <xQueueGenericReceive+0x1a>
     a8c:	1f 92       	push	r1
     a8e:	cd b7       	in	r28, 0x3d	; 61
     a90:	de b7       	in	r29, 0x3e	; 62
     a92:	8c 01       	movw	r16, r24
     a94:	6b 01       	movw	r12, r22
     a96:	5d 83       	std	Y+5, r21	; 0x05
     a98:	4c 83       	std	Y+4, r20	; 0x04
     a9a:	92 2e       	mov	r9, r18
     a9c:	b1 2c       	mov	r11, r1
     a9e:	aa 24       	eor	r10, r10
     aa0:	a3 94       	inc	r10
     aa2:	7c 01       	movw	r14, r24
     aa4:	81 e1       	ldi	r24, 0x11	; 17
     aa6:	e8 0e       	add	r14, r24
     aa8:	f1 1c       	adc	r15, r1
     aaa:	0f b6       	in	r0, 0x3f	; 63
     aac:	f8 94       	cli
     aae:	0f 92       	push	r0
     ab0:	f8 01       	movw	r30, r16
     ab2:	82 8d       	ldd	r24, Z+26	; 0x1a
     ab4:	88 23       	and	r24, r24
     ab6:	99 f1       	breq	.+102    	; 0xb1e <xQueueGenericReceive+0xac>
     ab8:	e6 80       	ldd	r14, Z+6	; 0x06
     aba:	f7 80       	ldd	r15, Z+7	; 0x07
     abc:	b6 01       	movw	r22, r12
     abe:	c8 01       	movw	r24, r16
     ac0:	0e 94 32 04 	call	0x864	; 0x864 <prvCopyDataFromQueue>
     ac4:	91 10       	cpse	r9, r1
     ac6:	1a c0       	rjmp	.+52     	; 0xafc <xQueueGenericReceive+0x8a>
     ac8:	f8 01       	movw	r30, r16
     aca:	82 8d       	ldd	r24, Z+26	; 0x1a
     acc:	81 50       	subi	r24, 0x01	; 1
     ace:	82 8f       	std	Z+26, r24	; 0x1a
     ad0:	80 81       	ld	r24, Z
     ad2:	91 81       	ldd	r25, Z+1	; 0x01
     ad4:	89 2b       	or	r24, r25
     ad6:	29 f4       	brne	.+10     	; 0xae2 <xQueueGenericReceive+0x70>
     ad8:	0e 94 35 0b 	call	0x166a	; 0x166a <pvTaskIncrementMutexHeldCount>
     adc:	f8 01       	movw	r30, r16
     ade:	93 83       	std	Z+3, r25	; 0x03
     ae0:	82 83       	std	Z+2, r24	; 0x02
     ae2:	f8 01       	movw	r30, r16
     ae4:	80 85       	ldd	r24, Z+8	; 0x08
     ae6:	88 23       	and	r24, r24
     ae8:	b1 f0       	breq	.+44     	; 0xb16 <xQueueGenericReceive+0xa4>
     aea:	c8 01       	movw	r24, r16
     aec:	08 96       	adiw	r24, 0x08	; 8
     aee:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskRemoveFromEventList>
     af2:	81 30       	cpi	r24, 0x01	; 1
     af4:	81 f4       	brne	.+32     	; 0xb16 <xQueueGenericReceive+0xa4>
     af6:	0e 94 4d 02 	call	0x49a	; 0x49a <vPortYield>
     afa:	0d c0       	rjmp	.+26     	; 0xb16 <xQueueGenericReceive+0xa4>
     afc:	f8 01       	movw	r30, r16
     afe:	f7 82       	std	Z+7, r15	; 0x07
     b00:	e6 82       	std	Z+6, r14	; 0x06
     b02:	81 89       	ldd	r24, Z+17	; 0x11
     b04:	88 23       	and	r24, r24
     b06:	39 f0       	breq	.+14     	; 0xb16 <xQueueGenericReceive+0xa4>
     b08:	c8 01       	movw	r24, r16
     b0a:	41 96       	adiw	r24, 0x11	; 17
     b0c:	0e 94 03 0a 	call	0x1406	; 0x1406 <xTaskRemoveFromEventList>
     b10:	81 11       	cpse	r24, r1
     b12:	0e 94 4d 02 	call	0x49a	; 0x49a <vPortYield>
     b16:	0f 90       	pop	r0
     b18:	0f be       	out	0x3f, r0	; 63
     b1a:	81 e0       	ldi	r24, 0x01	; 1
     b1c:	5c c0       	rjmp	.+184    	; 0xbd6 <xQueueGenericReceive+0x164>
     b1e:	8c 81       	ldd	r24, Y+4	; 0x04
     b20:	9d 81       	ldd	r25, Y+5	; 0x05
     b22:	89 2b       	or	r24, r25
     b24:	21 f4       	brne	.+8      	; 0xb2e <xQueueGenericReceive+0xbc>
     b26:	0f 90       	pop	r0
     b28:	0f be       	out	0x3f, r0	; 63
     b2a:	80 e0       	ldi	r24, 0x00	; 0
     b2c:	54 c0       	rjmp	.+168    	; 0xbd6 <xQueueGenericReceive+0x164>
     b2e:	b1 10       	cpse	r11, r1
     b30:	05 c0       	rjmp	.+10     	; 0xb3c <xQueueGenericReceive+0xca>
     b32:	ce 01       	movw	r24, r28
     b34:	01 96       	adiw	r24, 0x01	; 1
     b36:	0e 94 4b 0a 	call	0x1496	; 0x1496 <vTaskSetTimeOutState>
     b3a:	ba 2c       	mov	r11, r10
     b3c:	0f 90       	pop	r0
     b3e:	0f be       	out	0x3f, r0	; 63
     b40:	0e 94 97 07 	call	0xf2e	; 0xf2e <vTaskSuspendAll>
     b44:	0f b6       	in	r0, 0x3f	; 63
     b46:	f8 94       	cli
     b48:	0f 92       	push	r0
     b4a:	f8 01       	movw	r30, r16
     b4c:	85 8d       	ldd	r24, Z+29	; 0x1d
     b4e:	8f 3f       	cpi	r24, 0xFF	; 255
     b50:	09 f4       	brne	.+2      	; 0xb54 <xQueueGenericReceive+0xe2>
     b52:	15 8e       	std	Z+29, r1	; 0x1d
     b54:	f8 01       	movw	r30, r16
     b56:	86 8d       	ldd	r24, Z+30	; 0x1e
     b58:	8f 3f       	cpi	r24, 0xFF	; 255
     b5a:	09 f4       	brne	.+2      	; 0xb5e <xQueueGenericReceive+0xec>
     b5c:	16 8e       	std	Z+30, r1	; 0x1e
     b5e:	0f 90       	pop	r0
     b60:	0f be       	out	0x3f, r0	; 63
     b62:	be 01       	movw	r22, r28
     b64:	6c 5f       	subi	r22, 0xFC	; 252
     b66:	7f 4f       	sbci	r23, 0xFF	; 255
     b68:	ce 01       	movw	r24, r28
     b6a:	01 96       	adiw	r24, 0x01	; 1
     b6c:	0e 94 56 0a 	call	0x14ac	; 0x14ac <xTaskCheckForTimeOut>
     b70:	81 11       	cpse	r24, r1
     b72:	2b c0       	rjmp	.+86     	; 0xbca <xQueueGenericReceive+0x158>
     b74:	0f b6       	in	r0, 0x3f	; 63
     b76:	f8 94       	cli
     b78:	0f 92       	push	r0
     b7a:	f8 01       	movw	r30, r16
     b7c:	82 8d       	ldd	r24, Z+26	; 0x1a
     b7e:	0f 90       	pop	r0
     b80:	0f be       	out	0x3f, r0	; 63
     b82:	81 11       	cpse	r24, r1
     b84:	1c c0       	rjmp	.+56     	; 0xbbe <xQueueGenericReceive+0x14c>
     b86:	80 81       	ld	r24, Z
     b88:	91 81       	ldd	r25, Z+1	; 0x01
     b8a:	89 2b       	or	r24, r25
     b8c:	49 f4       	brne	.+18     	; 0xba0 <xQueueGenericReceive+0x12e>
     b8e:	0f b6       	in	r0, 0x3f	; 63
     b90:	f8 94       	cli
     b92:	0f 92       	push	r0
     b94:	82 81       	ldd	r24, Z+2	; 0x02
     b96:	93 81       	ldd	r25, Z+3	; 0x03
     b98:	0e 94 93 0a 	call	0x1526	; 0x1526 <vTaskPriorityInherit>
     b9c:	0f 90       	pop	r0
     b9e:	0f be       	out	0x3f, r0	; 63
     ba0:	6c 81       	ldd	r22, Y+4	; 0x04
     ba2:	7d 81       	ldd	r23, Y+5	; 0x05
     ba4:	c7 01       	movw	r24, r14
     ba6:	0e 94 d7 09 	call	0x13ae	; 0x13ae <vTaskPlaceOnEventList>
     baa:	c8 01       	movw	r24, r16
     bac:	0e 94 4c 04 	call	0x898	; 0x898 <prvUnlockQueue>
     bb0:	0e 94 69 08 	call	0x10d2	; 0x10d2 <xTaskResumeAll>
     bb4:	81 11       	cpse	r24, r1
     bb6:	79 cf       	rjmp	.-270    	; 0xaaa <xQueueGenericReceive+0x38>
     bb8:	0e 94 4d 02 	call	0x49a	; 0x49a <vPortYield>
     bbc:	76 cf       	rjmp	.-276    	; 0xaaa <xQueueGenericReceive+0x38>
     bbe:	c8 01       	movw	r24, r16
     bc0:	0e 94 4c 04 	call	0x898	; 0x898 <prvUnlockQueue>
     bc4:	0e 94 69 08 	call	0x10d2	; 0x10d2 <xTaskResumeAll>
     bc8:	70 cf       	rjmp	.-288    	; 0xaaa <xQueueGenericReceive+0x38>
     bca:	c8 01       	movw	r24, r16
     bcc:	0e 94 4c 04 	call	0x898	; 0x898 <prvUnlockQueue>
     bd0:	0e 94 69 08 	call	0x10d2	; 0x10d2 <xTaskResumeAll>
     bd4:	80 e0       	ldi	r24, 0x00	; 0
     bd6:	0f 90       	pop	r0
     bd8:	0f 90       	pop	r0
     bda:	0f 90       	pop	r0
     bdc:	0f 90       	pop	r0
     bde:	0f 90       	pop	r0
     be0:	df 91       	pop	r29
     be2:	cf 91       	pop	r28
     be4:	1f 91       	pop	r17
     be6:	0f 91       	pop	r16
     be8:	ff 90       	pop	r15
     bea:	ef 90       	pop	r14
     bec:	df 90       	pop	r13
     bee:	cf 90       	pop	r12
     bf0:	bf 90       	pop	r11
     bf2:	af 90       	pop	r10
     bf4:	9f 90       	pop	r9
     bf6:	08 95       	ret

00000bf8 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
     bf8:	0f b6       	in	r0, 0x3f	; 63
     bfa:	f8 94       	cli
     bfc:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
     bfe:	fc 01       	movw	r30, r24
     c00:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
     c02:	0f 90       	pop	r0
     c04:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
     c06:	08 95       	ret

00000c08 <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
     c08:	e0 91 f3 07 	lds	r30, 0x07F3	; 0x8007f3 <pxDelayedTaskList>
     c0c:	f0 91 f4 07 	lds	r31, 0x07F4	; 0x8007f4 <pxDelayedTaskList+0x1>
     c10:	80 81       	ld	r24, Z
     c12:	81 11       	cpse	r24, r1
     c14:	07 c0       	rjmp	.+14     	; 0xc24 <prvResetNextTaskUnblockTime+0x1c>
     c16:	8f ef       	ldi	r24, 0xFF	; 255
     c18:	9f ef       	ldi	r25, 0xFF	; 255
     c1a:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <xNextTaskUnblockTime+0x1>
     c1e:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <xNextTaskUnblockTime>
     c22:	08 95       	ret
     c24:	e0 91 f3 07 	lds	r30, 0x07F3	; 0x8007f3 <pxDelayedTaskList>
     c28:	f0 91 f4 07 	lds	r31, 0x07F4	; 0x8007f4 <pxDelayedTaskList+0x1>
     c2c:	05 80       	ldd	r0, Z+5	; 0x05
     c2e:	f6 81       	ldd	r31, Z+6	; 0x06
     c30:	e0 2d       	mov	r30, r0
     c32:	06 80       	ldd	r0, Z+6	; 0x06
     c34:	f7 81       	ldd	r31, Z+7	; 0x07
     c36:	e0 2d       	mov	r30, r0
     c38:	82 81       	ldd	r24, Z+2	; 0x02
     c3a:	93 81       	ldd	r25, Z+3	; 0x03
     c3c:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <xNextTaskUnblockTime+0x1>
     c40:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <xNextTaskUnblockTime>
     c44:	08 95       	ret

00000c46 <prvAddCurrentTaskToDelayedList>:
     c46:	cf 93       	push	r28
     c48:	df 93       	push	r29
     c4a:	ec 01       	movw	r28, r24
     c4c:	e0 91 22 08 	lds	r30, 0x0822	; 0x800822 <pxCurrentTCB>
     c50:	f0 91 23 08 	lds	r31, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
     c54:	93 83       	std	Z+3, r25	; 0x03
     c56:	82 83       	std	Z+2, r24	; 0x02
     c58:	80 91 d0 07 	lds	r24, 0x07D0	; 0x8007d0 <xTickCount>
     c5c:	90 91 d1 07 	lds	r25, 0x07D1	; 0x8007d1 <xTickCount+0x1>
     c60:	c8 17       	cp	r28, r24
     c62:	d9 07       	cpc	r29, r25
     c64:	68 f4       	brcc	.+26     	; 0xc80 <prvAddCurrentTaskToDelayedList+0x3a>
     c66:	60 91 22 08 	lds	r22, 0x0822	; 0x800822 <pxCurrentTCB>
     c6a:	70 91 23 08 	lds	r23, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
     c6e:	80 91 f1 07 	lds	r24, 0x07F1	; 0x8007f1 <pxOverflowDelayedTaskList>
     c72:	90 91 f2 07 	lds	r25, 0x07F2	; 0x8007f2 <pxOverflowDelayedTaskList+0x1>
     c76:	6e 5f       	subi	r22, 0xFE	; 254
     c78:	7f 4f       	sbci	r23, 0xFF	; 255
     c7a:	0e 94 50 01 	call	0x2a0	; 0x2a0 <vListInsert>
     c7e:	17 c0       	rjmp	.+46     	; 0xcae <prvAddCurrentTaskToDelayedList+0x68>
     c80:	60 91 22 08 	lds	r22, 0x0822	; 0x800822 <pxCurrentTCB>
     c84:	70 91 23 08 	lds	r23, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
     c88:	80 91 f3 07 	lds	r24, 0x07F3	; 0x8007f3 <pxDelayedTaskList>
     c8c:	90 91 f4 07 	lds	r25, 0x07F4	; 0x8007f4 <pxDelayedTaskList+0x1>
     c90:	6e 5f       	subi	r22, 0xFE	; 254
     c92:	7f 4f       	sbci	r23, 0xFF	; 255
     c94:	0e 94 50 01 	call	0x2a0	; 0x2a0 <vListInsert>
     c98:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <xNextTaskUnblockTime>
     c9c:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <xNextTaskUnblockTime+0x1>
     ca0:	c8 17       	cp	r28, r24
     ca2:	d9 07       	cpc	r29, r25
     ca4:	20 f4       	brcc	.+8      	; 0xcae <prvAddCurrentTaskToDelayedList+0x68>
     ca6:	d0 93 0d 01 	sts	0x010D, r29	; 0x80010d <xNextTaskUnblockTime+0x1>
     caa:	c0 93 0c 01 	sts	0x010C, r28	; 0x80010c <xNextTaskUnblockTime>
     cae:	df 91       	pop	r29
     cb0:	cf 91       	pop	r28
     cb2:	08 95       	ret

00000cb4 <xTaskGenericCreate>:
     cb4:	4f 92       	push	r4
     cb6:	5f 92       	push	r5
     cb8:	6f 92       	push	r6
     cba:	7f 92       	push	r7
     cbc:	8f 92       	push	r8
     cbe:	9f 92       	push	r9
     cc0:	af 92       	push	r10
     cc2:	bf 92       	push	r11
     cc4:	cf 92       	push	r12
     cc6:	df 92       	push	r13
     cc8:	ef 92       	push	r14
     cca:	ff 92       	push	r15
     ccc:	0f 93       	push	r16
     cce:	1f 93       	push	r17
     cd0:	cf 93       	push	r28
     cd2:	df 93       	push	r29
     cd4:	4c 01       	movw	r8, r24
     cd6:	eb 01       	movw	r28, r22
     cd8:	5a 01       	movw	r10, r20
     cda:	29 01       	movw	r4, r18
     cdc:	c1 14       	cp	r12, r1
     cde:	d1 04       	cpc	r13, r1
     ce0:	39 f4       	brne	.+14     	; 0xcf0 <xTaskGenericCreate+0x3c>
     ce2:	ca 01       	movw	r24, r20
     ce4:	0e 94 05 03 	call	0x60a	; 0x60a <pvPortMalloc>
     ce8:	6c 01       	movw	r12, r24
     cea:	89 2b       	or	r24, r25
     cec:	09 f4       	brne	.+2      	; 0xcf0 <xTaskGenericCreate+0x3c>
     cee:	de c0       	rjmp	.+444    	; 0xeac <xTaskGenericCreate+0x1f8>
     cf0:	88 e2       	ldi	r24, 0x28	; 40
     cf2:	90 e0       	ldi	r25, 0x00	; 0
     cf4:	0e 94 05 03 	call	0x60a	; 0x60a <pvPortMalloc>
     cf8:	3c 01       	movw	r6, r24
     cfa:	00 97       	sbiw	r24, 0x00	; 0
     cfc:	79 f0       	breq	.+30     	; 0xd1c <xTaskGenericCreate+0x68>
     cfe:	fc 01       	movw	r30, r24
     d00:	d0 8e       	std	Z+24, r13	; 0x18
     d02:	c7 8a       	std	Z+23, r12	; 0x17
     d04:	f1 e0       	ldi	r31, 0x01	; 1
     d06:	af 1a       	sub	r10, r31
     d08:	b1 08       	sbc	r11, r1
     d0a:	ca 0c       	add	r12, r10
     d0c:	db 1c       	adc	r13, r11
     d0e:	88 81       	ld	r24, Y
     d10:	f3 01       	movw	r30, r6
     d12:	81 8f       	std	Z+25, r24	; 0x19
     d14:	88 81       	ld	r24, Y
     d16:	81 11       	cpse	r24, r1
     d18:	05 c0       	rjmp	.+10     	; 0xd24 <xTaskGenericCreate+0x70>
     d1a:	14 c0       	rjmp	.+40     	; 0xd44 <xTaskGenericCreate+0x90>
     d1c:	c6 01       	movw	r24, r12
     d1e:	0e 94 9f 03 	call	0x73e	; 0x73e <vPortFree>
     d22:	c4 c0       	rjmp	.+392    	; 0xeac <xTaskGenericCreate+0x1f8>
     d24:	d3 01       	movw	r26, r6
     d26:	5a 96       	adiw	r26, 0x1a	; 26
     d28:	fe 01       	movw	r30, r28
     d2a:	31 96       	adiw	r30, 0x01	; 1
     d2c:	9e 01       	movw	r18, r28
     d2e:	28 5f       	subi	r18, 0xF8	; 248
     d30:	3f 4f       	sbci	r19, 0xFF	; 255
     d32:	ef 01       	movw	r28, r30
     d34:	81 91       	ld	r24, Z+
     d36:	8d 93       	st	X+, r24
     d38:	88 81       	ld	r24, Y
     d3a:	88 23       	and	r24, r24
     d3c:	19 f0       	breq	.+6      	; 0xd44 <xTaskGenericCreate+0x90>
     d3e:	e2 17       	cp	r30, r18
     d40:	f3 07       	cpc	r31, r19
     d42:	b9 f7       	brne	.-18     	; 0xd32 <xTaskGenericCreate+0x7e>
     d44:	f3 01       	movw	r30, r6
     d46:	10 a2       	std	Z+32, r1	; 0x20
     d48:	10 2f       	mov	r17, r16
     d4a:	03 30       	cpi	r16, 0x03	; 3
     d4c:	08 f0       	brcs	.+2      	; 0xd50 <xTaskGenericCreate+0x9c>
     d4e:	12 e0       	ldi	r17, 0x02	; 2
     d50:	f3 01       	movw	r30, r6
     d52:	16 8b       	std	Z+22, r17	; 0x16
     d54:	11 a3       	std	Z+33, r17	; 0x21
     d56:	12 a2       	std	Z+34, r1	; 0x22
     d58:	e3 01       	movw	r28, r6
     d5a:	22 96       	adiw	r28, 0x02	; 2
     d5c:	ce 01       	movw	r24, r28
     d5e:	0e 94 2b 01 	call	0x256	; 0x256 <vListInitialiseItem>
     d62:	c3 01       	movw	r24, r6
     d64:	0c 96       	adiw	r24, 0x0c	; 12
     d66:	0e 94 2b 01 	call	0x256	; 0x256 <vListInitialiseItem>
     d6a:	f3 01       	movw	r30, r6
     d6c:	71 86       	std	Z+9, r7	; 0x09
     d6e:	60 86       	std	Z+8, r6	; 0x08
     d70:	83 e0       	ldi	r24, 0x03	; 3
     d72:	90 e0       	ldi	r25, 0x00	; 0
     d74:	81 1b       	sub	r24, r17
     d76:	91 09       	sbc	r25, r1
     d78:	95 87       	std	Z+13, r25	; 0x0d
     d7a:	84 87       	std	Z+12, r24	; 0x0c
     d7c:	73 8a       	std	Z+19, r7	; 0x13
     d7e:	62 8a       	std	Z+18, r6	; 0x12
     d80:	13 a2       	std	Z+35, r1	; 0x23
     d82:	14 a2       	std	Z+36, r1	; 0x24
     d84:	15 a2       	std	Z+37, r1	; 0x25
     d86:	16 a2       	std	Z+38, r1	; 0x26
     d88:	17 a2       	std	Z+39, r1	; 0x27
     d8a:	a2 01       	movw	r20, r4
     d8c:	b4 01       	movw	r22, r8
     d8e:	c6 01       	movw	r24, r12
     d90:	0e 94 a7 01 	call	0x34e	; 0x34e <pxPortInitialiseStack>
     d94:	f3 01       	movw	r30, r6
     d96:	91 83       	std	Z+1, r25	; 0x01
     d98:	80 83       	st	Z, r24
     d9a:	e1 14       	cp	r14, r1
     d9c:	f1 04       	cpc	r15, r1
     d9e:	19 f0       	breq	.+6      	; 0xda6 <xTaskGenericCreate+0xf2>
     da0:	f7 01       	movw	r30, r14
     da2:	71 82       	std	Z+1, r7	; 0x01
     da4:	60 82       	st	Z, r6
     da6:	0f b6       	in	r0, 0x3f	; 63
     da8:	f8 94       	cli
     daa:	0f 92       	push	r0
     dac:	80 91 d2 07 	lds	r24, 0x07D2	; 0x8007d2 <uxCurrentNumberOfTasks>
     db0:	8f 5f       	subi	r24, 0xFF	; 255
     db2:	80 93 d2 07 	sts	0x07D2, r24	; 0x8007d2 <uxCurrentNumberOfTasks>
     db6:	80 91 22 08 	lds	r24, 0x0822	; 0x800822 <pxCurrentTCB>
     dba:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
     dbe:	89 2b       	or	r24, r25
     dc0:	a9 f5       	brne	.+106    	; 0xe2c <xTaskGenericCreate+0x178>
     dc2:	70 92 23 08 	sts	0x0823, r7	; 0x800823 <pxCurrentTCB+0x1>
     dc6:	60 92 22 08 	sts	0x0822, r6	; 0x800822 <pxCurrentTCB>
     dca:	80 91 d2 07 	lds	r24, 0x07D2	; 0x8007d2 <uxCurrentNumberOfTasks>
     dce:	81 30       	cpi	r24, 0x01	; 1
     dd0:	e1 f5       	brne	.+120    	; 0xe4a <xTaskGenericCreate+0x196>
     dd2:	87 e0       	ldi	r24, 0x07	; 7
     dd4:	98 e0       	ldi	r25, 0x08	; 8
     dd6:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInitialise>
     dda:	80 e1       	ldi	r24, 0x10	; 16
     ddc:	98 e0       	ldi	r25, 0x08	; 8
     dde:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInitialise>
     de2:	89 e1       	ldi	r24, 0x19	; 25
     de4:	98 e0       	ldi	r25, 0x08	; 8
     de6:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInitialise>
     dea:	8e ef       	ldi	r24, 0xFE	; 254
     dec:	97 e0       	ldi	r25, 0x07	; 7
     dee:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInitialise>
     df2:	85 ef       	ldi	r24, 0xF5	; 245
     df4:	97 e0       	ldi	r25, 0x07	; 7
     df6:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInitialise>
     dfa:	88 ee       	ldi	r24, 0xE8	; 232
     dfc:	97 e0       	ldi	r25, 0x07	; 7
     dfe:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInitialise>
     e02:	8f ed       	ldi	r24, 0xDF	; 223
     e04:	97 e0       	ldi	r25, 0x07	; 7
     e06:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInitialise>
     e0a:	85 ed       	ldi	r24, 0xD5	; 213
     e0c:	97 e0       	ldi	r25, 0x07	; 7
     e0e:	0e 94 1d 01 	call	0x23a	; 0x23a <vListInitialise>
     e12:	8e ef       	ldi	r24, 0xFE	; 254
     e14:	97 e0       	ldi	r25, 0x07	; 7
     e16:	90 93 f4 07 	sts	0x07F4, r25	; 0x8007f4 <pxDelayedTaskList+0x1>
     e1a:	80 93 f3 07 	sts	0x07F3, r24	; 0x8007f3 <pxDelayedTaskList>
     e1e:	85 ef       	ldi	r24, 0xF5	; 245
     e20:	97 e0       	ldi	r25, 0x07	; 7
     e22:	90 93 f2 07 	sts	0x07F2, r25	; 0x8007f2 <pxOverflowDelayedTaskList+0x1>
     e26:	80 93 f1 07 	sts	0x07F1, r24	; 0x8007f1 <pxOverflowDelayedTaskList>
     e2a:	0f c0       	rjmp	.+30     	; 0xe4a <xTaskGenericCreate+0x196>
     e2c:	80 91 ce 07 	lds	r24, 0x07CE	; 0x8007ce <xSchedulerRunning>
     e30:	81 11       	cpse	r24, r1
     e32:	0b c0       	rjmp	.+22     	; 0xe4a <xTaskGenericCreate+0x196>
     e34:	e0 91 22 08 	lds	r30, 0x0822	; 0x800822 <pxCurrentTCB>
     e38:	f0 91 23 08 	lds	r31, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
     e3c:	86 89       	ldd	r24, Z+22	; 0x16
     e3e:	08 17       	cp	r16, r24
     e40:	20 f0       	brcs	.+8      	; 0xe4a <xTaskGenericCreate+0x196>
     e42:	70 92 23 08 	sts	0x0823, r7	; 0x800823 <pxCurrentTCB+0x1>
     e46:	60 92 22 08 	sts	0x0822, r6	; 0x800822 <pxCurrentTCB>
     e4a:	80 91 ca 07 	lds	r24, 0x07CA	; 0x8007ca <uxTaskNumber>
     e4e:	8f 5f       	subi	r24, 0xFF	; 255
     e50:	80 93 ca 07 	sts	0x07CA, r24	; 0x8007ca <uxTaskNumber>
     e54:	f3 01       	movw	r30, r6
     e56:	86 89       	ldd	r24, Z+22	; 0x16
     e58:	90 91 cf 07 	lds	r25, 0x07CF	; 0x8007cf <uxTopReadyPriority>
     e5c:	98 17       	cp	r25, r24
     e5e:	10 f4       	brcc	.+4      	; 0xe64 <xTaskGenericCreate+0x1b0>
     e60:	80 93 cf 07 	sts	0x07CF, r24	; 0x8007cf <uxTopReadyPriority>
     e64:	90 e0       	ldi	r25, 0x00	; 0
     e66:	9c 01       	movw	r18, r24
     e68:	22 0f       	add	r18, r18
     e6a:	33 1f       	adc	r19, r19
     e6c:	22 0f       	add	r18, r18
     e6e:	33 1f       	adc	r19, r19
     e70:	22 0f       	add	r18, r18
     e72:	33 1f       	adc	r19, r19
     e74:	82 0f       	add	r24, r18
     e76:	93 1f       	adc	r25, r19
     e78:	be 01       	movw	r22, r28
     e7a:	89 5f       	subi	r24, 0xF9	; 249
     e7c:	97 4f       	sbci	r25, 0xF7	; 247
     e7e:	0e 94 2f 01 	call	0x25e	; 0x25e <vListInsertEnd>
     e82:	0f 90       	pop	r0
     e84:	0f be       	out	0x3f, r0	; 63
     e86:	80 91 ce 07 	lds	r24, 0x07CE	; 0x8007ce <xSchedulerRunning>
     e8a:	88 23       	and	r24, r24
     e8c:	59 f0       	breq	.+22     	; 0xea4 <xTaskGenericCreate+0x1f0>
     e8e:	e0 91 22 08 	lds	r30, 0x0822	; 0x800822 <pxCurrentTCB>
     e92:	f0 91 23 08 	lds	r31, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
     e96:	86 89       	ldd	r24, Z+22	; 0x16
     e98:	80 17       	cp	r24, r16
     e9a:	30 f4       	brcc	.+12     	; 0xea8 <xTaskGenericCreate+0x1f4>
     e9c:	0e 94 4d 02 	call	0x49a	; 0x49a <vPortYield>
     ea0:	81 e0       	ldi	r24, 0x01	; 1
     ea2:	05 c0       	rjmp	.+10     	; 0xeae <xTaskGenericCreate+0x1fa>
     ea4:	81 e0       	ldi	r24, 0x01	; 1
     ea6:	03 c0       	rjmp	.+6      	; 0xeae <xTaskGenericCreate+0x1fa>
     ea8:	81 e0       	ldi	r24, 0x01	; 1
     eaa:	01 c0       	rjmp	.+2      	; 0xeae <xTaskGenericCreate+0x1fa>
     eac:	8f ef       	ldi	r24, 0xFF	; 255
     eae:	df 91       	pop	r29
     eb0:	cf 91       	pop	r28
     eb2:	1f 91       	pop	r17
     eb4:	0f 91       	pop	r16
     eb6:	ff 90       	pop	r15
     eb8:	ef 90       	pop	r14
     eba:	df 90       	pop	r13
     ebc:	cf 90       	pop	r12
     ebe:	bf 90       	pop	r11
     ec0:	af 90       	pop	r10
     ec2:	9f 90       	pop	r9
     ec4:	8f 90       	pop	r8
     ec6:	7f 90       	pop	r7
     ec8:	6f 90       	pop	r6
     eca:	5f 90       	pop	r5
     ecc:	4f 90       	pop	r4
     ece:	08 95       	ret

00000ed0 <vTaskStartScheduler>:
     ed0:	af 92       	push	r10
     ed2:	bf 92       	push	r11
     ed4:	cf 92       	push	r12
     ed6:	df 92       	push	r13
     ed8:	ef 92       	push	r14
     eda:	ff 92       	push	r15
     edc:	0f 93       	push	r16
     ede:	a1 2c       	mov	r10, r1
     ee0:	b1 2c       	mov	r11, r1
     ee2:	c1 2c       	mov	r12, r1
     ee4:	d1 2c       	mov	r13, r1
     ee6:	0f 2e       	mov	r0, r31
     ee8:	f3 ed       	ldi	r31, 0xD3	; 211
     eea:	ef 2e       	mov	r14, r31
     eec:	f7 e0       	ldi	r31, 0x07	; 7
     eee:	ff 2e       	mov	r15, r31
     ef0:	f0 2d       	mov	r31, r0
     ef2:	00 e0       	ldi	r16, 0x00	; 0
     ef4:	20 e0       	ldi	r18, 0x00	; 0
     ef6:	30 e0       	ldi	r19, 0x00	; 0
     ef8:	45 e5       	ldi	r20, 0x55	; 85
     efa:	50 e0       	ldi	r21, 0x00	; 0
     efc:	6c ed       	ldi	r22, 0xDC	; 220
     efe:	71 e0       	ldi	r23, 0x01	; 1
     f00:	8d e2       	ldi	r24, 0x2D	; 45
     f02:	99 e0       	ldi	r25, 0x09	; 9
     f04:	0e 94 5a 06 	call	0xcb4	; 0xcb4 <xTaskGenericCreate>
     f08:	81 30       	cpi	r24, 0x01	; 1
     f0a:	49 f4       	brne	.+18     	; 0xf1e <vTaskStartScheduler+0x4e>
     f0c:	f8 94       	cli
     f0e:	80 93 ce 07 	sts	0x07CE, r24	; 0x8007ce <xSchedulerRunning>
     f12:	10 92 d1 07 	sts	0x07D1, r1	; 0x8007d1 <xTickCount+0x1>
     f16:	10 92 d0 07 	sts	0x07D0, r1	; 0x8007d0 <xTickCount>
     f1a:	0e 94 13 02 	call	0x426	; 0x426 <xPortStartScheduler>
     f1e:	0f 91       	pop	r16
     f20:	ff 90       	pop	r15
     f22:	ef 90       	pop	r14
     f24:	df 90       	pop	r13
     f26:	cf 90       	pop	r12
     f28:	bf 90       	pop	r11
     f2a:	af 90       	pop	r10
     f2c:	08 95       	ret

00000f2e <vTaskSuspendAll>:
     f2e:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <uxSchedulerSuspended>
     f32:	8f 5f       	subi	r24, 0xFF	; 255
     f34:	80 93 c9 07 	sts	0x07C9, r24	; 0x8007c9 <uxSchedulerSuspended>
     f38:	08 95       	ret

00000f3a <xTaskGetTickCount>:
     f3a:	0f b6       	in	r0, 0x3f	; 63
     f3c:	f8 94       	cli
     f3e:	0f 92       	push	r0
     f40:	80 91 d0 07 	lds	r24, 0x07D0	; 0x8007d0 <xTickCount>
     f44:	90 91 d1 07 	lds	r25, 0x07D1	; 0x8007d1 <xTickCount+0x1>
     f48:	0f 90       	pop	r0
     f4a:	0f be       	out	0x3f, r0	; 63
     f4c:	08 95       	ret

00000f4e <xTaskGetTickCountFromISR>:
     f4e:	80 91 d0 07 	lds	r24, 0x07D0	; 0x8007d0 <xTickCount>
     f52:	90 91 d1 07 	lds	r25, 0x07D1	; 0x8007d1 <xTickCount+0x1>
     f56:	08 95       	ret

00000f58 <xTaskIncrementTick>:
     f58:	cf 92       	push	r12
     f5a:	df 92       	push	r13
     f5c:	ef 92       	push	r14
     f5e:	ff 92       	push	r15
     f60:	0f 93       	push	r16
     f62:	1f 93       	push	r17
     f64:	cf 93       	push	r28
     f66:	df 93       	push	r29
     f68:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <uxSchedulerSuspended>
     f6c:	81 11       	cpse	r24, r1
     f6e:	9b c0       	rjmp	.+310    	; 0x10a6 <xTaskIncrementTick+0x14e>
     f70:	80 91 d0 07 	lds	r24, 0x07D0	; 0x8007d0 <xTickCount>
     f74:	90 91 d1 07 	lds	r25, 0x07D1	; 0x8007d1 <xTickCount+0x1>
     f78:	01 96       	adiw	r24, 0x01	; 1
     f7a:	90 93 d1 07 	sts	0x07D1, r25	; 0x8007d1 <xTickCount+0x1>
     f7e:	80 93 d0 07 	sts	0x07D0, r24	; 0x8007d0 <xTickCount>
     f82:	e0 90 d0 07 	lds	r14, 0x07D0	; 0x8007d0 <xTickCount>
     f86:	f0 90 d1 07 	lds	r15, 0x07D1	; 0x8007d1 <xTickCount+0x1>
     f8a:	e1 14       	cp	r14, r1
     f8c:	f1 04       	cpc	r15, r1
     f8e:	b9 f4       	brne	.+46     	; 0xfbe <xTaskIncrementTick+0x66>
     f90:	80 91 f3 07 	lds	r24, 0x07F3	; 0x8007f3 <pxDelayedTaskList>
     f94:	90 91 f4 07 	lds	r25, 0x07F4	; 0x8007f4 <pxDelayedTaskList+0x1>
     f98:	20 91 f1 07 	lds	r18, 0x07F1	; 0x8007f1 <pxOverflowDelayedTaskList>
     f9c:	30 91 f2 07 	lds	r19, 0x07F2	; 0x8007f2 <pxOverflowDelayedTaskList+0x1>
     fa0:	30 93 f4 07 	sts	0x07F4, r19	; 0x8007f4 <pxDelayedTaskList+0x1>
     fa4:	20 93 f3 07 	sts	0x07F3, r18	; 0x8007f3 <pxDelayedTaskList>
     fa8:	90 93 f2 07 	sts	0x07F2, r25	; 0x8007f2 <pxOverflowDelayedTaskList+0x1>
     fac:	80 93 f1 07 	sts	0x07F1, r24	; 0x8007f1 <pxOverflowDelayedTaskList>
     fb0:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <xNumOfOverflows>
     fb4:	8f 5f       	subi	r24, 0xFF	; 255
     fb6:	80 93 cb 07 	sts	0x07CB, r24	; 0x8007cb <xNumOfOverflows>
     fba:	0e 94 04 06 	call	0xc08	; 0xc08 <prvResetNextTaskUnblockTime>
     fbe:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <xNextTaskUnblockTime>
     fc2:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <xNextTaskUnblockTime+0x1>
     fc6:	e8 16       	cp	r14, r24
     fc8:	f9 06       	cpc	r15, r25
     fca:	10 f4       	brcc	.+4      	; 0xfd0 <xTaskIncrementTick+0x78>
     fcc:	d1 2c       	mov	r13, r1
     fce:	53 c0       	rjmp	.+166    	; 0x1076 <xTaskIncrementTick+0x11e>
     fd0:	d1 2c       	mov	r13, r1
     fd2:	cc 24       	eor	r12, r12
     fd4:	c3 94       	inc	r12
     fd6:	e0 91 f3 07 	lds	r30, 0x07F3	; 0x8007f3 <pxDelayedTaskList>
     fda:	f0 91 f4 07 	lds	r31, 0x07F4	; 0x8007f4 <pxDelayedTaskList+0x1>
     fde:	80 81       	ld	r24, Z
     fe0:	81 11       	cpse	r24, r1
     fe2:	07 c0       	rjmp	.+14     	; 0xff2 <xTaskIncrementTick+0x9a>
     fe4:	8f ef       	ldi	r24, 0xFF	; 255
     fe6:	9f ef       	ldi	r25, 0xFF	; 255
     fe8:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <xNextTaskUnblockTime+0x1>
     fec:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <xNextTaskUnblockTime>
     ff0:	42 c0       	rjmp	.+132    	; 0x1076 <xTaskIncrementTick+0x11e>
     ff2:	e0 91 f3 07 	lds	r30, 0x07F3	; 0x8007f3 <pxDelayedTaskList>
     ff6:	f0 91 f4 07 	lds	r31, 0x07F4	; 0x8007f4 <pxDelayedTaskList+0x1>
     ffa:	05 80       	ldd	r0, Z+5	; 0x05
     ffc:	f6 81       	ldd	r31, Z+6	; 0x06
     ffe:	e0 2d       	mov	r30, r0
    1000:	c6 81       	ldd	r28, Z+6	; 0x06
    1002:	d7 81       	ldd	r29, Z+7	; 0x07
    1004:	8a 81       	ldd	r24, Y+2	; 0x02
    1006:	9b 81       	ldd	r25, Y+3	; 0x03
    1008:	e8 16       	cp	r14, r24
    100a:	f9 06       	cpc	r15, r25
    100c:	28 f4       	brcc	.+10     	; 0x1018 <xTaskIncrementTick+0xc0>
    100e:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <xNextTaskUnblockTime+0x1>
    1012:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <xNextTaskUnblockTime>
    1016:	2f c0       	rjmp	.+94     	; 0x1076 <xTaskIncrementTick+0x11e>
    1018:	8e 01       	movw	r16, r28
    101a:	0e 5f       	subi	r16, 0xFE	; 254
    101c:	1f 4f       	sbci	r17, 0xFF	; 255
    101e:	c8 01       	movw	r24, r16
    1020:	0e 94 81 01 	call	0x302	; 0x302 <uxListRemove>
    1024:	8c 89       	ldd	r24, Y+20	; 0x14
    1026:	9d 89       	ldd	r25, Y+21	; 0x15
    1028:	89 2b       	or	r24, r25
    102a:	21 f0       	breq	.+8      	; 0x1034 <xTaskIncrementTick+0xdc>
    102c:	ce 01       	movw	r24, r28
    102e:	0c 96       	adiw	r24, 0x0c	; 12
    1030:	0e 94 81 01 	call	0x302	; 0x302 <uxListRemove>
    1034:	8e 89       	ldd	r24, Y+22	; 0x16
    1036:	90 91 cf 07 	lds	r25, 0x07CF	; 0x8007cf <uxTopReadyPriority>
    103a:	98 17       	cp	r25, r24
    103c:	10 f4       	brcc	.+4      	; 0x1042 <xTaskIncrementTick+0xea>
    103e:	80 93 cf 07 	sts	0x07CF, r24	; 0x8007cf <uxTopReadyPriority>
    1042:	90 e0       	ldi	r25, 0x00	; 0
    1044:	9c 01       	movw	r18, r24
    1046:	22 0f       	add	r18, r18
    1048:	33 1f       	adc	r19, r19
    104a:	22 0f       	add	r18, r18
    104c:	33 1f       	adc	r19, r19
    104e:	22 0f       	add	r18, r18
    1050:	33 1f       	adc	r19, r19
    1052:	82 0f       	add	r24, r18
    1054:	93 1f       	adc	r25, r19
    1056:	b8 01       	movw	r22, r16
    1058:	89 5f       	subi	r24, 0xF9	; 249
    105a:	97 4f       	sbci	r25, 0xF7	; 247
    105c:	0e 94 2f 01 	call	0x25e	; 0x25e <vListInsertEnd>
    1060:	e0 91 22 08 	lds	r30, 0x0822	; 0x800822 <pxCurrentTCB>
    1064:	f0 91 23 08 	lds	r31, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
    1068:	9e 89       	ldd	r25, Y+22	; 0x16
    106a:	86 89       	ldd	r24, Z+22	; 0x16
    106c:	98 17       	cp	r25, r24
    106e:	08 f4       	brcc	.+2      	; 0x1072 <xTaskIncrementTick+0x11a>
    1070:	b2 cf       	rjmp	.-156    	; 0xfd6 <xTaskIncrementTick+0x7e>
    1072:	dc 2c       	mov	r13, r12
    1074:	b0 cf       	rjmp	.-160    	; 0xfd6 <xTaskIncrementTick+0x7e>
    1076:	e0 91 22 08 	lds	r30, 0x0822	; 0x800822 <pxCurrentTCB>
    107a:	f0 91 23 08 	lds	r31, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
    107e:	86 89       	ldd	r24, Z+22	; 0x16
    1080:	90 e0       	ldi	r25, 0x00	; 0
    1082:	fc 01       	movw	r30, r24
    1084:	ee 0f       	add	r30, r30
    1086:	ff 1f       	adc	r31, r31
    1088:	ee 0f       	add	r30, r30
    108a:	ff 1f       	adc	r31, r31
    108c:	ee 0f       	add	r30, r30
    108e:	ff 1f       	adc	r31, r31
    1090:	8e 0f       	add	r24, r30
    1092:	9f 1f       	adc	r25, r31
    1094:	fc 01       	movw	r30, r24
    1096:	e9 5f       	subi	r30, 0xF9	; 249
    1098:	f7 4f       	sbci	r31, 0xF7	; 247
    109a:	80 81       	ld	r24, Z
    109c:	82 30       	cpi	r24, 0x02	; 2
    109e:	48 f0       	brcs	.+18     	; 0x10b2 <xTaskIncrementTick+0x15a>
    10a0:	dd 24       	eor	r13, r13
    10a2:	d3 94       	inc	r13
    10a4:	06 c0       	rjmp	.+12     	; 0x10b2 <xTaskIncrementTick+0x15a>
    10a6:	80 91 cd 07 	lds	r24, 0x07CD	; 0x8007cd <uxPendedTicks>
    10aa:	8f 5f       	subi	r24, 0xFF	; 255
    10ac:	80 93 cd 07 	sts	0x07CD, r24	; 0x8007cd <uxPendedTicks>
    10b0:	d1 2c       	mov	r13, r1
    10b2:	80 91 cc 07 	lds	r24, 0x07CC	; 0x8007cc <xYieldPending>
    10b6:	88 23       	and	r24, r24
    10b8:	11 f0       	breq	.+4      	; 0x10be <xTaskIncrementTick+0x166>
    10ba:	dd 24       	eor	r13, r13
    10bc:	d3 94       	inc	r13
    10be:	8d 2d       	mov	r24, r13
    10c0:	df 91       	pop	r29
    10c2:	cf 91       	pop	r28
    10c4:	1f 91       	pop	r17
    10c6:	0f 91       	pop	r16
    10c8:	ff 90       	pop	r15
    10ca:	ef 90       	pop	r14
    10cc:	df 90       	pop	r13
    10ce:	cf 90       	pop	r12
    10d0:	08 95       	ret

000010d2 <xTaskResumeAll>:
    10d2:	df 92       	push	r13
    10d4:	ef 92       	push	r14
    10d6:	ff 92       	push	r15
    10d8:	0f 93       	push	r16
    10da:	1f 93       	push	r17
    10dc:	cf 93       	push	r28
    10de:	df 93       	push	r29
    10e0:	0f b6       	in	r0, 0x3f	; 63
    10e2:	f8 94       	cli
    10e4:	0f 92       	push	r0
    10e6:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <uxSchedulerSuspended>
    10ea:	81 50       	subi	r24, 0x01	; 1
    10ec:	80 93 c9 07 	sts	0x07C9, r24	; 0x8007c9 <uxSchedulerSuspended>
    10f0:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <uxSchedulerSuspended>
    10f4:	81 11       	cpse	r24, r1
    10f6:	62 c0       	rjmp	.+196    	; 0x11bc <xTaskResumeAll+0xea>
    10f8:	80 91 d2 07 	lds	r24, 0x07D2	; 0x8007d2 <uxCurrentNumberOfTasks>
    10fc:	81 11       	cpse	r24, r1
    10fe:	33 c0       	rjmp	.+102    	; 0x1166 <xTaskResumeAll+0x94>
    1100:	60 c0       	rjmp	.+192    	; 0x11c2 <xTaskResumeAll+0xf0>
    1102:	d7 01       	movw	r26, r14
    1104:	15 96       	adiw	r26, 0x05	; 5
    1106:	ed 91       	ld	r30, X+
    1108:	fc 91       	ld	r31, X
    110a:	16 97       	sbiw	r26, 0x06	; 6
    110c:	c6 81       	ldd	r28, Z+6	; 0x06
    110e:	d7 81       	ldd	r29, Z+7	; 0x07
    1110:	ce 01       	movw	r24, r28
    1112:	0c 96       	adiw	r24, 0x0c	; 12
    1114:	0e 94 81 01 	call	0x302	; 0x302 <uxListRemove>
    1118:	8e 01       	movw	r16, r28
    111a:	0e 5f       	subi	r16, 0xFE	; 254
    111c:	1f 4f       	sbci	r17, 0xFF	; 255
    111e:	c8 01       	movw	r24, r16
    1120:	0e 94 81 01 	call	0x302	; 0x302 <uxListRemove>
    1124:	8e 89       	ldd	r24, Y+22	; 0x16
    1126:	90 91 cf 07 	lds	r25, 0x07CF	; 0x8007cf <uxTopReadyPriority>
    112a:	98 17       	cp	r25, r24
    112c:	10 f4       	brcc	.+4      	; 0x1132 <xTaskResumeAll+0x60>
    112e:	80 93 cf 07 	sts	0x07CF, r24	; 0x8007cf <uxTopReadyPriority>
    1132:	90 e0       	ldi	r25, 0x00	; 0
    1134:	9c 01       	movw	r18, r24
    1136:	22 0f       	add	r18, r18
    1138:	33 1f       	adc	r19, r19
    113a:	22 0f       	add	r18, r18
    113c:	33 1f       	adc	r19, r19
    113e:	22 0f       	add	r18, r18
    1140:	33 1f       	adc	r19, r19
    1142:	82 0f       	add	r24, r18
    1144:	93 1f       	adc	r25, r19
    1146:	b8 01       	movw	r22, r16
    1148:	89 5f       	subi	r24, 0xF9	; 249
    114a:	97 4f       	sbci	r25, 0xF7	; 247
    114c:	0e 94 2f 01 	call	0x25e	; 0x25e <vListInsertEnd>
    1150:	e0 91 22 08 	lds	r30, 0x0822	; 0x800822 <pxCurrentTCB>
    1154:	f0 91 23 08 	lds	r31, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
    1158:	9e 89       	ldd	r25, Y+22	; 0x16
    115a:	86 89       	ldd	r24, Z+22	; 0x16
    115c:	98 17       	cp	r25, r24
    115e:	58 f0       	brcs	.+22     	; 0x1176 <xTaskResumeAll+0xa4>
    1160:	d0 92 cc 07 	sts	0x07CC, r13	; 0x8007cc <xYieldPending>
    1164:	08 c0       	rjmp	.+16     	; 0x1176 <xTaskResumeAll+0xa4>
    1166:	0f 2e       	mov	r0, r31
    1168:	f8 ee       	ldi	r31, 0xE8	; 232
    116a:	ef 2e       	mov	r14, r31
    116c:	f7 e0       	ldi	r31, 0x07	; 7
    116e:	ff 2e       	mov	r15, r31
    1170:	f0 2d       	mov	r31, r0
    1172:	dd 24       	eor	r13, r13
    1174:	d3 94       	inc	r13
    1176:	f7 01       	movw	r30, r14
    1178:	80 81       	ld	r24, Z
    117a:	81 11       	cpse	r24, r1
    117c:	c2 cf       	rjmp	.-124    	; 0x1102 <xTaskResumeAll+0x30>
    117e:	80 91 cd 07 	lds	r24, 0x07CD	; 0x8007cd <uxPendedTicks>
    1182:	88 23       	and	r24, r24
    1184:	99 f0       	breq	.+38     	; 0x11ac <xTaskResumeAll+0xda>
    1186:	80 91 cd 07 	lds	r24, 0x07CD	; 0x8007cd <uxPendedTicks>
    118a:	88 23       	and	r24, r24
    118c:	79 f0       	breq	.+30     	; 0x11ac <xTaskResumeAll+0xda>
    118e:	c1 e0       	ldi	r28, 0x01	; 1
    1190:	0e 94 ac 07 	call	0xf58	; 0xf58 <xTaskIncrementTick>
    1194:	81 11       	cpse	r24, r1
    1196:	c0 93 cc 07 	sts	0x07CC, r28	; 0x8007cc <xYieldPending>
    119a:	80 91 cd 07 	lds	r24, 0x07CD	; 0x8007cd <uxPendedTicks>
    119e:	81 50       	subi	r24, 0x01	; 1
    11a0:	80 93 cd 07 	sts	0x07CD, r24	; 0x8007cd <uxPendedTicks>
    11a4:	80 91 cd 07 	lds	r24, 0x07CD	; 0x8007cd <uxPendedTicks>
    11a8:	81 11       	cpse	r24, r1
    11aa:	f2 cf       	rjmp	.-28     	; 0x1190 <xTaskResumeAll+0xbe>
    11ac:	80 91 cc 07 	lds	r24, 0x07CC	; 0x8007cc <xYieldPending>
    11b0:	81 30       	cpi	r24, 0x01	; 1
    11b2:	31 f4       	brne	.+12     	; 0x11c0 <xTaskResumeAll+0xee>
    11b4:	0e 94 4d 02 	call	0x49a	; 0x49a <vPortYield>
    11b8:	81 e0       	ldi	r24, 0x01	; 1
    11ba:	03 c0       	rjmp	.+6      	; 0x11c2 <xTaskResumeAll+0xf0>
    11bc:	80 e0       	ldi	r24, 0x00	; 0
    11be:	01 c0       	rjmp	.+2      	; 0x11c2 <xTaskResumeAll+0xf0>
    11c0:	80 e0       	ldi	r24, 0x00	; 0
    11c2:	0f 90       	pop	r0
    11c4:	0f be       	out	0x3f, r0	; 63
    11c6:	df 91       	pop	r29
    11c8:	cf 91       	pop	r28
    11ca:	1f 91       	pop	r17
    11cc:	0f 91       	pop	r16
    11ce:	ff 90       	pop	r15
    11d0:	ef 90       	pop	r14
    11d2:	df 90       	pop	r13
    11d4:	08 95       	ret

000011d6 <vTaskDelayUntil>:
    11d6:	0f 93       	push	r16
    11d8:	1f 93       	push	r17
    11da:	cf 93       	push	r28
    11dc:	df 93       	push	r29
    11de:	8c 01       	movw	r16, r24
    11e0:	eb 01       	movw	r28, r22
    11e2:	0e 94 97 07 	call	0xf2e	; 0xf2e <vTaskSuspendAll>
    11e6:	20 91 d0 07 	lds	r18, 0x07D0	; 0x8007d0 <xTickCount>
    11ea:	30 91 d1 07 	lds	r19, 0x07D1	; 0x8007d1 <xTickCount+0x1>
    11ee:	f8 01       	movw	r30, r16
    11f0:	80 81       	ld	r24, Z
    11f2:	91 81       	ldd	r25, Z+1	; 0x01
    11f4:	c8 0f       	add	r28, r24
    11f6:	d9 1f       	adc	r29, r25
    11f8:	28 17       	cp	r18, r24
    11fa:	39 07       	cpc	r19, r25
    11fc:	48 f4       	brcc	.+18     	; 0x1210 <vTaskDelayUntil+0x3a>
    11fe:	c8 17       	cp	r28, r24
    1200:	d9 07       	cpc	r29, r25
    1202:	10 f5       	brcc	.+68     	; 0x1248 <vTaskDelayUntil+0x72>
    1204:	d1 83       	std	Z+1, r29	; 0x01
    1206:	c0 83       	st	Z, r28
    1208:	2c 17       	cp	r18, r28
    120a:	3d 07       	cpc	r19, r29
    120c:	90 f4       	brcc	.+36     	; 0x1232 <vTaskDelayUntil+0x5c>
    120e:	07 c0       	rjmp	.+14     	; 0x121e <vTaskDelayUntil+0x48>
    1210:	c8 17       	cp	r28, r24
    1212:	d9 07       	cpc	r29, r25
    1214:	a8 f0       	brcs	.+42     	; 0x1240 <vTaskDelayUntil+0x6a>
    1216:	2c 17       	cp	r18, r28
    1218:	3d 07       	cpc	r19, r29
    121a:	90 f0       	brcs	.+36     	; 0x1240 <vTaskDelayUntil+0x6a>
    121c:	15 c0       	rjmp	.+42     	; 0x1248 <vTaskDelayUntil+0x72>
    121e:	80 91 22 08 	lds	r24, 0x0822	; 0x800822 <pxCurrentTCB>
    1222:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
    1226:	02 96       	adiw	r24, 0x02	; 2
    1228:	0e 94 81 01 	call	0x302	; 0x302 <uxListRemove>
    122c:	ce 01       	movw	r24, r28
    122e:	0e 94 23 06 	call	0xc46	; 0xc46 <prvAddCurrentTaskToDelayedList>
    1232:	0e 94 69 08 	call	0x10d2	; 0x10d2 <xTaskResumeAll>
    1236:	81 11       	cpse	r24, r1
    1238:	0b c0       	rjmp	.+22     	; 0x1250 <vTaskDelayUntil+0x7a>
    123a:	0e 94 4d 02 	call	0x49a	; 0x49a <vPortYield>
    123e:	08 c0       	rjmp	.+16     	; 0x1250 <vTaskDelayUntil+0x7a>
    1240:	f8 01       	movw	r30, r16
    1242:	d1 83       	std	Z+1, r29	; 0x01
    1244:	c0 83       	st	Z, r28
    1246:	eb cf       	rjmp	.-42     	; 0x121e <vTaskDelayUntil+0x48>
    1248:	f8 01       	movw	r30, r16
    124a:	d1 83       	std	Z+1, r29	; 0x01
    124c:	c0 83       	st	Z, r28
    124e:	f1 cf       	rjmp	.-30     	; 0x1232 <vTaskDelayUntil+0x5c>
    1250:	df 91       	pop	r29
    1252:	cf 91       	pop	r28
    1254:	1f 91       	pop	r17
    1256:	0f 91       	pop	r16
    1258:	08 95       	ret

0000125a <prvIdleTask>:
    125a:	0f ed       	ldi	r16, 0xDF	; 223
    125c:	17 e0       	ldi	r17, 0x07	; 7
    125e:	0f 2e       	mov	r0, r31
    1260:	f7 e0       	ldi	r31, 0x07	; 7
    1262:	ef 2e       	mov	r14, r31
    1264:	f8 e0       	ldi	r31, 0x08	; 8
    1266:	ff 2e       	mov	r15, r31
    1268:	f0 2d       	mov	r31, r0
    126a:	29 c0       	rjmp	.+82     	; 0x12be <prvIdleTask+0x64>
    126c:	0e 94 97 07 	call	0xf2e	; 0xf2e <vTaskSuspendAll>
    1270:	d8 01       	movw	r26, r16
    1272:	cc 91       	ld	r28, X
    1274:	0e 94 69 08 	call	0x10d2	; 0x10d2 <xTaskResumeAll>
    1278:	cc 23       	and	r28, r28
    127a:	09 f1       	breq	.+66     	; 0x12be <prvIdleTask+0x64>
    127c:	0f b6       	in	r0, 0x3f	; 63
    127e:	f8 94       	cli
    1280:	0f 92       	push	r0
    1282:	d8 01       	movw	r26, r16
    1284:	15 96       	adiw	r26, 0x05	; 5
    1286:	ed 91       	ld	r30, X+
    1288:	fc 91       	ld	r31, X
    128a:	16 97       	sbiw	r26, 0x06	; 6
    128c:	c6 81       	ldd	r28, Z+6	; 0x06
    128e:	d7 81       	ldd	r29, Z+7	; 0x07
    1290:	ce 01       	movw	r24, r28
    1292:	02 96       	adiw	r24, 0x02	; 2
    1294:	0e 94 81 01 	call	0x302	; 0x302 <uxListRemove>
    1298:	80 91 d2 07 	lds	r24, 0x07D2	; 0x8007d2 <uxCurrentNumberOfTasks>
    129c:	81 50       	subi	r24, 0x01	; 1
    129e:	80 93 d2 07 	sts	0x07D2, r24	; 0x8007d2 <uxCurrentNumberOfTasks>
    12a2:	80 91 de 07 	lds	r24, 0x07DE	; 0x8007de <uxTasksDeleted>
    12a6:	81 50       	subi	r24, 0x01	; 1
    12a8:	80 93 de 07 	sts	0x07DE, r24	; 0x8007de <uxTasksDeleted>
    12ac:	0f 90       	pop	r0
    12ae:	0f be       	out	0x3f, r0	; 63
    12b0:	8f 89       	ldd	r24, Y+23	; 0x17
    12b2:	98 8d       	ldd	r25, Y+24	; 0x18
    12b4:	0e 94 9f 03 	call	0x73e	; 0x73e <vPortFree>
    12b8:	ce 01       	movw	r24, r28
    12ba:	0e 94 9f 03 	call	0x73e	; 0x73e <vPortFree>
    12be:	80 91 de 07 	lds	r24, 0x07DE	; 0x8007de <uxTasksDeleted>
    12c2:	81 11       	cpse	r24, r1
    12c4:	d3 cf       	rjmp	.-90     	; 0x126c <prvIdleTask+0x12>
    12c6:	f7 01       	movw	r30, r14
    12c8:	80 81       	ld	r24, Z
    12ca:	82 30       	cpi	r24, 0x02	; 2
    12cc:	c0 f3       	brcs	.-16     	; 0x12be <prvIdleTask+0x64>
    12ce:	0e 94 4d 02 	call	0x49a	; 0x49a <vPortYield>
    12d2:	f5 cf       	rjmp	.-22     	; 0x12be <prvIdleTask+0x64>

000012d4 <vTaskSwitchContext>:
    12d4:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <uxSchedulerSuspended>
    12d8:	88 23       	and	r24, r24
    12da:	21 f0       	breq	.+8      	; 0x12e4 <vTaskSwitchContext+0x10>
    12dc:	81 e0       	ldi	r24, 0x01	; 1
    12de:	80 93 cc 07 	sts	0x07CC, r24	; 0x8007cc <xYieldPending>
    12e2:	08 95       	ret
    12e4:	10 92 cc 07 	sts	0x07CC, r1	; 0x8007cc <xYieldPending>
    12e8:	80 91 cf 07 	lds	r24, 0x07CF	; 0x8007cf <uxTopReadyPriority>
    12ec:	90 e0       	ldi	r25, 0x00	; 0
    12ee:	fc 01       	movw	r30, r24
    12f0:	ee 0f       	add	r30, r30
    12f2:	ff 1f       	adc	r31, r31
    12f4:	ee 0f       	add	r30, r30
    12f6:	ff 1f       	adc	r31, r31
    12f8:	ee 0f       	add	r30, r30
    12fa:	ff 1f       	adc	r31, r31
    12fc:	8e 0f       	add	r24, r30
    12fe:	9f 1f       	adc	r25, r31
    1300:	fc 01       	movw	r30, r24
    1302:	e9 5f       	subi	r30, 0xF9	; 249
    1304:	f7 4f       	sbci	r31, 0xF7	; 247
    1306:	80 81       	ld	r24, Z
    1308:	81 11       	cpse	r24, r1
    130a:	17 c0       	rjmp	.+46     	; 0x133a <vTaskSwitchContext+0x66>
    130c:	80 91 cf 07 	lds	r24, 0x07CF	; 0x8007cf <uxTopReadyPriority>
    1310:	81 50       	subi	r24, 0x01	; 1
    1312:	80 93 cf 07 	sts	0x07CF, r24	; 0x8007cf <uxTopReadyPriority>
    1316:	80 91 cf 07 	lds	r24, 0x07CF	; 0x8007cf <uxTopReadyPriority>
    131a:	90 e0       	ldi	r25, 0x00	; 0
    131c:	fc 01       	movw	r30, r24
    131e:	ee 0f       	add	r30, r30
    1320:	ff 1f       	adc	r31, r31
    1322:	ee 0f       	add	r30, r30
    1324:	ff 1f       	adc	r31, r31
    1326:	ee 0f       	add	r30, r30
    1328:	ff 1f       	adc	r31, r31
    132a:	8e 0f       	add	r24, r30
    132c:	9f 1f       	adc	r25, r31
    132e:	fc 01       	movw	r30, r24
    1330:	e9 5f       	subi	r30, 0xF9	; 249
    1332:	f7 4f       	sbci	r31, 0xF7	; 247
    1334:	80 81       	ld	r24, Z
    1336:	88 23       	and	r24, r24
    1338:	49 f3       	breq	.-46     	; 0x130c <vTaskSwitchContext+0x38>
    133a:	80 91 cf 07 	lds	r24, 0x07CF	; 0x8007cf <uxTopReadyPriority>
    133e:	90 e0       	ldi	r25, 0x00	; 0
    1340:	9c 01       	movw	r18, r24
    1342:	22 0f       	add	r18, r18
    1344:	33 1f       	adc	r19, r19
    1346:	22 0f       	add	r18, r18
    1348:	33 1f       	adc	r19, r19
    134a:	22 0f       	add	r18, r18
    134c:	33 1f       	adc	r19, r19
    134e:	28 0f       	add	r18, r24
    1350:	39 1f       	adc	r19, r25
    1352:	d9 01       	movw	r26, r18
    1354:	a9 5f       	subi	r26, 0xF9	; 249
    1356:	b7 4f       	sbci	r27, 0xF7	; 247
    1358:	11 96       	adiw	r26, 0x01	; 1
    135a:	ed 91       	ld	r30, X+
    135c:	fc 91       	ld	r31, X
    135e:	12 97       	sbiw	r26, 0x02	; 2
    1360:	02 80       	ldd	r0, Z+2	; 0x02
    1362:	f3 81       	ldd	r31, Z+3	; 0x03
    1364:	e0 2d       	mov	r30, r0
    1366:	12 96       	adiw	r26, 0x02	; 2
    1368:	fc 93       	st	X, r31
    136a:	ee 93       	st	-X, r30
    136c:	11 97       	sbiw	r26, 0x01	; 1
    136e:	26 5f       	subi	r18, 0xF6	; 246
    1370:	37 4f       	sbci	r19, 0xF7	; 247
    1372:	e2 17       	cp	r30, r18
    1374:	f3 07       	cpc	r31, r19
    1376:	29 f4       	brne	.+10     	; 0x1382 <vTaskSwitchContext+0xae>
    1378:	22 81       	ldd	r18, Z+2	; 0x02
    137a:	33 81       	ldd	r19, Z+3	; 0x03
    137c:	fd 01       	movw	r30, r26
    137e:	32 83       	std	Z+2, r19	; 0x02
    1380:	21 83       	std	Z+1, r18	; 0x01
    1382:	fc 01       	movw	r30, r24
    1384:	ee 0f       	add	r30, r30
    1386:	ff 1f       	adc	r31, r31
    1388:	ee 0f       	add	r30, r30
    138a:	ff 1f       	adc	r31, r31
    138c:	ee 0f       	add	r30, r30
    138e:	ff 1f       	adc	r31, r31
    1390:	8e 0f       	add	r24, r30
    1392:	9f 1f       	adc	r25, r31
    1394:	fc 01       	movw	r30, r24
    1396:	e9 5f       	subi	r30, 0xF9	; 249
    1398:	f7 4f       	sbci	r31, 0xF7	; 247
    139a:	01 80       	ldd	r0, Z+1	; 0x01
    139c:	f2 81       	ldd	r31, Z+2	; 0x02
    139e:	e0 2d       	mov	r30, r0
    13a0:	86 81       	ldd	r24, Z+6	; 0x06
    13a2:	97 81       	ldd	r25, Z+7	; 0x07
    13a4:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <pxCurrentTCB+0x1>
    13a8:	80 93 22 08 	sts	0x0822, r24	; 0x800822 <pxCurrentTCB>
    13ac:	08 95       	ret

000013ae <vTaskPlaceOnEventList>:
    13ae:	cf 93       	push	r28
    13b0:	df 93       	push	r29
    13b2:	eb 01       	movw	r28, r22
    13b4:	60 91 22 08 	lds	r22, 0x0822	; 0x800822 <pxCurrentTCB>
    13b8:	70 91 23 08 	lds	r23, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
    13bc:	64 5f       	subi	r22, 0xF4	; 244
    13be:	7f 4f       	sbci	r23, 0xFF	; 255
    13c0:	0e 94 50 01 	call	0x2a0	; 0x2a0 <vListInsert>
    13c4:	80 91 22 08 	lds	r24, 0x0822	; 0x800822 <pxCurrentTCB>
    13c8:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
    13cc:	02 96       	adiw	r24, 0x02	; 2
    13ce:	0e 94 81 01 	call	0x302	; 0x302 <uxListRemove>
    13d2:	cf 3f       	cpi	r28, 0xFF	; 255
    13d4:	8f ef       	ldi	r24, 0xFF	; 255
    13d6:	d8 07       	cpc	r29, r24
    13d8:	59 f4       	brne	.+22     	; 0x13f0 <vTaskPlaceOnEventList+0x42>
    13da:	60 91 22 08 	lds	r22, 0x0822	; 0x800822 <pxCurrentTCB>
    13de:	70 91 23 08 	lds	r23, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
    13e2:	6e 5f       	subi	r22, 0xFE	; 254
    13e4:	7f 4f       	sbci	r23, 0xFF	; 255
    13e6:	85 ed       	ldi	r24, 0xD5	; 213
    13e8:	97 e0       	ldi	r25, 0x07	; 7
    13ea:	0e 94 2f 01 	call	0x25e	; 0x25e <vListInsertEnd>
    13ee:	08 c0       	rjmp	.+16     	; 0x1400 <vTaskPlaceOnEventList+0x52>
    13f0:	80 91 d0 07 	lds	r24, 0x07D0	; 0x8007d0 <xTickCount>
    13f4:	90 91 d1 07 	lds	r25, 0x07D1	; 0x8007d1 <xTickCount+0x1>
    13f8:	8c 0f       	add	r24, r28
    13fa:	9d 1f       	adc	r25, r29
    13fc:	0e 94 23 06 	call	0xc46	; 0xc46 <prvAddCurrentTaskToDelayedList>
    1400:	df 91       	pop	r29
    1402:	cf 91       	pop	r28
    1404:	08 95       	ret

00001406 <xTaskRemoveFromEventList>:
    1406:	0f 93       	push	r16
    1408:	1f 93       	push	r17
    140a:	cf 93       	push	r28
    140c:	df 93       	push	r29
    140e:	dc 01       	movw	r26, r24
    1410:	15 96       	adiw	r26, 0x05	; 5
    1412:	ed 91       	ld	r30, X+
    1414:	fc 91       	ld	r31, X
    1416:	16 97       	sbiw	r26, 0x06	; 6
    1418:	c6 81       	ldd	r28, Z+6	; 0x06
    141a:	d7 81       	ldd	r29, Z+7	; 0x07
    141c:	8e 01       	movw	r16, r28
    141e:	04 5f       	subi	r16, 0xF4	; 244
    1420:	1f 4f       	sbci	r17, 0xFF	; 255
    1422:	c8 01       	movw	r24, r16
    1424:	0e 94 81 01 	call	0x302	; 0x302 <uxListRemove>
    1428:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <uxSchedulerSuspended>
    142c:	81 11       	cpse	r24, r1
    142e:	1c c0       	rjmp	.+56     	; 0x1468 <xTaskRemoveFromEventList+0x62>
    1430:	0a 50       	subi	r16, 0x0A	; 10
    1432:	11 09       	sbc	r17, r1
    1434:	c8 01       	movw	r24, r16
    1436:	0e 94 81 01 	call	0x302	; 0x302 <uxListRemove>
    143a:	8e 89       	ldd	r24, Y+22	; 0x16
    143c:	90 91 cf 07 	lds	r25, 0x07CF	; 0x8007cf <uxTopReadyPriority>
    1440:	98 17       	cp	r25, r24
    1442:	10 f4       	brcc	.+4      	; 0x1448 <xTaskRemoveFromEventList+0x42>
    1444:	80 93 cf 07 	sts	0x07CF, r24	; 0x8007cf <uxTopReadyPriority>
    1448:	90 e0       	ldi	r25, 0x00	; 0
    144a:	9c 01       	movw	r18, r24
    144c:	22 0f       	add	r18, r18
    144e:	33 1f       	adc	r19, r19
    1450:	22 0f       	add	r18, r18
    1452:	33 1f       	adc	r19, r19
    1454:	22 0f       	add	r18, r18
    1456:	33 1f       	adc	r19, r19
    1458:	82 0f       	add	r24, r18
    145a:	93 1f       	adc	r25, r19
    145c:	b8 01       	movw	r22, r16
    145e:	89 5f       	subi	r24, 0xF9	; 249
    1460:	97 4f       	sbci	r25, 0xF7	; 247
    1462:	0e 94 2f 01 	call	0x25e	; 0x25e <vListInsertEnd>
    1466:	05 c0       	rjmp	.+10     	; 0x1472 <xTaskRemoveFromEventList+0x6c>
    1468:	b8 01       	movw	r22, r16
    146a:	88 ee       	ldi	r24, 0xE8	; 232
    146c:	97 e0       	ldi	r25, 0x07	; 7
    146e:	0e 94 2f 01 	call	0x25e	; 0x25e <vListInsertEnd>
    1472:	e0 91 22 08 	lds	r30, 0x0822	; 0x800822 <pxCurrentTCB>
    1476:	f0 91 23 08 	lds	r31, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
    147a:	9e 89       	ldd	r25, Y+22	; 0x16
    147c:	86 89       	ldd	r24, Z+22	; 0x16
    147e:	89 17       	cp	r24, r25
    1480:	20 f4       	brcc	.+8      	; 0x148a <xTaskRemoveFromEventList+0x84>
    1482:	81 e0       	ldi	r24, 0x01	; 1
    1484:	80 93 cc 07 	sts	0x07CC, r24	; 0x8007cc <xYieldPending>
    1488:	01 c0       	rjmp	.+2      	; 0x148c <xTaskRemoveFromEventList+0x86>
    148a:	80 e0       	ldi	r24, 0x00	; 0
    148c:	df 91       	pop	r29
    148e:	cf 91       	pop	r28
    1490:	1f 91       	pop	r17
    1492:	0f 91       	pop	r16
    1494:	08 95       	ret

00001496 <vTaskSetTimeOutState>:
    1496:	20 91 cb 07 	lds	r18, 0x07CB	; 0x8007cb <xNumOfOverflows>
    149a:	fc 01       	movw	r30, r24
    149c:	20 83       	st	Z, r18
    149e:	20 91 d0 07 	lds	r18, 0x07D0	; 0x8007d0 <xTickCount>
    14a2:	30 91 d1 07 	lds	r19, 0x07D1	; 0x8007d1 <xTickCount+0x1>
    14a6:	32 83       	std	Z+2, r19	; 0x02
    14a8:	21 83       	std	Z+1, r18	; 0x01
    14aa:	08 95       	ret

000014ac <xTaskCheckForTimeOut>:
    14ac:	0f b6       	in	r0, 0x3f	; 63
    14ae:	f8 94       	cli
    14b0:	0f 92       	push	r0
    14b2:	40 91 d0 07 	lds	r20, 0x07D0	; 0x8007d0 <xTickCount>
    14b6:	50 91 d1 07 	lds	r21, 0x07D1	; 0x8007d1 <xTickCount+0x1>
    14ba:	db 01       	movw	r26, r22
    14bc:	2d 91       	ld	r18, X+
    14be:	3c 91       	ld	r19, X
    14c0:	2f 3f       	cpi	r18, 0xFF	; 255
    14c2:	bf ef       	ldi	r27, 0xFF	; 255
    14c4:	3b 07       	cpc	r19, r27
    14c6:	19 f1       	breq	.+70     	; 0x150e <xTaskCheckForTimeOut+0x62>
    14c8:	e0 91 cb 07 	lds	r30, 0x07CB	; 0x8007cb <xNumOfOverflows>
    14cc:	dc 01       	movw	r26, r24
    14ce:	fc 91       	ld	r31, X
    14d0:	fe 17       	cp	r31, r30
    14d2:	39 f0       	breq	.+14     	; 0x14e2 <xTaskCheckForTimeOut+0x36>
    14d4:	11 96       	adiw	r26, 0x01	; 1
    14d6:	ed 91       	ld	r30, X+
    14d8:	fc 91       	ld	r31, X
    14da:	12 97       	sbiw	r26, 0x02	; 2
    14dc:	4e 17       	cp	r20, r30
    14de:	5f 07       	cpc	r21, r31
    14e0:	c0 f4       	brcc	.+48     	; 0x1512 <xTaskCheckForTimeOut+0x66>
    14e2:	dc 01       	movw	r26, r24
    14e4:	11 96       	adiw	r26, 0x01	; 1
    14e6:	ed 91       	ld	r30, X+
    14e8:	fc 91       	ld	r31, X
    14ea:	12 97       	sbiw	r26, 0x02	; 2
    14ec:	da 01       	movw	r26, r20
    14ee:	ae 1b       	sub	r26, r30
    14f0:	bf 0b       	sbc	r27, r31
    14f2:	a2 17       	cp	r26, r18
    14f4:	b3 07       	cpc	r27, r19
    14f6:	78 f4       	brcc	.+30     	; 0x1516 <xTaskCheckForTimeOut+0x6a>
    14f8:	db 01       	movw	r26, r22
    14fa:	e4 1b       	sub	r30, r20
    14fc:	f5 0b       	sbc	r31, r21
    14fe:	2e 0f       	add	r18, r30
    1500:	3f 1f       	adc	r19, r31
    1502:	2d 93       	st	X+, r18
    1504:	3c 93       	st	X, r19
    1506:	0e 94 4b 0a 	call	0x1496	; 0x1496 <vTaskSetTimeOutState>
    150a:	80 e0       	ldi	r24, 0x00	; 0
    150c:	05 c0       	rjmp	.+10     	; 0x1518 <xTaskCheckForTimeOut+0x6c>
    150e:	80 e0       	ldi	r24, 0x00	; 0
    1510:	03 c0       	rjmp	.+6      	; 0x1518 <xTaskCheckForTimeOut+0x6c>
    1512:	81 e0       	ldi	r24, 0x01	; 1
    1514:	01 c0       	rjmp	.+2      	; 0x1518 <xTaskCheckForTimeOut+0x6c>
    1516:	81 e0       	ldi	r24, 0x01	; 1
    1518:	0f 90       	pop	r0
    151a:	0f be       	out	0x3f, r0	; 63
    151c:	08 95       	ret

0000151e <vTaskMissedYield>:
    151e:	81 e0       	ldi	r24, 0x01	; 1
    1520:	80 93 cc 07 	sts	0x07CC, r24	; 0x8007cc <xYieldPending>
    1524:	08 95       	ret

00001526 <vTaskPriorityInherit>:
    1526:	0f 93       	push	r16
    1528:	1f 93       	push	r17
    152a:	cf 93       	push	r28
    152c:	df 93       	push	r29
    152e:	fc 01       	movw	r30, r24
    1530:	89 2b       	or	r24, r25
    1532:	09 f4       	brne	.+2      	; 0x1536 <vTaskPriorityInherit+0x10>
    1534:	55 c0       	rjmp	.+170    	; 0x15e0 <vTaskPriorityInherit+0xba>
    1536:	26 89       	ldd	r18, Z+22	; 0x16
    1538:	a0 91 22 08 	lds	r26, 0x0822	; 0x800822 <pxCurrentTCB>
    153c:	b0 91 23 08 	lds	r27, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
    1540:	56 96       	adiw	r26, 0x16	; 22
    1542:	8c 91       	ld	r24, X
    1544:	28 17       	cp	r18, r24
    1546:	08 f0       	brcs	.+2      	; 0x154a <vTaskPriorityInherit+0x24>
    1548:	4b c0       	rjmp	.+150    	; 0x15e0 <vTaskPriorityInherit+0xba>
    154a:	84 85       	ldd	r24, Z+12	; 0x0c
    154c:	95 85       	ldd	r25, Z+13	; 0x0d
    154e:	99 23       	and	r25, r25
    1550:	64 f0       	brlt	.+24     	; 0x156a <vTaskPriorityInherit+0x44>
    1552:	a0 91 22 08 	lds	r26, 0x0822	; 0x800822 <pxCurrentTCB>
    1556:	b0 91 23 08 	lds	r27, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
    155a:	56 96       	adiw	r26, 0x16	; 22
    155c:	3c 91       	ld	r19, X
    155e:	83 e0       	ldi	r24, 0x03	; 3
    1560:	90 e0       	ldi	r25, 0x00	; 0
    1562:	83 1b       	sub	r24, r19
    1564:	91 09       	sbc	r25, r1
    1566:	95 87       	std	Z+13, r25	; 0x0d
    1568:	84 87       	std	Z+12, r24	; 0x0c
    156a:	30 e0       	ldi	r19, 0x00	; 0
    156c:	c9 01       	movw	r24, r18
    156e:	88 0f       	add	r24, r24
    1570:	99 1f       	adc	r25, r25
    1572:	88 0f       	add	r24, r24
    1574:	99 1f       	adc	r25, r25
    1576:	88 0f       	add	r24, r24
    1578:	99 1f       	adc	r25, r25
    157a:	28 0f       	add	r18, r24
    157c:	39 1f       	adc	r19, r25
    157e:	29 5f       	subi	r18, 0xF9	; 249
    1580:	37 4f       	sbci	r19, 0xF7	; 247
    1582:	82 85       	ldd	r24, Z+10	; 0x0a
    1584:	93 85       	ldd	r25, Z+11	; 0x0b
    1586:	82 17       	cp	r24, r18
    1588:	93 07       	cpc	r25, r19
    158a:	19 f5       	brne	.+70     	; 0x15d2 <vTaskPriorityInherit+0xac>
    158c:	8f 01       	movw	r16, r30
    158e:	ef 01       	movw	r28, r30
    1590:	22 96       	adiw	r28, 0x02	; 2
    1592:	ce 01       	movw	r24, r28
    1594:	0e 94 81 01 	call	0x302	; 0x302 <uxListRemove>
    1598:	e0 91 22 08 	lds	r30, 0x0822	; 0x800822 <pxCurrentTCB>
    159c:	f0 91 23 08 	lds	r31, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
    15a0:	86 89       	ldd	r24, Z+22	; 0x16
    15a2:	f8 01       	movw	r30, r16
    15a4:	86 8b       	std	Z+22, r24	; 0x16
    15a6:	90 91 cf 07 	lds	r25, 0x07CF	; 0x8007cf <uxTopReadyPriority>
    15aa:	98 17       	cp	r25, r24
    15ac:	10 f4       	brcc	.+4      	; 0x15b2 <vTaskPriorityInherit+0x8c>
    15ae:	80 93 cf 07 	sts	0x07CF, r24	; 0x8007cf <uxTopReadyPriority>
    15b2:	90 e0       	ldi	r25, 0x00	; 0
    15b4:	9c 01       	movw	r18, r24
    15b6:	22 0f       	add	r18, r18
    15b8:	33 1f       	adc	r19, r19
    15ba:	22 0f       	add	r18, r18
    15bc:	33 1f       	adc	r19, r19
    15be:	22 0f       	add	r18, r18
    15c0:	33 1f       	adc	r19, r19
    15c2:	82 0f       	add	r24, r18
    15c4:	93 1f       	adc	r25, r19
    15c6:	be 01       	movw	r22, r28
    15c8:	89 5f       	subi	r24, 0xF9	; 249
    15ca:	97 4f       	sbci	r25, 0xF7	; 247
    15cc:	0e 94 2f 01 	call	0x25e	; 0x25e <vListInsertEnd>
    15d0:	07 c0       	rjmp	.+14     	; 0x15e0 <vTaskPriorityInherit+0xba>
    15d2:	a0 91 22 08 	lds	r26, 0x0822	; 0x800822 <pxCurrentTCB>
    15d6:	b0 91 23 08 	lds	r27, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
    15da:	56 96       	adiw	r26, 0x16	; 22
    15dc:	8c 91       	ld	r24, X
    15de:	86 8b       	std	Z+22, r24	; 0x16
    15e0:	df 91       	pop	r29
    15e2:	cf 91       	pop	r28
    15e4:	1f 91       	pop	r17
    15e6:	0f 91       	pop	r16
    15e8:	08 95       	ret

000015ea <xTaskPriorityDisinherit>:
    15ea:	0f 93       	push	r16
    15ec:	1f 93       	push	r17
    15ee:	cf 93       	push	r28
    15f0:	df 93       	push	r29
    15f2:	fc 01       	movw	r30, r24
    15f4:	89 2b       	or	r24, r25
    15f6:	79 f1       	breq	.+94     	; 0x1656 <xTaskPriorityDisinherit+0x6c>
    15f8:	82 a1       	ldd	r24, Z+34	; 0x22
    15fa:	81 50       	subi	r24, 0x01	; 1
    15fc:	82 a3       	std	Z+34, r24	; 0x22
    15fe:	26 89       	ldd	r18, Z+22	; 0x16
    1600:	91 a1       	ldd	r25, Z+33	; 0x21
    1602:	29 17       	cp	r18, r25
    1604:	51 f1       	breq	.+84     	; 0x165a <xTaskPriorityDisinherit+0x70>
    1606:	81 11       	cpse	r24, r1
    1608:	2a c0       	rjmp	.+84     	; 0x165e <xTaskPriorityDisinherit+0x74>
    160a:	ef 01       	movw	r28, r30
    160c:	8f 01       	movw	r16, r30
    160e:	0e 5f       	subi	r16, 0xFE	; 254
    1610:	1f 4f       	sbci	r17, 0xFF	; 255
    1612:	c8 01       	movw	r24, r16
    1614:	0e 94 81 01 	call	0x302	; 0x302 <uxListRemove>
    1618:	89 a1       	ldd	r24, Y+33	; 0x21
    161a:	8e 8b       	std	Y+22, r24	; 0x16
    161c:	23 e0       	ldi	r18, 0x03	; 3
    161e:	30 e0       	ldi	r19, 0x00	; 0
    1620:	28 1b       	sub	r18, r24
    1622:	31 09       	sbc	r19, r1
    1624:	3d 87       	std	Y+13, r19	; 0x0d
    1626:	2c 87       	std	Y+12, r18	; 0x0c
    1628:	90 91 cf 07 	lds	r25, 0x07CF	; 0x8007cf <uxTopReadyPriority>
    162c:	98 17       	cp	r25, r24
    162e:	10 f4       	brcc	.+4      	; 0x1634 <xTaskPriorityDisinherit+0x4a>
    1630:	80 93 cf 07 	sts	0x07CF, r24	; 0x8007cf <uxTopReadyPriority>
    1634:	90 e0       	ldi	r25, 0x00	; 0
    1636:	9c 01       	movw	r18, r24
    1638:	22 0f       	add	r18, r18
    163a:	33 1f       	adc	r19, r19
    163c:	22 0f       	add	r18, r18
    163e:	33 1f       	adc	r19, r19
    1640:	22 0f       	add	r18, r18
    1642:	33 1f       	adc	r19, r19
    1644:	82 0f       	add	r24, r18
    1646:	93 1f       	adc	r25, r19
    1648:	b8 01       	movw	r22, r16
    164a:	89 5f       	subi	r24, 0xF9	; 249
    164c:	97 4f       	sbci	r25, 0xF7	; 247
    164e:	0e 94 2f 01 	call	0x25e	; 0x25e <vListInsertEnd>
    1652:	81 e0       	ldi	r24, 0x01	; 1
    1654:	05 c0       	rjmp	.+10     	; 0x1660 <xTaskPriorityDisinherit+0x76>
    1656:	80 e0       	ldi	r24, 0x00	; 0
    1658:	03 c0       	rjmp	.+6      	; 0x1660 <xTaskPriorityDisinherit+0x76>
    165a:	80 e0       	ldi	r24, 0x00	; 0
    165c:	01 c0       	rjmp	.+2      	; 0x1660 <xTaskPriorityDisinherit+0x76>
    165e:	80 e0       	ldi	r24, 0x00	; 0
    1660:	df 91       	pop	r29
    1662:	cf 91       	pop	r28
    1664:	1f 91       	pop	r17
    1666:	0f 91       	pop	r16
    1668:	08 95       	ret

0000166a <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    166a:	80 91 22 08 	lds	r24, 0x0822	; 0x800822 <pxCurrentTCB>
    166e:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
    1672:	89 2b       	or	r24, r25
    1674:	39 f0       	breq	.+14     	; 0x1684 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1676:	e0 91 22 08 	lds	r30, 0x0822	; 0x800822 <pxCurrentTCB>
    167a:	f0 91 23 08 	lds	r31, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
    167e:	82 a1       	ldd	r24, Z+34	; 0x22
    1680:	8f 5f       	subi	r24, 0xFF	; 255
    1682:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    1684:	80 91 22 08 	lds	r24, 0x0822	; 0x800822 <pxCurrentTCB>
    1688:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <pxCurrentTCB+0x1>
	}
    168c:	08 95       	ret

0000168e <attachInterrupt>:
    #endif
      break;
#endif
    }
      
    intFunc[interruptNum] = 0;
    168e:	82 30       	cpi	r24, 0x02	; 2
    1690:	00 f5       	brcc	.+64     	; 0x16d2 <attachInterrupt+0x44>
    1692:	e8 2f       	mov	r30, r24
    1694:	f0 e0       	ldi	r31, 0x00	; 0
    1696:	ee 0f       	add	r30, r30
    1698:	ff 1f       	adc	r31, r31
    169a:	ec 5d       	subi	r30, 0xDC	; 220
    169c:	f7 4f       	sbci	r31, 0xF7	; 247
    169e:	71 83       	std	Z+1, r23	; 0x01
    16a0:	60 83       	st	Z, r22
    16a2:	88 23       	and	r24, r24
    16a4:	19 f0       	breq	.+6      	; 0x16ac <attachInterrupt+0x1e>
    16a6:	81 30       	cpi	r24, 0x01	; 1
    16a8:	49 f0       	breq	.+18     	; 0x16bc <attachInterrupt+0x2e>
    16aa:	08 95       	ret
    16ac:	e9 e6       	ldi	r30, 0x69	; 105
    16ae:	f0 e0       	ldi	r31, 0x00	; 0
    16b0:	80 81       	ld	r24, Z
    16b2:	8c 7f       	andi	r24, 0xFC	; 252
    16b4:	48 2b       	or	r20, r24
    16b6:	40 83       	st	Z, r20
    16b8:	e8 9a       	sbi	0x1d, 0	; 29
    16ba:	08 95       	ret
    16bc:	e9 e6       	ldi	r30, 0x69	; 105
    16be:	f0 e0       	ldi	r31, 0x00	; 0
    16c0:	80 81       	ld	r24, Z
    16c2:	83 7f       	andi	r24, 0xF3	; 243
    16c4:	44 0f       	add	r20, r20
    16c6:	55 1f       	adc	r21, r21
    16c8:	44 0f       	add	r20, r20
    16ca:	55 1f       	adc	r21, r21
    16cc:	48 2b       	or	r20, r24
    16ce:	40 83       	st	Z, r20
    16d0:	e9 9a       	sbi	0x1d, 1	; 29
    16d2:	08 95       	ret

000016d4 <__vector_1>:
    intFunc[EXTERNAL_INT_7]();
}

#else

ISR(INT0_vect) {
    16d4:	1f 92       	push	r1
    16d6:	0f 92       	push	r0
    16d8:	0f b6       	in	r0, 0x3f	; 63
    16da:	0f 92       	push	r0
    16dc:	11 24       	eor	r1, r1
    16de:	2f 93       	push	r18
    16e0:	3f 93       	push	r19
    16e2:	4f 93       	push	r20
    16e4:	5f 93       	push	r21
    16e6:	6f 93       	push	r22
    16e8:	7f 93       	push	r23
    16ea:	8f 93       	push	r24
    16ec:	9f 93       	push	r25
    16ee:	af 93       	push	r26
    16f0:	bf 93       	push	r27
    16f2:	ef 93       	push	r30
    16f4:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_0])
    16f6:	80 91 24 08 	lds	r24, 0x0824	; 0x800824 <intFunc>
    16fa:	90 91 25 08 	lds	r25, 0x0825	; 0x800825 <intFunc+0x1>
    16fe:	89 2b       	or	r24, r25
    1700:	29 f0       	breq	.+10     	; 0x170c <__vector_1+0x38>
    intFunc[EXTERNAL_INT_0]();
    1702:	e0 91 24 08 	lds	r30, 0x0824	; 0x800824 <intFunc>
    1706:	f0 91 25 08 	lds	r31, 0x0825	; 0x800825 <intFunc+0x1>
    170a:	09 95       	icall
}
    170c:	ff 91       	pop	r31
    170e:	ef 91       	pop	r30
    1710:	bf 91       	pop	r27
    1712:	af 91       	pop	r26
    1714:	9f 91       	pop	r25
    1716:	8f 91       	pop	r24
    1718:	7f 91       	pop	r23
    171a:	6f 91       	pop	r22
    171c:	5f 91       	pop	r21
    171e:	4f 91       	pop	r20
    1720:	3f 91       	pop	r19
    1722:	2f 91       	pop	r18
    1724:	0f 90       	pop	r0
    1726:	0f be       	out	0x3f, r0	; 63
    1728:	0f 90       	pop	r0
    172a:	1f 90       	pop	r1
    172c:	18 95       	reti

0000172e <__vector_2>:

ISR(INT1_vect) {
    172e:	1f 92       	push	r1
    1730:	0f 92       	push	r0
    1732:	0f b6       	in	r0, 0x3f	; 63
    1734:	0f 92       	push	r0
    1736:	11 24       	eor	r1, r1
    1738:	2f 93       	push	r18
    173a:	3f 93       	push	r19
    173c:	4f 93       	push	r20
    173e:	5f 93       	push	r21
    1740:	6f 93       	push	r22
    1742:	7f 93       	push	r23
    1744:	8f 93       	push	r24
    1746:	9f 93       	push	r25
    1748:	af 93       	push	r26
    174a:	bf 93       	push	r27
    174c:	ef 93       	push	r30
    174e:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_1])
    1750:	80 91 26 08 	lds	r24, 0x0826	; 0x800826 <intFunc+0x2>
    1754:	90 91 27 08 	lds	r25, 0x0827	; 0x800827 <intFunc+0x3>
    1758:	89 2b       	or	r24, r25
    175a:	29 f0       	breq	.+10     	; 0x1766 <__vector_2+0x38>
    intFunc[EXTERNAL_INT_1]();
    175c:	e0 91 26 08 	lds	r30, 0x0826	; 0x800826 <intFunc+0x2>
    1760:	f0 91 27 08 	lds	r31, 0x0827	; 0x800827 <intFunc+0x3>
    1764:	09 95       	icall
}
    1766:	ff 91       	pop	r31
    1768:	ef 91       	pop	r30
    176a:	bf 91       	pop	r27
    176c:	af 91       	pop	r26
    176e:	9f 91       	pop	r25
    1770:	8f 91       	pop	r24
    1772:	7f 91       	pop	r23
    1774:	6f 91       	pop	r22
    1776:	5f 91       	pop	r21
    1778:	4f 91       	pop	r20
    177a:	3f 91       	pop	r19
    177c:	2f 91       	pop	r18
    177e:	0f 90       	pop	r0
    1780:	0f be       	out	0x3f, r0	; 63
    1782:	0f 90       	pop	r0
    1784:	1f 90       	pop	r1
    1786:	18 95       	reti

00001788 <USART_init>:



void USART_init(void){
	
	UBRR0H = (uint8_t)(BAUD_PRESCALLER>>8);
    1788:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7f80c5>
	UBRR0L = (uint8_t)(BAUD_PRESCALLER);
    178c:	87 e6       	ldi	r24, 0x67	; 103
    178e:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7f80c4>
	UCSR0B = (1<<RXEN0)|(1<<TXEN0)|(1<<UCSZ02);
    1792:	8c e1       	ldi	r24, 0x1C	; 28
    1794:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7f80c1>
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));
    1798:	86 e0       	ldi	r24, 0x06	; 6
    179a:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7f80c2>
    179e:	08 95       	ret

000017a0 <USART_send>:
	}
}

void USART_send( unsigned char data){
	
	while(!(UCSR0A & (1<<UDRE0)));
    17a0:	e0 ec       	ldi	r30, 0xC0	; 192
    17a2:	f0 e0       	ldi	r31, 0x00	; 0
    17a4:	90 81       	ld	r25, Z
    17a6:	95 ff       	sbrs	r25, 5
    17a8:	fd cf       	rjmp	.-6      	; 0x17a4 <USART_send+0x4>
	UDR0 = data;
    17aa:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7f80c6>
    17ae:	08 95       	ret

000017b0 <USART_sendstr>:
	UCSR0B = (1<<RXEN0)|(1<<TXEN0)|(1<<UCSZ02);
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));
}


void USART_sendstr( unsigned char* str){
    17b0:	cf 93       	push	r28
    17b2:	df 93       	push	r29
    17b4:	ec 01       	movw	r28, r24
	int i =0;
	
	while (str[i] != 0x00)
    17b6:	88 81       	ld	r24, Y
    17b8:	88 23       	and	r24, r24
    17ba:	31 f0       	breq	.+12     	; 0x17c8 <USART_sendstr+0x18>
    17bc:	21 96       	adiw	r28, 0x01	; 1
	{
		USART_send(str[i]);
    17be:	0e 94 d0 0b 	call	0x17a0	; 0x17a0 <USART_send>


void USART_sendstr( unsigned char* str){
	int i =0;
	
	while (str[i] != 0x00)
    17c2:	89 91       	ld	r24, Y+
    17c4:	81 11       	cpse	r24, r1
    17c6:	fb cf       	rjmp	.-10     	; 0x17be <USART_sendstr+0xe>
	{
		USART_send(str[i]);
		i++;
	}
}
    17c8:	df 91       	pop	r29
    17ca:	cf 91       	pop	r28
    17cc:	08 95       	ret

000017ce <memcpy>:
    17ce:	fb 01       	movw	r30, r22
    17d0:	dc 01       	movw	r26, r24
    17d2:	02 c0       	rjmp	.+4      	; 0x17d8 <memcpy+0xa>
    17d4:	01 90       	ld	r0, Z+
    17d6:	0d 92       	st	X+, r0
    17d8:	41 50       	subi	r20, 0x01	; 1
    17da:	50 40       	sbci	r21, 0x00	; 0
    17dc:	d8 f7       	brcc	.-10     	; 0x17d4 <memcpy+0x6>
    17de:	08 95       	ret

000017e0 <_exit>:
    17e0:	f8 94       	cli

000017e2 <__stop_program>:
    17e2:	ff cf       	rjmp	.-2      	; 0x17e2 <__stop_program>

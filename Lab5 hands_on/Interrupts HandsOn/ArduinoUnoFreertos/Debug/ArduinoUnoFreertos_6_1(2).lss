
ArduinoUnoFreertos_6_1(2).elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000e2  00800100  000017ce  00001862  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000017ce  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000655  008001e2  008001e2  00001944  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001944  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001974  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003a8  00000000  00000000  000019b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004444  00000000  00000000  00001d5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000dc8  00000000  00000000  000061a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000015e6  00000000  00000000  00006f68  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000b30  00000000  00000000  00008550  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000014c6  00000000  00000000  00009080  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000045ff  00000000  00000000  0000a546  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000003a0  00000000  00000000  0000eb45  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 5f 0b 	jmp	0x16be	; 0x16be <__vector_1>
       8:	0c 94 8c 0b 	jmp	0x1718	; 0x1718 <__vector_2>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 ef 02 	jmp	0x5de	; 0x5de <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	ee ec       	ldi	r30, 0xCE	; 206
      7c:	f7 e1       	ldi	r31, 0x17	; 23
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a2 3e       	cpi	r26, 0xE2	; 226
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	28 e0       	ldi	r18, 0x08	; 8
      8c:	a2 ee       	ldi	r26, 0xE2	; 226
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a7 33       	cpi	r26, 0x37	; 55
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 db 00 	call	0x1b6	; 0x1b6 <main>
      9e:	0c 94 e5 0b 	jmp	0x17ca	; 0x17ca <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vReceiverTask>:
	}
}


static void vReceiverTask( void *pvParameters )
{
      a6:	cf 93       	push	r28
      a8:	df 93       	push	r29
      aa:	00 d0       	rcall	.+0      	; 0xac <vReceiverTask+0x6>
      ac:	00 d0       	rcall	.+0      	; 0xae <vReceiverTask+0x8>
      ae:	cd b7       	in	r28, 0x3d	; 61
      b0:	de b7       	in	r29, 0x3e	; 62
	/* Declare the variable that will hold the values received from the queue. */
	char * lReceivedValue;
	BaseType_t xStatus;
	const TickType_t xTicksToWait = pdMS_TO_TICKS( 99UL );
	TickType_t xLastWakeTime = xTaskGetTickCount();
      b2:	0e 94 91 07 	call	0xf22	; 0xf22 <xTaskGetTickCount>
      b6:	9c 83       	std	Y+4, r25	; 0x04
      b8:	8b 83       	std	Y+3, r24	; 0x03
	for( ;; )
	{
		if( uxQueueMessagesWaiting( xQueue ) != 0 )
      ba:	80 91 35 08 	lds	r24, 0x0835
      be:	90 91 36 08 	lds	r25, 0x0836
      c2:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <uxQueueMessagesWaiting>
      c6:	88 23       	and	r24, r24
      c8:	21 f0       	breq	.+8      	; 0xd2 <vReceiverTask+0x2c>
		USART_sendstr("Queue should have been empty!\r\n");
      ca:	8e e0       	ldi	r24, 0x0E	; 14
      cc:	91 e0       	ldi	r25, 0x01	; 1
      ce:	0e 94 cd 0b 	call	0x179a	; 0x179a <USART_sendstr>
		
		xStatus = xQueueReceive( xQueue, &lReceivedValue, xTicksToWait );
      d2:	20 e0       	ldi	r18, 0x00	; 0
      d4:	41 e2       	ldi	r20, 0x21	; 33
      d6:	50 e0       	ldi	r21, 0x00	; 0
      d8:	be 01       	movw	r22, r28
      da:	6f 5f       	subi	r22, 0xFF	; 255
      dc:	7f 4f       	sbci	r23, 0xFF	; 255
      de:	80 91 35 08 	lds	r24, 0x0835
      e2:	90 91 36 08 	lds	r25, 0x0836
      e6:	0e 94 28 05 	call	0xa50	; 0xa50 <xQueueGenericReceive>
		if( xStatus == pdPASS )
      ea:	81 30       	cpi	r24, 0x01	; 1
      ec:	69 f4       	brne	.+26     	; 0x108 <vReceiverTask+0x62>
		{
			USART_sendstr("Received= system runs ");
      ee:	8e e2       	ldi	r24, 0x2E	; 46
      f0:	91 e0       	ldi	r25, 0x01	; 1
      f2:	0e 94 cd 0b 	call	0x179a	; 0x179a <USART_sendstr>
			USART_sendstr(lReceivedValue);
      f6:	89 81       	ldd	r24, Y+1	; 0x01
      f8:	9a 81       	ldd	r25, Y+2	; 0x02
      fa:	0e 94 cd 0b 	call	0x179a	; 0x179a <USART_sendstr>
			USART_sendstr( "\r\n");
      fe:	8b e2       	ldi	r24, 0x2B	; 43
     100:	91 e0       	ldi	r25, 0x01	; 1
     102:	0e 94 cd 0b 	call	0x179a	; 0x179a <USART_sendstr>
     106:	04 c0       	rjmp	.+8      	; 0x110 <vReceiverTask+0x6a>
		}
		else
		USART_sendstr("Could not receive from the queue.\r\n" );
     108:	85 e4       	ldi	r24, 0x45	; 69
     10a:	91 e0       	ldi	r25, 0x01	; 1
     10c:	0e 94 cd 0b 	call	0x179a	; 0x179a <USART_sendstr>
		
		vTaskDelayUntil(&xLastWakeTime, (1000 / portTICK_PERIOD_MS));
     110:	68 ee       	ldi	r22, 0xE8	; 232
     112:	73 e0       	ldi	r23, 0x03	; 3
     114:	ce 01       	movw	r24, r28
     116:	03 96       	adiw	r24, 0x03	; 3
     118:	0e 94 df 08 	call	0x11be	; 0x11be <vTaskDelayUntil>
	}
     11c:	ce cf       	rjmp	.-100    	; 0xba <vReceiverTask+0x14>

0000011e <vGetNextTrack>:
static void vGetNextTrack()
{
	char *lValueToSend = NULL;
	BaseType_t xStatus;
	
	if(xTaskGetTickCountFromISR() - lastInterrupt > 500) // we set a 10ms no-interrupts window
     11e:	0e 94 9b 07 	call	0xf36	; 0xf36 <xTaskGetTickCountFromISR>
     122:	40 91 31 08 	lds	r20, 0x0831
     126:	50 91 32 08 	lds	r21, 0x0832
     12a:	60 91 33 08 	lds	r22, 0x0833
     12e:	70 91 34 08 	lds	r23, 0x0834
     132:	a0 e0       	ldi	r26, 0x00	; 0
     134:	b0 e0       	ldi	r27, 0x00	; 0
     136:	84 1b       	sub	r24, r20
     138:	95 0b       	sbc	r25, r21
     13a:	a6 0b       	sbc	r26, r22
     13c:	b7 0b       	sbc	r27, r23
     13e:	85 3f       	cpi	r24, 0xF5	; 245
     140:	91 40       	sbci	r25, 0x01	; 1
     142:	a1 05       	cpc	r26, r1
     144:	b1 05       	cpc	r27, r1
     146:	b0 f1       	brcs	.+108    	; 0x1b4 <vGetNextTrack+0x96>
	{
		// todo #2
		// 1. set lValueToSend to the right track
		lValueToSend=playList[playListIndex];
     148:	e0 91 e2 01 	lds	r30, 0x01E2
     14c:	f0 91 e3 01 	lds	r31, 0x01E3
     150:	ee 0f       	add	r30, r30
     152:	ff 1f       	adc	r31, r31
     154:	e0 50       	subi	r30, 0x00	; 0
     156:	ff 4f       	sbci	r31, 0xFF	; 255
		// 2. send lValueToSend to Queue using appropriate methods 'suffix by FromISR'
		xQueueSendToBackFromISR(xQueue,lValueToSend,0);
     158:	60 81       	ld	r22, Z
     15a:	71 81       	ldd	r23, Z+1	; 0x01
     15c:	20 e0       	ldi	r18, 0x00	; 0
     15e:	40 e0       	ldi	r20, 0x00	; 0
     160:	50 e0       	ldi	r21, 0x00	; 0
     162:	80 91 35 08 	lds	r24, 0x0835
     166:	90 91 36 08 	lds	r25, 0x0836
     16a:	0e 94 f0 04 	call	0x9e0	; 0x9e0 <xQueueGenericSendFromISR>
		
		if( xStatus != pdPASS )
		USART_sendstr("Could not send to the queue.");
     16e:	89 e6       	ldi	r24, 0x69	; 105
     170:	91 e0       	ldi	r25, 0x01	; 1
     172:	0e 94 cd 0b 	call	0x179a	; 0x179a <USART_sendstr>
		
		lastInterrupt = xTaskGetTickCountFromISR();
     176:	0e 94 9b 07 	call	0xf36	; 0xf36 <xTaskGetTickCountFromISR>
     17a:	a0 e0       	ldi	r26, 0x00	; 0
     17c:	b0 e0       	ldi	r27, 0x00	; 0
     17e:	80 93 31 08 	sts	0x0831, r24
     182:	90 93 32 08 	sts	0x0832, r25
     186:	a0 93 33 08 	sts	0x0833, r26
     18a:	b0 93 34 08 	sts	0x0834, r27
		
		playListIndex++;
     18e:	80 91 e2 01 	lds	r24, 0x01E2
     192:	90 91 e3 01 	lds	r25, 0x01E3
     196:	01 96       	adiw	r24, 0x01	; 1
     198:	90 93 e3 01 	sts	0x01E3, r25
     19c:	80 93 e2 01 	sts	0x01E2, r24
		if(playListIndex >= TrackSize)
     1a0:	80 91 e2 01 	lds	r24, 0x01E2
     1a4:	90 91 e3 01 	lds	r25, 0x01E3
     1a8:	05 97       	sbiw	r24, 0x05	; 5
     1aa:	24 f0       	brlt	.+8      	; 0x1b4 <vGetNextTrack+0x96>
		playListIndex = 0;
     1ac:	10 92 e3 01 	sts	0x01E3, r1
     1b0:	10 92 e2 01 	sts	0x01E2, r1
     1b4:	08 95       	ret

000001b6 <main>:
int main(void)
{
	// todo #1
	// 1. disable global interrupt
	// 2. assign vGetNextTrack method to external Int0
	cli();
     1b6:	f8 94       	cli
	attachInterrupt(0,vGetNextTrack,1);
     1b8:	41 e0       	ldi	r20, 0x01	; 1
     1ba:	50 e0       	ldi	r21, 0x00	; 0
     1bc:	6f e8       	ldi	r22, 0x8F	; 143
     1be:	70 e0       	ldi	r23, 0x00	; 0
     1c0:	80 e0       	ldi	r24, 0x00	; 0
     1c2:	0e 94 3c 0b 	call	0x1678	; 0x1678 <attachInterrupt>
	USART_init();
     1c6:	0e 94 b9 0b 	call	0x1772	; 0x1772 <USART_init>
	//sei();
	/* The queue is created to hold a maximum of 5 long values. */
	xQueue = xQueueCreate(5, sizeof(char *));
     1ca:	40 e0       	ldi	r20, 0x00	; 0
     1cc:	62 e0       	ldi	r22, 0x02	; 2
     1ce:	85 e0       	ldi	r24, 0x05	; 5
     1d0:	0e 94 c4 04 	call	0x988	; 0x988 <xQueueGenericCreate>
     1d4:	90 93 36 08 	sts	0x0836, r25
     1d8:	80 93 35 08 	sts	0x0835, r24
	if( xQueue != NULL )
     1dc:	89 2b       	or	r24, r25
     1de:	a9 f0       	breq	.+42     	; 0x20a <main+0x54>
	{
		xTaskCreate(vReceiverTask, "Receiver", 256, NULL, 2, NULL );
     1e0:	a1 2c       	mov	r10, r1
     1e2:	b1 2c       	mov	r11, r1
     1e4:	c1 2c       	mov	r12, r1
     1e6:	d1 2c       	mov	r13, r1
     1e8:	e1 2c       	mov	r14, r1
     1ea:	f1 2c       	mov	r15, r1
     1ec:	02 e0       	ldi	r16, 0x02	; 2
     1ee:	20 e0       	ldi	r18, 0x00	; 0
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	51 e0       	ldi	r21, 0x01	; 1
     1f6:	66 e8       	ldi	r22, 0x86	; 134
     1f8:	71 e0       	ldi	r23, 0x01	; 1
     1fa:	83 e5       	ldi	r24, 0x53	; 83
     1fc:	90 e0       	ldi	r25, 0x00	; 0
     1fe:	0e 94 49 06 	call	0xc92	; 0xc92 <xTaskGenericCreate>
		sei();
     202:	78 94       	sei
		vTaskStartScheduler();
     204:	0e 94 5c 07 	call	0xeb8	; 0xeb8 <vTaskStartScheduler>
     208:	04 c0       	rjmp	.+8      	; 0x212 <main+0x5c>
	}
	else
	USART_sendstr("The queue could not be created");
     20a:	8f e8       	ldi	r24, 0x8F	; 143
     20c:	91 e0       	ldi	r25, 0x01	; 1
     20e:	0e 94 cd 0b 	call	0x179a	; 0x179a <USART_sendstr>

	for( ;; );
     212:	ff cf       	rjmp	.-2      	; 0x212 <main+0x5c>

00000214 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     214:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     216:	03 96       	adiw	r24, 0x03	; 3
     218:	92 83       	std	Z+2, r25	; 0x02
     21a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     21c:	2f ef       	ldi	r18, 0xFF	; 255
     21e:	3f ef       	ldi	r19, 0xFF	; 255
     220:	34 83       	std	Z+4, r19	; 0x04
     222:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     224:	96 83       	std	Z+6, r25	; 0x06
     226:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     228:	90 87       	std	Z+8, r25	; 0x08
     22a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     22c:	10 82       	st	Z, r1
     22e:	08 95       	ret

00000230 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     230:	fc 01       	movw	r30, r24
     232:	11 86       	std	Z+9, r1	; 0x09
     234:	10 86       	std	Z+8, r1	; 0x08
     236:	08 95       	ret

00000238 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     238:	cf 93       	push	r28
     23a:	df 93       	push	r29
     23c:	9c 01       	movw	r18, r24
     23e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     240:	dc 01       	movw	r26, r24
     242:	11 96       	adiw	r26, 0x01	; 1
     244:	cd 91       	ld	r28, X+
     246:	dc 91       	ld	r29, X
     248:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     24a:	d3 83       	std	Z+3, r29	; 0x03
     24c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     24e:	8c 81       	ldd	r24, Y+4	; 0x04
     250:	9d 81       	ldd	r25, Y+5	; 0x05
     252:	95 83       	std	Z+5, r25	; 0x05
     254:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     256:	8c 81       	ldd	r24, Y+4	; 0x04
     258:	9d 81       	ldd	r25, Y+5	; 0x05
     25a:	dc 01       	movw	r26, r24
     25c:	13 96       	adiw	r26, 0x03	; 3
     25e:	7c 93       	st	X, r23
     260:	6e 93       	st	-X, r22
     262:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     264:	7d 83       	std	Y+5, r23	; 0x05
     266:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     268:	31 87       	std	Z+9, r19	; 0x09
     26a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     26c:	f9 01       	movw	r30, r18
     26e:	80 81       	ld	r24, Z
     270:	8f 5f       	subi	r24, 0xFF	; 255
     272:	80 83       	st	Z, r24
}
     274:	df 91       	pop	r29
     276:	cf 91       	pop	r28
     278:	08 95       	ret

0000027a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     27a:	cf 93       	push	r28
     27c:	df 93       	push	r29
     27e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     280:	48 81       	ld	r20, Y
     282:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     284:	4f 3f       	cpi	r20, 0xFF	; 255
     286:	2f ef       	ldi	r18, 0xFF	; 255
     288:	52 07       	cpc	r21, r18
     28a:	21 f4       	brne	.+8      	; 0x294 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     28c:	fc 01       	movw	r30, r24
     28e:	a7 81       	ldd	r26, Z+7	; 0x07
     290:	b0 85       	ldd	r27, Z+8	; 0x08
     292:	0d c0       	rjmp	.+26     	; 0x2ae <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     294:	dc 01       	movw	r26, r24
     296:	13 96       	adiw	r26, 0x03	; 3
     298:	01 c0       	rjmp	.+2      	; 0x29c <vListInsert+0x22>
     29a:	df 01       	movw	r26, r30
     29c:	12 96       	adiw	r26, 0x02	; 2
     29e:	ed 91       	ld	r30, X+
     2a0:	fc 91       	ld	r31, X
     2a2:	13 97       	sbiw	r26, 0x03	; 3
     2a4:	20 81       	ld	r18, Z
     2a6:	31 81       	ldd	r19, Z+1	; 0x01
     2a8:	42 17       	cp	r20, r18
     2aa:	53 07       	cpc	r21, r19
     2ac:	b0 f7       	brcc	.-20     	; 0x29a <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     2ae:	12 96       	adiw	r26, 0x02	; 2
     2b0:	ed 91       	ld	r30, X+
     2b2:	fc 91       	ld	r31, X
     2b4:	13 97       	sbiw	r26, 0x03	; 3
     2b6:	fb 83       	std	Y+3, r31	; 0x03
     2b8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     2ba:	d5 83       	std	Z+5, r29	; 0x05
     2bc:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     2be:	bd 83       	std	Y+5, r27	; 0x05
     2c0:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     2c2:	13 96       	adiw	r26, 0x03	; 3
     2c4:	dc 93       	st	X, r29
     2c6:	ce 93       	st	-X, r28
     2c8:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2ca:	99 87       	std	Y+9, r25	; 0x09
     2cc:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     2ce:	fc 01       	movw	r30, r24
     2d0:	20 81       	ld	r18, Z
     2d2:	2f 5f       	subi	r18, 0xFF	; 255
     2d4:	20 83       	st	Z, r18
}
     2d6:	df 91       	pop	r29
     2d8:	cf 91       	pop	r28
     2da:	08 95       	ret

000002dc <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     2dc:	cf 93       	push	r28
     2de:	df 93       	push	r29
     2e0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     2e2:	a0 85       	ldd	r26, Z+8	; 0x08
     2e4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     2e6:	c2 81       	ldd	r28, Z+2	; 0x02
     2e8:	d3 81       	ldd	r29, Z+3	; 0x03
     2ea:	84 81       	ldd	r24, Z+4	; 0x04
     2ec:	95 81       	ldd	r25, Z+5	; 0x05
     2ee:	9d 83       	std	Y+5, r25	; 0x05
     2f0:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     2f2:	c4 81       	ldd	r28, Z+4	; 0x04
     2f4:	d5 81       	ldd	r29, Z+5	; 0x05
     2f6:	82 81       	ldd	r24, Z+2	; 0x02
     2f8:	93 81       	ldd	r25, Z+3	; 0x03
     2fa:	9b 83       	std	Y+3, r25	; 0x03
     2fc:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     2fe:	11 96       	adiw	r26, 0x01	; 1
     300:	cd 91       	ld	r28, X+
     302:	dc 91       	ld	r29, X
     304:	12 97       	sbiw	r26, 0x02	; 2
     306:	ce 17       	cp	r28, r30
     308:	df 07       	cpc	r29, r31
     30a:	31 f4       	brne	.+12     	; 0x318 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     30c:	8c 81       	ldd	r24, Y+4	; 0x04
     30e:	9d 81       	ldd	r25, Y+5	; 0x05
     310:	12 96       	adiw	r26, 0x02	; 2
     312:	9c 93       	st	X, r25
     314:	8e 93       	st	-X, r24
     316:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     318:	11 86       	std	Z+9, r1	; 0x09
     31a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     31c:	8c 91       	ld	r24, X
     31e:	81 50       	subi	r24, 0x01	; 1
     320:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     322:	df 91       	pop	r29
     324:	cf 91       	pop	r28
     326:	08 95       	ret

00000328 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     328:	31 e1       	ldi	r19, 0x11	; 17
     32a:	fc 01       	movw	r30, r24
     32c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     32e:	31 97       	sbiw	r30, 0x01	; 1
     330:	22 e2       	ldi	r18, 0x22	; 34
     332:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     334:	31 97       	sbiw	r30, 0x01	; 1
     336:	a3 e3       	ldi	r26, 0x33	; 51
     338:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     33a:	31 97       	sbiw	r30, 0x01	; 1
     33c:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     33e:	31 97       	sbiw	r30, 0x01	; 1
     340:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     342:	31 97       	sbiw	r30, 0x01	; 1
     344:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     346:	31 97       	sbiw	r30, 0x01	; 1
     348:	60 e8       	ldi	r22, 0x80	; 128
     34a:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     34c:	31 97       	sbiw	r30, 0x01	; 1
     34e:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     350:	31 97       	sbiw	r30, 0x01	; 1
     352:	62 e0       	ldi	r22, 0x02	; 2
     354:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     356:	31 97       	sbiw	r30, 0x01	; 1
     358:	63 e0       	ldi	r22, 0x03	; 3
     35a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     35c:	31 97       	sbiw	r30, 0x01	; 1
     35e:	64 e0       	ldi	r22, 0x04	; 4
     360:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     362:	31 97       	sbiw	r30, 0x01	; 1
     364:	65 e0       	ldi	r22, 0x05	; 5
     366:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     368:	31 97       	sbiw	r30, 0x01	; 1
     36a:	66 e0       	ldi	r22, 0x06	; 6
     36c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     36e:	31 97       	sbiw	r30, 0x01	; 1
     370:	67 e0       	ldi	r22, 0x07	; 7
     372:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     374:	31 97       	sbiw	r30, 0x01	; 1
     376:	68 e0       	ldi	r22, 0x08	; 8
     378:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     37a:	31 97       	sbiw	r30, 0x01	; 1
     37c:	69 e0       	ldi	r22, 0x09	; 9
     37e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     380:	31 97       	sbiw	r30, 0x01	; 1
     382:	60 e1       	ldi	r22, 0x10	; 16
     384:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     386:	31 97       	sbiw	r30, 0x01	; 1
     388:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     38a:	31 97       	sbiw	r30, 0x01	; 1
     38c:	32 e1       	ldi	r19, 0x12	; 18
     38e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     390:	31 97       	sbiw	r30, 0x01	; 1
     392:	33 e1       	ldi	r19, 0x13	; 19
     394:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     396:	31 97       	sbiw	r30, 0x01	; 1
     398:	34 e1       	ldi	r19, 0x14	; 20
     39a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     39c:	31 97       	sbiw	r30, 0x01	; 1
     39e:	35 e1       	ldi	r19, 0x15	; 21
     3a0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     3a2:	31 97       	sbiw	r30, 0x01	; 1
     3a4:	36 e1       	ldi	r19, 0x16	; 22
     3a6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     3a8:	31 97       	sbiw	r30, 0x01	; 1
     3aa:	37 e1       	ldi	r19, 0x17	; 23
     3ac:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     3ae:	31 97       	sbiw	r30, 0x01	; 1
     3b0:	38 e1       	ldi	r19, 0x18	; 24
     3b2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     3b4:	31 97       	sbiw	r30, 0x01	; 1
     3b6:	39 e1       	ldi	r19, 0x19	; 25
     3b8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     3ba:	31 97       	sbiw	r30, 0x01	; 1
     3bc:	30 e2       	ldi	r19, 0x20	; 32
     3be:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     3c0:	31 97       	sbiw	r30, 0x01	; 1
     3c2:	31 e2       	ldi	r19, 0x21	; 33
     3c4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     3c6:	31 97       	sbiw	r30, 0x01	; 1
     3c8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     3ca:	31 97       	sbiw	r30, 0x01	; 1
     3cc:	23 e2       	ldi	r18, 0x23	; 35
     3ce:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     3d0:	31 97       	sbiw	r30, 0x01	; 1
     3d2:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     3d4:	31 97       	sbiw	r30, 0x01	; 1
     3d6:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     3d8:	31 97       	sbiw	r30, 0x01	; 1
     3da:	26 e2       	ldi	r18, 0x26	; 38
     3dc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     3de:	31 97       	sbiw	r30, 0x01	; 1
     3e0:	27 e2       	ldi	r18, 0x27	; 39
     3e2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     3e4:	31 97       	sbiw	r30, 0x01	; 1
     3e6:	28 e2       	ldi	r18, 0x28	; 40
     3e8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     3ea:	31 97       	sbiw	r30, 0x01	; 1
     3ec:	29 e2       	ldi	r18, 0x29	; 41
     3ee:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     3f0:	31 97       	sbiw	r30, 0x01	; 1
     3f2:	20 e3       	ldi	r18, 0x30	; 48
     3f4:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     3f6:	31 97       	sbiw	r30, 0x01	; 1
     3f8:	21 e3       	ldi	r18, 0x31	; 49
     3fa:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     3fc:	86 97       	sbiw	r24, 0x26	; 38
     3fe:	08 95       	ret

00000400 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     400:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
     404:	8c e7       	ldi	r24, 0x7C	; 124
     406:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     40a:	8b e0       	ldi	r24, 0x0B	; 11
     40c:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     410:	ef e6       	ldi	r30, 0x6F	; 111
     412:	f0 e0       	ldi	r31, 0x00	; 0
     414:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     416:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
     418:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     41a:	a0 91 2b 08 	lds	r26, 0x082B
     41e:	b0 91 2c 08 	lds	r27, 0x082C
     422:	cd 91       	ld	r28, X+
     424:	cd bf       	out	0x3d, r28	; 61
     426:	dd 91       	ld	r29, X+
     428:	de bf       	out	0x3e, r29	; 62
     42a:	ff 91       	pop	r31
     42c:	ef 91       	pop	r30
     42e:	df 91       	pop	r29
     430:	cf 91       	pop	r28
     432:	bf 91       	pop	r27
     434:	af 91       	pop	r26
     436:	9f 91       	pop	r25
     438:	8f 91       	pop	r24
     43a:	7f 91       	pop	r23
     43c:	6f 91       	pop	r22
     43e:	5f 91       	pop	r21
     440:	4f 91       	pop	r20
     442:	3f 91       	pop	r19
     444:	2f 91       	pop	r18
     446:	1f 91       	pop	r17
     448:	0f 91       	pop	r16
     44a:	ff 90       	pop	r15
     44c:	ef 90       	pop	r14
     44e:	df 90       	pop	r13
     450:	cf 90       	pop	r12
     452:	bf 90       	pop	r11
     454:	af 90       	pop	r10
     456:	9f 90       	pop	r9
     458:	8f 90       	pop	r8
     45a:	7f 90       	pop	r7
     45c:	6f 90       	pop	r6
     45e:	5f 90       	pop	r5
     460:	4f 90       	pop	r4
     462:	3f 90       	pop	r3
     464:	2f 90       	pop	r2
     466:	1f 90       	pop	r1
     468:	0f 90       	pop	r0
     46a:	0f be       	out	0x3f, r0	; 63
     46c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     46e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     470:	81 e0       	ldi	r24, 0x01	; 1
     472:	08 95       	ret

00000474 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     474:	0f 92       	push	r0
     476:	0f b6       	in	r0, 0x3f	; 63
     478:	f8 94       	cli
     47a:	0f 92       	push	r0
     47c:	1f 92       	push	r1
     47e:	11 24       	eor	r1, r1
     480:	2f 92       	push	r2
     482:	3f 92       	push	r3
     484:	4f 92       	push	r4
     486:	5f 92       	push	r5
     488:	6f 92       	push	r6
     48a:	7f 92       	push	r7
     48c:	8f 92       	push	r8
     48e:	9f 92       	push	r9
     490:	af 92       	push	r10
     492:	bf 92       	push	r11
     494:	cf 92       	push	r12
     496:	df 92       	push	r13
     498:	ef 92       	push	r14
     49a:	ff 92       	push	r15
     49c:	0f 93       	push	r16
     49e:	1f 93       	push	r17
     4a0:	2f 93       	push	r18
     4a2:	3f 93       	push	r19
     4a4:	4f 93       	push	r20
     4a6:	5f 93       	push	r21
     4a8:	6f 93       	push	r22
     4aa:	7f 93       	push	r23
     4ac:	8f 93       	push	r24
     4ae:	9f 93       	push	r25
     4b0:	af 93       	push	r26
     4b2:	bf 93       	push	r27
     4b4:	cf 93       	push	r28
     4b6:	df 93       	push	r29
     4b8:	ef 93       	push	r30
     4ba:	ff 93       	push	r31
     4bc:	a0 91 2b 08 	lds	r26, 0x082B
     4c0:	b0 91 2c 08 	lds	r27, 0x082C
     4c4:	0d b6       	in	r0, 0x3d	; 61
     4c6:	0d 92       	st	X+, r0
     4c8:	0e b6       	in	r0, 0x3e	; 62
     4ca:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     4cc:	0e 94 5e 09 	call	0x12bc	; 0x12bc <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     4d0:	a0 91 2b 08 	lds	r26, 0x082B
     4d4:	b0 91 2c 08 	lds	r27, 0x082C
     4d8:	cd 91       	ld	r28, X+
     4da:	cd bf       	out	0x3d, r28	; 61
     4dc:	dd 91       	ld	r29, X+
     4de:	de bf       	out	0x3e, r29	; 62
     4e0:	ff 91       	pop	r31
     4e2:	ef 91       	pop	r30
     4e4:	df 91       	pop	r29
     4e6:	cf 91       	pop	r28
     4e8:	bf 91       	pop	r27
     4ea:	af 91       	pop	r26
     4ec:	9f 91       	pop	r25
     4ee:	8f 91       	pop	r24
     4f0:	7f 91       	pop	r23
     4f2:	6f 91       	pop	r22
     4f4:	5f 91       	pop	r21
     4f6:	4f 91       	pop	r20
     4f8:	3f 91       	pop	r19
     4fa:	2f 91       	pop	r18
     4fc:	1f 91       	pop	r17
     4fe:	0f 91       	pop	r16
     500:	ff 90       	pop	r15
     502:	ef 90       	pop	r14
     504:	df 90       	pop	r13
     506:	cf 90       	pop	r12
     508:	bf 90       	pop	r11
     50a:	af 90       	pop	r10
     50c:	9f 90       	pop	r9
     50e:	8f 90       	pop	r8
     510:	7f 90       	pop	r7
     512:	6f 90       	pop	r6
     514:	5f 90       	pop	r5
     516:	4f 90       	pop	r4
     518:	3f 90       	pop	r3
     51a:	2f 90       	pop	r2
     51c:	1f 90       	pop	r1
     51e:	0f 90       	pop	r0
     520:	0f be       	out	0x3f, r0	; 63
     522:	0f 90       	pop	r0

	asm volatile ( "ret" );
     524:	08 95       	ret

00000526 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     526:	0f 92       	push	r0
     528:	0f b6       	in	r0, 0x3f	; 63
     52a:	f8 94       	cli
     52c:	0f 92       	push	r0
     52e:	1f 92       	push	r1
     530:	11 24       	eor	r1, r1
     532:	2f 92       	push	r2
     534:	3f 92       	push	r3
     536:	4f 92       	push	r4
     538:	5f 92       	push	r5
     53a:	6f 92       	push	r6
     53c:	7f 92       	push	r7
     53e:	8f 92       	push	r8
     540:	9f 92       	push	r9
     542:	af 92       	push	r10
     544:	bf 92       	push	r11
     546:	cf 92       	push	r12
     548:	df 92       	push	r13
     54a:	ef 92       	push	r14
     54c:	ff 92       	push	r15
     54e:	0f 93       	push	r16
     550:	1f 93       	push	r17
     552:	2f 93       	push	r18
     554:	3f 93       	push	r19
     556:	4f 93       	push	r20
     558:	5f 93       	push	r21
     55a:	6f 93       	push	r22
     55c:	7f 93       	push	r23
     55e:	8f 93       	push	r24
     560:	9f 93       	push	r25
     562:	af 93       	push	r26
     564:	bf 93       	push	r27
     566:	cf 93       	push	r28
     568:	df 93       	push	r29
     56a:	ef 93       	push	r30
     56c:	ff 93       	push	r31
     56e:	a0 91 2b 08 	lds	r26, 0x082B
     572:	b0 91 2c 08 	lds	r27, 0x082C
     576:	0d b6       	in	r0, 0x3d	; 61
     578:	0d 92       	st	X+, r0
     57a:	0e b6       	in	r0, 0x3e	; 62
     57c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     57e:	0e 94 a0 07 	call	0xf40	; 0xf40 <xTaskIncrementTick>
     582:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     584:	0e 94 5e 09 	call	0x12bc	; 0x12bc <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     588:	a0 91 2b 08 	lds	r26, 0x082B
     58c:	b0 91 2c 08 	lds	r27, 0x082C
     590:	cd 91       	ld	r28, X+
     592:	cd bf       	out	0x3d, r28	; 61
     594:	dd 91       	ld	r29, X+
     596:	de bf       	out	0x3e, r29	; 62
     598:	ff 91       	pop	r31
     59a:	ef 91       	pop	r30
     59c:	df 91       	pop	r29
     59e:	cf 91       	pop	r28
     5a0:	bf 91       	pop	r27
     5a2:	af 91       	pop	r26
     5a4:	9f 91       	pop	r25
     5a6:	8f 91       	pop	r24
     5a8:	7f 91       	pop	r23
     5aa:	6f 91       	pop	r22
     5ac:	5f 91       	pop	r21
     5ae:	4f 91       	pop	r20
     5b0:	3f 91       	pop	r19
     5b2:	2f 91       	pop	r18
     5b4:	1f 91       	pop	r17
     5b6:	0f 91       	pop	r16
     5b8:	ff 90       	pop	r15
     5ba:	ef 90       	pop	r14
     5bc:	df 90       	pop	r13
     5be:	cf 90       	pop	r12
     5c0:	bf 90       	pop	r11
     5c2:	af 90       	pop	r10
     5c4:	9f 90       	pop	r9
     5c6:	8f 90       	pop	r8
     5c8:	7f 90       	pop	r7
     5ca:	6f 90       	pop	r6
     5cc:	5f 90       	pop	r5
     5ce:	4f 90       	pop	r4
     5d0:	3f 90       	pop	r3
     5d2:	2f 90       	pop	r2
     5d4:	1f 90       	pop	r1
     5d6:	0f 90       	pop	r0
     5d8:	0f be       	out	0x3f, r0	; 63
     5da:	0f 90       	pop	r0

	asm volatile ( "ret" );
     5dc:	08 95       	ret

000005de <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect(void) __attribute__ ((signal, naked));
	void TIMER1_COMPA_vect(void)
	{
		vPortYieldFromTick();
     5de:	0e 94 93 02 	call	0x526	; 0x526 <vPortYieldFromTick>
		asm volatile ( "reti" );
     5e2:	18 95       	reti

000005e4 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     5e4:	0f 93       	push	r16
     5e6:	1f 93       	push	r17
     5e8:	cf 93       	push	r28
     5ea:	df 93       	push	r29
     5ec:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
     5ee:	0e 94 8b 07 	call	0xf16	; 0xf16 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
     5f2:	80 91 e4 01 	lds	r24, 0x01E4
     5f6:	81 11       	cpse	r24, r1
     5f8:	1d c0       	rjmp	.+58     	; 0x634 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     5fa:	e9 ee       	ldi	r30, 0xE9	; 233
     5fc:	f1 e0       	ldi	r31, 0x01	; 1
     5fe:	8e ee       	ldi	r24, 0xEE	; 238
     600:	91 e0       	ldi	r25, 0x01	; 1
     602:	91 83       	std	Z+1, r25	; 0x01
     604:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
     606:	13 82       	std	Z+3, r1	; 0x03
     608:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
     60a:	e5 ee       	ldi	r30, 0xE5	; 229
     60c:	f1 e0       	ldi	r31, 0x01	; 1
     60e:	8b ed       	ldi	r24, 0xDB	; 219
     610:	95 e0       	ldi	r25, 0x05	; 5
     612:	93 83       	std	Z+3, r25	; 0x03
     614:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
     616:	11 82       	std	Z+1, r1	; 0x01
     618:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
     61a:	ad ee       	ldi	r26, 0xED	; 237
     61c:	b1 e0       	ldi	r27, 0x01	; 1
     61e:	14 96       	adiw	r26, 0x04	; 4
     620:	9c 93       	st	X, r25
     622:	8e 93       	st	-X, r24
     624:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
     626:	12 96       	adiw	r26, 0x02	; 2
     628:	fc 93       	st	X, r31
     62a:	ee 93       	st	-X, r30
     62c:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
     62e:	81 e0       	ldi	r24, 0x01	; 1
     630:	80 93 e4 01 	sts	0x01E4, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
     634:	20 97       	sbiw	r28, 0x00	; 0
     636:	09 f4       	brne	.+2      	; 0x63a <pvPortMalloc+0x56>
     638:	5f c0       	rjmp	.+190    	; 0x6f8 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
     63a:	9e 01       	movw	r18, r28
     63c:	2c 5f       	subi	r18, 0xFC	; 252
     63e:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
     640:	23 96       	adiw	r28, 0x03	; 3
     642:	ca 3d       	cpi	r28, 0xDA	; 218
     644:	d5 40       	sbci	r29, 0x05	; 5
     646:	08 f0       	brcs	.+2      	; 0x64a <pvPortMalloc+0x66>
     648:	5a c0       	rjmp	.+180    	; 0x6fe <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
     64a:	e0 91 e9 01 	lds	r30, 0x01E9
     64e:	f0 91 ea 01 	lds	r31, 0x01EA

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
     652:	a9 ee       	ldi	r26, 0xE9	; 233
     654:	b1 e0       	ldi	r27, 0x01	; 1
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     656:	02 c0       	rjmp	.+4      	; 0x65c <pvPortMalloc+0x78>
     658:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
     65a:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     65c:	82 81       	ldd	r24, Z+2	; 0x02
     65e:	93 81       	ldd	r25, Z+3	; 0x03
     660:	82 17       	cp	r24, r18
     662:	93 07       	cpc	r25, r19
     664:	20 f4       	brcc	.+8      	; 0x66e <pvPortMalloc+0x8a>
     666:	80 81       	ld	r24, Z
     668:	91 81       	ldd	r25, Z+1	; 0x01
     66a:	00 97       	sbiw	r24, 0x00	; 0
     66c:	a9 f7       	brne	.-22     	; 0x658 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
     66e:	c1 e0       	ldi	r28, 0x01	; 1
     670:	e5 3e       	cpi	r30, 0xE5	; 229
     672:	fc 07       	cpc	r31, r28
     674:	09 f4       	brne	.+2      	; 0x678 <pvPortMalloc+0x94>
     676:	46 c0       	rjmp	.+140    	; 0x704 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
     678:	cd 91       	ld	r28, X+
     67a:	dc 91       	ld	r29, X
     67c:	11 97       	sbiw	r26, 0x01	; 1
     67e:	8e 01       	movw	r16, r28
     680:	0c 5f       	subi	r16, 0xFC	; 252
     682:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     684:	80 81       	ld	r24, Z
     686:	91 81       	ldd	r25, Z+1	; 0x01
     688:	8d 93       	st	X+, r24
     68a:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     68c:	82 81       	ldd	r24, Z+2	; 0x02
     68e:	93 81       	ldd	r25, Z+3	; 0x03
     690:	82 1b       	sub	r24, r18
     692:	93 0b       	sbc	r25, r19
     694:	89 30       	cpi	r24, 0x09	; 9
     696:	91 05       	cpc	r25, r1
     698:	10 f1       	brcs	.+68     	; 0x6de <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     69a:	bf 01       	movw	r22, r30
     69c:	62 0f       	add	r22, r18
     69e:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     6a0:	db 01       	movw	r26, r22
     6a2:	13 96       	adiw	r26, 0x03	; 3
     6a4:	9c 93       	st	X, r25
     6a6:	8e 93       	st	-X, r24
     6a8:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
     6aa:	33 83       	std	Z+3, r19	; 0x03
     6ac:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
     6ae:	12 96       	adiw	r26, 0x02	; 2
     6b0:	4d 91       	ld	r20, X+
     6b2:	5c 91       	ld	r21, X
     6b4:	13 97       	sbiw	r26, 0x03	; 3
     6b6:	89 ee       	ldi	r24, 0xE9	; 233
     6b8:	91 e0       	ldi	r25, 0x01	; 1
     6ba:	01 c0       	rjmp	.+2      	; 0x6be <pvPortMalloc+0xda>
     6bc:	cd 01       	movw	r24, r26
     6be:	ec 01       	movw	r28, r24
     6c0:	a8 81       	ld	r26, Y
     6c2:	b9 81       	ldd	r27, Y+1	; 0x01
     6c4:	12 96       	adiw	r26, 0x02	; 2
     6c6:	2d 91       	ld	r18, X+
     6c8:	3c 91       	ld	r19, X
     6ca:	13 97       	sbiw	r26, 0x03	; 3
     6cc:	24 17       	cp	r18, r20
     6ce:	35 07       	cpc	r19, r21
     6d0:	a8 f3       	brcs	.-22     	; 0x6bc <pvPortMalloc+0xd8>
     6d2:	eb 01       	movw	r28, r22
     6d4:	b9 83       	std	Y+1, r27	; 0x01
     6d6:	a8 83       	st	Y, r26
     6d8:	dc 01       	movw	r26, r24
     6da:	6d 93       	st	X+, r22
     6dc:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
     6de:	80 91 0a 01 	lds	r24, 0x010A
     6e2:	90 91 0b 01 	lds	r25, 0x010B
     6e6:	22 81       	ldd	r18, Z+2	; 0x02
     6e8:	33 81       	ldd	r19, Z+3	; 0x03
     6ea:	82 1b       	sub	r24, r18
     6ec:	93 0b       	sbc	r25, r19
     6ee:	90 93 0b 01 	sts	0x010B, r25
     6f2:	80 93 0a 01 	sts	0x010A, r24
     6f6:	08 c0       	rjmp	.+16     	; 0x708 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
     6f8:	00 e0       	ldi	r16, 0x00	; 0
     6fa:	10 e0       	ldi	r17, 0x00	; 0
     6fc:	05 c0       	rjmp	.+10     	; 0x708 <pvPortMalloc+0x124>
     6fe:	00 e0       	ldi	r16, 0x00	; 0
     700:	10 e0       	ldi	r17, 0x00	; 0
     702:	02 c0       	rjmp	.+4      	; 0x708 <pvPortMalloc+0x124>
     704:	00 e0       	ldi	r16, 0x00	; 0
     706:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     708:	0e 94 5d 08 	call	0x10ba	; 0x10ba <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     70c:	c8 01       	movw	r24, r16
     70e:	df 91       	pop	r29
     710:	cf 91       	pop	r28
     712:	1f 91       	pop	r17
     714:	0f 91       	pop	r16
     716:	08 95       	ret

00000718 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     718:	0f 93       	push	r16
     71a:	1f 93       	push	r17
     71c:	cf 93       	push	r28
     71e:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     720:	00 97       	sbiw	r24, 0x00	; 0
     722:	41 f1       	breq	.+80     	; 0x774 <vPortFree+0x5c>
     724:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
     726:	8c 01       	movw	r16, r24
     728:	04 50       	subi	r16, 0x04	; 4
     72a:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
     72c:	0e 94 8b 07 	call	0xf16	; 0xf16 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     730:	f8 01       	movw	r30, r16
     732:	42 81       	ldd	r20, Z+2	; 0x02
     734:	53 81       	ldd	r21, Z+3	; 0x03
     736:	a9 ee       	ldi	r26, 0xE9	; 233
     738:	b1 e0       	ldi	r27, 0x01	; 1
     73a:	01 c0       	rjmp	.+2      	; 0x73e <vPortFree+0x26>
     73c:	df 01       	movw	r26, r30
     73e:	ed 91       	ld	r30, X+
     740:	fc 91       	ld	r31, X
     742:	11 97       	sbiw	r26, 0x01	; 1
     744:	22 81       	ldd	r18, Z+2	; 0x02
     746:	33 81       	ldd	r19, Z+3	; 0x03
     748:	24 17       	cp	r18, r20
     74a:	35 07       	cpc	r19, r21
     74c:	b8 f3       	brcs	.-18     	; 0x73c <vPortFree+0x24>
     74e:	24 97       	sbiw	r28, 0x04	; 4
     750:	f9 83       	std	Y+1, r31	; 0x01
     752:	e8 83       	st	Y, r30
     754:	0d 93       	st	X+, r16
     756:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
     758:	20 91 0a 01 	lds	r18, 0x010A
     75c:	30 91 0b 01 	lds	r19, 0x010B
     760:	8a 81       	ldd	r24, Y+2	; 0x02
     762:	9b 81       	ldd	r25, Y+3	; 0x03
     764:	82 0f       	add	r24, r18
     766:	93 1f       	adc	r25, r19
     768:	90 93 0b 01 	sts	0x010B, r25
     76c:	80 93 0a 01 	sts	0x010A, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
     770:	0e 94 5d 08 	call	0x10ba	; 0x10ba <xTaskResumeAll>
	}
}
     774:	df 91       	pop	r29
     776:	cf 91       	pop	r28
     778:	1f 91       	pop	r17
     77a:	0f 91       	pop	r16
     77c:	08 95       	ret

0000077e <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     77e:	1f 93       	push	r17
     780:	cf 93       	push	r28
     782:	df 93       	push	r29
     784:	ec 01       	movw	r28, r24
     786:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     788:	8c 8d       	ldd	r24, Y+28	; 0x1c
     78a:	81 11       	cpse	r24, r1
     78c:	0c c0       	rjmp	.+24     	; 0x7a6 <prvCopyDataToQueue+0x28>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     78e:	88 81       	ld	r24, Y
     790:	99 81       	ldd	r25, Y+1	; 0x01
     792:	89 2b       	or	r24, r25
     794:	09 f0       	breq	.+2      	; 0x798 <prvCopyDataToQueue+0x1a>
     796:	47 c0       	rjmp	.+142    	; 0x826 <prvCopyDataToQueue+0xa8>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
     798:	8a 81       	ldd	r24, Y+2	; 0x02
     79a:	9b 81       	ldd	r25, Y+3	; 0x03
     79c:	0e 94 ea 0a 	call	0x15d4	; 0x15d4 <xTaskPriorityDisinherit>
				pxQueue->pxMutexHolder = NULL;
     7a0:	1b 82       	std	Y+3, r1	; 0x03
     7a2:	1a 82       	std	Y+2, r1	; 0x02
     7a4:	47 c0       	rjmp	.+142    	; 0x834 <prvCopyDataToQueue+0xb6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     7a6:	41 11       	cpse	r20, r1
     7a8:	18 c0       	rjmp	.+48     	; 0x7da <prvCopyDataToQueue+0x5c>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     7aa:	48 2f       	mov	r20, r24
     7ac:	50 e0       	ldi	r21, 0x00	; 0
     7ae:	8c 81       	ldd	r24, Y+4	; 0x04
     7b0:	9d 81       	ldd	r25, Y+5	; 0x05
     7b2:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     7b6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     7b8:	8c 81       	ldd	r24, Y+4	; 0x04
     7ba:	9d 81       	ldd	r25, Y+5	; 0x05
     7bc:	82 0f       	add	r24, r18
     7be:	91 1d       	adc	r25, r1
     7c0:	9d 83       	std	Y+5, r25	; 0x05
     7c2:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     7c4:	2a 81       	ldd	r18, Y+2	; 0x02
     7c6:	3b 81       	ldd	r19, Y+3	; 0x03
     7c8:	82 17       	cp	r24, r18
     7ca:	93 07       	cpc	r25, r19
     7cc:	70 f1       	brcs	.+92     	; 0x82a <prvCopyDataToQueue+0xac>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     7ce:	88 81       	ld	r24, Y
     7d0:	99 81       	ldd	r25, Y+1	; 0x01
     7d2:	9d 83       	std	Y+5, r25	; 0x05
     7d4:	8c 83       	std	Y+4, r24	; 0x04
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     7d6:	80 e0       	ldi	r24, 0x00	; 0
     7d8:	2d c0       	rjmp	.+90     	; 0x834 <prvCopyDataToQueue+0xb6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     7da:	48 2f       	mov	r20, r24
     7dc:	50 e0       	ldi	r21, 0x00	; 0
     7de:	8e 81       	ldd	r24, Y+6	; 0x06
     7e0:	9f 81       	ldd	r25, Y+7	; 0x07
     7e2:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     7e6:	8c 8d       	ldd	r24, Y+28	; 0x1c
     7e8:	90 e0       	ldi	r25, 0x00	; 0
     7ea:	91 95       	neg	r25
     7ec:	81 95       	neg	r24
     7ee:	91 09       	sbc	r25, r1
     7f0:	2e 81       	ldd	r18, Y+6	; 0x06
     7f2:	3f 81       	ldd	r19, Y+7	; 0x07
     7f4:	28 0f       	add	r18, r24
     7f6:	39 1f       	adc	r19, r25
     7f8:	3f 83       	std	Y+7, r19	; 0x07
     7fa:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     7fc:	48 81       	ld	r20, Y
     7fe:	59 81       	ldd	r21, Y+1	; 0x01
     800:	24 17       	cp	r18, r20
     802:	35 07       	cpc	r19, r21
     804:	30 f4       	brcc	.+12     	; 0x812 <prvCopyDataToQueue+0x94>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     806:	2a 81       	ldd	r18, Y+2	; 0x02
     808:	3b 81       	ldd	r19, Y+3	; 0x03
     80a:	82 0f       	add	r24, r18
     80c:	93 1f       	adc	r25, r19
     80e:	9f 83       	std	Y+7, r25	; 0x07
     810:	8e 83       	std	Y+6, r24	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     812:	12 30       	cpi	r17, 0x02	; 2
     814:	61 f4       	brne	.+24     	; 0x82e <prvCopyDataToQueue+0xb0>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     816:	8a 8d       	ldd	r24, Y+26	; 0x1a
     818:	88 23       	and	r24, r24
     81a:	59 f0       	breq	.+22     	; 0x832 <prvCopyDataToQueue+0xb4>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
     81c:	8a 8d       	ldd	r24, Y+26	; 0x1a
     81e:	81 50       	subi	r24, 0x01	; 1
     820:	8a 8f       	std	Y+26, r24	; 0x1a
#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
BaseType_t xReturn = pdFALSE;
     822:	80 e0       	ldi	r24, 0x00	; 0
     824:	07 c0       	rjmp	.+14     	; 0x834 <prvCopyDataToQueue+0xb6>
     826:	80 e0       	ldi	r24, 0x00	; 0
     828:	05 c0       	rjmp	.+10     	; 0x834 <prvCopyDataToQueue+0xb6>
     82a:	80 e0       	ldi	r24, 0x00	; 0
     82c:	03 c0       	rjmp	.+6      	; 0x834 <prvCopyDataToQueue+0xb6>
     82e:	80 e0       	ldi	r24, 0x00	; 0
     830:	01 c0       	rjmp	.+2      	; 0x834 <prvCopyDataToQueue+0xb6>
     832:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
     834:	9a 8d       	ldd	r25, Y+26	; 0x1a
     836:	9f 5f       	subi	r25, 0xFF	; 255
     838:	9a 8f       	std	Y+26, r25	; 0x1a

	return xReturn;
}
     83a:	df 91       	pop	r29
     83c:	cf 91       	pop	r28
     83e:	1f 91       	pop	r17
     840:	08 95       	ret

00000842 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     842:	fc 01       	movw	r30, r24
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     844:	44 8d       	ldd	r20, Z+28	; 0x1c
     846:	44 23       	and	r20, r20
     848:	a9 f0       	breq	.+42     	; 0x874 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     84a:	50 e0       	ldi	r21, 0x00	; 0
     84c:	26 81       	ldd	r18, Z+6	; 0x06
     84e:	37 81       	ldd	r19, Z+7	; 0x07
     850:	24 0f       	add	r18, r20
     852:	35 1f       	adc	r19, r21
     854:	37 83       	std	Z+7, r19	; 0x07
     856:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     858:	82 81       	ldd	r24, Z+2	; 0x02
     85a:	93 81       	ldd	r25, Z+3	; 0x03
     85c:	28 17       	cp	r18, r24
     85e:	39 07       	cpc	r19, r25
     860:	20 f0       	brcs	.+8      	; 0x86a <prvCopyDataFromQueue+0x28>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     862:	80 81       	ld	r24, Z
     864:	91 81       	ldd	r25, Z+1	; 0x01
     866:	97 83       	std	Z+7, r25	; 0x07
     868:	86 83       	std	Z+6, r24	; 0x06
     86a:	cb 01       	movw	r24, r22
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     86c:	66 81       	ldd	r22, Z+6	; 0x06
     86e:	77 81       	ldd	r23, Z+7	; 0x07
     870:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <memcpy>
     874:	08 95       	ret

00000876 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     876:	0f 93       	push	r16
     878:	1f 93       	push	r17
     87a:	cf 93       	push	r28
     87c:	df 93       	push	r29
     87e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     880:	0f b6       	in	r0, 0x3f	; 63
     882:	f8 94       	cli
     884:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     886:	8e 8d       	ldd	r24, Y+30	; 0x1e
     888:	18 16       	cp	r1, r24
     88a:	bc f4       	brge	.+46     	; 0x8ba <prvUnlockQueue+0x44>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     88c:	89 89       	ldd	r24, Y+17	; 0x11
     88e:	81 11       	cpse	r24, r1
     890:	05 c0       	rjmp	.+10     	; 0x89c <prvUnlockQueue+0x26>
     892:	13 c0       	rjmp	.+38     	; 0x8ba <prvUnlockQueue+0x44>
     894:	99 89       	ldd	r25, Y+17	; 0x11
     896:	91 11       	cpse	r25, r1
     898:	04 c0       	rjmp	.+8      	; 0x8a2 <prvUnlockQueue+0x2c>
     89a:	0f c0       	rjmp	.+30     	; 0x8ba <prvUnlockQueue+0x44>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     89c:	8e 01       	movw	r16, r28
     89e:	0f 5e       	subi	r16, 0xEF	; 239
     8a0:	1f 4f       	sbci	r17, 0xFF	; 255
     8a2:	c8 01       	movw	r24, r16
     8a4:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <xTaskRemoveFromEventList>
     8a8:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
     8aa:	0e 94 84 0a 	call	0x1508	; 0x1508 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
     8ae:	9e 8d       	ldd	r25, Y+30	; 0x1e
     8b0:	91 50       	subi	r25, 0x01	; 1
     8b2:	9e 8f       	std	Y+30, r25	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     8b4:	9e 8d       	ldd	r25, Y+30	; 0x1e
     8b6:	19 16       	cp	r1, r25
     8b8:	6c f3       	brlt	.-38     	; 0x894 <prvUnlockQueue+0x1e>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
     8ba:	8f ef       	ldi	r24, 0xFF	; 255
     8bc:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     8be:	0f 90       	pop	r0
     8c0:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     8c2:	0f b6       	in	r0, 0x3f	; 63
     8c4:	f8 94       	cli
     8c6:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     8c8:	8d 8d       	ldd	r24, Y+29	; 0x1d
     8ca:	18 16       	cp	r1, r24
     8cc:	bc f4       	brge	.+46     	; 0x8fc <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     8ce:	88 85       	ldd	r24, Y+8	; 0x08
     8d0:	81 11       	cpse	r24, r1
     8d2:	05 c0       	rjmp	.+10     	; 0x8de <prvUnlockQueue+0x68>
     8d4:	13 c0       	rjmp	.+38     	; 0x8fc <prvUnlockQueue+0x86>
     8d6:	98 85       	ldd	r25, Y+8	; 0x08
     8d8:	91 11       	cpse	r25, r1
     8da:	04 c0       	rjmp	.+8      	; 0x8e4 <prvUnlockQueue+0x6e>
     8dc:	0f c0       	rjmp	.+30     	; 0x8fc <prvUnlockQueue+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     8de:	8e 01       	movw	r16, r28
     8e0:	08 5f       	subi	r16, 0xF8	; 248
     8e2:	1f 4f       	sbci	r17, 0xFF	; 255
     8e4:	c8 01       	movw	r24, r16
     8e6:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <xTaskRemoveFromEventList>
     8ea:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     8ec:	0e 94 84 0a 	call	0x1508	; 0x1508 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
     8f0:	9d 8d       	ldd	r25, Y+29	; 0x1d
     8f2:	91 50       	subi	r25, 0x01	; 1
     8f4:	9d 8f       	std	Y+29, r25	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     8f6:	9d 8d       	ldd	r25, Y+29	; 0x1d
     8f8:	19 16       	cp	r1, r25
     8fa:	6c f3       	brlt	.-38     	; 0x8d6 <prvUnlockQueue+0x60>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     8fc:	8f ef       	ldi	r24, 0xFF	; 255
     8fe:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     900:	0f 90       	pop	r0
     902:	0f be       	out	0x3f, r0	; 63
}
     904:	df 91       	pop	r29
     906:	cf 91       	pop	r28
     908:	1f 91       	pop	r17
     90a:	0f 91       	pop	r16
     90c:	08 95       	ret

0000090e <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     90e:	cf 93       	push	r28
     910:	df 93       	push	r29
     912:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     914:	0f b6       	in	r0, 0x3f	; 63
     916:	f8 94       	cli
     918:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     91a:	48 81       	ld	r20, Y
     91c:	59 81       	ldd	r21, Y+1	; 0x01
     91e:	2c 8d       	ldd	r18, Y+28	; 0x1c
     920:	30 e0       	ldi	r19, 0x00	; 0
     922:	7b 8d       	ldd	r23, Y+27	; 0x1b
     924:	72 9f       	mul	r23, r18
     926:	c0 01       	movw	r24, r0
     928:	73 9f       	mul	r23, r19
     92a:	90 0d       	add	r25, r0
     92c:	11 24       	eor	r1, r1
     92e:	fa 01       	movw	r30, r20
     930:	e8 0f       	add	r30, r24
     932:	f9 1f       	adc	r31, r25
     934:	fb 83       	std	Y+3, r31	; 0x03
     936:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     938:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     93a:	5d 83       	std	Y+5, r21	; 0x05
     93c:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     93e:	82 1b       	sub	r24, r18
     940:	93 0b       	sbc	r25, r19
     942:	84 0f       	add	r24, r20
     944:	95 1f       	adc	r25, r21
     946:	9f 83       	std	Y+7, r25	; 0x07
     948:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     94a:	8f ef       	ldi	r24, 0xFF	; 255
     94c:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     94e:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     950:	61 11       	cpse	r22, r1
     952:	0c c0       	rjmp	.+24     	; 0x96c <xQueueGenericReset+0x5e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     954:	88 85       	ldd	r24, Y+8	; 0x08
     956:	88 23       	and	r24, r24
     958:	89 f0       	breq	.+34     	; 0x97c <xQueueGenericReset+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     95a:	ce 01       	movw	r24, r28
     95c:	08 96       	adiw	r24, 0x08	; 8
     95e:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <xTaskRemoveFromEventList>
     962:	81 30       	cpi	r24, 0x01	; 1
     964:	59 f4       	brne	.+22     	; 0x97c <xQueueGenericReset+0x6e>
				{
					queueYIELD_IF_USING_PREEMPTION();
     966:	0e 94 3a 02 	call	0x474	; 0x474 <vPortYield>
     96a:	08 c0       	rjmp	.+16     	; 0x97c <xQueueGenericReset+0x6e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     96c:	ce 01       	movw	r24, r28
     96e:	08 96       	adiw	r24, 0x08	; 8
     970:	0e 94 0a 01 	call	0x214	; 0x214 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     974:	ce 01       	movw	r24, r28
     976:	41 96       	adiw	r24, 0x11	; 17
     978:	0e 94 0a 01 	call	0x214	; 0x214 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     97c:	0f 90       	pop	r0
     97e:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     980:	81 e0       	ldi	r24, 0x01	; 1
     982:	df 91       	pop	r29
     984:	cf 91       	pop	r28
     986:	08 95       	ret

00000988 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
     988:	0f 93       	push	r16
     98a:	1f 93       	push	r17
     98c:	cf 93       	push	r28
     98e:	df 93       	push	r29
     990:	08 2f       	mov	r16, r24
     992:	16 2f       	mov	r17, r22
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
     994:	66 23       	and	r22, r22
     996:	b9 f0       	breq	.+46     	; 0x9c6 <xQueueGenericCreate+0x3e>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     998:	86 9f       	mul	r24, r22
     99a:	c0 01       	movw	r24, r0
     99c:	11 24       	eor	r1, r1
	}

	/* Allocate the new queue structure and storage area. */
	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     99e:	80 96       	adiw	r24, 0x20	; 32
     9a0:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <pvPortMalloc>
     9a4:	ec 01       	movw	r28, r24

	if( pcAllocatedBuffer != NULL )
     9a6:	00 97       	sbiw	r24, 0x00	; 0
     9a8:	21 f4       	brne	.+8      	; 0x9b2 <xQueueGenericCreate+0x2a>
     9aa:	14 c0       	rjmp	.+40     	; 0x9d4 <xQueueGenericCreate+0x4c>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     9ac:	d9 83       	std	Y+1, r29	; 0x01
     9ae:	c8 83       	st	Y, r28
     9b0:	03 c0       	rjmp	.+6      	; 0x9b8 <xQueueGenericCreate+0x30>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area - adding the padding bytes to get a better alignment. */
			pxNewQueue->pcHead = pcAllocatedBuffer + sizeof( Queue_t );
     9b2:	4f 96       	adiw	r24, 0x1f	; 31
     9b4:	99 83       	std	Y+1, r25	; 0x01
     9b6:	88 83       	st	Y, r24
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
     9b8:	0b 8f       	std	Y+27, r16	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
     9ba:	1c 8f       	std	Y+28, r17	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     9bc:	61 e0       	ldi	r22, 0x01	; 1
     9be:	ce 01       	movw	r24, r28
     9c0:	0e 94 87 04 	call	0x90e	; 0x90e <xQueueGenericReset>
     9c4:	07 c0       	rjmp	.+14     	; 0x9d4 <xQueueGenericCreate+0x4c>
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}

	/* Allocate the new queue structure and storage area. */
	pcAllocatedBuffer = ( int8_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     9c6:	8f e1       	ldi	r24, 0x1F	; 31
     9c8:	90 e0       	ldi	r25, 0x00	; 0
     9ca:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <pvPortMalloc>
     9ce:	ec 01       	movw	r28, r24

	if( pcAllocatedBuffer != NULL )
     9d0:	89 2b       	or	r24, r25
     9d2:	61 f7       	brne	.-40     	; 0x9ac <xQueueGenericCreate+0x24>
	}

	configASSERT( xReturn );

	return xReturn;
}
     9d4:	ce 01       	movw	r24, r28
     9d6:	df 91       	pop	r29
     9d8:	cf 91       	pop	r28
     9da:	1f 91       	pop	r17
     9dc:	0f 91       	pop	r16
     9de:	08 95       	ret

000009e0 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
     9e0:	0f 93       	push	r16
     9e2:	1f 93       	push	r17
     9e4:	cf 93       	push	r28
     9e6:	df 93       	push	r29
     9e8:	fa 01       	movw	r30, r20
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     9ea:	dc 01       	movw	r26, r24
     9ec:	5a 96       	adiw	r26, 0x1a	; 26
     9ee:	5c 91       	ld	r21, X
     9f0:	5a 97       	sbiw	r26, 0x1a	; 26
     9f2:	5b 96       	adiw	r26, 0x1b	; 27
     9f4:	3c 91       	ld	r19, X
     9f6:	53 17       	cp	r21, r19
     9f8:	10 f0       	brcs	.+4      	; 0x9fe <xQueueGenericSendFromISR+0x1e>
     9fa:	22 30       	cpi	r18, 0x02	; 2
     9fc:	e9 f4       	brne	.+58     	; 0xa38 <xQueueGenericSendFromISR+0x58>
     9fe:	42 2f       	mov	r20, r18
     a00:	8f 01       	movw	r16, r30
     a02:	ec 01       	movw	r28, r24
			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
			in a task disinheriting a priority and prvCopyDataToQueue() can be
			called here even though the disinherit function does not check if
			the scheduler is suspended before accessing the ready lists. */
			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     a04:	0e 94 bf 03 	call	0x77e	; 0x77e <prvCopyDataToQueue>

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
     a08:	8e 8d       	ldd	r24, Y+30	; 0x1e
     a0a:	8f 3f       	cpi	r24, 0xFF	; 255
     a0c:	81 f4       	brne	.+32     	; 0xa2e <xQueueGenericSendFromISR+0x4e>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     a0e:	89 89       	ldd	r24, Y+17	; 0x11
     a10:	88 23       	and	r24, r24
     a12:	a1 f0       	breq	.+40     	; 0xa3c <xQueueGenericSendFromISR+0x5c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     a14:	ce 01       	movw	r24, r28
     a16:	41 96       	adiw	r24, 0x11	; 17
     a18:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <xTaskRemoveFromEventList>
     a1c:	88 23       	and	r24, r24
     a1e:	81 f0       	breq	.+32     	; 0xa40 <xQueueGenericSendFromISR+0x60>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
     a20:	01 15       	cp	r16, r1
     a22:	11 05       	cpc	r17, r1
     a24:	79 f0       	breq	.+30     	; 0xa44 <xQueueGenericSendFromISR+0x64>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
     a26:	81 e0       	ldi	r24, 0x01	; 1
     a28:	f8 01       	movw	r30, r16
     a2a:	80 83       	st	Z, r24
     a2c:	0c c0       	rjmp	.+24     	; 0xa46 <xQueueGenericSendFromISR+0x66>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
     a2e:	8e 8d       	ldd	r24, Y+30	; 0x1e
     a30:	8f 5f       	subi	r24, 0xFF	; 255
     a32:	8e 8f       	std	Y+30, r24	; 0x1e
			}

			xReturn = pdPASS;
     a34:	81 e0       	ldi	r24, 0x01	; 1
     a36:	07 c0       	rjmp	.+14     	; 0xa46 <xQueueGenericSendFromISR+0x66>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
     a38:	80 e0       	ldi	r24, 0x00	; 0
     a3a:	05 c0       	rjmp	.+10     	; 0xa46 <xQueueGenericSendFromISR+0x66>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
     a3c:	81 e0       	ldi	r24, 0x01	; 1
     a3e:	03 c0       	rjmp	.+6      	; 0xa46 <xQueueGenericSendFromISR+0x66>
     a40:	81 e0       	ldi	r24, 0x01	; 1
     a42:	01 c0       	rjmp	.+2      	; 0xa46 <xQueueGenericSendFromISR+0x66>
     a44:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     a46:	df 91       	pop	r29
     a48:	cf 91       	pop	r28
     a4a:	1f 91       	pop	r17
     a4c:	0f 91       	pop	r16
     a4e:	08 95       	ret

00000a50 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     a50:	9f 92       	push	r9
     a52:	af 92       	push	r10
     a54:	bf 92       	push	r11
     a56:	cf 92       	push	r12
     a58:	df 92       	push	r13
     a5a:	ef 92       	push	r14
     a5c:	ff 92       	push	r15
     a5e:	0f 93       	push	r16
     a60:	1f 93       	push	r17
     a62:	cf 93       	push	r28
     a64:	df 93       	push	r29
     a66:	00 d0       	rcall	.+0      	; 0xa68 <xQueueGenericReceive+0x18>
     a68:	00 d0       	rcall	.+0      	; 0xa6a <xQueueGenericReceive+0x1a>
     a6a:	1f 92       	push	r1
     a6c:	cd b7       	in	r28, 0x3d	; 61
     a6e:	de b7       	in	r29, 0x3e	; 62
     a70:	8c 01       	movw	r16, r24
     a72:	6b 01       	movw	r12, r22
     a74:	5d 83       	std	Y+5, r21	; 0x05
     a76:	4c 83       	std	Y+4, r20	; 0x04
     a78:	92 2e       	mov	r9, r18
BaseType_t xEntryTimeSet = pdFALSE;
     a7a:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     a7c:	aa 24       	eor	r10, r10
     a7e:	a3 94       	inc	r10
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     a80:	7c 01       	movw	r14, r24
     a82:	81 e1       	ldi	r24, 0x11	; 17
     a84:	e8 0e       	add	r14, r24
     a86:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     a88:	0f b6       	in	r0, 0x3f	; 63
     a8a:	f8 94       	cli
     a8c:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     a8e:	f8 01       	movw	r30, r16
     a90:	92 8d       	ldd	r25, Z+26	; 0x1a
     a92:	99 23       	and	r25, r25
     a94:	99 f1       	breq	.+102    	; 0xafc <xQueueGenericReceive+0xac>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     a96:	e6 80       	ldd	r14, Z+6	; 0x06
     a98:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     a9a:	b6 01       	movw	r22, r12
     a9c:	c8 01       	movw	r24, r16
     a9e:	0e 94 21 04 	call	0x842	; 0x842 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     aa2:	91 10       	cpse	r9, r1
     aa4:	1a c0       	rjmp	.+52     	; 0xada <xQueueGenericReceive+0x8a>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     aa6:	f8 01       	movw	r30, r16
     aa8:	82 8d       	ldd	r24, Z+26	; 0x1a
     aaa:	81 50       	subi	r24, 0x01	; 1
     aac:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     aae:	80 81       	ld	r24, Z
     ab0:	91 81       	ldd	r25, Z+1	; 0x01
     ab2:	89 2b       	or	r24, r25
     ab4:	29 f4       	brne	.+10     	; 0xac0 <xQueueGenericReceive+0x70>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
     ab6:	0e 94 2a 0b 	call	0x1654	; 0x1654 <pvTaskIncrementMutexHeldCount>
     aba:	f8 01       	movw	r30, r16
     abc:	93 83       	std	Z+3, r25	; 0x03
     abe:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     ac0:	f8 01       	movw	r30, r16
     ac2:	80 85       	ldd	r24, Z+8	; 0x08
     ac4:	88 23       	and	r24, r24
     ac6:	b1 f0       	breq	.+44     	; 0xaf4 <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     ac8:	c8 01       	movw	r24, r16
     aca:	08 96       	adiw	r24, 0x08	; 8
     acc:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <xTaskRemoveFromEventList>
     ad0:	81 30       	cpi	r24, 0x01	; 1
     ad2:	81 f4       	brne	.+32     	; 0xaf4 <xQueueGenericReceive+0xa4>
						{
							queueYIELD_IF_USING_PREEMPTION();
     ad4:	0e 94 3a 02 	call	0x474	; 0x474 <vPortYield>
     ad8:	0d c0       	rjmp	.+26     	; 0xaf4 <xQueueGenericReceive+0xa4>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     ada:	f8 01       	movw	r30, r16
     adc:	f7 82       	std	Z+7, r15	; 0x07
     ade:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     ae0:	81 89       	ldd	r24, Z+17	; 0x11
     ae2:	88 23       	and	r24, r24
     ae4:	39 f0       	breq	.+14     	; 0xaf4 <xQueueGenericReceive+0xa4>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     ae6:	c8 01       	movw	r24, r16
     ae8:	41 96       	adiw	r24, 0x11	; 17
     aea:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <xTaskRemoveFromEventList>
     aee:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     af0:	0e 94 3a 02 	call	0x474	; 0x474 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     af4:	0f 90       	pop	r0
     af6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     af8:	81 e0       	ldi	r24, 0x01	; 1
     afa:	5c c0       	rjmp	.+184    	; 0xbb4 <xQueueGenericReceive+0x164>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     afc:	4c 81       	ldd	r20, Y+4	; 0x04
     afe:	5d 81       	ldd	r21, Y+5	; 0x05
     b00:	45 2b       	or	r20, r21
     b02:	21 f4       	brne	.+8      	; 0xb0c <xQueueGenericReceive+0xbc>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     b04:	0f 90       	pop	r0
     b06:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     b08:	80 e0       	ldi	r24, 0x00	; 0
     b0a:	54 c0       	rjmp	.+168    	; 0xbb4 <xQueueGenericReceive+0x164>
				}
				else if( xEntryTimeSet == pdFALSE )
     b0c:	b1 10       	cpse	r11, r1
     b0e:	05 c0       	rjmp	.+10     	; 0xb1a <xQueueGenericReceive+0xca>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     b10:	ce 01       	movw	r24, r28
     b12:	01 96       	adiw	r24, 0x01	; 1
     b14:	0e 94 40 0a 	call	0x1480	; 0x1480 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     b18:	ba 2c       	mov	r11, r10
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     b1a:	0f 90       	pop	r0
     b1c:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     b1e:	0e 94 8b 07 	call	0xf16	; 0xf16 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     b22:	0f b6       	in	r0, 0x3f	; 63
     b24:	f8 94       	cli
     b26:	0f 92       	push	r0
     b28:	f8 01       	movw	r30, r16
     b2a:	85 8d       	ldd	r24, Z+29	; 0x1d
     b2c:	8f 3f       	cpi	r24, 0xFF	; 255
     b2e:	09 f4       	brne	.+2      	; 0xb32 <xQueueGenericReceive+0xe2>
     b30:	15 8e       	std	Z+29, r1	; 0x1d
     b32:	f8 01       	movw	r30, r16
     b34:	96 8d       	ldd	r25, Z+30	; 0x1e
     b36:	9f 3f       	cpi	r25, 0xFF	; 255
     b38:	09 f4       	brne	.+2      	; 0xb3c <xQueueGenericReceive+0xec>
     b3a:	16 8e       	std	Z+30, r1	; 0x1e
     b3c:	0f 90       	pop	r0
     b3e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     b40:	be 01       	movw	r22, r28
     b42:	6c 5f       	subi	r22, 0xFC	; 252
     b44:	7f 4f       	sbci	r23, 0xFF	; 255
     b46:	ce 01       	movw	r24, r28
     b48:	01 96       	adiw	r24, 0x01	; 1
     b4a:	0e 94 4b 0a 	call	0x1496	; 0x1496 <xTaskCheckForTimeOut>
     b4e:	81 11       	cpse	r24, r1
     b50:	2b c0       	rjmp	.+86     	; 0xba8 <xQueueGenericReceive+0x158>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     b52:	0f b6       	in	r0, 0x3f	; 63
     b54:	f8 94       	cli
     b56:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     b58:	f8 01       	movw	r30, r16
     b5a:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     b5c:	0f 90       	pop	r0
     b5e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     b60:	81 11       	cpse	r24, r1
     b62:	1c c0       	rjmp	.+56     	; 0xb9c <xQueueGenericReceive+0x14c>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
     b64:	80 81       	ld	r24, Z
     b66:	91 81       	ldd	r25, Z+1	; 0x01
     b68:	89 2b       	or	r24, r25
     b6a:	49 f4       	brne	.+18     	; 0xb7e <xQueueGenericReceive+0x12e>
					{
						taskENTER_CRITICAL();
     b6c:	0f b6       	in	r0, 0x3f	; 63
     b6e:	f8 94       	cli
     b70:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
     b72:	82 81       	ldd	r24, Z+2	; 0x02
     b74:	93 81       	ldd	r25, Z+3	; 0x03
     b76:	0e 94 88 0a 	call	0x1510	; 0x1510 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
     b7a:	0f 90       	pop	r0
     b7c:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     b7e:	6c 81       	ldd	r22, Y+4	; 0x04
     b80:	7d 81       	ldd	r23, Y+5	; 0x05
     b82:	c7 01       	movw	r24, r14
     b84:	0e 94 cb 09 	call	0x1396	; 0x1396 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     b88:	c8 01       	movw	r24, r16
     b8a:	0e 94 3b 04 	call	0x876	; 0x876 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     b8e:	0e 94 5d 08 	call	0x10ba	; 0x10ba <xTaskResumeAll>
     b92:	81 11       	cpse	r24, r1
     b94:	79 cf       	rjmp	.-270    	; 0xa88 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
     b96:	0e 94 3a 02 	call	0x474	; 0x474 <vPortYield>
     b9a:	76 cf       	rjmp	.-276    	; 0xa88 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     b9c:	c8 01       	movw	r24, r16
     b9e:	0e 94 3b 04 	call	0x876	; 0x876 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     ba2:	0e 94 5d 08 	call	0x10ba	; 0x10ba <xTaskResumeAll>
     ba6:	70 cf       	rjmp	.-288    	; 0xa88 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     ba8:	c8 01       	movw	r24, r16
     baa:	0e 94 3b 04 	call	0x876	; 0x876 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     bae:	0e 94 5d 08 	call	0x10ba	; 0x10ba <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     bb2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     bb4:	0f 90       	pop	r0
     bb6:	0f 90       	pop	r0
     bb8:	0f 90       	pop	r0
     bba:	0f 90       	pop	r0
     bbc:	0f 90       	pop	r0
     bbe:	df 91       	pop	r29
     bc0:	cf 91       	pop	r28
     bc2:	1f 91       	pop	r17
     bc4:	0f 91       	pop	r16
     bc6:	ff 90       	pop	r15
     bc8:	ef 90       	pop	r14
     bca:	df 90       	pop	r13
     bcc:	cf 90       	pop	r12
     bce:	bf 90       	pop	r11
     bd0:	af 90       	pop	r10
     bd2:	9f 90       	pop	r9
     bd4:	08 95       	ret

00000bd6 <uxQueueMessagesWaiting>:
{
UBaseType_t uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
     bd6:	0f b6       	in	r0, 0x3f	; 63
     bd8:	f8 94       	cli
     bda:	0f 92       	push	r0
	{
		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
     bdc:	fc 01       	movw	r30, r24
     bde:	82 8d       	ldd	r24, Z+26	; 0x1a
	}
	taskEXIT_CRITICAL();
     be0:	0f 90       	pop	r0
     be2:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
     be4:	08 95       	ret

00000be6 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     be6:	e0 91 f3 07 	lds	r30, 0x07F3
     bea:	f0 91 f4 07 	lds	r31, 0x07F4
     bee:	80 81       	ld	r24, Z
     bf0:	81 11       	cpse	r24, r1
     bf2:	07 c0       	rjmp	.+14     	; 0xc02 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     bf4:	8f ef       	ldi	r24, 0xFF	; 255
     bf6:	9f ef       	ldi	r25, 0xFF	; 255
     bf8:	90 93 0d 01 	sts	0x010D, r25
     bfc:	80 93 0c 01 	sts	0x010C, r24
     c00:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     c02:	e0 91 f3 07 	lds	r30, 0x07F3
     c06:	f0 91 f4 07 	lds	r31, 0x07F4
     c0a:	05 80       	ldd	r0, Z+5	; 0x05
     c0c:	f6 81       	ldd	r31, Z+6	; 0x06
     c0e:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
     c10:	06 80       	ldd	r0, Z+6	; 0x06
     c12:	f7 81       	ldd	r31, Z+7	; 0x07
     c14:	e0 2d       	mov	r30, r0
     c16:	82 81       	ldd	r24, Z+2	; 0x02
     c18:	93 81       	ldd	r25, Z+3	; 0x03
     c1a:	90 93 0d 01 	sts	0x010D, r25
     c1e:	80 93 0c 01 	sts	0x010C, r24
     c22:	08 95       	ret

00000c24 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
     c24:	cf 93       	push	r28
     c26:	df 93       	push	r29
     c28:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     c2a:	e0 91 2b 08 	lds	r30, 0x082B
     c2e:	f0 91 2c 08 	lds	r31, 0x082C
     c32:	93 83       	std	Z+3, r25	; 0x03
     c34:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
     c36:	80 91 d0 07 	lds	r24, 0x07D0
     c3a:	90 91 d1 07 	lds	r25, 0x07D1
     c3e:	c8 17       	cp	r28, r24
     c40:	d9 07       	cpc	r29, r25
     c42:	68 f4       	brcc	.+26     	; 0xc5e <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     c44:	60 91 2b 08 	lds	r22, 0x082B
     c48:	70 91 2c 08 	lds	r23, 0x082C
     c4c:	80 91 f1 07 	lds	r24, 0x07F1
     c50:	90 91 f2 07 	lds	r25, 0x07F2
     c54:	6e 5f       	subi	r22, 0xFE	; 254
     c56:	7f 4f       	sbci	r23, 0xFF	; 255
     c58:	0e 94 3d 01 	call	0x27a	; 0x27a <vListInsert>
     c5c:	17 c0       	rjmp	.+46     	; 0xc8c <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     c5e:	60 91 2b 08 	lds	r22, 0x082B
     c62:	70 91 2c 08 	lds	r23, 0x082C
     c66:	80 91 f3 07 	lds	r24, 0x07F3
     c6a:	90 91 f4 07 	lds	r25, 0x07F4
     c6e:	6e 5f       	subi	r22, 0xFE	; 254
     c70:	7f 4f       	sbci	r23, 0xFF	; 255
     c72:	0e 94 3d 01 	call	0x27a	; 0x27a <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     c76:	80 91 0c 01 	lds	r24, 0x010C
     c7a:	90 91 0d 01 	lds	r25, 0x010D
     c7e:	c8 17       	cp	r28, r24
     c80:	d9 07       	cpc	r29, r25
     c82:	20 f4       	brcc	.+8      	; 0xc8c <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
     c84:	d0 93 0d 01 	sts	0x010D, r29
     c88:	c0 93 0c 01 	sts	0x010C, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     c8c:	df 91       	pop	r29
     c8e:	cf 91       	pop	r28
     c90:	08 95       	ret

00000c92 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
     c92:	4f 92       	push	r4
     c94:	5f 92       	push	r5
     c96:	6f 92       	push	r6
     c98:	7f 92       	push	r7
     c9a:	8f 92       	push	r8
     c9c:	9f 92       	push	r9
     c9e:	af 92       	push	r10
     ca0:	bf 92       	push	r11
     ca2:	cf 92       	push	r12
     ca4:	df 92       	push	r13
     ca6:	ef 92       	push	r14
     ca8:	ff 92       	push	r15
     caa:	0f 93       	push	r16
     cac:	1f 93       	push	r17
     cae:	cf 93       	push	r28
     cb0:	df 93       	push	r29
     cb2:	4c 01       	movw	r8, r24
     cb4:	eb 01       	movw	r28, r22
     cb6:	5a 01       	movw	r10, r20
     cb8:	29 01       	movw	r4, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     cba:	c1 14       	cp	r12, r1
     cbc:	d1 04       	cpc	r13, r1
     cbe:	39 f4       	brne	.+14     	; 0xcce <xTaskGenericCreate+0x3c>
     cc0:	ca 01       	movw	r24, r20
     cc2:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <pvPortMalloc>
     cc6:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
     cc8:	89 2b       	or	r24, r25
     cca:	09 f4       	brne	.+2      	; 0xcce <xTaskGenericCreate+0x3c>
     ccc:	e3 c0       	rjmp	.+454    	; 0xe94 <xTaskGenericCreate+0x202>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     cce:	88 e2       	ldi	r24, 0x28	; 40
     cd0:	90 e0       	ldi	r25, 0x00	; 0
     cd2:	0e 94 f2 02 	call	0x5e4	; 0x5e4 <pvPortMalloc>
     cd6:	3c 01       	movw	r6, r24

			if( pxNewTCB != NULL )
     cd8:	00 97       	sbiw	r24, 0x00	; 0
     cda:	79 f0       	breq	.+30     	; 0xcfa <xTaskGenericCreate+0x68>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
     cdc:	fc 01       	movw	r30, r24
     cde:	d0 8e       	std	Z+24, r13	; 0x18
     ce0:	c7 8a       	std	Z+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
     ce2:	f1 e0       	ldi	r31, 0x01	; 1
     ce4:	af 1a       	sub	r10, r31
     ce6:	b1 08       	sbc	r11, r1
     ce8:	ca 0c       	add	r12, r10
     cea:	db 1c       	adc	r13, r11
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     cec:	88 81       	ld	r24, Y
     cee:	f3 01       	movw	r30, r6
     cf0:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     cf2:	88 81       	ld	r24, Y
     cf4:	81 11       	cpse	r24, r1
     cf6:	05 c0       	rjmp	.+10     	; 0xd02 <xTaskGenericCreate+0x70>
     cf8:	14 c0       	rjmp	.+40     	; 0xd22 <xTaskGenericCreate+0x90>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
     cfa:	c6 01       	movw	r24, r12
     cfc:	0e 94 8c 03 	call	0x718	; 0x718 <vPortFree>
     d00:	c9 c0       	rjmp	.+402    	; 0xe94 <xTaskGenericCreate+0x202>
     d02:	d3 01       	movw	r26, r6
     d04:	5a 96       	adiw	r26, 0x1a	; 26
     d06:	fe 01       	movw	r30, r28
     d08:	31 96       	adiw	r30, 0x01	; 1
     d0a:	9e 01       	movw	r18, r28
     d0c:	28 5f       	subi	r18, 0xF8	; 248
     d0e:	3f 4f       	sbci	r19, 0xFF	; 255
     d10:	ef 01       	movw	r28, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     d12:	81 91       	ld	r24, Z+
     d14:	8d 93       	st	X+, r24

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     d16:	88 81       	ld	r24, Y
     d18:	88 23       	and	r24, r24
     d1a:	19 f0       	breq	.+6      	; 0xd22 <xTaskGenericCreate+0x90>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     d1c:	e2 17       	cp	r30, r18
     d1e:	f3 07       	cpc	r31, r19
     d20:	b9 f7       	brne	.-18     	; 0xd10 <xTaskGenericCreate+0x7e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     d22:	f3 01       	movw	r30, r6
     d24:	10 a2       	std	Z+32, r1	; 0x20
     d26:	10 2f       	mov	r17, r16
     d28:	04 30       	cpi	r16, 0x04	; 4
     d2a:	08 f0       	brcs	.+2      	; 0xd2e <xTaskGenericCreate+0x9c>
     d2c:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
     d2e:	f3 01       	movw	r30, r6
     d30:	16 8b       	std	Z+22, r17	; 0x16
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
     d32:	11 a3       	std	Z+33, r17	; 0x21
		pxTCB->uxMutexesHeld = 0;
     d34:	12 a2       	std	Z+34, r1	; 0x22
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     d36:	e3 01       	movw	r28, r6
     d38:	22 96       	adiw	r28, 0x02	; 2
     d3a:	ce 01       	movw	r24, r28
     d3c:	0e 94 18 01 	call	0x230	; 0x230 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     d40:	c3 01       	movw	r24, r6
     d42:	0c 96       	adiw	r24, 0x0c	; 12
     d44:	0e 94 18 01 	call	0x230	; 0x230 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     d48:	f3 01       	movw	r30, r6
     d4a:	71 86       	std	Z+9, r7	; 0x09
     d4c:	60 86       	std	Z+8, r6	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     d4e:	84 e0       	ldi	r24, 0x04	; 4
     d50:	90 e0       	ldi	r25, 0x00	; 0
     d52:	81 1b       	sub	r24, r17
     d54:	91 09       	sbc	r25, r1
     d56:	95 87       	std	Z+13, r25	; 0x0d
     d58:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     d5a:	73 8a       	std	Z+19, r7	; 0x13
     d5c:	62 8a       	std	Z+18, r6	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
     d5e:	13 a2       	std	Z+35, r1	; 0x23
     d60:	14 a2       	std	Z+36, r1	; 0x24
     d62:	15 a2       	std	Z+37, r1	; 0x25
     d64:	16 a2       	std	Z+38, r1	; 0x26
		pxTCB->eNotifyState = eNotWaitingNotification;
     d66:	17 a2       	std	Z+39, r1	; 0x27
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     d68:	a2 01       	movw	r20, r4
     d6a:	b4 01       	movw	r22, r8
     d6c:	c6 01       	movw	r24, r12
     d6e:	0e 94 94 01 	call	0x328	; 0x328 <pxPortInitialiseStack>
     d72:	f3 01       	movw	r30, r6
     d74:	91 83       	std	Z+1, r25	; 0x01
     d76:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     d78:	e1 14       	cp	r14, r1
     d7a:	f1 04       	cpc	r15, r1
     d7c:	19 f0       	breq	.+6      	; 0xd84 <xTaskGenericCreate+0xf2>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     d7e:	f7 01       	movw	r30, r14
     d80:	71 82       	std	Z+1, r7	; 0x01
     d82:	60 82       	st	Z, r6
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     d84:	0f b6       	in	r0, 0x3f	; 63
     d86:	f8 94       	cli
     d88:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     d8a:	80 91 d2 07 	lds	r24, 0x07D2
     d8e:	8f 5f       	subi	r24, 0xFF	; 255
     d90:	80 93 d2 07 	sts	0x07D2, r24
			if( pxCurrentTCB == NULL )
     d94:	80 91 2b 08 	lds	r24, 0x082B
     d98:	90 91 2c 08 	lds	r25, 0x082C
     d9c:	89 2b       	or	r24, r25
     d9e:	d1 f5       	brne	.+116    	; 0xe14 <xTaskGenericCreate+0x182>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     da0:	70 92 2c 08 	sts	0x082C, r7
     da4:	60 92 2b 08 	sts	0x082B, r6

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     da8:	80 91 d2 07 	lds	r24, 0x07D2
     dac:	81 30       	cpi	r24, 0x01	; 1
     dae:	09 f0       	breq	.+2      	; 0xdb2 <xTaskGenericCreate+0x120>
     db0:	40 c0       	rjmp	.+128    	; 0xe32 <xTaskGenericCreate+0x1a0>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     db2:	87 e0       	ldi	r24, 0x07	; 7
     db4:	98 e0       	ldi	r25, 0x08	; 8
     db6:	0e 94 0a 01 	call	0x214	; 0x214 <vListInitialise>
     dba:	80 e1       	ldi	r24, 0x10	; 16
     dbc:	98 e0       	ldi	r25, 0x08	; 8
     dbe:	0e 94 0a 01 	call	0x214	; 0x214 <vListInitialise>
     dc2:	89 e1       	ldi	r24, 0x19	; 25
     dc4:	98 e0       	ldi	r25, 0x08	; 8
     dc6:	0e 94 0a 01 	call	0x214	; 0x214 <vListInitialise>
     dca:	82 e2       	ldi	r24, 0x22	; 34
     dcc:	98 e0       	ldi	r25, 0x08	; 8
     dce:	0e 94 0a 01 	call	0x214	; 0x214 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     dd2:	8e ef       	ldi	r24, 0xFE	; 254
     dd4:	97 e0       	ldi	r25, 0x07	; 7
     dd6:	0e 94 0a 01 	call	0x214	; 0x214 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     dda:	85 ef       	ldi	r24, 0xF5	; 245
     ddc:	97 e0       	ldi	r25, 0x07	; 7
     dde:	0e 94 0a 01 	call	0x214	; 0x214 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     de2:	88 ee       	ldi	r24, 0xE8	; 232
     de4:	97 e0       	ldi	r25, 0x07	; 7
     de6:	0e 94 0a 01 	call	0x214	; 0x214 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     dea:	8f ed       	ldi	r24, 0xDF	; 223
     dec:	97 e0       	ldi	r25, 0x07	; 7
     dee:	0e 94 0a 01 	call	0x214	; 0x214 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     df2:	85 ed       	ldi	r24, 0xD5	; 213
     df4:	97 e0       	ldi	r25, 0x07	; 7
     df6:	0e 94 0a 01 	call	0x214	; 0x214 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     dfa:	8e ef       	ldi	r24, 0xFE	; 254
     dfc:	97 e0       	ldi	r25, 0x07	; 7
     dfe:	90 93 f4 07 	sts	0x07F4, r25
     e02:	80 93 f3 07 	sts	0x07F3, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     e06:	85 ef       	ldi	r24, 0xF5	; 245
     e08:	97 e0       	ldi	r25, 0x07	; 7
     e0a:	90 93 f2 07 	sts	0x07F2, r25
     e0e:	80 93 f1 07 	sts	0x07F1, r24
     e12:	0f c0       	rjmp	.+30     	; 0xe32 <xTaskGenericCreate+0x1a0>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     e14:	80 91 ce 07 	lds	r24, 0x07CE
     e18:	81 11       	cpse	r24, r1
     e1a:	0b c0       	rjmp	.+22     	; 0xe32 <xTaskGenericCreate+0x1a0>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     e1c:	e0 91 2b 08 	lds	r30, 0x082B
     e20:	f0 91 2c 08 	lds	r31, 0x082C
     e24:	86 89       	ldd	r24, Z+22	; 0x16
     e26:	08 17       	cp	r16, r24
     e28:	20 f0       	brcs	.+8      	; 0xe32 <xTaskGenericCreate+0x1a0>
					{
						pxCurrentTCB = pxNewTCB;
     e2a:	70 92 2c 08 	sts	0x082C, r7
     e2e:	60 92 2b 08 	sts	0x082B, r6
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
     e32:	80 91 ca 07 	lds	r24, 0x07CA
     e36:	8f 5f       	subi	r24, 0xFF	; 255
     e38:	80 93 ca 07 	sts	0x07CA, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     e3c:	f3 01       	movw	r30, r6
     e3e:	86 89       	ldd	r24, Z+22	; 0x16
     e40:	90 91 cf 07 	lds	r25, 0x07CF
     e44:	98 17       	cp	r25, r24
     e46:	10 f4       	brcc	.+4      	; 0xe4c <xTaskGenericCreate+0x1ba>
     e48:	80 93 cf 07 	sts	0x07CF, r24
     e4c:	90 e0       	ldi	r25, 0x00	; 0
     e4e:	9c 01       	movw	r18, r24
     e50:	22 0f       	add	r18, r18
     e52:	33 1f       	adc	r19, r19
     e54:	22 0f       	add	r18, r18
     e56:	33 1f       	adc	r19, r19
     e58:	22 0f       	add	r18, r18
     e5a:	33 1f       	adc	r19, r19
     e5c:	82 0f       	add	r24, r18
     e5e:	93 1f       	adc	r25, r19
     e60:	be 01       	movw	r22, r28
     e62:	89 5f       	subi	r24, 0xF9	; 249
     e64:	97 4f       	sbci	r25, 0xF7	; 247
     e66:	0e 94 1c 01 	call	0x238	; 0x238 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     e6a:	0f 90       	pop	r0
     e6c:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
     e6e:	80 91 ce 07 	lds	r24, 0x07CE
     e72:	88 23       	and	r24, r24
     e74:	59 f0       	breq	.+22     	; 0xe8c <xTaskGenericCreate+0x1fa>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     e76:	e0 91 2b 08 	lds	r30, 0x082B
     e7a:	f0 91 2c 08 	lds	r31, 0x082C
     e7e:	86 89       	ldd	r24, Z+22	; 0x16
     e80:	80 17       	cp	r24, r16
     e82:	30 f4       	brcc	.+12     	; 0xe90 <xTaskGenericCreate+0x1fe>
			{
				taskYIELD_IF_USING_PREEMPTION();
     e84:	0e 94 3a 02 	call	0x474	; 0x474 <vPortYield>
     e88:	81 e0       	ldi	r24, 0x01	; 1
     e8a:	05 c0       	rjmp	.+10     	; 0xe96 <xTaskGenericCreate+0x204>
     e8c:	81 e0       	ldi	r24, 0x01	; 1
     e8e:	03 c0       	rjmp	.+6      	; 0xe96 <xTaskGenericCreate+0x204>
     e90:	81 e0       	ldi	r24, 0x01	; 1
     e92:	01 c0       	rjmp	.+2      	; 0xe96 <xTaskGenericCreate+0x204>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     e94:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
     e96:	df 91       	pop	r29
     e98:	cf 91       	pop	r28
     e9a:	1f 91       	pop	r17
     e9c:	0f 91       	pop	r16
     e9e:	ff 90       	pop	r15
     ea0:	ef 90       	pop	r14
     ea2:	df 90       	pop	r13
     ea4:	cf 90       	pop	r12
     ea6:	bf 90       	pop	r11
     ea8:	af 90       	pop	r10
     eaa:	9f 90       	pop	r9
     eac:	8f 90       	pop	r8
     eae:	7f 90       	pop	r7
     eb0:	6f 90       	pop	r6
     eb2:	5f 90       	pop	r5
     eb4:	4f 90       	pop	r4
     eb6:	08 95       	ret

00000eb8 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     eb8:	af 92       	push	r10
     eba:	bf 92       	push	r11
     ebc:	cf 92       	push	r12
     ebe:	df 92       	push	r13
     ec0:	ef 92       	push	r14
     ec2:	ff 92       	push	r15
     ec4:	0f 93       	push	r16
	/* Add the idle task at the lowest priority. */
	#if ( INCLUDE_xTaskGetIdleTaskHandle == 1 )
	{
		/* Create the idle task, storing its handle in xIdleTaskHandle so it can
		be returned by the xTaskGetIdleTaskHandle() function. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
     ec6:	a1 2c       	mov	r10, r1
     ec8:	b1 2c       	mov	r11, r1
     eca:	c1 2c       	mov	r12, r1
     ecc:	d1 2c       	mov	r13, r1
     ece:	0f 2e       	mov	r0, r31
     ed0:	f3 ed       	ldi	r31, 0xD3	; 211
     ed2:	ef 2e       	mov	r14, r31
     ed4:	f7 e0       	ldi	r31, 0x07	; 7
     ed6:	ff 2e       	mov	r15, r31
     ed8:	f0 2d       	mov	r31, r0
     eda:	00 e0       	ldi	r16, 0x00	; 0
     edc:	20 e0       	ldi	r18, 0x00	; 0
     ede:	30 e0       	ldi	r19, 0x00	; 0
     ee0:	45 e5       	ldi	r20, 0x55	; 85
     ee2:	50 e0       	ldi	r21, 0x00	; 0
     ee4:	6c ed       	ldi	r22, 0xDC	; 220
     ee6:	71 e0       	ldi	r23, 0x01	; 1
     ee8:	81 e2       	ldi	r24, 0x21	; 33
     eea:	99 e0       	ldi	r25, 0x09	; 9
     eec:	0e 94 49 06 	call	0xc92	; 0xc92 <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     ef0:	81 30       	cpi	r24, 0x01	; 1
     ef2:	49 f4       	brne	.+18     	; 0xf06 <vTaskStartScheduler+0x4e>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     ef4:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
     ef6:	80 93 ce 07 	sts	0x07CE, r24
		xTickCount = ( TickType_t ) 0U;
     efa:	10 92 d1 07 	sts	0x07D1, r1
     efe:	10 92 d0 07 	sts	0x07D0, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     f02:	0e 94 00 02 	call	0x400	; 0x400 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     f06:	0f 91       	pop	r16
     f08:	ff 90       	pop	r15
     f0a:	ef 90       	pop	r14
     f0c:	df 90       	pop	r13
     f0e:	cf 90       	pop	r12
     f10:	bf 90       	pop	r11
     f12:	af 90       	pop	r10
     f14:	08 95       	ret

00000f16 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     f16:	80 91 c9 07 	lds	r24, 0x07C9
     f1a:	8f 5f       	subi	r24, 0xFF	; 255
     f1c:	80 93 c9 07 	sts	0x07C9, r24
     f20:	08 95       	ret

00000f22 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     f22:	0f b6       	in	r0, 0x3f	; 63
     f24:	f8 94       	cli
     f26:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     f28:	80 91 d0 07 	lds	r24, 0x07D0
     f2c:	90 91 d1 07 	lds	r25, 0x07D1
	}
	portTICK_TYPE_EXIT_CRITICAL();
     f30:	0f 90       	pop	r0
     f32:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     f34:	08 95       	ret

00000f36 <xTaskGetTickCountFromISR>:
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
	{
		xReturn = xTickCount;
     f36:	80 91 d0 07 	lds	r24, 0x07D0
     f3a:	90 91 d1 07 	lds	r25, 0x07D1
	}
	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     f3e:	08 95       	ret

00000f40 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     f40:	cf 92       	push	r12
     f42:	df 92       	push	r13
     f44:	ef 92       	push	r14
     f46:	ff 92       	push	r15
     f48:	0f 93       	push	r16
     f4a:	1f 93       	push	r17
     f4c:	cf 93       	push	r28
     f4e:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     f50:	80 91 c9 07 	lds	r24, 0x07C9
     f54:	81 11       	cpse	r24, r1
     f56:	9b c0       	rjmp	.+310    	; 0x108e <xTaskIncrementTick+0x14e>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
     f58:	80 91 d0 07 	lds	r24, 0x07D0
     f5c:	90 91 d1 07 	lds	r25, 0x07D1
     f60:	01 96       	adiw	r24, 0x01	; 1
     f62:	90 93 d1 07 	sts	0x07D1, r25
     f66:	80 93 d0 07 	sts	0x07D0, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     f6a:	e0 90 d0 07 	lds	r14, 0x07D0
     f6e:	f0 90 d1 07 	lds	r15, 0x07D1

			if( xConstTickCount == ( TickType_t ) 0U )
     f72:	e1 14       	cp	r14, r1
     f74:	f1 04       	cpc	r15, r1
     f76:	b9 f4       	brne	.+46     	; 0xfa6 <xTaskIncrementTick+0x66>
			{
				taskSWITCH_DELAYED_LISTS();
     f78:	80 91 f3 07 	lds	r24, 0x07F3
     f7c:	90 91 f4 07 	lds	r25, 0x07F4
     f80:	20 91 f1 07 	lds	r18, 0x07F1
     f84:	30 91 f2 07 	lds	r19, 0x07F2
     f88:	30 93 f4 07 	sts	0x07F4, r19
     f8c:	20 93 f3 07 	sts	0x07F3, r18
     f90:	90 93 f2 07 	sts	0x07F2, r25
     f94:	80 93 f1 07 	sts	0x07F1, r24
     f98:	80 91 cb 07 	lds	r24, 0x07CB
     f9c:	8f 5f       	subi	r24, 0xFF	; 255
     f9e:	80 93 cb 07 	sts	0x07CB, r24
     fa2:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
     fa6:	80 91 0c 01 	lds	r24, 0x010C
     faa:	90 91 0d 01 	lds	r25, 0x010D
     fae:	e8 16       	cp	r14, r24
     fb0:	f9 06       	cpc	r15, r25
     fb2:	10 f4       	brcc	.+4      	; 0xfb8 <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     fb4:	d1 2c       	mov	r13, r1
     fb6:	53 c0       	rjmp	.+166    	; 0x105e <xTaskIncrementTick+0x11e>
     fb8:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
     fba:	cc 24       	eor	r12, r12
     fbc:	c3 94       	inc	r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     fbe:	e0 91 f3 07 	lds	r30, 0x07F3
     fc2:	f0 91 f4 07 	lds	r31, 0x07F4
     fc6:	90 81       	ld	r25, Z
     fc8:	91 11       	cpse	r25, r1
     fca:	07 c0       	rjmp	.+14     	; 0xfda <xTaskIncrementTick+0x9a>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
     fcc:	8f ef       	ldi	r24, 0xFF	; 255
     fce:	9f ef       	ldi	r25, 0xFF	; 255
     fd0:	90 93 0d 01 	sts	0x010D, r25
     fd4:	80 93 0c 01 	sts	0x010C, r24
						break;
     fd8:	42 c0       	rjmp	.+132    	; 0x105e <xTaskIncrementTick+0x11e>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     fda:	e0 91 f3 07 	lds	r30, 0x07F3
     fde:	f0 91 f4 07 	lds	r31, 0x07F4
     fe2:	05 80       	ldd	r0, Z+5	; 0x05
     fe4:	f6 81       	ldd	r31, Z+6	; 0x06
     fe6:	e0 2d       	mov	r30, r0
     fe8:	c6 81       	ldd	r28, Z+6	; 0x06
     fea:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     fec:	2a 81       	ldd	r18, Y+2	; 0x02
     fee:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
     ff0:	e2 16       	cp	r14, r18
     ff2:	f3 06       	cpc	r15, r19
     ff4:	28 f4       	brcc	.+10     	; 0x1000 <xTaskIncrementTick+0xc0>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
     ff6:	30 93 0d 01 	sts	0x010D, r19
     ffa:	20 93 0c 01 	sts	0x010C, r18
							break;
     ffe:	2f c0       	rjmp	.+94     	; 0x105e <xTaskIncrementTick+0x11e>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1000:	8e 01       	movw	r16, r28
    1002:	0e 5f       	subi	r16, 0xFE	; 254
    1004:	1f 4f       	sbci	r17, 0xFF	; 255
    1006:	c8 01       	movw	r24, r16
    1008:	0e 94 6e 01 	call	0x2dc	; 0x2dc <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    100c:	8c 89       	ldd	r24, Y+20	; 0x14
    100e:	9d 89       	ldd	r25, Y+21	; 0x15
    1010:	89 2b       	or	r24, r25
    1012:	21 f0       	breq	.+8      	; 0x101c <xTaskIncrementTick+0xdc>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1014:	ce 01       	movw	r24, r28
    1016:	0c 96       	adiw	r24, 0x0c	; 12
    1018:	0e 94 6e 01 	call	0x2dc	; 0x2dc <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
    101c:	2e 89       	ldd	r18, Y+22	; 0x16
    101e:	80 91 cf 07 	lds	r24, 0x07CF
    1022:	82 17       	cp	r24, r18
    1024:	10 f4       	brcc	.+4      	; 0x102a <xTaskIncrementTick+0xea>
    1026:	20 93 cf 07 	sts	0x07CF, r18
    102a:	30 e0       	ldi	r19, 0x00	; 0
    102c:	c9 01       	movw	r24, r18
    102e:	88 0f       	add	r24, r24
    1030:	99 1f       	adc	r25, r25
    1032:	88 0f       	add	r24, r24
    1034:	99 1f       	adc	r25, r25
    1036:	88 0f       	add	r24, r24
    1038:	99 1f       	adc	r25, r25
    103a:	82 0f       	add	r24, r18
    103c:	93 1f       	adc	r25, r19
    103e:	b8 01       	movw	r22, r16
    1040:	89 5f       	subi	r24, 0xF9	; 249
    1042:	97 4f       	sbci	r25, 0xF7	; 247
    1044:	0e 94 1c 01 	call	0x238	; 0x238 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1048:	e0 91 2b 08 	lds	r30, 0x082B
    104c:	f0 91 2c 08 	lds	r31, 0x082C
    1050:	9e 89       	ldd	r25, Y+22	; 0x16
    1052:	86 89       	ldd	r24, Z+22	; 0x16
    1054:	98 17       	cp	r25, r24
    1056:	08 f4       	brcc	.+2      	; 0x105a <xTaskIncrementTick+0x11a>
    1058:	b2 cf       	rjmp	.-156    	; 0xfbe <xTaskIncrementTick+0x7e>
							{
								xSwitchRequired = pdTRUE;
    105a:	dc 2c       	mov	r13, r12
    105c:	b0 cf       	rjmp	.-160    	; 0xfbe <xTaskIncrementTick+0x7e>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    105e:	e0 91 2b 08 	lds	r30, 0x082B
    1062:	f0 91 2c 08 	lds	r31, 0x082C
    1066:	86 89       	ldd	r24, Z+22	; 0x16
    1068:	90 e0       	ldi	r25, 0x00	; 0
    106a:	fc 01       	movw	r30, r24
    106c:	ee 0f       	add	r30, r30
    106e:	ff 1f       	adc	r31, r31
    1070:	ee 0f       	add	r30, r30
    1072:	ff 1f       	adc	r31, r31
    1074:	ee 0f       	add	r30, r30
    1076:	ff 1f       	adc	r31, r31
    1078:	8e 0f       	add	r24, r30
    107a:	9f 1f       	adc	r25, r31
    107c:	fc 01       	movw	r30, r24
    107e:	e9 5f       	subi	r30, 0xF9	; 249
    1080:	f7 4f       	sbci	r31, 0xF7	; 247
    1082:	80 81       	ld	r24, Z
    1084:	82 30       	cpi	r24, 0x02	; 2
    1086:	48 f0       	brcs	.+18     	; 0x109a <xTaskIncrementTick+0x15a>
			{
				xSwitchRequired = pdTRUE;
    1088:	dd 24       	eor	r13, r13
    108a:	d3 94       	inc	r13
    108c:	06 c0       	rjmp	.+12     	; 0x109a <xTaskIncrementTick+0x15a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
    108e:	80 91 cd 07 	lds	r24, 0x07CD
    1092:	8f 5f       	subi	r24, 0xFF	; 255
    1094:	80 93 cd 07 	sts	0x07CD, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
    1098:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
    109a:	80 91 cc 07 	lds	r24, 0x07CC
    109e:	88 23       	and	r24, r24
    10a0:	11 f0       	breq	.+4      	; 0x10a6 <xTaskIncrementTick+0x166>
		{
			xSwitchRequired = pdTRUE;
    10a2:	dd 24       	eor	r13, r13
    10a4:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
    10a6:	8d 2d       	mov	r24, r13
    10a8:	df 91       	pop	r29
    10aa:	cf 91       	pop	r28
    10ac:	1f 91       	pop	r17
    10ae:	0f 91       	pop	r16
    10b0:	ff 90       	pop	r15
    10b2:	ef 90       	pop	r14
    10b4:	df 90       	pop	r13
    10b6:	cf 90       	pop	r12
    10b8:	08 95       	ret

000010ba <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    10ba:	df 92       	push	r13
    10bc:	ef 92       	push	r14
    10be:	ff 92       	push	r15
    10c0:	0f 93       	push	r16
    10c2:	1f 93       	push	r17
    10c4:	cf 93       	push	r28
    10c6:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    10c8:	0f b6       	in	r0, 0x3f	; 63
    10ca:	f8 94       	cli
    10cc:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    10ce:	80 91 c9 07 	lds	r24, 0x07C9
    10d2:	81 50       	subi	r24, 0x01	; 1
    10d4:	80 93 c9 07 	sts	0x07C9, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    10d8:	80 91 c9 07 	lds	r24, 0x07C9
    10dc:	81 11       	cpse	r24, r1
    10de:	62 c0       	rjmp	.+196    	; 0x11a4 <xTaskResumeAll+0xea>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    10e0:	80 91 d2 07 	lds	r24, 0x07D2
    10e4:	81 11       	cpse	r24, r1
    10e6:	33 c0       	rjmp	.+102    	; 0x114e <xTaskResumeAll+0x94>
    10e8:	60 c0       	rjmp	.+192    	; 0x11aa <xTaskResumeAll+0xf0>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    10ea:	d7 01       	movw	r26, r14
    10ec:	15 96       	adiw	r26, 0x05	; 5
    10ee:	ed 91       	ld	r30, X+
    10f0:	fc 91       	ld	r31, X
    10f2:	16 97       	sbiw	r26, 0x06	; 6
    10f4:	c6 81       	ldd	r28, Z+6	; 0x06
    10f6:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    10f8:	ce 01       	movw	r24, r28
    10fa:	0c 96       	adiw	r24, 0x0c	; 12
    10fc:	0e 94 6e 01 	call	0x2dc	; 0x2dc <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1100:	8e 01       	movw	r16, r28
    1102:	0e 5f       	subi	r16, 0xFE	; 254
    1104:	1f 4f       	sbci	r17, 0xFF	; 255
    1106:	c8 01       	movw	r24, r16
    1108:	0e 94 6e 01 	call	0x2dc	; 0x2dc <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    110c:	2e 89       	ldd	r18, Y+22	; 0x16
    110e:	80 91 cf 07 	lds	r24, 0x07CF
    1112:	82 17       	cp	r24, r18
    1114:	10 f4       	brcc	.+4      	; 0x111a <xTaskResumeAll+0x60>
    1116:	20 93 cf 07 	sts	0x07CF, r18
    111a:	30 e0       	ldi	r19, 0x00	; 0
    111c:	c9 01       	movw	r24, r18
    111e:	88 0f       	add	r24, r24
    1120:	99 1f       	adc	r25, r25
    1122:	88 0f       	add	r24, r24
    1124:	99 1f       	adc	r25, r25
    1126:	88 0f       	add	r24, r24
    1128:	99 1f       	adc	r25, r25
    112a:	82 0f       	add	r24, r18
    112c:	93 1f       	adc	r25, r19
    112e:	b8 01       	movw	r22, r16
    1130:	89 5f       	subi	r24, 0xF9	; 249
    1132:	97 4f       	sbci	r25, 0xF7	; 247
    1134:	0e 94 1c 01 	call	0x238	; 0x238 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1138:	e0 91 2b 08 	lds	r30, 0x082B
    113c:	f0 91 2c 08 	lds	r31, 0x082C
    1140:	9e 89       	ldd	r25, Y+22	; 0x16
    1142:	86 89       	ldd	r24, Z+22	; 0x16
    1144:	98 17       	cp	r25, r24
    1146:	58 f0       	brcs	.+22     	; 0x115e <xTaskResumeAll+0xa4>
					{
						xYieldPending = pdTRUE;
    1148:	d0 92 cc 07 	sts	0x07CC, r13
    114c:	08 c0       	rjmp	.+16     	; 0x115e <xTaskResumeAll+0xa4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    114e:	0f 2e       	mov	r0, r31
    1150:	f8 ee       	ldi	r31, 0xE8	; 232
    1152:	ef 2e       	mov	r14, r31
    1154:	f7 e0       	ldi	r31, 0x07	; 7
    1156:	ff 2e       	mov	r15, r31
    1158:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    115a:	dd 24       	eor	r13, r13
    115c:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    115e:	f7 01       	movw	r30, r14
    1160:	80 81       	ld	r24, Z
    1162:	81 11       	cpse	r24, r1
    1164:	c2 cf       	rjmp	.-124    	; 0x10ea <xTaskResumeAll+0x30>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    1166:	80 91 cd 07 	lds	r24, 0x07CD
    116a:	88 23       	and	r24, r24
    116c:	99 f0       	breq	.+38     	; 0x1194 <xTaskResumeAll+0xda>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    116e:	80 91 cd 07 	lds	r24, 0x07CD
    1172:	88 23       	and	r24, r24
    1174:	79 f0       	breq	.+30     	; 0x1194 <xTaskResumeAll+0xda>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
    1176:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    1178:	0e 94 a0 07 	call	0xf40	; 0xf40 <xTaskIncrementTick>
    117c:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
    117e:	c0 93 cc 07 	sts	0x07CC, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    1182:	80 91 cd 07 	lds	r24, 0x07CD
    1186:	81 50       	subi	r24, 0x01	; 1
    1188:	80 93 cd 07 	sts	0x07CD, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    118c:	80 91 cd 07 	lds	r24, 0x07CD
    1190:	81 11       	cpse	r24, r1
    1192:	f2 cf       	rjmp	.-28     	; 0x1178 <xTaskResumeAll+0xbe>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    1194:	80 91 cc 07 	lds	r24, 0x07CC
    1198:	81 30       	cpi	r24, 0x01	; 1
    119a:	31 f4       	brne	.+12     	; 0x11a8 <xTaskResumeAll+0xee>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    119c:	0e 94 3a 02 	call	0x474	; 0x474 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    11a0:	81 e0       	ldi	r24, 0x01	; 1
    11a2:	03 c0       	rjmp	.+6      	; 0x11aa <xTaskResumeAll+0xf0>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    11a4:	80 e0       	ldi	r24, 0x00	; 0
    11a6:	01 c0       	rjmp	.+2      	; 0x11aa <xTaskResumeAll+0xf0>
    11a8:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    11aa:	0f 90       	pop	r0
    11ac:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    11ae:	df 91       	pop	r29
    11b0:	cf 91       	pop	r28
    11b2:	1f 91       	pop	r17
    11b4:	0f 91       	pop	r16
    11b6:	ff 90       	pop	r15
    11b8:	ef 90       	pop	r14
    11ba:	df 90       	pop	r13
    11bc:	08 95       	ret

000011be <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
    11be:	0f 93       	push	r16
    11c0:	1f 93       	push	r17
    11c2:	cf 93       	push	r28
    11c4:	df 93       	push	r29
    11c6:	8c 01       	movw	r16, r24
    11c8:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
    11ca:	0e 94 8b 07 	call	0xf16	; 0xf16 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
    11ce:	80 91 d0 07 	lds	r24, 0x07D0
    11d2:	90 91 d1 07 	lds	r25, 0x07D1

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    11d6:	f8 01       	movw	r30, r16
    11d8:	20 81       	ld	r18, Z
    11da:	31 81       	ldd	r19, Z+1	; 0x01
    11dc:	c2 0f       	add	r28, r18
    11de:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
    11e0:	82 17       	cp	r24, r18
    11e2:	93 07       	cpc	r25, r19
    11e4:	48 f4       	brcc	.+18     	; 0x11f8 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    11e6:	c2 17       	cp	r28, r18
    11e8:	d3 07       	cpc	r29, r19
    11ea:	10 f5       	brcc	.+68     	; 0x1230 <vTaskDelayUntil+0x72>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    11ec:	d1 83       	std	Z+1, r29	; 0x01
    11ee:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
    11f0:	8c 17       	cp	r24, r28
    11f2:	9d 07       	cpc	r25, r29
    11f4:	90 f4       	brcc	.+36     	; 0x121a <vTaskDelayUntil+0x5c>
    11f6:	07 c0       	rjmp	.+14     	; 0x1206 <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    11f8:	c2 17       	cp	r28, r18
    11fa:	d3 07       	cpc	r29, r19
    11fc:	a8 f0       	brcs	.+42     	; 0x1228 <vTaskDelayUntil+0x6a>
    11fe:	8c 17       	cp	r24, r28
    1200:	9d 07       	cpc	r25, r29
    1202:	90 f0       	brcs	.+36     	; 0x1228 <vTaskDelayUntil+0x6a>
    1204:	15 c0       	rjmp	.+42     	; 0x1230 <vTaskDelayUntil+0x72>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1206:	80 91 2b 08 	lds	r24, 0x082B
    120a:	90 91 2c 08 	lds	r25, 0x082C
    120e:	02 96       	adiw	r24, 0x02	; 2
    1210:	0e 94 6e 01 	call	0x2dc	; 0x2dc <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1214:	ce 01       	movw	r24, r28
    1216:	0e 94 12 06 	call	0xc24	; 0xc24 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    121a:	0e 94 5d 08 	call	0x10ba	; 0x10ba <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    121e:	81 11       	cpse	r24, r1
    1220:	0b c0       	rjmp	.+22     	; 0x1238 <vTaskDelayUntil+0x7a>
		{
			portYIELD_WITHIN_API();
    1222:	0e 94 3a 02 	call	0x474	; 0x474 <vPortYield>
    1226:	08 c0       	rjmp	.+16     	; 0x1238 <vTaskDelayUntil+0x7a>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    1228:	f8 01       	movw	r30, r16
    122a:	d1 83       	std	Z+1, r29	; 0x01
    122c:	c0 83       	st	Z, r28
    122e:	eb cf       	rjmp	.-42     	; 0x1206 <vTaskDelayUntil+0x48>
    1230:	f8 01       	movw	r30, r16
    1232:	d1 83       	std	Z+1, r29	; 0x01
    1234:	c0 83       	st	Z, r28
    1236:	f1 cf       	rjmp	.-30     	; 0x121a <vTaskDelayUntil+0x5c>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1238:	df 91       	pop	r29
    123a:	cf 91       	pop	r28
    123c:	1f 91       	pop	r17
    123e:	0f 91       	pop	r16
    1240:	08 95       	ret

00001242 <prvIdleTask>:
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1242:	0f ed       	ldi	r16, 0xDF	; 223
    1244:	17 e0       	ldi	r17, 0x07	; 7

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1246:	0f 2e       	mov	r0, r31
    1248:	f7 e0       	ldi	r31, 0x07	; 7
    124a:	ef 2e       	mov	r14, r31
    124c:	f8 e0       	ldi	r31, 0x08	; 8
    124e:	ff 2e       	mov	r15, r31
    1250:	f0 2d       	mov	r31, r0
    1252:	29 c0       	rjmp	.+82     	; 0x12a6 <prvIdleTask+0x64>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    1254:	0e 94 8b 07 	call	0xf16	; 0xf16 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1258:	d8 01       	movw	r26, r16
    125a:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
    125c:	0e 94 5d 08 	call	0x10ba	; 0x10ba <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1260:	cc 23       	and	r28, r28
    1262:	09 f1       	breq	.+66     	; 0x12a6 <prvIdleTask+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    1264:	0f b6       	in	r0, 0x3f	; 63
    1266:	f8 94       	cli
    1268:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    126a:	d8 01       	movw	r26, r16
    126c:	15 96       	adiw	r26, 0x05	; 5
    126e:	ed 91       	ld	r30, X+
    1270:	fc 91       	ld	r31, X
    1272:	16 97       	sbiw	r26, 0x06	; 6
    1274:	c6 81       	ldd	r28, Z+6	; 0x06
    1276:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1278:	ce 01       	movw	r24, r28
    127a:	02 96       	adiw	r24, 0x02	; 2
    127c:	0e 94 6e 01 	call	0x2dc	; 0x2dc <uxListRemove>
					--uxCurrentNumberOfTasks;
    1280:	80 91 d2 07 	lds	r24, 0x07D2
    1284:	81 50       	subi	r24, 0x01	; 1
    1286:	80 93 d2 07 	sts	0x07D2, r24
					--uxTasksDeleted;
    128a:	80 91 de 07 	lds	r24, 0x07DE
    128e:	81 50       	subi	r24, 0x01	; 1
    1290:	80 93 de 07 	sts	0x07DE, r24
				}
				taskEXIT_CRITICAL();
    1294:	0f 90       	pop	r0
    1296:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    1298:	8f 89       	ldd	r24, Y+23	; 0x17
    129a:	98 8d       	ldd	r25, Y+24	; 0x18
    129c:	0e 94 8c 03 	call	0x718	; 0x718 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    12a0:	ce 01       	movw	r24, r28
    12a2:	0e 94 8c 03 	call	0x718	; 0x718 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    12a6:	80 91 de 07 	lds	r24, 0x07DE
    12aa:	81 11       	cpse	r24, r1
    12ac:	d3 cf       	rjmp	.-90     	; 0x1254 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    12ae:	f7 01       	movw	r30, r14
    12b0:	80 81       	ld	r24, Z
    12b2:	82 30       	cpi	r24, 0x02	; 2
    12b4:	c0 f3       	brcs	.-16     	; 0x12a6 <prvIdleTask+0x64>
			{
				taskYIELD();
    12b6:	0e 94 3a 02 	call	0x474	; 0x474 <vPortYield>
    12ba:	f5 cf       	rjmp	.-22     	; 0x12a6 <prvIdleTask+0x64>

000012bc <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    12bc:	80 91 c9 07 	lds	r24, 0x07C9
    12c0:	88 23       	and	r24, r24
    12c2:	21 f0       	breq	.+8      	; 0x12cc <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    12c4:	81 e0       	ldi	r24, 0x01	; 1
    12c6:	80 93 cc 07 	sts	0x07CC, r24
    12ca:	08 95       	ret
	//	USART_sendstr("uxSchedulerSuspended");
	}
	else
	{
		xYieldPending = pdFALSE;
    12cc:	10 92 cc 07 	sts	0x07CC, r1
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
	//	USART_sendstr("HIGHEST_PRIORITY_TASK\n");
		taskSELECT_HIGHEST_PRIORITY_TASK();
    12d0:	80 91 cf 07 	lds	r24, 0x07CF
    12d4:	90 e0       	ldi	r25, 0x00	; 0
    12d6:	fc 01       	movw	r30, r24
    12d8:	ee 0f       	add	r30, r30
    12da:	ff 1f       	adc	r31, r31
    12dc:	ee 0f       	add	r30, r30
    12de:	ff 1f       	adc	r31, r31
    12e0:	ee 0f       	add	r30, r30
    12e2:	ff 1f       	adc	r31, r31
    12e4:	8e 0f       	add	r24, r30
    12e6:	9f 1f       	adc	r25, r31
    12e8:	fc 01       	movw	r30, r24
    12ea:	e9 5f       	subi	r30, 0xF9	; 249
    12ec:	f7 4f       	sbci	r31, 0xF7	; 247
    12ee:	80 81       	ld	r24, Z
    12f0:	81 11       	cpse	r24, r1
    12f2:	17 c0       	rjmp	.+46     	; 0x1322 <vTaskSwitchContext+0x66>
    12f4:	80 91 cf 07 	lds	r24, 0x07CF
    12f8:	81 50       	subi	r24, 0x01	; 1
    12fa:	80 93 cf 07 	sts	0x07CF, r24
    12fe:	80 91 cf 07 	lds	r24, 0x07CF
    1302:	90 e0       	ldi	r25, 0x00	; 0
    1304:	fc 01       	movw	r30, r24
    1306:	ee 0f       	add	r30, r30
    1308:	ff 1f       	adc	r31, r31
    130a:	ee 0f       	add	r30, r30
    130c:	ff 1f       	adc	r31, r31
    130e:	ee 0f       	add	r30, r30
    1310:	ff 1f       	adc	r31, r31
    1312:	8e 0f       	add	r24, r30
    1314:	9f 1f       	adc	r25, r31
    1316:	fc 01       	movw	r30, r24
    1318:	e9 5f       	subi	r30, 0xF9	; 249
    131a:	f7 4f       	sbci	r31, 0xF7	; 247
    131c:	80 81       	ld	r24, Z
    131e:	88 23       	and	r24, r24
    1320:	49 f3       	breq	.-46     	; 0x12f4 <vTaskSwitchContext+0x38>
    1322:	80 91 cf 07 	lds	r24, 0x07CF
    1326:	90 e0       	ldi	r25, 0x00	; 0
    1328:	9c 01       	movw	r18, r24
    132a:	22 0f       	add	r18, r18
    132c:	33 1f       	adc	r19, r19
    132e:	22 0f       	add	r18, r18
    1330:	33 1f       	adc	r19, r19
    1332:	22 0f       	add	r18, r18
    1334:	33 1f       	adc	r19, r19
    1336:	28 0f       	add	r18, r24
    1338:	39 1f       	adc	r19, r25
    133a:	d9 01       	movw	r26, r18
    133c:	a9 5f       	subi	r26, 0xF9	; 249
    133e:	b7 4f       	sbci	r27, 0xF7	; 247
    1340:	11 96       	adiw	r26, 0x01	; 1
    1342:	ed 91       	ld	r30, X+
    1344:	fc 91       	ld	r31, X
    1346:	12 97       	sbiw	r26, 0x02	; 2
    1348:	02 80       	ldd	r0, Z+2	; 0x02
    134a:	f3 81       	ldd	r31, Z+3	; 0x03
    134c:	e0 2d       	mov	r30, r0
    134e:	12 96       	adiw	r26, 0x02	; 2
    1350:	fc 93       	st	X, r31
    1352:	ee 93       	st	-X, r30
    1354:	11 97       	sbiw	r26, 0x01	; 1
    1356:	26 5f       	subi	r18, 0xF6	; 246
    1358:	37 4f       	sbci	r19, 0xF7	; 247
    135a:	e2 17       	cp	r30, r18
    135c:	f3 07       	cpc	r31, r19
    135e:	29 f4       	brne	.+10     	; 0x136a <vTaskSwitchContext+0xae>
    1360:	22 81       	ldd	r18, Z+2	; 0x02
    1362:	33 81       	ldd	r19, Z+3	; 0x03
    1364:	fd 01       	movw	r30, r26
    1366:	32 83       	std	Z+2, r19	; 0x02
    1368:	21 83       	std	Z+1, r18	; 0x01
    136a:	fc 01       	movw	r30, r24
    136c:	ee 0f       	add	r30, r30
    136e:	ff 1f       	adc	r31, r31
    1370:	ee 0f       	add	r30, r30
    1372:	ff 1f       	adc	r31, r31
    1374:	ee 0f       	add	r30, r30
    1376:	ff 1f       	adc	r31, r31
    1378:	8e 0f       	add	r24, r30
    137a:	9f 1f       	adc	r25, r31
    137c:	fc 01       	movw	r30, r24
    137e:	e9 5f       	subi	r30, 0xF9	; 249
    1380:	f7 4f       	sbci	r31, 0xF7	; 247
    1382:	01 80       	ldd	r0, Z+1	; 0x01
    1384:	f2 81       	ldd	r31, Z+2	; 0x02
    1386:	e0 2d       	mov	r30, r0
    1388:	86 81       	ldd	r24, Z+6	; 0x06
    138a:	97 81       	ldd	r25, Z+7	; 0x07
    138c:	90 93 2c 08 	sts	0x082C, r25
    1390:	80 93 2b 08 	sts	0x082B, r24
    1394:	08 95       	ret

00001396 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    1396:	cf 93       	push	r28
    1398:	df 93       	push	r29
    139a:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    139c:	20 91 2b 08 	lds	r18, 0x082B
    13a0:	30 91 2c 08 	lds	r19, 0x082C
    13a4:	b9 01       	movw	r22, r18
    13a6:	64 5f       	subi	r22, 0xF4	; 244
    13a8:	7f 4f       	sbci	r23, 0xFF	; 255
    13aa:	0e 94 3d 01 	call	0x27a	; 0x27a <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    13ae:	80 91 2b 08 	lds	r24, 0x082B
    13b2:	90 91 2c 08 	lds	r25, 0x082C
    13b6:	02 96       	adiw	r24, 0x02	; 2
    13b8:	0e 94 6e 01 	call	0x2dc	; 0x2dc <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    13bc:	cf 3f       	cpi	r28, 0xFF	; 255
    13be:	8f ef       	ldi	r24, 0xFF	; 255
    13c0:	d8 07       	cpc	r29, r24
    13c2:	59 f4       	brne	.+22     	; 0x13da <vTaskPlaceOnEventList+0x44>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    13c4:	60 91 2b 08 	lds	r22, 0x082B
    13c8:	70 91 2c 08 	lds	r23, 0x082C
    13cc:	6e 5f       	subi	r22, 0xFE	; 254
    13ce:	7f 4f       	sbci	r23, 0xFF	; 255
    13d0:	85 ed       	ldi	r24, 0xD5	; 213
    13d2:	97 e0       	ldi	r25, 0x07	; 7
    13d4:	0e 94 1c 01 	call	0x238	; 0x238 <vListInsertEnd>
    13d8:	08 c0       	rjmp	.+16     	; 0x13ea <vTaskPlaceOnEventList+0x54>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    13da:	80 91 d0 07 	lds	r24, 0x07D0
    13de:	90 91 d1 07 	lds	r25, 0x07D1
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    13e2:	8c 0f       	add	r24, r28
    13e4:	9d 1f       	adc	r25, r29
    13e6:	0e 94 12 06 	call	0xc24	; 0xc24 <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    13ea:	df 91       	pop	r29
    13ec:	cf 91       	pop	r28
    13ee:	08 95       	ret

000013f0 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    13f0:	0f 93       	push	r16
    13f2:	1f 93       	push	r17
    13f4:	cf 93       	push	r28
    13f6:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    13f8:	dc 01       	movw	r26, r24
    13fa:	15 96       	adiw	r26, 0x05	; 5
    13fc:	ed 91       	ld	r30, X+
    13fe:	fc 91       	ld	r31, X
    1400:	16 97       	sbiw	r26, 0x06	; 6
    1402:	c6 81       	ldd	r28, Z+6	; 0x06
    1404:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1406:	8e 01       	movw	r16, r28
    1408:	04 5f       	subi	r16, 0xF4	; 244
    140a:	1f 4f       	sbci	r17, 0xFF	; 255
    140c:	c8 01       	movw	r24, r16
    140e:	0e 94 6e 01 	call	0x2dc	; 0x2dc <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1412:	80 91 c9 07 	lds	r24, 0x07C9
    1416:	81 11       	cpse	r24, r1
    1418:	1c c0       	rjmp	.+56     	; 0x1452 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    141a:	0a 50       	subi	r16, 0x0A	; 10
    141c:	11 09       	sbc	r17, r1
    141e:	c8 01       	movw	r24, r16
    1420:	0e 94 6e 01 	call	0x2dc	; 0x2dc <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    1424:	2e 89       	ldd	r18, Y+22	; 0x16
    1426:	80 91 cf 07 	lds	r24, 0x07CF
    142a:	82 17       	cp	r24, r18
    142c:	10 f4       	brcc	.+4      	; 0x1432 <xTaskRemoveFromEventList+0x42>
    142e:	20 93 cf 07 	sts	0x07CF, r18
    1432:	30 e0       	ldi	r19, 0x00	; 0
    1434:	c9 01       	movw	r24, r18
    1436:	88 0f       	add	r24, r24
    1438:	99 1f       	adc	r25, r25
    143a:	88 0f       	add	r24, r24
    143c:	99 1f       	adc	r25, r25
    143e:	88 0f       	add	r24, r24
    1440:	99 1f       	adc	r25, r25
    1442:	82 0f       	add	r24, r18
    1444:	93 1f       	adc	r25, r19
    1446:	b8 01       	movw	r22, r16
    1448:	89 5f       	subi	r24, 0xF9	; 249
    144a:	97 4f       	sbci	r25, 0xF7	; 247
    144c:	0e 94 1c 01 	call	0x238	; 0x238 <vListInsertEnd>
    1450:	05 c0       	rjmp	.+10     	; 0x145c <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1452:	b8 01       	movw	r22, r16
    1454:	88 ee       	ldi	r24, 0xE8	; 232
    1456:	97 e0       	ldi	r25, 0x07	; 7
    1458:	0e 94 1c 01 	call	0x238	; 0x238 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    145c:	e0 91 2b 08 	lds	r30, 0x082B
    1460:	f0 91 2c 08 	lds	r31, 0x082C
    1464:	9e 89       	ldd	r25, Y+22	; 0x16
    1466:	86 89       	ldd	r24, Z+22	; 0x16
    1468:	89 17       	cp	r24, r25
    146a:	20 f4       	brcc	.+8      	; 0x1474 <xTaskRemoveFromEventList+0x84>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    146c:	81 e0       	ldi	r24, 0x01	; 1
    146e:	80 93 cc 07 	sts	0x07CC, r24
    1472:	01 c0       	rjmp	.+2      	; 0x1476 <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		xReturn = pdFALSE;
    1474:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    1476:	df 91       	pop	r29
    1478:	cf 91       	pop	r28
    147a:	1f 91       	pop	r17
    147c:	0f 91       	pop	r16
    147e:	08 95       	ret

00001480 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1480:	20 91 cb 07 	lds	r18, 0x07CB
    1484:	fc 01       	movw	r30, r24
    1486:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1488:	20 91 d0 07 	lds	r18, 0x07D0
    148c:	30 91 d1 07 	lds	r19, 0x07D1
    1490:	32 83       	std	Z+2, r19	; 0x02
    1492:	21 83       	std	Z+1, r18	; 0x01
    1494:	08 95       	ret

00001496 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1496:	0f b6       	in	r0, 0x3f	; 63
    1498:	f8 94       	cli
    149a:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    149c:	40 91 d0 07 	lds	r20, 0x07D0
    14a0:	50 91 d1 07 	lds	r21, 0x07D1

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    14a4:	db 01       	movw	r26, r22
    14a6:	2d 91       	ld	r18, X+
    14a8:	3c 91       	ld	r19, X
    14aa:	2f 3f       	cpi	r18, 0xFF	; 255
    14ac:	bf ef       	ldi	r27, 0xFF	; 255
    14ae:	3b 07       	cpc	r19, r27
    14b0:	19 f1       	breq	.+70     	; 0x14f8 <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    14b2:	e0 91 cb 07 	lds	r30, 0x07CB
    14b6:	dc 01       	movw	r26, r24
    14b8:	fc 91       	ld	r31, X
    14ba:	fe 17       	cp	r31, r30
    14bc:	39 f0       	breq	.+14     	; 0x14cc <xTaskCheckForTimeOut+0x36>
    14be:	11 96       	adiw	r26, 0x01	; 1
    14c0:	ed 91       	ld	r30, X+
    14c2:	fc 91       	ld	r31, X
    14c4:	12 97       	sbiw	r26, 0x02	; 2
    14c6:	4e 17       	cp	r20, r30
    14c8:	5f 07       	cpc	r21, r31
    14ca:	c0 f4       	brcc	.+48     	; 0x14fc <xTaskCheckForTimeOut+0x66>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    14cc:	dc 01       	movw	r26, r24
    14ce:	11 96       	adiw	r26, 0x01	; 1
    14d0:	ed 91       	ld	r30, X+
    14d2:	fc 91       	ld	r31, X
    14d4:	12 97       	sbiw	r26, 0x02	; 2
    14d6:	da 01       	movw	r26, r20
    14d8:	ae 1b       	sub	r26, r30
    14da:	bf 0b       	sbc	r27, r31
    14dc:	a2 17       	cp	r26, r18
    14de:	b3 07       	cpc	r27, r19
    14e0:	78 f4       	brcc	.+30     	; 0x1500 <xTaskCheckForTimeOut+0x6a>
    14e2:	db 01       	movw	r26, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    14e4:	e4 1b       	sub	r30, r20
    14e6:	f5 0b       	sbc	r31, r21
    14e8:	2e 0f       	add	r18, r30
    14ea:	3f 1f       	adc	r19, r31
    14ec:	2d 93       	st	X+, r18
    14ee:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    14f0:	0e 94 40 0a 	call	0x1480	; 0x1480 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    14f4:	80 e0       	ldi	r24, 0x00	; 0
    14f6:	05 c0       	rjmp	.+10     	; 0x1502 <xTaskCheckForTimeOut+0x6c>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    14f8:	80 e0       	ldi	r24, 0x00	; 0
    14fa:	03 c0       	rjmp	.+6      	; 0x1502 <xTaskCheckForTimeOut+0x6c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    14fc:	81 e0       	ldi	r24, 0x01	; 1
    14fe:	01 c0       	rjmp	.+2      	; 0x1502 <xTaskCheckForTimeOut+0x6c>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1500:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1502:	0f 90       	pop	r0
    1504:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1506:	08 95       	ret

00001508 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1508:	81 e0       	ldi	r24, 0x01	; 1
    150a:	80 93 cc 07 	sts	0x07CC, r24
    150e:	08 95       	ret

00001510 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
    1510:	0f 93       	push	r16
    1512:	1f 93       	push	r17
    1514:	cf 93       	push	r28
    1516:	df 93       	push	r29
    1518:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
    151a:	89 2b       	or	r24, r25
    151c:	09 f4       	brne	.+2      	; 0x1520 <vTaskPriorityInherit+0x10>
    151e:	55 c0       	rjmp	.+170    	; 0x15ca <vTaskPriorityInherit+0xba>
		{
			/* If the holder of the mutex has a priority below the priority of
			the task attempting to obtain the mutex then it will temporarily
			inherit the priority of the task attempting to obtain the mutex. */
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
    1520:	26 89       	ldd	r18, Z+22	; 0x16
    1522:	a0 91 2b 08 	lds	r26, 0x082B
    1526:	b0 91 2c 08 	lds	r27, 0x082C
    152a:	56 96       	adiw	r26, 0x16	; 22
    152c:	8c 91       	ld	r24, X
    152e:	28 17       	cp	r18, r24
    1530:	08 f0       	brcs	.+2      	; 0x1534 <vTaskPriorityInherit+0x24>
    1532:	4b c0       	rjmp	.+150    	; 0x15ca <vTaskPriorityInherit+0xba>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
    1534:	84 85       	ldd	r24, Z+12	; 0x0c
    1536:	95 85       	ldd	r25, Z+13	; 0x0d
    1538:	99 23       	and	r25, r25
    153a:	64 f0       	brlt	.+24     	; 0x1554 <vTaskPriorityInherit+0x44>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    153c:	a0 91 2b 08 	lds	r26, 0x082B
    1540:	b0 91 2c 08 	lds	r27, 0x082C
    1544:	56 96       	adiw	r26, 0x16	; 22
    1546:	3c 91       	ld	r19, X
    1548:	84 e0       	ldi	r24, 0x04	; 4
    154a:	90 e0       	ldi	r25, 0x00	; 0
    154c:	83 1b       	sub	r24, r19
    154e:	91 09       	sbc	r25, r1
    1550:	95 87       	std	Z+13, r25	; 0x0d
    1552:	84 87       	std	Z+12, r24	; 0x0c
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need
				to be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
    1554:	30 e0       	ldi	r19, 0x00	; 0
    1556:	c9 01       	movw	r24, r18
    1558:	88 0f       	add	r24, r24
    155a:	99 1f       	adc	r25, r25
    155c:	88 0f       	add	r24, r24
    155e:	99 1f       	adc	r25, r25
    1560:	88 0f       	add	r24, r24
    1562:	99 1f       	adc	r25, r25
    1564:	28 0f       	add	r18, r24
    1566:	39 1f       	adc	r19, r25
    1568:	29 5f       	subi	r18, 0xF9	; 249
    156a:	37 4f       	sbci	r19, 0xF7	; 247
    156c:	82 85       	ldd	r24, Z+10	; 0x0a
    156e:	93 85       	ldd	r25, Z+11	; 0x0b
    1570:	82 17       	cp	r24, r18
    1572:	93 07       	cpc	r25, r19
    1574:	19 f5       	brne	.+70     	; 0x15bc <vTaskPriorityInherit+0xac>
    1576:	8f 01       	movw	r16, r30
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1578:	ef 01       	movw	r28, r30
    157a:	22 96       	adiw	r28, 0x02	; 2
    157c:	ce 01       	movw	r24, r28
    157e:	0e 94 6e 01 	call	0x2dc	; 0x2dc <uxListRemove>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    1582:	e0 91 2b 08 	lds	r30, 0x082B
    1586:	f0 91 2c 08 	lds	r31, 0x082C
    158a:	26 89       	ldd	r18, Z+22	; 0x16
    158c:	f8 01       	movw	r30, r16
    158e:	26 8b       	std	Z+22, r18	; 0x16
					prvAddTaskToReadyList( pxTCB );
    1590:	80 91 cf 07 	lds	r24, 0x07CF
    1594:	82 17       	cp	r24, r18
    1596:	10 f4       	brcc	.+4      	; 0x159c <vTaskPriorityInherit+0x8c>
    1598:	20 93 cf 07 	sts	0x07CF, r18
    159c:	30 e0       	ldi	r19, 0x00	; 0
    159e:	c9 01       	movw	r24, r18
    15a0:	88 0f       	add	r24, r24
    15a2:	99 1f       	adc	r25, r25
    15a4:	88 0f       	add	r24, r24
    15a6:	99 1f       	adc	r25, r25
    15a8:	88 0f       	add	r24, r24
    15aa:	99 1f       	adc	r25, r25
    15ac:	82 0f       	add	r24, r18
    15ae:	93 1f       	adc	r25, r19
    15b0:	be 01       	movw	r22, r28
    15b2:	89 5f       	subi	r24, 0xF9	; 249
    15b4:	97 4f       	sbci	r25, 0xF7	; 247
    15b6:	0e 94 1c 01 	call	0x238	; 0x238 <vListInsertEnd>
    15ba:	07 c0       	rjmp	.+14     	; 0x15ca <vTaskPriorityInherit+0xba>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
    15bc:	a0 91 2b 08 	lds	r26, 0x082B
    15c0:	b0 91 2c 08 	lds	r27, 0x082C
    15c4:	56 96       	adiw	r26, 0x16	; 22
    15c6:	8c 91       	ld	r24, X
    15c8:	86 8b       	std	Z+22, r24	; 0x16
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    15ca:	df 91       	pop	r29
    15cc:	cf 91       	pop	r28
    15ce:	1f 91       	pop	r17
    15d0:	0f 91       	pop	r16
    15d2:	08 95       	ret

000015d4 <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
    15d4:	0f 93       	push	r16
    15d6:	1f 93       	push	r17
    15d8:	cf 93       	push	r28
    15da:	df 93       	push	r29
    15dc:	fc 01       	movw	r30, r24
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;

		if( pxMutexHolder != NULL )
    15de:	89 2b       	or	r24, r25
    15e0:	79 f1       	breq	.+94     	; 0x1640 <xTaskPriorityDisinherit+0x6c>
			interrupt, and if a mutex is given by the holding task then it must
			be the running state task. */
			configASSERT( pxTCB == pxCurrentTCB );

			configASSERT( pxTCB->uxMutexesHeld );
			( pxTCB->uxMutexesHeld )--;
    15e2:	82 a1       	ldd	r24, Z+34	; 0x22
    15e4:	81 50       	subi	r24, 0x01	; 1
    15e6:	82 a3       	std	Z+34, r24	; 0x22

			/* Has the holder of the mutex inherited the priority of another
			task? */
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
    15e8:	26 89       	ldd	r18, Z+22	; 0x16
    15ea:	91 a1       	ldd	r25, Z+33	; 0x21
    15ec:	29 17       	cp	r18, r25
    15ee:	51 f1       	breq	.+84     	; 0x1644 <xTaskPriorityDisinherit+0x70>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
    15f0:	81 11       	cpse	r24, r1
    15f2:	2a c0       	rjmp	.+84     	; 0x1648 <xTaskPriorityDisinherit+0x74>
    15f4:	ef 01       	movw	r28, r30
					/* A task can only have an inherited priority if it holds
					the mutex.  If the mutex is held by a task then it cannot be
					given from an interrupt, and if a mutex is given by the
					holding	task then it must be the running state task.  Remove
					the	holding task from the ready	list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    15f6:	8f 01       	movw	r16, r30
    15f8:	0e 5f       	subi	r16, 0xFE	; 254
    15fa:	1f 4f       	sbci	r17, 0xFF	; 255
    15fc:	c8 01       	movw	r24, r16
    15fe:	0e 94 6e 01 	call	0x2dc	; 0x2dc <uxListRemove>
					}

					/* Disinherit the priority before adding the task into the
					new	ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
    1602:	29 a1       	ldd	r18, Y+33	; 0x21
    1604:	2e 8b       	std	Y+22, r18	; 0x16

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    1606:	44 e0       	ldi	r20, 0x04	; 4
    1608:	50 e0       	ldi	r21, 0x00	; 0
    160a:	42 1b       	sub	r20, r18
    160c:	51 09       	sbc	r21, r1
    160e:	5d 87       	std	Y+13, r21	; 0x0d
    1610:	4c 87       	std	Y+12, r20	; 0x0c
					prvAddTaskToReadyList( pxTCB );
    1612:	80 91 cf 07 	lds	r24, 0x07CF
    1616:	82 17       	cp	r24, r18
    1618:	10 f4       	brcc	.+4      	; 0x161e <xTaskPriorityDisinherit+0x4a>
    161a:	20 93 cf 07 	sts	0x07CF, r18
    161e:	30 e0       	ldi	r19, 0x00	; 0
    1620:	c9 01       	movw	r24, r18
    1622:	88 0f       	add	r24, r24
    1624:	99 1f       	adc	r25, r25
    1626:	88 0f       	add	r24, r24
    1628:	99 1f       	adc	r25, r25
    162a:	88 0f       	add	r24, r24
    162c:	99 1f       	adc	r25, r25
    162e:	82 0f       	add	r24, r18
    1630:	93 1f       	adc	r25, r19
    1632:	b8 01       	movw	r22, r16
    1634:	89 5f       	subi	r24, 0xF9	; 249
    1636:	97 4f       	sbci	r25, 0xF7	; 247
    1638:	0e 94 1c 01 	call	0x238	; 0x238 <vListInsertEnd>
					in an order different to that in which they were taken.
					If a context switch did not occur when the first mutex was
					returned, even if a task was waiting on it, then a context
					switch should occur when the last mutex is returned whether
					a task is waiting on it or not. */
					xReturn = pdTRUE;
    163c:	81 e0       	ldi	r24, 0x01	; 1
    163e:	05 c0       	rjmp	.+10     	; 0x164a <xTaskPriorityDisinherit+0x76>
#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
	BaseType_t xReturn = pdFALSE;
    1640:	80 e0       	ldi	r24, 0x00	; 0
    1642:	03 c0       	rjmp	.+6      	; 0x164a <xTaskPriorityDisinherit+0x76>
    1644:	80 e0       	ldi	r24, 0x00	; 0
    1646:	01 c0       	rjmp	.+2      	; 0x164a <xTaskPriorityDisinherit+0x76>
    1648:	80 e0       	ldi	r24, 0x00	; 0
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
	}
    164a:	df 91       	pop	r29
    164c:	cf 91       	pop	r28
    164e:	1f 91       	pop	r17
    1650:	0f 91       	pop	r16
    1652:	08 95       	ret

00001654 <pvTaskIncrementMutexHeldCount>:

	void *pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    1654:	80 91 2b 08 	lds	r24, 0x082B
    1658:	90 91 2c 08 	lds	r25, 0x082C
    165c:	89 2b       	or	r24, r25
    165e:	39 f0       	breq	.+14     	; 0x166e <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    1660:	e0 91 2b 08 	lds	r30, 0x082B
    1664:	f0 91 2c 08 	lds	r31, 0x082C
    1668:	82 a1       	ldd	r24, Z+34	; 0x22
    166a:	8f 5f       	subi	r24, 0xFF	; 255
    166c:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    166e:	80 91 2b 08 	lds	r24, 0x082B
    1672:	90 91 2c 08 	lds	r25, 0x082C
	}
    1676:	08 95       	ret

00001678 <attachInterrupt>:

static volatile voidFuncPtr intFunc[EXTERNAL_NUM_INTERRUPTS];
// volatile static voidFuncPtr twiIntFunc;

void attachInterrupt(uint8_t interruptNum, void (*userFunc)(void), int mode) {
  if(interruptNum < EXTERNAL_NUM_INTERRUPTS) {
    1678:	82 30       	cpi	r24, 0x02	; 2
    167a:	00 f5       	brcc	.+64     	; 0x16bc <attachInterrupt+0x44>
    intFunc[interruptNum] = userFunc;
    167c:	e8 2f       	mov	r30, r24
    167e:	f0 e0       	ldi	r31, 0x00	; 0
    1680:	ee 0f       	add	r30, r30
    1682:	ff 1f       	adc	r31, r31
    1684:	e3 5d       	subi	r30, 0xD3	; 211
    1686:	f7 4f       	sbci	r31, 0xF7	; 247
    1688:	71 83       	std	Z+1, r23	; 0x01
    168a:	60 83       	st	Z, r22
    // to the configuration bits in the hardware register, so we simply shift
    // the mode into place.
      
    // Enable the interrupt.
      
    switch (interruptNum) {
    168c:	88 23       	and	r24, r24
    168e:	19 f0       	breq	.+6      	; 0x1696 <attachInterrupt+0x1e>
    1690:	81 30       	cpi	r24, 0x01	; 1
    1692:	49 f0       	breq	.+18     	; 0x16a6 <attachInterrupt+0x2e>
    1694:	08 95       	ret
      EIMSK |= (1 << INT7);
      break;
#else		
    case 0:
    #if defined(EICRA) && defined(ISC00) && defined(EIMSK)
      EICRA = (EICRA & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
    1696:	e9 e6       	ldi	r30, 0x69	; 105
    1698:	f0 e0       	ldi	r31, 0x00	; 0
    169a:	80 81       	ld	r24, Z
    169c:	8c 7f       	andi	r24, 0xFC	; 252
    169e:	48 2b       	or	r20, r24
    16a0:	40 83       	st	Z, r20
      EIMSK |= (1 << INT0);
    16a2:	e8 9a       	sbi	0x1d, 0	; 29
      MCUCR = (MCUCR & ~((1 << ISC00) | (1 << ISC01))) | (mode << ISC00);
      GIMSK |= (1 << INT0);
    #else
      #error attachInterrupt not finished for this CPU (case 0)
    #endif
      break;
    16a4:	08 95       	ret

    case 1:
    #if defined(EICRA) && defined(ISC10) && defined(ISC11) && defined(EIMSK)
      EICRA = (EICRA & ~((1 << ISC10) | (1 << ISC11))) | (mode << ISC10);
    16a6:	e9 e6       	ldi	r30, 0x69	; 105
    16a8:	f0 e0       	ldi	r31, 0x00	; 0
    16aa:	80 81       	ld	r24, Z
    16ac:	44 0f       	add	r20, r20
    16ae:	55 1f       	adc	r21, r21
    16b0:	44 0f       	add	r20, r20
    16b2:	55 1f       	adc	r21, r21
    16b4:	83 7f       	andi	r24, 0xF3	; 243
    16b6:	48 2b       	or	r20, r24
    16b8:	40 83       	st	Z, r20
      EIMSK |= (1 << INT1);
    16ba:	e9 9a       	sbi	0x1d, 1	; 29
    16bc:	08 95       	ret

000016be <__vector_1>:
    intFunc[EXTERNAL_INT_7]();
}

#else

ISR(INT0_vect) {
    16be:	1f 92       	push	r1
    16c0:	0f 92       	push	r0
    16c2:	0f b6       	in	r0, 0x3f	; 63
    16c4:	0f 92       	push	r0
    16c6:	11 24       	eor	r1, r1
    16c8:	2f 93       	push	r18
    16ca:	3f 93       	push	r19
    16cc:	4f 93       	push	r20
    16ce:	5f 93       	push	r21
    16d0:	6f 93       	push	r22
    16d2:	7f 93       	push	r23
    16d4:	8f 93       	push	r24
    16d6:	9f 93       	push	r25
    16d8:	af 93       	push	r26
    16da:	bf 93       	push	r27
    16dc:	ef 93       	push	r30
    16de:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_0])
    16e0:	80 91 2d 08 	lds	r24, 0x082D
    16e4:	90 91 2e 08 	lds	r25, 0x082E
    16e8:	89 2b       	or	r24, r25
    16ea:	29 f0       	breq	.+10     	; 0x16f6 <__vector_1+0x38>
    intFunc[EXTERNAL_INT_0]();
    16ec:	e0 91 2d 08 	lds	r30, 0x082D
    16f0:	f0 91 2e 08 	lds	r31, 0x082E
    16f4:	09 95       	icall
}
    16f6:	ff 91       	pop	r31
    16f8:	ef 91       	pop	r30
    16fa:	bf 91       	pop	r27
    16fc:	af 91       	pop	r26
    16fe:	9f 91       	pop	r25
    1700:	8f 91       	pop	r24
    1702:	7f 91       	pop	r23
    1704:	6f 91       	pop	r22
    1706:	5f 91       	pop	r21
    1708:	4f 91       	pop	r20
    170a:	3f 91       	pop	r19
    170c:	2f 91       	pop	r18
    170e:	0f 90       	pop	r0
    1710:	0f be       	out	0x3f, r0	; 63
    1712:	0f 90       	pop	r0
    1714:	1f 90       	pop	r1
    1716:	18 95       	reti

00001718 <__vector_2>:

ISR(INT1_vect) {
    1718:	1f 92       	push	r1
    171a:	0f 92       	push	r0
    171c:	0f b6       	in	r0, 0x3f	; 63
    171e:	0f 92       	push	r0
    1720:	11 24       	eor	r1, r1
    1722:	2f 93       	push	r18
    1724:	3f 93       	push	r19
    1726:	4f 93       	push	r20
    1728:	5f 93       	push	r21
    172a:	6f 93       	push	r22
    172c:	7f 93       	push	r23
    172e:	8f 93       	push	r24
    1730:	9f 93       	push	r25
    1732:	af 93       	push	r26
    1734:	bf 93       	push	r27
    1736:	ef 93       	push	r30
    1738:	ff 93       	push	r31
  if(intFunc[EXTERNAL_INT_1])
    173a:	80 91 2f 08 	lds	r24, 0x082F
    173e:	90 91 30 08 	lds	r25, 0x0830
    1742:	89 2b       	or	r24, r25
    1744:	29 f0       	breq	.+10     	; 0x1750 <__vector_2+0x38>
    intFunc[EXTERNAL_INT_1]();
    1746:	e0 91 2f 08 	lds	r30, 0x082F
    174a:	f0 91 30 08 	lds	r31, 0x0830
    174e:	09 95       	icall
}
    1750:	ff 91       	pop	r31
    1752:	ef 91       	pop	r30
    1754:	bf 91       	pop	r27
    1756:	af 91       	pop	r26
    1758:	9f 91       	pop	r25
    175a:	8f 91       	pop	r24
    175c:	7f 91       	pop	r23
    175e:	6f 91       	pop	r22
    1760:	5f 91       	pop	r21
    1762:	4f 91       	pop	r20
    1764:	3f 91       	pop	r19
    1766:	2f 91       	pop	r18
    1768:	0f 90       	pop	r0
    176a:	0f be       	out	0x3f, r0	; 63
    176c:	0f 90       	pop	r0
    176e:	1f 90       	pop	r1
    1770:	18 95       	reti

00001772 <USART_init>:



void USART_init(void){
	
	UBRR0H = (uint8_t)(BAUD_PRESCALLER>>8);
    1772:	10 92 c5 00 	sts	0x00C5, r1
	UBRR0L = (uint8_t)(BAUD_PRESCALLER);
    1776:	87 e6       	ldi	r24, 0x67	; 103
    1778:	80 93 c4 00 	sts	0x00C4, r24
	UCSR0B = (1<<RXEN0)|(1<<TXEN0)|(1<<UCSZ02);
    177c:	8c e1       	ldi	r24, 0x1C	; 28
    177e:	80 93 c1 00 	sts	0x00C1, r24
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));
    1782:	86 e0       	ldi	r24, 0x06	; 6
    1784:	80 93 c2 00 	sts	0x00C2, r24
    1788:	08 95       	ret

0000178a <USART_send>:
	}
}

void USART_send( unsigned char data){
	
	while(!(UCSR0A & (1<<UDRE0)));
    178a:	e0 ec       	ldi	r30, 0xC0	; 192
    178c:	f0 e0       	ldi	r31, 0x00	; 0
    178e:	90 81       	ld	r25, Z
    1790:	95 ff       	sbrs	r25, 5
    1792:	fd cf       	rjmp	.-6      	; 0x178e <USART_send+0x4>
	UDR0 = data;
    1794:	80 93 c6 00 	sts	0x00C6, r24
    1798:	08 95       	ret

0000179a <USART_sendstr>:
	UCSR0B = (1<<RXEN0)|(1<<TXEN0)|(1<<UCSZ02);
	UCSR0C = ((1<<UCSZ00)|(1<<UCSZ01));
}


void USART_sendstr( unsigned char* str){
    179a:	cf 93       	push	r28
    179c:	df 93       	push	r29
    179e:	ec 01       	movw	r28, r24
	int i =0;
	
	while (str[i] != 0x00)
    17a0:	88 81       	ld	r24, Y
    17a2:	88 23       	and	r24, r24
    17a4:	31 f0       	breq	.+12     	; 0x17b2 <USART_sendstr+0x18>
    17a6:	21 96       	adiw	r28, 0x01	; 1
	{
		USART_send(str[i]);
    17a8:	0e 94 c5 0b 	call	0x178a	; 0x178a <USART_send>


void USART_sendstr( unsigned char* str){
	int i =0;
	
	while (str[i] != 0x00)
    17ac:	89 91       	ld	r24, Y+
    17ae:	81 11       	cpse	r24, r1
    17b0:	fb cf       	rjmp	.-10     	; 0x17a8 <USART_sendstr+0xe>
	{
		USART_send(str[i]);
		i++;
	}
}
    17b2:	df 91       	pop	r29
    17b4:	cf 91       	pop	r28
    17b6:	08 95       	ret

000017b8 <memcpy>:
    17b8:	fb 01       	movw	r30, r22
    17ba:	dc 01       	movw	r26, r24
    17bc:	02 c0       	rjmp	.+4      	; 0x17c2 <memcpy+0xa>
    17be:	01 90       	ld	r0, Z+
    17c0:	0d 92       	st	X+, r0
    17c2:	41 50       	subi	r20, 0x01	; 1
    17c4:	50 40       	sbci	r21, 0x00	; 0
    17c6:	d8 f7       	brcc	.-10     	; 0x17be <memcpy+0x6>
    17c8:	08 95       	ret

000017ca <_exit>:
    17ca:	f8 94       	cli

000017cc <__stop_program>:
    17cc:	ff cf       	rjmp	.-2      	; 0x17cc <__stop_program>

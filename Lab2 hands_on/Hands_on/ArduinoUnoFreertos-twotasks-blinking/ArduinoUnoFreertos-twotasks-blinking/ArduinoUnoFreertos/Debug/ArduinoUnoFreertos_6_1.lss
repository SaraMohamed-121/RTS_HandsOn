
ArduinoUnoFreertos_6_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  00000dbe  00000e52  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000dbe  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000647  0080011e  0080011e  00000e70  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000e70  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000ea0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000208  00000000  00000000  00000ee0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002b18  00000000  00000000  000010e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000d73  00000000  00000000  00003c00  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001872  00000000  00000000  00004973  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000600  00000000  00000000  000061e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000ff7  00000000  00000000  000067e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000022cb  00000000  00000000  000077df  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000230  00000000  00000000  00009aaa  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 6c 02 	jmp	0x4d8	; 0x4d8 <__vector_11>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ee eb       	ldi	r30, 0xBE	; 190
  7c:	fd e0       	ldi	r31, 0x0D	; 13
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	ae 31       	cpi	r26, 0x1E	; 30
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	27 e0       	ldi	r18, 0x07	; 7
  8c:	ae e1       	ldi	r26, 0x1E	; 30
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a5 36       	cpi	r26, 0x65	; 101
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 65 00 	call	0xca	; 0xca <main>
  9e:	0c 94 dd 06 	jmp	0xdba	; 0xdba <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vLightTask>:
#define LIGHT_PIN (1 << PB0)
#define FAN_PIN (1 << PB1)

void vLightTask(void *pvParameters) {
	while (1) {
		PORTB ^= LIGHT_PIN; // Toggle the light
  a6:	c1 e0       	ldi	r28, 0x01	; 1
  a8:	85 b1       	in	r24, 0x05	; 5
  aa:	8c 27       	eor	r24, r28
  ac:	85 b9       	out	0x05, r24	; 5
		vTaskDelay(500 / portTICK_PERIOD_MS); // Toggle every 500ms
  ae:	84 ef       	ldi	r24, 0xF4	; 244
  b0:	91 e0       	ldi	r25, 0x01	; 1
  b2:	0e 94 13 06 	call	0xc26	; 0xc26 <vTaskDelay>
  b6:	f8 cf       	rjmp	.-16     	; 0xa8 <vLightTask+0x2>

000000b8 <vFanTask>:
	}
}

void vFanTask(void *pvParameters) {
	while (1) {
		PORTB ^= FAN_PIN; // Toggle the fan
  b8:	c2 e0       	ldi	r28, 0x02	; 2
  ba:	85 b1       	in	r24, 0x05	; 5
  bc:	8c 27       	eor	r24, r28
  be:	85 b9       	out	0x05, r24	; 5
		vTaskDelay(1000 / portTICK_PERIOD_MS); // Toggle every 1000ms
  c0:	88 ee       	ldi	r24, 0xE8	; 232
  c2:	93 e0       	ldi	r25, 0x03	; 3
  c4:	0e 94 13 06 	call	0xc26	; 0xc26 <vTaskDelay>
  c8:	f8 cf       	rjmp	.-16     	; 0xba <vFanTask+0x2>

000000ca <main>:
}

int main(void) {
	// Initialize hardware, ports, and FreeRTOS

	DDRB |= LIGHT_PIN | FAN_PIN; // Set PB0 and PB1 as outputs
  ca:	84 b1       	in	r24, 0x04	; 4
  cc:	83 60       	ori	r24, 0x03	; 3
  ce:	84 b9       	out	0x04, r24	; 4

	xTaskCreate(vLightTask, "Light Task", configMINIMAL_STACK_SIZE, NULL, 1, NULL);
  d0:	a1 2c       	mov	r10, r1
  d2:	b1 2c       	mov	r11, r1
  d4:	c1 2c       	mov	r12, r1
  d6:	d1 2c       	mov	r13, r1
  d8:	e1 2c       	mov	r14, r1
  da:	f1 2c       	mov	r15, r1
  dc:	01 e0       	ldi	r16, 0x01	; 1
  de:	20 e0       	ldi	r18, 0x00	; 0
  e0:	30 e0       	ldi	r19, 0x00	; 0
  e2:	45 e5       	ldi	r20, 0x55	; 85
  e4:	50 e0       	ldi	r21, 0x00	; 0
  e6:	64 e0       	ldi	r22, 0x04	; 4
  e8:	71 e0       	ldi	r23, 0x01	; 1
  ea:	83 e5       	ldi	r24, 0x53	; 83
  ec:	90 e0       	ldi	r25, 0x00	; 0
  ee:	0e 94 92 03 	call	0x724	; 0x724 <xTaskGenericCreate>
	xTaskCreate(vFanTask, "Fan Task", configMINIMAL_STACK_SIZE, NULL, 2, NULL);
  f2:	02 e0       	ldi	r16, 0x02	; 2
  f4:	20 e0       	ldi	r18, 0x00	; 0
  f6:	30 e0       	ldi	r19, 0x00	; 0
  f8:	45 e5       	ldi	r20, 0x55	; 85
  fa:	50 e0       	ldi	r21, 0x00	; 0
  fc:	6f e0       	ldi	r22, 0x0F	; 15
  fe:	71 e0       	ldi	r23, 0x01	; 1
 100:	8c e5       	ldi	r24, 0x5C	; 92
 102:	90 e0       	ldi	r25, 0x00	; 0
 104:	0e 94 92 03 	call	0x724	; 0x724 <xTaskGenericCreate>

	vTaskStartScheduler();
 108:	0e 94 a3 04 	call	0x946	; 0x946 <vTaskStartScheduler>
 10c:	ff cf       	rjmp	.-2      	; 0x10c <main+0x42>

0000010e <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 10e:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 110:	03 96       	adiw	r24, 0x03	; 3
 112:	92 83       	std	Z+2, r25	; 0x02
 114:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 116:	2f ef       	ldi	r18, 0xFF	; 255
 118:	3f ef       	ldi	r19, 0xFF	; 255
 11a:	34 83       	std	Z+4, r19	; 0x04
 11c:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 11e:	96 83       	std	Z+6, r25	; 0x06
 120:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 122:	90 87       	std	Z+8, r25	; 0x08
 124:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 126:	10 82       	st	Z, r1
 128:	08 95       	ret

0000012a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 12a:	fc 01       	movw	r30, r24
 12c:	11 86       	std	Z+9, r1	; 0x09
 12e:	10 86       	std	Z+8, r1	; 0x08
 130:	08 95       	ret

00000132 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 132:	cf 93       	push	r28
 134:	df 93       	push	r29
 136:	9c 01       	movw	r18, r24
 138:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 13a:	dc 01       	movw	r26, r24
 13c:	11 96       	adiw	r26, 0x01	; 1
 13e:	cd 91       	ld	r28, X+
 140:	dc 91       	ld	r29, X
 142:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 144:	d3 83       	std	Z+3, r29	; 0x03
 146:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 148:	8c 81       	ldd	r24, Y+4	; 0x04
 14a:	9d 81       	ldd	r25, Y+5	; 0x05
 14c:	95 83       	std	Z+5, r25	; 0x05
 14e:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 150:	8c 81       	ldd	r24, Y+4	; 0x04
 152:	9d 81       	ldd	r25, Y+5	; 0x05
 154:	dc 01       	movw	r26, r24
 156:	13 96       	adiw	r26, 0x03	; 3
 158:	7c 93       	st	X, r23
 15a:	6e 93       	st	-X, r22
 15c:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 15e:	7d 83       	std	Y+5, r23	; 0x05
 160:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 162:	31 87       	std	Z+9, r19	; 0x09
 164:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 166:	f9 01       	movw	r30, r18
 168:	80 81       	ld	r24, Z
 16a:	8f 5f       	subi	r24, 0xFF	; 255
 16c:	80 83       	st	Z, r24
}
 16e:	df 91       	pop	r29
 170:	cf 91       	pop	r28
 172:	08 95       	ret

00000174 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 174:	cf 93       	push	r28
 176:	df 93       	push	r29
 178:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 17a:	48 81       	ld	r20, Y
 17c:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 17e:	4f 3f       	cpi	r20, 0xFF	; 255
 180:	2f ef       	ldi	r18, 0xFF	; 255
 182:	52 07       	cpc	r21, r18
 184:	21 f4       	brne	.+8      	; 0x18e <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 186:	fc 01       	movw	r30, r24
 188:	a7 81       	ldd	r26, Z+7	; 0x07
 18a:	b0 85       	ldd	r27, Z+8	; 0x08
 18c:	0d c0       	rjmp	.+26     	; 0x1a8 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 18e:	dc 01       	movw	r26, r24
 190:	13 96       	adiw	r26, 0x03	; 3
 192:	01 c0       	rjmp	.+2      	; 0x196 <vListInsert+0x22>
 194:	df 01       	movw	r26, r30
 196:	12 96       	adiw	r26, 0x02	; 2
 198:	ed 91       	ld	r30, X+
 19a:	fc 91       	ld	r31, X
 19c:	13 97       	sbiw	r26, 0x03	; 3
 19e:	20 81       	ld	r18, Z
 1a0:	31 81       	ldd	r19, Z+1	; 0x01
 1a2:	42 17       	cp	r20, r18
 1a4:	53 07       	cpc	r21, r19
 1a6:	b0 f7       	brcc	.-20     	; 0x194 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1a8:	12 96       	adiw	r26, 0x02	; 2
 1aa:	ed 91       	ld	r30, X+
 1ac:	fc 91       	ld	r31, X
 1ae:	13 97       	sbiw	r26, 0x03	; 3
 1b0:	fb 83       	std	Y+3, r31	; 0x03
 1b2:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 1b4:	d5 83       	std	Z+5, r29	; 0x05
 1b6:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 1b8:	bd 83       	std	Y+5, r27	; 0x05
 1ba:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 1bc:	13 96       	adiw	r26, 0x03	; 3
 1be:	dc 93       	st	X, r29
 1c0:	ce 93       	st	-X, r28
 1c2:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1c4:	99 87       	std	Y+9, r25	; 0x09
 1c6:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 1c8:	fc 01       	movw	r30, r24
 1ca:	20 81       	ld	r18, Z
 1cc:	2f 5f       	subi	r18, 0xFF	; 255
 1ce:	20 83       	st	Z, r18
}
 1d0:	df 91       	pop	r29
 1d2:	cf 91       	pop	r28
 1d4:	08 95       	ret

000001d6 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 1d6:	cf 93       	push	r28
 1d8:	df 93       	push	r29
 1da:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 1dc:	a0 85       	ldd	r26, Z+8	; 0x08
 1de:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 1e0:	c2 81       	ldd	r28, Z+2	; 0x02
 1e2:	d3 81       	ldd	r29, Z+3	; 0x03
 1e4:	84 81       	ldd	r24, Z+4	; 0x04
 1e6:	95 81       	ldd	r25, Z+5	; 0x05
 1e8:	9d 83       	std	Y+5, r25	; 0x05
 1ea:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 1ec:	c4 81       	ldd	r28, Z+4	; 0x04
 1ee:	d5 81       	ldd	r29, Z+5	; 0x05
 1f0:	82 81       	ldd	r24, Z+2	; 0x02
 1f2:	93 81       	ldd	r25, Z+3	; 0x03
 1f4:	9b 83       	std	Y+3, r25	; 0x03
 1f6:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 1f8:	11 96       	adiw	r26, 0x01	; 1
 1fa:	8d 91       	ld	r24, X+
 1fc:	9c 91       	ld	r25, X
 1fe:	12 97       	sbiw	r26, 0x02	; 2
 200:	e8 17       	cp	r30, r24
 202:	f9 07       	cpc	r31, r25
 204:	31 f4       	brne	.+12     	; 0x212 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 206:	84 81       	ldd	r24, Z+4	; 0x04
 208:	95 81       	ldd	r25, Z+5	; 0x05
 20a:	12 96       	adiw	r26, 0x02	; 2
 20c:	9c 93       	st	X, r25
 20e:	8e 93       	st	-X, r24
 210:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 212:	11 86       	std	Z+9, r1	; 0x09
 214:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 216:	8c 91       	ld	r24, X
 218:	81 50       	subi	r24, 0x01	; 1
 21a:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 21c:	df 91       	pop	r29
 21e:	cf 91       	pop	r28
 220:	08 95       	ret

00000222 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 222:	31 e1       	ldi	r19, 0x11	; 17
 224:	fc 01       	movw	r30, r24
 226:	30 83       	st	Z, r19
 228:	31 97       	sbiw	r30, 0x01	; 1
 22a:	22 e2       	ldi	r18, 0x22	; 34
 22c:	20 83       	st	Z, r18
 22e:	31 97       	sbiw	r30, 0x01	; 1
 230:	a3 e3       	ldi	r26, 0x33	; 51
 232:	a0 83       	st	Z, r26
 234:	31 97       	sbiw	r30, 0x01	; 1
 236:	60 83       	st	Z, r22
 238:	31 97       	sbiw	r30, 0x01	; 1
 23a:	70 83       	st	Z, r23
 23c:	31 97       	sbiw	r30, 0x01	; 1
 23e:	10 82       	st	Z, r1
 240:	31 97       	sbiw	r30, 0x01	; 1
 242:	60 e8       	ldi	r22, 0x80	; 128
 244:	60 83       	st	Z, r22
 246:	31 97       	sbiw	r30, 0x01	; 1
 248:	10 82       	st	Z, r1
 24a:	31 97       	sbiw	r30, 0x01	; 1
 24c:	62 e0       	ldi	r22, 0x02	; 2
 24e:	60 83       	st	Z, r22
 250:	31 97       	sbiw	r30, 0x01	; 1
 252:	63 e0       	ldi	r22, 0x03	; 3
 254:	60 83       	st	Z, r22
 256:	31 97       	sbiw	r30, 0x01	; 1
 258:	64 e0       	ldi	r22, 0x04	; 4
 25a:	60 83       	st	Z, r22
 25c:	31 97       	sbiw	r30, 0x01	; 1
 25e:	65 e0       	ldi	r22, 0x05	; 5
 260:	60 83       	st	Z, r22
 262:	31 97       	sbiw	r30, 0x01	; 1
 264:	66 e0       	ldi	r22, 0x06	; 6
 266:	60 83       	st	Z, r22
 268:	31 97       	sbiw	r30, 0x01	; 1
 26a:	67 e0       	ldi	r22, 0x07	; 7
 26c:	60 83       	st	Z, r22
 26e:	31 97       	sbiw	r30, 0x01	; 1
 270:	68 e0       	ldi	r22, 0x08	; 8
 272:	60 83       	st	Z, r22
 274:	31 97       	sbiw	r30, 0x01	; 1
 276:	69 e0       	ldi	r22, 0x09	; 9
 278:	60 83       	st	Z, r22
 27a:	31 97       	sbiw	r30, 0x01	; 1
 27c:	60 e1       	ldi	r22, 0x10	; 16
 27e:	60 83       	st	Z, r22
 280:	31 97       	sbiw	r30, 0x01	; 1
 282:	30 83       	st	Z, r19
 284:	31 97       	sbiw	r30, 0x01	; 1
 286:	32 e1       	ldi	r19, 0x12	; 18
 288:	30 83       	st	Z, r19
 28a:	31 97       	sbiw	r30, 0x01	; 1
 28c:	33 e1       	ldi	r19, 0x13	; 19
 28e:	30 83       	st	Z, r19
 290:	31 97       	sbiw	r30, 0x01	; 1
 292:	34 e1       	ldi	r19, 0x14	; 20
 294:	30 83       	st	Z, r19
 296:	31 97       	sbiw	r30, 0x01	; 1
 298:	35 e1       	ldi	r19, 0x15	; 21
 29a:	30 83       	st	Z, r19
 29c:	31 97       	sbiw	r30, 0x01	; 1
 29e:	36 e1       	ldi	r19, 0x16	; 22
 2a0:	30 83       	st	Z, r19
 2a2:	31 97       	sbiw	r30, 0x01	; 1
 2a4:	37 e1       	ldi	r19, 0x17	; 23
 2a6:	30 83       	st	Z, r19
 2a8:	31 97       	sbiw	r30, 0x01	; 1
 2aa:	38 e1       	ldi	r19, 0x18	; 24
 2ac:	30 83       	st	Z, r19
 2ae:	31 97       	sbiw	r30, 0x01	; 1
 2b0:	39 e1       	ldi	r19, 0x19	; 25
 2b2:	30 83       	st	Z, r19
 2b4:	31 97       	sbiw	r30, 0x01	; 1
 2b6:	30 e2       	ldi	r19, 0x20	; 32
 2b8:	30 83       	st	Z, r19
 2ba:	31 97       	sbiw	r30, 0x01	; 1
 2bc:	31 e2       	ldi	r19, 0x21	; 33
 2be:	30 83       	st	Z, r19
 2c0:	31 97       	sbiw	r30, 0x01	; 1
 2c2:	20 83       	st	Z, r18
 2c4:	31 97       	sbiw	r30, 0x01	; 1
 2c6:	23 e2       	ldi	r18, 0x23	; 35
 2c8:	20 83       	st	Z, r18
 2ca:	31 97       	sbiw	r30, 0x01	; 1
 2cc:	40 83       	st	Z, r20
 2ce:	31 97       	sbiw	r30, 0x01	; 1
 2d0:	50 83       	st	Z, r21
 2d2:	31 97       	sbiw	r30, 0x01	; 1
 2d4:	26 e2       	ldi	r18, 0x26	; 38
 2d6:	20 83       	st	Z, r18
 2d8:	31 97       	sbiw	r30, 0x01	; 1
 2da:	27 e2       	ldi	r18, 0x27	; 39
 2dc:	20 83       	st	Z, r18
 2de:	31 97       	sbiw	r30, 0x01	; 1
 2e0:	28 e2       	ldi	r18, 0x28	; 40
 2e2:	20 83       	st	Z, r18
 2e4:	31 97       	sbiw	r30, 0x01	; 1
 2e6:	29 e2       	ldi	r18, 0x29	; 41
 2e8:	20 83       	st	Z, r18
 2ea:	31 97       	sbiw	r30, 0x01	; 1
 2ec:	20 e3       	ldi	r18, 0x30	; 48
 2ee:	20 83       	st	Z, r18
 2f0:	31 97       	sbiw	r30, 0x01	; 1
 2f2:	21 e3       	ldi	r18, 0x31	; 49
 2f4:	20 83       	st	Z, r18
 2f6:	86 97       	sbiw	r24, 0x26	; 38
 2f8:	08 95       	ret

000002fa <xPortStartScheduler>:
 2fa:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
 2fe:	8c e7       	ldi	r24, 0x7C	; 124
 300:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
 304:	8b e0       	ldi	r24, 0x0B	; 11
 306:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
 30a:	ef e6       	ldi	r30, 0x6F	; 111
 30c:	f0 e0       	ldi	r31, 0x00	; 0
 30e:	80 81       	ld	r24, Z
 310:	82 60       	ori	r24, 0x02	; 2
 312:	80 83       	st	Z, r24
 314:	a0 91 63 07 	lds	r26, 0x0763	; 0x800763 <pxCurrentTCB>
 318:	b0 91 64 07 	lds	r27, 0x0764	; 0x800764 <pxCurrentTCB+0x1>
 31c:	cd 91       	ld	r28, X+
 31e:	cd bf       	out	0x3d, r28	; 61
 320:	dd 91       	ld	r29, X+
 322:	de bf       	out	0x3e, r29	; 62
 324:	ff 91       	pop	r31
 326:	ef 91       	pop	r30
 328:	df 91       	pop	r29
 32a:	cf 91       	pop	r28
 32c:	bf 91       	pop	r27
 32e:	af 91       	pop	r26
 330:	9f 91       	pop	r25
 332:	8f 91       	pop	r24
 334:	7f 91       	pop	r23
 336:	6f 91       	pop	r22
 338:	5f 91       	pop	r21
 33a:	4f 91       	pop	r20
 33c:	3f 91       	pop	r19
 33e:	2f 91       	pop	r18
 340:	1f 91       	pop	r17
 342:	0f 91       	pop	r16
 344:	ff 90       	pop	r15
 346:	ef 90       	pop	r14
 348:	df 90       	pop	r13
 34a:	cf 90       	pop	r12
 34c:	bf 90       	pop	r11
 34e:	af 90       	pop	r10
 350:	9f 90       	pop	r9
 352:	8f 90       	pop	r8
 354:	7f 90       	pop	r7
 356:	6f 90       	pop	r6
 358:	5f 90       	pop	r5
 35a:	4f 90       	pop	r4
 35c:	3f 90       	pop	r3
 35e:	2f 90       	pop	r2
 360:	1f 90       	pop	r1
 362:	0f 90       	pop	r0
 364:	0f be       	out	0x3f, r0	; 63
 366:	0f 90       	pop	r0
 368:	08 95       	ret
 36a:	81 e0       	ldi	r24, 0x01	; 1
 36c:	08 95       	ret

0000036e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 36e:	0f 92       	push	r0
 370:	0f b6       	in	r0, 0x3f	; 63
 372:	f8 94       	cli
 374:	0f 92       	push	r0
 376:	1f 92       	push	r1
 378:	11 24       	eor	r1, r1
 37a:	2f 92       	push	r2
 37c:	3f 92       	push	r3
 37e:	4f 92       	push	r4
 380:	5f 92       	push	r5
 382:	6f 92       	push	r6
 384:	7f 92       	push	r7
 386:	8f 92       	push	r8
 388:	9f 92       	push	r9
 38a:	af 92       	push	r10
 38c:	bf 92       	push	r11
 38e:	cf 92       	push	r12
 390:	df 92       	push	r13
 392:	ef 92       	push	r14
 394:	ff 92       	push	r15
 396:	0f 93       	push	r16
 398:	1f 93       	push	r17
 39a:	2f 93       	push	r18
 39c:	3f 93       	push	r19
 39e:	4f 93       	push	r20
 3a0:	5f 93       	push	r21
 3a2:	6f 93       	push	r22
 3a4:	7f 93       	push	r23
 3a6:	8f 93       	push	r24
 3a8:	9f 93       	push	r25
 3aa:	af 93       	push	r26
 3ac:	bf 93       	push	r27
 3ae:	cf 93       	push	r28
 3b0:	df 93       	push	r29
 3b2:	ef 93       	push	r30
 3b4:	ff 93       	push	r31
 3b6:	a0 91 63 07 	lds	r26, 0x0763	; 0x800763 <pxCurrentTCB>
 3ba:	b0 91 64 07 	lds	r27, 0x0764	; 0x800764 <pxCurrentTCB+0x1>
 3be:	0d b6       	in	r0, 0x3d	; 61
 3c0:	0d 92       	st	X+, r0
 3c2:	0e b6       	in	r0, 0x3e	; 62
 3c4:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 3c6:	0e 94 70 06 	call	0xce0	; 0xce0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 3ca:	a0 91 63 07 	lds	r26, 0x0763	; 0x800763 <pxCurrentTCB>
 3ce:	b0 91 64 07 	lds	r27, 0x0764	; 0x800764 <pxCurrentTCB+0x1>
 3d2:	cd 91       	ld	r28, X+
 3d4:	cd bf       	out	0x3d, r28	; 61
 3d6:	dd 91       	ld	r29, X+
 3d8:	de bf       	out	0x3e, r29	; 62
 3da:	ff 91       	pop	r31
 3dc:	ef 91       	pop	r30
 3de:	df 91       	pop	r29
 3e0:	cf 91       	pop	r28
 3e2:	bf 91       	pop	r27
 3e4:	af 91       	pop	r26
 3e6:	9f 91       	pop	r25
 3e8:	8f 91       	pop	r24
 3ea:	7f 91       	pop	r23
 3ec:	6f 91       	pop	r22
 3ee:	5f 91       	pop	r21
 3f0:	4f 91       	pop	r20
 3f2:	3f 91       	pop	r19
 3f4:	2f 91       	pop	r18
 3f6:	1f 91       	pop	r17
 3f8:	0f 91       	pop	r16
 3fa:	ff 90       	pop	r15
 3fc:	ef 90       	pop	r14
 3fe:	df 90       	pop	r13
 400:	cf 90       	pop	r12
 402:	bf 90       	pop	r11
 404:	af 90       	pop	r10
 406:	9f 90       	pop	r9
 408:	8f 90       	pop	r8
 40a:	7f 90       	pop	r7
 40c:	6f 90       	pop	r6
 40e:	5f 90       	pop	r5
 410:	4f 90       	pop	r4
 412:	3f 90       	pop	r3
 414:	2f 90       	pop	r2
 416:	1f 90       	pop	r1
 418:	0f 90       	pop	r0
 41a:	0f be       	out	0x3f, r0	; 63
 41c:	0f 90       	pop	r0

	asm volatile ( "ret" );
 41e:	08 95       	ret

00000420 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 420:	0f 92       	push	r0
 422:	0f b6       	in	r0, 0x3f	; 63
 424:	f8 94       	cli
 426:	0f 92       	push	r0
 428:	1f 92       	push	r1
 42a:	11 24       	eor	r1, r1
 42c:	2f 92       	push	r2
 42e:	3f 92       	push	r3
 430:	4f 92       	push	r4
 432:	5f 92       	push	r5
 434:	6f 92       	push	r6
 436:	7f 92       	push	r7
 438:	8f 92       	push	r8
 43a:	9f 92       	push	r9
 43c:	af 92       	push	r10
 43e:	bf 92       	push	r11
 440:	cf 92       	push	r12
 442:	df 92       	push	r13
 444:	ef 92       	push	r14
 446:	ff 92       	push	r15
 448:	0f 93       	push	r16
 44a:	1f 93       	push	r17
 44c:	2f 93       	push	r18
 44e:	3f 93       	push	r19
 450:	4f 93       	push	r20
 452:	5f 93       	push	r21
 454:	6f 93       	push	r22
 456:	7f 93       	push	r23
 458:	8f 93       	push	r24
 45a:	9f 93       	push	r25
 45c:	af 93       	push	r26
 45e:	bf 93       	push	r27
 460:	cf 93       	push	r28
 462:	df 93       	push	r29
 464:	ef 93       	push	r30
 466:	ff 93       	push	r31
 468:	a0 91 63 07 	lds	r26, 0x0763	; 0x800763 <pxCurrentTCB>
 46c:	b0 91 64 07 	lds	r27, 0x0764	; 0x800764 <pxCurrentTCB+0x1>
 470:	0d b6       	in	r0, 0x3d	; 61
 472:	0d 92       	st	X+, r0
 474:	0e b6       	in	r0, 0x3e	; 62
 476:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 478:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <xTaskIncrementTick>
 47c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 47e:	0e 94 70 06 	call	0xce0	; 0xce0 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 482:	a0 91 63 07 	lds	r26, 0x0763	; 0x800763 <pxCurrentTCB>
 486:	b0 91 64 07 	lds	r27, 0x0764	; 0x800764 <pxCurrentTCB+0x1>
 48a:	cd 91       	ld	r28, X+
 48c:	cd bf       	out	0x3d, r28	; 61
 48e:	dd 91       	ld	r29, X+
 490:	de bf       	out	0x3e, r29	; 62
 492:	ff 91       	pop	r31
 494:	ef 91       	pop	r30
 496:	df 91       	pop	r29
 498:	cf 91       	pop	r28
 49a:	bf 91       	pop	r27
 49c:	af 91       	pop	r26
 49e:	9f 91       	pop	r25
 4a0:	8f 91       	pop	r24
 4a2:	7f 91       	pop	r23
 4a4:	6f 91       	pop	r22
 4a6:	5f 91       	pop	r21
 4a8:	4f 91       	pop	r20
 4aa:	3f 91       	pop	r19
 4ac:	2f 91       	pop	r18
 4ae:	1f 91       	pop	r17
 4b0:	0f 91       	pop	r16
 4b2:	ff 90       	pop	r15
 4b4:	ef 90       	pop	r14
 4b6:	df 90       	pop	r13
 4b8:	cf 90       	pop	r12
 4ba:	bf 90       	pop	r11
 4bc:	af 90       	pop	r10
 4be:	9f 90       	pop	r9
 4c0:	8f 90       	pop	r8
 4c2:	7f 90       	pop	r7
 4c4:	6f 90       	pop	r6
 4c6:	5f 90       	pop	r5
 4c8:	4f 90       	pop	r4
 4ca:	3f 90       	pop	r3
 4cc:	2f 90       	pop	r2
 4ce:	1f 90       	pop	r1
 4d0:	0f 90       	pop	r0
 4d2:	0f be       	out	0x3f, r0	; 63
 4d4:	0f 90       	pop	r0

	asm volatile ( "ret" );
 4d6:	08 95       	ret

000004d8 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect(void) __attribute__ ((signal, naked));
	void TIMER1_COMPA_vect(void)
	{
		vPortYieldFromTick();
 4d8:	0e 94 10 02 	call	0x420	; 0x420 <vPortYieldFromTick>
		asm volatile ( "reti" );
 4dc:	18 95       	reti

000004de <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 4de:	0f 93       	push	r16
 4e0:	1f 93       	push	r17
 4e2:	cf 93       	push	r28
 4e4:	df 93       	push	r29
 4e6:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
 4e8:	0e 94 ce 04 	call	0x99c	; 0x99c <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 4ec:	80 91 1e 01 	lds	r24, 0x011E	; 0x80011e <__data_end>
 4f0:	81 11       	cpse	r24, r1
 4f2:	1d c0       	rjmp	.+58     	; 0x52e <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 4f4:	e3 e2       	ldi	r30, 0x23	; 35
 4f6:	f1 e0       	ldi	r31, 0x01	; 1
 4f8:	88 e2       	ldi	r24, 0x28	; 40
 4fa:	91 e0       	ldi	r25, 0x01	; 1
 4fc:	91 83       	std	Z+1, r25	; 0x01
 4fe:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
 500:	13 82       	std	Z+3, r1	; 0x03
 502:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
 504:	ef e1       	ldi	r30, 0x1F	; 31
 506:	f1 e0       	ldi	r31, 0x01	; 1
 508:	8b ed       	ldi	r24, 0xDB	; 219
 50a:	95 e0       	ldi	r25, 0x05	; 5
 50c:	93 83       	std	Z+3, r25	; 0x03
 50e:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
 510:	11 82       	std	Z+1, r1	; 0x01
 512:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
 514:	a7 e2       	ldi	r26, 0x27	; 39
 516:	b1 e0       	ldi	r27, 0x01	; 1
 518:	14 96       	adiw	r26, 0x04	; 4
 51a:	9c 93       	st	X, r25
 51c:	8e 93       	st	-X, r24
 51e:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
 520:	12 96       	adiw	r26, 0x02	; 2
 522:	fc 93       	st	X, r31
 524:	ee 93       	st	-X, r30
 526:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
 528:	81 e0       	ldi	r24, 0x01	; 1
 52a:	80 93 1e 01 	sts	0x011E, r24	; 0x80011e <__data_end>
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 52e:	20 97       	sbiw	r28, 0x00	; 0
 530:	09 f4       	brne	.+2      	; 0x534 <pvPortMalloc+0x56>
 532:	5f c0       	rjmp	.+190    	; 0x5f2 <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
 534:	9e 01       	movw	r18, r28
 536:	2c 5f       	subi	r18, 0xFC	; 252
 538:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
 53a:	23 96       	adiw	r28, 0x03	; 3
 53c:	ca 3d       	cpi	r28, 0xDA	; 218
 53e:	d5 40       	sbci	r29, 0x05	; 5
 540:	08 f0       	brcs	.+2      	; 0x544 <pvPortMalloc+0x66>
 542:	5a c0       	rjmp	.+180    	; 0x5f8 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
 544:	e0 91 23 01 	lds	r30, 0x0123	; 0x800123 <xStart>
 548:	f0 91 24 01 	lds	r31, 0x0124	; 0x800124 <xStart+0x1>

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 54c:	a3 e2       	ldi	r26, 0x23	; 35
 54e:	b1 e0       	ldi	r27, 0x01	; 1
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 550:	02 c0       	rjmp	.+4      	; 0x556 <pvPortMalloc+0x78>
 552:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
 554:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 556:	82 81       	ldd	r24, Z+2	; 0x02
 558:	93 81       	ldd	r25, Z+3	; 0x03
 55a:	82 17       	cp	r24, r18
 55c:	93 07       	cpc	r25, r19
 55e:	20 f4       	brcc	.+8      	; 0x568 <pvPortMalloc+0x8a>
 560:	80 81       	ld	r24, Z
 562:	91 81       	ldd	r25, Z+1	; 0x01
 564:	00 97       	sbiw	r24, 0x00	; 0
 566:	a9 f7       	brne	.-22     	; 0x552 <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 568:	c1 e0       	ldi	r28, 0x01	; 1
 56a:	ef 31       	cpi	r30, 0x1F	; 31
 56c:	fc 07       	cpc	r31, r28
 56e:	09 f4       	brne	.+2      	; 0x572 <pvPortMalloc+0x94>
 570:	46 c0       	rjmp	.+140    	; 0x5fe <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 572:	cd 91       	ld	r28, X+
 574:	dc 91       	ld	r29, X
 576:	11 97       	sbiw	r26, 0x01	; 1
 578:	8e 01       	movw	r16, r28
 57a:	0c 5f       	subi	r16, 0xFC	; 252
 57c:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 57e:	80 81       	ld	r24, Z
 580:	91 81       	ldd	r25, Z+1	; 0x01
 582:	8d 93       	st	X+, r24
 584:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 586:	82 81       	ldd	r24, Z+2	; 0x02
 588:	93 81       	ldd	r25, Z+3	; 0x03
 58a:	82 1b       	sub	r24, r18
 58c:	93 0b       	sbc	r25, r19
 58e:	89 30       	cpi	r24, 0x09	; 9
 590:	91 05       	cpc	r25, r1
 592:	10 f1       	brcs	.+68     	; 0x5d8 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 594:	bf 01       	movw	r22, r30
 596:	62 0f       	add	r22, r18
 598:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 59a:	db 01       	movw	r26, r22
 59c:	13 96       	adiw	r26, 0x03	; 3
 59e:	9c 93       	st	X, r25
 5a0:	8e 93       	st	-X, r24
 5a2:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
 5a4:	33 83       	std	Z+3, r19	; 0x03
 5a6:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 5a8:	12 96       	adiw	r26, 0x02	; 2
 5aa:	4d 91       	ld	r20, X+
 5ac:	5c 91       	ld	r21, X
 5ae:	13 97       	sbiw	r26, 0x03	; 3
 5b0:	83 e2       	ldi	r24, 0x23	; 35
 5b2:	91 e0       	ldi	r25, 0x01	; 1
 5b4:	01 c0       	rjmp	.+2      	; 0x5b8 <pvPortMalloc+0xda>
 5b6:	cd 01       	movw	r24, r26
 5b8:	ec 01       	movw	r28, r24
 5ba:	a8 81       	ld	r26, Y
 5bc:	b9 81       	ldd	r27, Y+1	; 0x01
 5be:	12 96       	adiw	r26, 0x02	; 2
 5c0:	2d 91       	ld	r18, X+
 5c2:	3c 91       	ld	r19, X
 5c4:	13 97       	sbiw	r26, 0x03	; 3
 5c6:	24 17       	cp	r18, r20
 5c8:	35 07       	cpc	r19, r21
 5ca:	a8 f3       	brcs	.-22     	; 0x5b6 <pvPortMalloc+0xd8>
 5cc:	eb 01       	movw	r28, r22
 5ce:	b9 83       	std	Y+1, r27	; 0x01
 5d0:	a8 83       	st	Y, r26
 5d2:	dc 01       	movw	r26, r24
 5d4:	6d 93       	st	X+, r22
 5d6:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
 5d8:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
 5dc:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <__data_start+0x1>
 5e0:	22 81       	ldd	r18, Z+2	; 0x02
 5e2:	33 81       	ldd	r19, Z+3	; 0x03
 5e4:	82 1b       	sub	r24, r18
 5e6:	93 0b       	sbc	r25, r19
 5e8:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 5ec:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 5f0:	08 c0       	rjmp	.+16     	; 0x602 <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 5f2:	00 e0       	ldi	r16, 0x00	; 0
 5f4:	10 e0       	ldi	r17, 0x00	; 0
 5f6:	05 c0       	rjmp	.+10     	; 0x602 <pvPortMalloc+0x124>
 5f8:	00 e0       	ldi	r16, 0x00	; 0
 5fa:	10 e0       	ldi	r17, 0x00	; 0
 5fc:	02 c0       	rjmp	.+4      	; 0x602 <pvPortMalloc+0x124>
 5fe:	00 e0       	ldi	r16, 0x00	; 0
 600:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 602:	0e 94 91 05 	call	0xb22	; 0xb22 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 606:	c8 01       	movw	r24, r16
 608:	df 91       	pop	r29
 60a:	cf 91       	pop	r28
 60c:	1f 91       	pop	r17
 60e:	0f 91       	pop	r16
 610:	08 95       	ret

00000612 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 612:	0f 93       	push	r16
 614:	1f 93       	push	r17
 616:	cf 93       	push	r28
 618:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
 61a:	00 97       	sbiw	r24, 0x00	; 0
 61c:	41 f1       	breq	.+80     	; 0x66e <vPortFree+0x5c>
 61e:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 620:	8c 01       	movw	r16, r24
 622:	04 50       	subi	r16, 0x04	; 4
 624:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
 626:	0e 94 ce 04 	call	0x99c	; 0x99c <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 62a:	f8 01       	movw	r30, r16
 62c:	42 81       	ldd	r20, Z+2	; 0x02
 62e:	53 81       	ldd	r21, Z+3	; 0x03
 630:	a3 e2       	ldi	r26, 0x23	; 35
 632:	b1 e0       	ldi	r27, 0x01	; 1
 634:	01 c0       	rjmp	.+2      	; 0x638 <vPortFree+0x26>
 636:	df 01       	movw	r26, r30
 638:	ed 91       	ld	r30, X+
 63a:	fc 91       	ld	r31, X
 63c:	11 97       	sbiw	r26, 0x01	; 1
 63e:	22 81       	ldd	r18, Z+2	; 0x02
 640:	33 81       	ldd	r19, Z+3	; 0x03
 642:	24 17       	cp	r18, r20
 644:	35 07       	cpc	r19, r21
 646:	b8 f3       	brcs	.-18     	; 0x636 <vPortFree+0x24>
 648:	24 97       	sbiw	r28, 0x04	; 4
 64a:	f9 83       	std	Y+1, r31	; 0x01
 64c:	e8 83       	st	Y, r30
 64e:	0d 93       	st	X+, r16
 650:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
 652:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
 656:	30 91 01 01 	lds	r19, 0x0101	; 0x800101 <__data_start+0x1>
 65a:	8a 81       	ldd	r24, Y+2	; 0x02
 65c:	9b 81       	ldd	r25, Y+3	; 0x03
 65e:	82 0f       	add	r24, r18
 660:	93 1f       	adc	r25, r19
 662:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 666:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
 66a:	0e 94 91 05 	call	0xb22	; 0xb22 <xTaskResumeAll>
	}
}
 66e:	df 91       	pop	r29
 670:	cf 91       	pop	r28
 672:	1f 91       	pop	r17
 674:	0f 91       	pop	r16
 676:	08 95       	ret

00000678 <prvResetNextTaskUnblockTime>:
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 678:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxDelayedTaskList>
 67c:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxDelayedTaskList+0x1>
 680:	80 81       	ld	r24, Z
 682:	81 11       	cpse	r24, r1
 684:	07 c0       	rjmp	.+14     	; 0x694 <prvResetNextTaskUnblockTime+0x1c>
 686:	8f ef       	ldi	r24, 0xFF	; 255
 688:	9f ef       	ldi	r25, 0xFF	; 255
 68a:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
 68e:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
 692:	08 95       	ret
 694:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxDelayedTaskList>
 698:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxDelayedTaskList+0x1>
 69c:	05 80       	ldd	r0, Z+5	; 0x05
 69e:	f6 81       	ldd	r31, Z+6	; 0x06
 6a0:	e0 2d       	mov	r30, r0
 6a2:	06 80       	ldd	r0, Z+6	; 0x06
 6a4:	f7 81       	ldd	r31, Z+7	; 0x07
 6a6:	e0 2d       	mov	r30, r0
 6a8:	82 81       	ldd	r24, Z+2	; 0x02
 6aa:	93 81       	ldd	r25, Z+3	; 0x03
 6ac:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
 6b0:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
 6b4:	08 95       	ret

000006b6 <prvAddCurrentTaskToDelayedList>:
 6b6:	cf 93       	push	r28
 6b8:	df 93       	push	r29
 6ba:	ec 01       	movw	r28, r24
 6bc:	e0 91 63 07 	lds	r30, 0x0763	; 0x800763 <pxCurrentTCB>
 6c0:	f0 91 64 07 	lds	r31, 0x0764	; 0x800764 <pxCurrentTCB+0x1>
 6c4:	93 83       	std	Z+3, r25	; 0x03
 6c6:	82 83       	std	Z+2, r24	; 0x02
 6c8:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <xTickCount>
 6cc:	90 91 0b 07 	lds	r25, 0x070B	; 0x80070b <xTickCount+0x1>
 6d0:	c8 17       	cp	r28, r24
 6d2:	d9 07       	cpc	r29, r25
 6d4:	68 f4       	brcc	.+26     	; 0x6f0 <prvAddCurrentTaskToDelayedList+0x3a>
 6d6:	60 91 63 07 	lds	r22, 0x0763	; 0x800763 <pxCurrentTCB>
 6da:	70 91 64 07 	lds	r23, 0x0764	; 0x800764 <pxCurrentTCB+0x1>
 6de:	80 91 29 07 	lds	r24, 0x0729	; 0x800729 <pxOverflowDelayedTaskList>
 6e2:	90 91 2a 07 	lds	r25, 0x072A	; 0x80072a <pxOverflowDelayedTaskList+0x1>
 6e6:	6e 5f       	subi	r22, 0xFE	; 254
 6e8:	7f 4f       	sbci	r23, 0xFF	; 255
 6ea:	0e 94 ba 00 	call	0x174	; 0x174 <vListInsert>
 6ee:	17 c0       	rjmp	.+46     	; 0x71e <prvAddCurrentTaskToDelayedList+0x68>
 6f0:	60 91 63 07 	lds	r22, 0x0763	; 0x800763 <pxCurrentTCB>
 6f4:	70 91 64 07 	lds	r23, 0x0764	; 0x800764 <pxCurrentTCB+0x1>
 6f8:	80 91 2b 07 	lds	r24, 0x072B	; 0x80072b <pxDelayedTaskList>
 6fc:	90 91 2c 07 	lds	r25, 0x072C	; 0x80072c <pxDelayedTaskList+0x1>
 700:	6e 5f       	subi	r22, 0xFE	; 254
 702:	7f 4f       	sbci	r23, 0xFF	; 255
 704:	0e 94 ba 00 	call	0x174	; 0x174 <vListInsert>
 708:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xNextTaskUnblockTime>
 70c:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <xNextTaskUnblockTime+0x1>
 710:	c8 17       	cp	r28, r24
 712:	d9 07       	cpc	r29, r25
 714:	20 f4       	brcc	.+8      	; 0x71e <prvAddCurrentTaskToDelayedList+0x68>
 716:	d0 93 03 01 	sts	0x0103, r29	; 0x800103 <xNextTaskUnblockTime+0x1>
 71a:	c0 93 02 01 	sts	0x0102, r28	; 0x800102 <xNextTaskUnblockTime>
 71e:	df 91       	pop	r29
 720:	cf 91       	pop	r28
 722:	08 95       	ret

00000724 <xTaskGenericCreate>:
 724:	4f 92       	push	r4
 726:	5f 92       	push	r5
 728:	6f 92       	push	r6
 72a:	7f 92       	push	r7
 72c:	8f 92       	push	r8
 72e:	9f 92       	push	r9
 730:	af 92       	push	r10
 732:	bf 92       	push	r11
 734:	cf 92       	push	r12
 736:	df 92       	push	r13
 738:	ef 92       	push	r14
 73a:	ff 92       	push	r15
 73c:	0f 93       	push	r16
 73e:	1f 93       	push	r17
 740:	cf 93       	push	r28
 742:	df 93       	push	r29
 744:	4c 01       	movw	r8, r24
 746:	eb 01       	movw	r28, r22
 748:	5a 01       	movw	r10, r20
 74a:	29 01       	movw	r4, r18
 74c:	c1 14       	cp	r12, r1
 74e:	d1 04       	cpc	r13, r1
 750:	39 f4       	brne	.+14     	; 0x760 <xTaskGenericCreate+0x3c>
 752:	ca 01       	movw	r24, r20
 754:	0e 94 6f 02 	call	0x4de	; 0x4de <pvPortMalloc>
 758:	6c 01       	movw	r12, r24
 75a:	89 2b       	or	r24, r25
 75c:	09 f4       	brne	.+2      	; 0x760 <xTaskGenericCreate+0x3c>
 75e:	e1 c0       	rjmp	.+450    	; 0x922 <__stack+0x23>
 760:	86 e2       	ldi	r24, 0x26	; 38
 762:	90 e0       	ldi	r25, 0x00	; 0
 764:	0e 94 6f 02 	call	0x4de	; 0x4de <pvPortMalloc>
 768:	3c 01       	movw	r6, r24
 76a:	00 97       	sbiw	r24, 0x00	; 0
 76c:	79 f0       	breq	.+30     	; 0x78c <xTaskGenericCreate+0x68>
 76e:	fc 01       	movw	r30, r24
 770:	d0 8e       	std	Z+24, r13	; 0x18
 772:	c7 8a       	std	Z+23, r12	; 0x17
 774:	f1 e0       	ldi	r31, 0x01	; 1
 776:	af 1a       	sub	r10, r31
 778:	b1 08       	sbc	r11, r1
 77a:	ca 0c       	add	r12, r10
 77c:	db 1c       	adc	r13, r11
 77e:	88 81       	ld	r24, Y
 780:	f3 01       	movw	r30, r6
 782:	81 8f       	std	Z+25, r24	; 0x19
 784:	88 81       	ld	r24, Y
 786:	81 11       	cpse	r24, r1
 788:	05 c0       	rjmp	.+10     	; 0x794 <xTaskGenericCreate+0x70>
 78a:	14 c0       	rjmp	.+40     	; 0x7b4 <xTaskGenericCreate+0x90>
 78c:	c6 01       	movw	r24, r12
 78e:	0e 94 09 03 	call	0x612	; 0x612 <vPortFree>
 792:	c7 c0       	rjmp	.+398    	; 0x922 <__stack+0x23>
 794:	d3 01       	movw	r26, r6
 796:	5a 96       	adiw	r26, 0x1a	; 26
 798:	fe 01       	movw	r30, r28
 79a:	31 96       	adiw	r30, 0x01	; 1
 79c:	9e 01       	movw	r18, r28
 79e:	28 5f       	subi	r18, 0xF8	; 248
 7a0:	3f 4f       	sbci	r19, 0xFF	; 255
 7a2:	ef 01       	movw	r28, r30
 7a4:	81 91       	ld	r24, Z+
 7a6:	8d 93       	st	X+, r24
 7a8:	88 81       	ld	r24, Y
 7aa:	88 23       	and	r24, r24
 7ac:	19 f0       	breq	.+6      	; 0x7b4 <xTaskGenericCreate+0x90>
 7ae:	e2 17       	cp	r30, r18
 7b0:	f3 07       	cpc	r31, r19
 7b2:	b9 f7       	brne	.-18     	; 0x7a2 <xTaskGenericCreate+0x7e>
 7b4:	f3 01       	movw	r30, r6
 7b6:	10 a2       	std	Z+32, r1	; 0x20
 7b8:	10 2f       	mov	r17, r16
 7ba:	04 30       	cpi	r16, 0x04	; 4
 7bc:	08 f0       	brcs	.+2      	; 0x7c0 <xTaskGenericCreate+0x9c>
 7be:	13 e0       	ldi	r17, 0x03	; 3
 7c0:	f3 01       	movw	r30, r6
 7c2:	16 8b       	std	Z+22, r17	; 0x16
 7c4:	e3 01       	movw	r28, r6
 7c6:	22 96       	adiw	r28, 0x02	; 2
 7c8:	ce 01       	movw	r24, r28
 7ca:	0e 94 95 00 	call	0x12a	; 0x12a <vListInitialiseItem>
 7ce:	c3 01       	movw	r24, r6
 7d0:	0c 96       	adiw	r24, 0x0c	; 12
 7d2:	0e 94 95 00 	call	0x12a	; 0x12a <vListInitialiseItem>
 7d6:	f3 01       	movw	r30, r6
 7d8:	71 86       	std	Z+9, r7	; 0x09
 7da:	60 86       	std	Z+8, r6	; 0x08
 7dc:	84 e0       	ldi	r24, 0x04	; 4
 7de:	90 e0       	ldi	r25, 0x00	; 0
 7e0:	81 1b       	sub	r24, r17
 7e2:	91 09       	sbc	r25, r1
 7e4:	95 87       	std	Z+13, r25	; 0x0d
 7e6:	84 87       	std	Z+12, r24	; 0x0c
 7e8:	73 8a       	std	Z+19, r7	; 0x13
 7ea:	62 8a       	std	Z+18, r6	; 0x12
 7ec:	11 a2       	std	Z+33, r1	; 0x21
 7ee:	12 a2       	std	Z+34, r1	; 0x22
 7f0:	13 a2       	std	Z+35, r1	; 0x23
 7f2:	14 a2       	std	Z+36, r1	; 0x24
 7f4:	15 a2       	std	Z+37, r1	; 0x25
 7f6:	a2 01       	movw	r20, r4
 7f8:	b4 01       	movw	r22, r8
 7fa:	c6 01       	movw	r24, r12
 7fc:	0e 94 11 01 	call	0x222	; 0x222 <pxPortInitialiseStack>
 800:	f3 01       	movw	r30, r6
 802:	91 83       	std	Z+1, r25	; 0x01
 804:	80 83       	st	Z, r24
 806:	e1 14       	cp	r14, r1
 808:	f1 04       	cpc	r15, r1
 80a:	19 f0       	breq	.+6      	; 0x812 <xTaskGenericCreate+0xee>
 80c:	f7 01       	movw	r30, r14
 80e:	71 82       	std	Z+1, r7	; 0x01
 810:	60 82       	st	Z, r6
 812:	0f b6       	in	r0, 0x3f	; 63
 814:	f8 94       	cli
 816:	0f 92       	push	r0
 818:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <uxCurrentNumberOfTasks>
 81c:	8f 5f       	subi	r24, 0xFF	; 255
 81e:	80 93 0c 07 	sts	0x070C, r24	; 0x80070c <uxCurrentNumberOfTasks>
 822:	80 91 63 07 	lds	r24, 0x0763	; 0x800763 <pxCurrentTCB>
 826:	90 91 64 07 	lds	r25, 0x0764	; 0x800764 <pxCurrentTCB+0x1>
 82a:	89 2b       	or	r24, r25
 82c:	d1 f5       	brne	.+116    	; 0x8a2 <xTaskGenericCreate+0x17e>
 82e:	70 92 64 07 	sts	0x0764, r7	; 0x800764 <pxCurrentTCB+0x1>
 832:	60 92 63 07 	sts	0x0763, r6	; 0x800763 <pxCurrentTCB>
 836:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <uxCurrentNumberOfTasks>
 83a:	81 30       	cpi	r24, 0x01	; 1
 83c:	09 f0       	breq	.+2      	; 0x840 <xTaskGenericCreate+0x11c>
 83e:	40 c0       	rjmp	.+128    	; 0x8c0 <xTaskGenericCreate+0x19c>
 840:	8f e3       	ldi	r24, 0x3F	; 63
 842:	97 e0       	ldi	r25, 0x07	; 7
 844:	0e 94 87 00 	call	0x10e	; 0x10e <vListInitialise>
 848:	88 e4       	ldi	r24, 0x48	; 72
 84a:	97 e0       	ldi	r25, 0x07	; 7
 84c:	0e 94 87 00 	call	0x10e	; 0x10e <vListInitialise>
 850:	81 e5       	ldi	r24, 0x51	; 81
 852:	97 e0       	ldi	r25, 0x07	; 7
 854:	0e 94 87 00 	call	0x10e	; 0x10e <vListInitialise>
 858:	8a e5       	ldi	r24, 0x5A	; 90
 85a:	97 e0       	ldi	r25, 0x07	; 7
 85c:	0e 94 87 00 	call	0x10e	; 0x10e <vListInitialise>
 860:	86 e3       	ldi	r24, 0x36	; 54
 862:	97 e0       	ldi	r25, 0x07	; 7
 864:	0e 94 87 00 	call	0x10e	; 0x10e <vListInitialise>
 868:	8d e2       	ldi	r24, 0x2D	; 45
 86a:	97 e0       	ldi	r25, 0x07	; 7
 86c:	0e 94 87 00 	call	0x10e	; 0x10e <vListInitialise>
 870:	80 e2       	ldi	r24, 0x20	; 32
 872:	97 e0       	ldi	r25, 0x07	; 7
 874:	0e 94 87 00 	call	0x10e	; 0x10e <vListInitialise>
 878:	87 e1       	ldi	r24, 0x17	; 23
 87a:	97 e0       	ldi	r25, 0x07	; 7
 87c:	0e 94 87 00 	call	0x10e	; 0x10e <vListInitialise>
 880:	8d e0       	ldi	r24, 0x0D	; 13
 882:	97 e0       	ldi	r25, 0x07	; 7
 884:	0e 94 87 00 	call	0x10e	; 0x10e <vListInitialise>
 888:	86 e3       	ldi	r24, 0x36	; 54
 88a:	97 e0       	ldi	r25, 0x07	; 7
 88c:	90 93 2c 07 	sts	0x072C, r25	; 0x80072c <pxDelayedTaskList+0x1>
 890:	80 93 2b 07 	sts	0x072B, r24	; 0x80072b <pxDelayedTaskList>
 894:	8d e2       	ldi	r24, 0x2D	; 45
 896:	97 e0       	ldi	r25, 0x07	; 7
 898:	90 93 2a 07 	sts	0x072A, r25	; 0x80072a <pxOverflowDelayedTaskList+0x1>
 89c:	80 93 29 07 	sts	0x0729, r24	; 0x800729 <pxOverflowDelayedTaskList>
 8a0:	0f c0       	rjmp	.+30     	; 0x8c0 <xTaskGenericCreate+0x19c>
 8a2:	80 91 08 07 	lds	r24, 0x0708	; 0x800708 <xSchedulerRunning>
 8a6:	81 11       	cpse	r24, r1
 8a8:	0b c0       	rjmp	.+22     	; 0x8c0 <xTaskGenericCreate+0x19c>
 8aa:	e0 91 63 07 	lds	r30, 0x0763	; 0x800763 <pxCurrentTCB>
 8ae:	f0 91 64 07 	lds	r31, 0x0764	; 0x800764 <pxCurrentTCB+0x1>
 8b2:	86 89       	ldd	r24, Z+22	; 0x16
 8b4:	08 17       	cp	r16, r24
 8b6:	20 f0       	brcs	.+8      	; 0x8c0 <xTaskGenericCreate+0x19c>
 8b8:	70 92 64 07 	sts	0x0764, r7	; 0x800764 <pxCurrentTCB+0x1>
 8bc:	60 92 63 07 	sts	0x0763, r6	; 0x800763 <pxCurrentTCB>
 8c0:	80 91 04 07 	lds	r24, 0x0704	; 0x800704 <uxTaskNumber>
 8c4:	8f 5f       	subi	r24, 0xFF	; 255
 8c6:	80 93 04 07 	sts	0x0704, r24	; 0x800704 <uxTaskNumber>
 8ca:	f3 01       	movw	r30, r6
 8cc:	86 89       	ldd	r24, Z+22	; 0x16
 8ce:	90 91 09 07 	lds	r25, 0x0709	; 0x800709 <uxTopReadyPriority>
 8d2:	98 17       	cp	r25, r24
 8d4:	10 f4       	brcc	.+4      	; 0x8da <xTaskGenericCreate+0x1b6>
 8d6:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <uxTopReadyPriority>
 8da:	90 e0       	ldi	r25, 0x00	; 0
 8dc:	9c 01       	movw	r18, r24
 8de:	22 0f       	add	r18, r18
 8e0:	33 1f       	adc	r19, r19
 8e2:	22 0f       	add	r18, r18
 8e4:	33 1f       	adc	r19, r19
 8e6:	22 0f       	add	r18, r18
 8e8:	33 1f       	adc	r19, r19
 8ea:	82 0f       	add	r24, r18
 8ec:	93 1f       	adc	r25, r19
 8ee:	be 01       	movw	r22, r28
 8f0:	81 5c       	subi	r24, 0xC1	; 193
 8f2:	98 4f       	sbci	r25, 0xF8	; 248
 8f4:	0e 94 99 00 	call	0x132	; 0x132 <vListInsertEnd>
 8f8:	0f 90       	pop	r0
 8fa:	0f be       	out	0x3f, r0	; 63
 8fc:	80 91 08 07 	lds	r24, 0x0708	; 0x800708 <xSchedulerRunning>
 900:	88 23       	and	r24, r24
 902:	59 f0       	breq	.+22     	; 0x91a <__stack+0x1b>
 904:	e0 91 63 07 	lds	r30, 0x0763	; 0x800763 <pxCurrentTCB>
 908:	f0 91 64 07 	lds	r31, 0x0764	; 0x800764 <pxCurrentTCB+0x1>
 90c:	86 89       	ldd	r24, Z+22	; 0x16
 90e:	80 17       	cp	r24, r16
 910:	30 f4       	brcc	.+12     	; 0x91e <__stack+0x1f>
 912:	0e 94 b7 01 	call	0x36e	; 0x36e <vPortYield>
 916:	81 e0       	ldi	r24, 0x01	; 1
 918:	05 c0       	rjmp	.+10     	; 0x924 <__stack+0x25>
 91a:	81 e0       	ldi	r24, 0x01	; 1
 91c:	03 c0       	rjmp	.+6      	; 0x924 <__stack+0x25>
 91e:	81 e0       	ldi	r24, 0x01	; 1
 920:	01 c0       	rjmp	.+2      	; 0x924 <__stack+0x25>
 922:	8f ef       	ldi	r24, 0xFF	; 255
 924:	df 91       	pop	r29
 926:	cf 91       	pop	r28
 928:	1f 91       	pop	r17
 92a:	0f 91       	pop	r16
 92c:	ff 90       	pop	r15
 92e:	ef 90       	pop	r14
 930:	df 90       	pop	r13
 932:	cf 90       	pop	r12
 934:	bf 90       	pop	r11
 936:	af 90       	pop	r10
 938:	9f 90       	pop	r9
 93a:	8f 90       	pop	r8
 93c:	7f 90       	pop	r7
 93e:	6f 90       	pop	r6
 940:	5f 90       	pop	r5
 942:	4f 90       	pop	r4
 944:	08 95       	ret

00000946 <vTaskStartScheduler>:
 946:	af 92       	push	r10
 948:	bf 92       	push	r11
 94a:	cf 92       	push	r12
 94c:	df 92       	push	r13
 94e:	ef 92       	push	r14
 950:	ff 92       	push	r15
 952:	0f 93       	push	r16
 954:	a1 2c       	mov	r10, r1
 956:	b1 2c       	mov	r11, r1
 958:	c1 2c       	mov	r12, r1
 95a:	d1 2c       	mov	r13, r1
 95c:	e1 2c       	mov	r14, r1
 95e:	f1 2c       	mov	r15, r1
 960:	00 e0       	ldi	r16, 0x00	; 0
 962:	20 e0       	ldi	r18, 0x00	; 0
 964:	30 e0       	ldi	r19, 0x00	; 0
 966:	45 e5       	ldi	r20, 0x55	; 85
 968:	50 e0       	ldi	r21, 0x00	; 0
 96a:	68 e1       	ldi	r22, 0x18	; 24
 96c:	71 e0       	ldi	r23, 0x01	; 1
 96e:	83 e3       	ldi	r24, 0x33	; 51
 970:	96 e0       	ldi	r25, 0x06	; 6
 972:	0e 94 92 03 	call	0x724	; 0x724 <xTaskGenericCreate>
 976:	81 30       	cpi	r24, 0x01	; 1
 978:	49 f4       	brne	.+18     	; 0x98c <vTaskStartScheduler+0x46>
 97a:	f8 94       	cli
 97c:	80 93 08 07 	sts	0x0708, r24	; 0x800708 <xSchedulerRunning>
 980:	10 92 0b 07 	sts	0x070B, r1	; 0x80070b <xTickCount+0x1>
 984:	10 92 0a 07 	sts	0x070A, r1	; 0x80070a <xTickCount>
 988:	0e 94 7d 01 	call	0x2fa	; 0x2fa <xPortStartScheduler>
 98c:	0f 91       	pop	r16
 98e:	ff 90       	pop	r15
 990:	ef 90       	pop	r14
 992:	df 90       	pop	r13
 994:	cf 90       	pop	r12
 996:	bf 90       	pop	r11
 998:	af 90       	pop	r10
 99a:	08 95       	ret

0000099c <vTaskSuspendAll>:
 99c:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxSchedulerSuspended>
 9a0:	8f 5f       	subi	r24, 0xFF	; 255
 9a2:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxSchedulerSuspended>
 9a6:	08 95       	ret

000009a8 <xTaskIncrementTick>:
 9a8:	cf 92       	push	r12
 9aa:	df 92       	push	r13
 9ac:	ef 92       	push	r14
 9ae:	ff 92       	push	r15
 9b0:	0f 93       	push	r16
 9b2:	1f 93       	push	r17
 9b4:	cf 93       	push	r28
 9b6:	df 93       	push	r29
 9b8:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxSchedulerSuspended>
 9bc:	81 11       	cpse	r24, r1
 9be:	9b c0       	rjmp	.+310    	; 0xaf6 <xTaskIncrementTick+0x14e>
 9c0:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <xTickCount>
 9c4:	90 91 0b 07 	lds	r25, 0x070B	; 0x80070b <xTickCount+0x1>
 9c8:	01 96       	adiw	r24, 0x01	; 1
 9ca:	90 93 0b 07 	sts	0x070B, r25	; 0x80070b <xTickCount+0x1>
 9ce:	80 93 0a 07 	sts	0x070A, r24	; 0x80070a <xTickCount>
 9d2:	e0 90 0a 07 	lds	r14, 0x070A	; 0x80070a <xTickCount>
 9d6:	f0 90 0b 07 	lds	r15, 0x070B	; 0x80070b <xTickCount+0x1>
 9da:	e1 14       	cp	r14, r1
 9dc:	f1 04       	cpc	r15, r1
 9de:	b9 f4       	brne	.+46     	; 0xa0e <xTaskIncrementTick+0x66>
 9e0:	80 91 2b 07 	lds	r24, 0x072B	; 0x80072b <pxDelayedTaskList>
 9e4:	90 91 2c 07 	lds	r25, 0x072C	; 0x80072c <pxDelayedTaskList+0x1>
 9e8:	20 91 29 07 	lds	r18, 0x0729	; 0x800729 <pxOverflowDelayedTaskList>
 9ec:	30 91 2a 07 	lds	r19, 0x072A	; 0x80072a <pxOverflowDelayedTaskList+0x1>
 9f0:	30 93 2c 07 	sts	0x072C, r19	; 0x80072c <pxDelayedTaskList+0x1>
 9f4:	20 93 2b 07 	sts	0x072B, r18	; 0x80072b <pxDelayedTaskList>
 9f8:	90 93 2a 07 	sts	0x072A, r25	; 0x80072a <pxOverflowDelayedTaskList+0x1>
 9fc:	80 93 29 07 	sts	0x0729, r24	; 0x800729 <pxOverflowDelayedTaskList>
 a00:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <xNumOfOverflows>
 a04:	8f 5f       	subi	r24, 0xFF	; 255
 a06:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <xNumOfOverflows>
 a0a:	0e 94 3c 03 	call	0x678	; 0x678 <prvResetNextTaskUnblockTime>
 a0e:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <xNextTaskUnblockTime>
 a12:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <xNextTaskUnblockTime+0x1>
 a16:	e8 16       	cp	r14, r24
 a18:	f9 06       	cpc	r15, r25
 a1a:	10 f4       	brcc	.+4      	; 0xa20 <xTaskIncrementTick+0x78>
 a1c:	d1 2c       	mov	r13, r1
 a1e:	53 c0       	rjmp	.+166    	; 0xac6 <xTaskIncrementTick+0x11e>
 a20:	d1 2c       	mov	r13, r1
 a22:	cc 24       	eor	r12, r12
 a24:	c3 94       	inc	r12
 a26:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxDelayedTaskList>
 a2a:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxDelayedTaskList+0x1>
 a2e:	80 81       	ld	r24, Z
 a30:	81 11       	cpse	r24, r1
 a32:	07 c0       	rjmp	.+14     	; 0xa42 <xTaskIncrementTick+0x9a>
 a34:	8f ef       	ldi	r24, 0xFF	; 255
 a36:	9f ef       	ldi	r25, 0xFF	; 255
 a38:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
 a3c:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
 a40:	42 c0       	rjmp	.+132    	; 0xac6 <xTaskIncrementTick+0x11e>
 a42:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxDelayedTaskList>
 a46:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxDelayedTaskList+0x1>
 a4a:	05 80       	ldd	r0, Z+5	; 0x05
 a4c:	f6 81       	ldd	r31, Z+6	; 0x06
 a4e:	e0 2d       	mov	r30, r0
 a50:	c6 81       	ldd	r28, Z+6	; 0x06
 a52:	d7 81       	ldd	r29, Z+7	; 0x07
 a54:	8a 81       	ldd	r24, Y+2	; 0x02
 a56:	9b 81       	ldd	r25, Y+3	; 0x03
 a58:	e8 16       	cp	r14, r24
 a5a:	f9 06       	cpc	r15, r25
 a5c:	28 f4       	brcc	.+10     	; 0xa68 <xTaskIncrementTick+0xc0>
 a5e:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <xNextTaskUnblockTime+0x1>
 a62:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <xNextTaskUnblockTime>
 a66:	2f c0       	rjmp	.+94     	; 0xac6 <xTaskIncrementTick+0x11e>
 a68:	8e 01       	movw	r16, r28
 a6a:	0e 5f       	subi	r16, 0xFE	; 254
 a6c:	1f 4f       	sbci	r17, 0xFF	; 255
 a6e:	c8 01       	movw	r24, r16
 a70:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <uxListRemove>
 a74:	8c 89       	ldd	r24, Y+20	; 0x14
 a76:	9d 89       	ldd	r25, Y+21	; 0x15
 a78:	89 2b       	or	r24, r25
 a7a:	21 f0       	breq	.+8      	; 0xa84 <xTaskIncrementTick+0xdc>
 a7c:	ce 01       	movw	r24, r28
 a7e:	0c 96       	adiw	r24, 0x0c	; 12
 a80:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <uxListRemove>
 a84:	8e 89       	ldd	r24, Y+22	; 0x16
 a86:	90 91 09 07 	lds	r25, 0x0709	; 0x800709 <uxTopReadyPriority>
 a8a:	98 17       	cp	r25, r24
 a8c:	10 f4       	brcc	.+4      	; 0xa92 <xTaskIncrementTick+0xea>
 a8e:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <uxTopReadyPriority>
 a92:	90 e0       	ldi	r25, 0x00	; 0
 a94:	9c 01       	movw	r18, r24
 a96:	22 0f       	add	r18, r18
 a98:	33 1f       	adc	r19, r19
 a9a:	22 0f       	add	r18, r18
 a9c:	33 1f       	adc	r19, r19
 a9e:	22 0f       	add	r18, r18
 aa0:	33 1f       	adc	r19, r19
 aa2:	82 0f       	add	r24, r18
 aa4:	93 1f       	adc	r25, r19
 aa6:	b8 01       	movw	r22, r16
 aa8:	81 5c       	subi	r24, 0xC1	; 193
 aaa:	98 4f       	sbci	r25, 0xF8	; 248
 aac:	0e 94 99 00 	call	0x132	; 0x132 <vListInsertEnd>
 ab0:	e0 91 63 07 	lds	r30, 0x0763	; 0x800763 <pxCurrentTCB>
 ab4:	f0 91 64 07 	lds	r31, 0x0764	; 0x800764 <pxCurrentTCB+0x1>
 ab8:	9e 89       	ldd	r25, Y+22	; 0x16
 aba:	86 89       	ldd	r24, Z+22	; 0x16
 abc:	98 17       	cp	r25, r24
 abe:	08 f4       	brcc	.+2      	; 0xac2 <xTaskIncrementTick+0x11a>
 ac0:	b2 cf       	rjmp	.-156    	; 0xa26 <xTaskIncrementTick+0x7e>
 ac2:	dc 2c       	mov	r13, r12
 ac4:	b0 cf       	rjmp	.-160    	; 0xa26 <xTaskIncrementTick+0x7e>
 ac6:	e0 91 63 07 	lds	r30, 0x0763	; 0x800763 <pxCurrentTCB>
 aca:	f0 91 64 07 	lds	r31, 0x0764	; 0x800764 <pxCurrentTCB+0x1>
 ace:	86 89       	ldd	r24, Z+22	; 0x16
 ad0:	90 e0       	ldi	r25, 0x00	; 0
 ad2:	fc 01       	movw	r30, r24
 ad4:	ee 0f       	add	r30, r30
 ad6:	ff 1f       	adc	r31, r31
 ad8:	ee 0f       	add	r30, r30
 ada:	ff 1f       	adc	r31, r31
 adc:	ee 0f       	add	r30, r30
 ade:	ff 1f       	adc	r31, r31
 ae0:	8e 0f       	add	r24, r30
 ae2:	9f 1f       	adc	r25, r31
 ae4:	fc 01       	movw	r30, r24
 ae6:	e1 5c       	subi	r30, 0xC1	; 193
 ae8:	f8 4f       	sbci	r31, 0xF8	; 248
 aea:	80 81       	ld	r24, Z
 aec:	82 30       	cpi	r24, 0x02	; 2
 aee:	48 f0       	brcs	.+18     	; 0xb02 <xTaskIncrementTick+0x15a>
 af0:	dd 24       	eor	r13, r13
 af2:	d3 94       	inc	r13
 af4:	06 c0       	rjmp	.+12     	; 0xb02 <xTaskIncrementTick+0x15a>
 af6:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <uxPendedTicks>
 afa:	8f 5f       	subi	r24, 0xFF	; 255
 afc:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <uxPendedTicks>
 b00:	d1 2c       	mov	r13, r1
 b02:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <xYieldPending>
 b06:	88 23       	and	r24, r24
 b08:	11 f0       	breq	.+4      	; 0xb0e <xTaskIncrementTick+0x166>
 b0a:	dd 24       	eor	r13, r13
 b0c:	d3 94       	inc	r13
 b0e:	8d 2d       	mov	r24, r13
 b10:	df 91       	pop	r29
 b12:	cf 91       	pop	r28
 b14:	1f 91       	pop	r17
 b16:	0f 91       	pop	r16
 b18:	ff 90       	pop	r15
 b1a:	ef 90       	pop	r14
 b1c:	df 90       	pop	r13
 b1e:	cf 90       	pop	r12
 b20:	08 95       	ret

00000b22 <xTaskResumeAll>:
 b22:	df 92       	push	r13
 b24:	ef 92       	push	r14
 b26:	ff 92       	push	r15
 b28:	0f 93       	push	r16
 b2a:	1f 93       	push	r17
 b2c:	cf 93       	push	r28
 b2e:	df 93       	push	r29
 b30:	0f b6       	in	r0, 0x3f	; 63
 b32:	f8 94       	cli
 b34:	0f 92       	push	r0
 b36:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxSchedulerSuspended>
 b3a:	81 50       	subi	r24, 0x01	; 1
 b3c:	80 93 03 07 	sts	0x0703, r24	; 0x800703 <uxSchedulerSuspended>
 b40:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxSchedulerSuspended>
 b44:	81 11       	cpse	r24, r1
 b46:	62 c0       	rjmp	.+196    	; 0xc0c <xTaskResumeAll+0xea>
 b48:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <uxCurrentNumberOfTasks>
 b4c:	81 11       	cpse	r24, r1
 b4e:	33 c0       	rjmp	.+102    	; 0xbb6 <xTaskResumeAll+0x94>
 b50:	60 c0       	rjmp	.+192    	; 0xc12 <xTaskResumeAll+0xf0>
 b52:	d7 01       	movw	r26, r14
 b54:	15 96       	adiw	r26, 0x05	; 5
 b56:	ed 91       	ld	r30, X+
 b58:	fc 91       	ld	r31, X
 b5a:	16 97       	sbiw	r26, 0x06	; 6
 b5c:	c6 81       	ldd	r28, Z+6	; 0x06
 b5e:	d7 81       	ldd	r29, Z+7	; 0x07
 b60:	ce 01       	movw	r24, r28
 b62:	0c 96       	adiw	r24, 0x0c	; 12
 b64:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <uxListRemove>
 b68:	8e 01       	movw	r16, r28
 b6a:	0e 5f       	subi	r16, 0xFE	; 254
 b6c:	1f 4f       	sbci	r17, 0xFF	; 255
 b6e:	c8 01       	movw	r24, r16
 b70:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <uxListRemove>
 b74:	8e 89       	ldd	r24, Y+22	; 0x16
 b76:	90 91 09 07 	lds	r25, 0x0709	; 0x800709 <uxTopReadyPriority>
 b7a:	98 17       	cp	r25, r24
 b7c:	10 f4       	brcc	.+4      	; 0xb82 <xTaskResumeAll+0x60>
 b7e:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <uxTopReadyPriority>
 b82:	90 e0       	ldi	r25, 0x00	; 0
 b84:	9c 01       	movw	r18, r24
 b86:	22 0f       	add	r18, r18
 b88:	33 1f       	adc	r19, r19
 b8a:	22 0f       	add	r18, r18
 b8c:	33 1f       	adc	r19, r19
 b8e:	22 0f       	add	r18, r18
 b90:	33 1f       	adc	r19, r19
 b92:	82 0f       	add	r24, r18
 b94:	93 1f       	adc	r25, r19
 b96:	b8 01       	movw	r22, r16
 b98:	81 5c       	subi	r24, 0xC1	; 193
 b9a:	98 4f       	sbci	r25, 0xF8	; 248
 b9c:	0e 94 99 00 	call	0x132	; 0x132 <vListInsertEnd>
 ba0:	e0 91 63 07 	lds	r30, 0x0763	; 0x800763 <pxCurrentTCB>
 ba4:	f0 91 64 07 	lds	r31, 0x0764	; 0x800764 <pxCurrentTCB+0x1>
 ba8:	9e 89       	ldd	r25, Y+22	; 0x16
 baa:	86 89       	ldd	r24, Z+22	; 0x16
 bac:	98 17       	cp	r25, r24
 bae:	58 f0       	brcs	.+22     	; 0xbc6 <xTaskResumeAll+0xa4>
 bb0:	d0 92 06 07 	sts	0x0706, r13	; 0x800706 <xYieldPending>
 bb4:	08 c0       	rjmp	.+16     	; 0xbc6 <xTaskResumeAll+0xa4>
 bb6:	0f 2e       	mov	r0, r31
 bb8:	f0 e2       	ldi	r31, 0x20	; 32
 bba:	ef 2e       	mov	r14, r31
 bbc:	f7 e0       	ldi	r31, 0x07	; 7
 bbe:	ff 2e       	mov	r15, r31
 bc0:	f0 2d       	mov	r31, r0
 bc2:	dd 24       	eor	r13, r13
 bc4:	d3 94       	inc	r13
 bc6:	f7 01       	movw	r30, r14
 bc8:	80 81       	ld	r24, Z
 bca:	81 11       	cpse	r24, r1
 bcc:	c2 cf       	rjmp	.-124    	; 0xb52 <xTaskResumeAll+0x30>
 bce:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <uxPendedTicks>
 bd2:	88 23       	and	r24, r24
 bd4:	99 f0       	breq	.+38     	; 0xbfc <xTaskResumeAll+0xda>
 bd6:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <uxPendedTicks>
 bda:	88 23       	and	r24, r24
 bdc:	79 f0       	breq	.+30     	; 0xbfc <xTaskResumeAll+0xda>
 bde:	c1 e0       	ldi	r28, 0x01	; 1
 be0:	0e 94 d4 04 	call	0x9a8	; 0x9a8 <xTaskIncrementTick>
 be4:	81 11       	cpse	r24, r1
 be6:	c0 93 06 07 	sts	0x0706, r28	; 0x800706 <xYieldPending>
 bea:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <uxPendedTicks>
 bee:	81 50       	subi	r24, 0x01	; 1
 bf0:	80 93 07 07 	sts	0x0707, r24	; 0x800707 <uxPendedTicks>
 bf4:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <uxPendedTicks>
 bf8:	81 11       	cpse	r24, r1
 bfa:	f2 cf       	rjmp	.-28     	; 0xbe0 <xTaskResumeAll+0xbe>
 bfc:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <xYieldPending>
 c00:	81 30       	cpi	r24, 0x01	; 1
 c02:	31 f4       	brne	.+12     	; 0xc10 <xTaskResumeAll+0xee>
 c04:	0e 94 b7 01 	call	0x36e	; 0x36e <vPortYield>
 c08:	81 e0       	ldi	r24, 0x01	; 1
 c0a:	03 c0       	rjmp	.+6      	; 0xc12 <xTaskResumeAll+0xf0>
 c0c:	80 e0       	ldi	r24, 0x00	; 0
 c0e:	01 c0       	rjmp	.+2      	; 0xc12 <xTaskResumeAll+0xf0>
 c10:	80 e0       	ldi	r24, 0x00	; 0
 c12:	0f 90       	pop	r0
 c14:	0f be       	out	0x3f, r0	; 63
 c16:	df 91       	pop	r29
 c18:	cf 91       	pop	r28
 c1a:	1f 91       	pop	r17
 c1c:	0f 91       	pop	r16
 c1e:	ff 90       	pop	r15
 c20:	ef 90       	pop	r14
 c22:	df 90       	pop	r13
 c24:	08 95       	ret

00000c26 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 c26:	cf 93       	push	r28
 c28:	df 93       	push	r29
 c2a:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 c2c:	89 2b       	or	r24, r25
 c2e:	b1 f0       	breq	.+44     	; 0xc5c <vTaskDelay+0x36>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 c30:	0e 94 ce 04 	call	0x99c	; 0x99c <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
 c34:	80 91 0a 07 	lds	r24, 0x070A	; 0x80070a <xTickCount>
 c38:	90 91 0b 07 	lds	r25, 0x070B	; 0x80070b <xTickCount+0x1>
 c3c:	c8 0f       	add	r28, r24
 c3e:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 c40:	80 91 63 07 	lds	r24, 0x0763	; 0x800763 <pxCurrentTCB>
 c44:	90 91 64 07 	lds	r25, 0x0764	; 0x800764 <pxCurrentTCB+0x1>
 c48:	02 96       	adiw	r24, 0x02	; 2
 c4a:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
 c4e:	ce 01       	movw	r24, r28
 c50:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 c54:	0e 94 91 05 	call	0xb22	; 0xb22 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 c58:	81 11       	cpse	r24, r1
 c5a:	02 c0       	rjmp	.+4      	; 0xc60 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
 c5c:	0e 94 b7 01 	call	0x36e	; 0x36e <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 c60:	df 91       	pop	r29
 c62:	cf 91       	pop	r28
 c64:	08 95       	ret

00000c66 <prvIdleTask>:
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 c66:	07 e1       	ldi	r16, 0x17	; 23
 c68:	17 e0       	ldi	r17, 0x07	; 7

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 c6a:	0f 2e       	mov	r0, r31
 c6c:	ff e3       	ldi	r31, 0x3F	; 63
 c6e:	ef 2e       	mov	r14, r31
 c70:	f7 e0       	ldi	r31, 0x07	; 7
 c72:	ff 2e       	mov	r15, r31
 c74:	f0 2d       	mov	r31, r0
 c76:	29 c0       	rjmp	.+82     	; 0xcca <prvIdleTask+0x64>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
 c78:	0e 94 ce 04 	call	0x99c	; 0x99c <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 c7c:	d8 01       	movw	r26, r16
 c7e:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
 c80:	0e 94 91 05 	call	0xb22	; 0xb22 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 c84:	cc 23       	and	r28, r28
 c86:	09 f1       	breq	.+66     	; 0xcca <prvIdleTask+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 c88:	0f b6       	in	r0, 0x3f	; 63
 c8a:	f8 94       	cli
 c8c:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 c8e:	d8 01       	movw	r26, r16
 c90:	15 96       	adiw	r26, 0x05	; 5
 c92:	ed 91       	ld	r30, X+
 c94:	fc 91       	ld	r31, X
 c96:	16 97       	sbiw	r26, 0x06	; 6
 c98:	c6 81       	ldd	r28, Z+6	; 0x06
 c9a:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 c9c:	ce 01       	movw	r24, r28
 c9e:	02 96       	adiw	r24, 0x02	; 2
 ca0:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <uxListRemove>
					--uxCurrentNumberOfTasks;
 ca4:	80 91 0c 07 	lds	r24, 0x070C	; 0x80070c <uxCurrentNumberOfTasks>
 ca8:	81 50       	subi	r24, 0x01	; 1
 caa:	80 93 0c 07 	sts	0x070C, r24	; 0x80070c <uxCurrentNumberOfTasks>
					--uxTasksDeleted;
 cae:	80 91 16 07 	lds	r24, 0x0716	; 0x800716 <uxTasksDeleted>
 cb2:	81 50       	subi	r24, 0x01	; 1
 cb4:	80 93 16 07 	sts	0x0716, r24	; 0x800716 <uxTasksDeleted>
				}
				taskEXIT_CRITICAL();
 cb8:	0f 90       	pop	r0
 cba:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
 cbc:	8f 89       	ldd	r24, Y+23	; 0x17
 cbe:	98 8d       	ldd	r25, Y+24	; 0x18
 cc0:	0e 94 09 03 	call	0x612	; 0x612 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
 cc4:	ce 01       	movw	r24, r28
 cc6:	0e 94 09 03 	call	0x612	; 0x612 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 cca:	80 91 16 07 	lds	r24, 0x0716	; 0x800716 <uxTasksDeleted>
 cce:	81 11       	cpse	r24, r1
 cd0:	d3 cf       	rjmp	.-90     	; 0xc78 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 cd2:	f7 01       	movw	r30, r14
 cd4:	80 81       	ld	r24, Z
 cd6:	82 30       	cpi	r24, 0x02	; 2
 cd8:	c0 f3       	brcs	.-16     	; 0xcca <prvIdleTask+0x64>
			{
				taskYIELD();
 cda:	0e 94 b7 01 	call	0x36e	; 0x36e <vPortYield>
 cde:	f5 cf       	rjmp	.-22     	; 0xcca <prvIdleTask+0x64>

00000ce0 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 ce0:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <uxSchedulerSuspended>
 ce4:	88 23       	and	r24, r24
 ce6:	21 f0       	breq	.+8      	; 0xcf0 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 ce8:	81 e0       	ldi	r24, 0x01	; 1
 cea:	80 93 06 07 	sts	0x0706, r24	; 0x800706 <xYieldPending>
 cee:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 cf0:	10 92 06 07 	sts	0x0706, r1	; 0x800706 <xYieldPending>
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 cf4:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <uxTopReadyPriority>
 cf8:	90 e0       	ldi	r25, 0x00	; 0
 cfa:	fc 01       	movw	r30, r24
 cfc:	ee 0f       	add	r30, r30
 cfe:	ff 1f       	adc	r31, r31
 d00:	ee 0f       	add	r30, r30
 d02:	ff 1f       	adc	r31, r31
 d04:	ee 0f       	add	r30, r30
 d06:	ff 1f       	adc	r31, r31
 d08:	8e 0f       	add	r24, r30
 d0a:	9f 1f       	adc	r25, r31
 d0c:	fc 01       	movw	r30, r24
 d0e:	e1 5c       	subi	r30, 0xC1	; 193
 d10:	f8 4f       	sbci	r31, 0xF8	; 248
 d12:	80 81       	ld	r24, Z
 d14:	81 11       	cpse	r24, r1
 d16:	17 c0       	rjmp	.+46     	; 0xd46 <vTaskSwitchContext+0x66>
 d18:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <uxTopReadyPriority>
 d1c:	81 50       	subi	r24, 0x01	; 1
 d1e:	80 93 09 07 	sts	0x0709, r24	; 0x800709 <uxTopReadyPriority>
 d22:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <uxTopReadyPriority>
 d26:	90 e0       	ldi	r25, 0x00	; 0
 d28:	fc 01       	movw	r30, r24
 d2a:	ee 0f       	add	r30, r30
 d2c:	ff 1f       	adc	r31, r31
 d2e:	ee 0f       	add	r30, r30
 d30:	ff 1f       	adc	r31, r31
 d32:	ee 0f       	add	r30, r30
 d34:	ff 1f       	adc	r31, r31
 d36:	8e 0f       	add	r24, r30
 d38:	9f 1f       	adc	r25, r31
 d3a:	fc 01       	movw	r30, r24
 d3c:	e1 5c       	subi	r30, 0xC1	; 193
 d3e:	f8 4f       	sbci	r31, 0xF8	; 248
 d40:	80 81       	ld	r24, Z
 d42:	88 23       	and	r24, r24
 d44:	49 f3       	breq	.-46     	; 0xd18 <vTaskSwitchContext+0x38>
 d46:	80 91 09 07 	lds	r24, 0x0709	; 0x800709 <uxTopReadyPriority>
 d4a:	90 e0       	ldi	r25, 0x00	; 0
 d4c:	9c 01       	movw	r18, r24
 d4e:	22 0f       	add	r18, r18
 d50:	33 1f       	adc	r19, r19
 d52:	22 0f       	add	r18, r18
 d54:	33 1f       	adc	r19, r19
 d56:	22 0f       	add	r18, r18
 d58:	33 1f       	adc	r19, r19
 d5a:	28 0f       	add	r18, r24
 d5c:	39 1f       	adc	r19, r25
 d5e:	d9 01       	movw	r26, r18
 d60:	a1 5c       	subi	r26, 0xC1	; 193
 d62:	b8 4f       	sbci	r27, 0xF8	; 248
 d64:	11 96       	adiw	r26, 0x01	; 1
 d66:	ed 91       	ld	r30, X+
 d68:	fc 91       	ld	r31, X
 d6a:	12 97       	sbiw	r26, 0x02	; 2
 d6c:	02 80       	ldd	r0, Z+2	; 0x02
 d6e:	f3 81       	ldd	r31, Z+3	; 0x03
 d70:	e0 2d       	mov	r30, r0
 d72:	12 96       	adiw	r26, 0x02	; 2
 d74:	fc 93       	st	X, r31
 d76:	ee 93       	st	-X, r30
 d78:	11 97       	sbiw	r26, 0x01	; 1
 d7a:	2e 5b       	subi	r18, 0xBE	; 190
 d7c:	38 4f       	sbci	r19, 0xF8	; 248
 d7e:	e2 17       	cp	r30, r18
 d80:	f3 07       	cpc	r31, r19
 d82:	29 f4       	brne	.+10     	; 0xd8e <vTaskSwitchContext+0xae>
 d84:	22 81       	ldd	r18, Z+2	; 0x02
 d86:	33 81       	ldd	r19, Z+3	; 0x03
 d88:	fd 01       	movw	r30, r26
 d8a:	32 83       	std	Z+2, r19	; 0x02
 d8c:	21 83       	std	Z+1, r18	; 0x01
 d8e:	fc 01       	movw	r30, r24
 d90:	ee 0f       	add	r30, r30
 d92:	ff 1f       	adc	r31, r31
 d94:	ee 0f       	add	r30, r30
 d96:	ff 1f       	adc	r31, r31
 d98:	ee 0f       	add	r30, r30
 d9a:	ff 1f       	adc	r31, r31
 d9c:	8e 0f       	add	r24, r30
 d9e:	9f 1f       	adc	r25, r31
 da0:	fc 01       	movw	r30, r24
 da2:	e1 5c       	subi	r30, 0xC1	; 193
 da4:	f8 4f       	sbci	r31, 0xF8	; 248
 da6:	01 80       	ldd	r0, Z+1	; 0x01
 da8:	f2 81       	ldd	r31, Z+2	; 0x02
 daa:	e0 2d       	mov	r30, r0
 dac:	86 81       	ldd	r24, Z+6	; 0x06
 dae:	97 81       	ldd	r25, Z+7	; 0x07
 db0:	90 93 64 07 	sts	0x0764, r25	; 0x800764 <pxCurrentTCB+0x1>
 db4:	80 93 63 07 	sts	0x0763, r24	; 0x800763 <pxCurrentTCB>
 db8:	08 95       	ret

00000dba <_exit>:
 dba:	f8 94       	cli

00000dbc <__stop_program>:
 dbc:	ff cf       	rjmp	.-2      	; 0xdbc <__stop_program>

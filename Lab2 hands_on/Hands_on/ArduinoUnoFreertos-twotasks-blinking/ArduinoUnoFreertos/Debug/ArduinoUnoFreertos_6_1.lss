
ArduinoUnoFreertos_6_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001e  00800100  00000e50  00000ee4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000e50  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000647  0080011e  0080011e  00000f02  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000f02  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000f34  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000208  00000000  00000000  00000f74  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002722  00000000  00000000  0000117c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000008a9  00000000  00000000  0000389e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000d42  00000000  00000000  00004147  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000620  00000000  00000000  00004e8c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000df1  00000000  00000000  000054ac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002367  00000000  00000000  0000629d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000230  00000000  00000000  00008604  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 89 02 	jmp	0x512	; 0x512 <__vector_11>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e0 e5       	ldi	r30, 0x50	; 80
  7c:	fe e0       	ldi	r31, 0x0E	; 14
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	ae 31       	cpi	r26, 0x1E	; 30
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	27 e0       	ldi	r18, 0x07	; 7
  8c:	ae e1       	ldi	r26, 0x1E	; 30
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a5 36       	cpi	r26, 0x65	; 101
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 83 00 	call	0x106	; 0x106 <main>
  9e:	0c 94 26 07 	jmp	0xe4c	; 0xe4c <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vLightTask>:
	vTaskStartScheduler();

	for(;;);
}

void vLightTask(void *pvParameters){
  a6:	cf 93       	push	r28
  a8:	df 93       	push	r29
  aa:	00 d0       	rcall	.+0      	; 0xac <vLightTask+0x6>
  ac:	cd b7       	in	r28, 0x3d	; 61
  ae:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	xLastWakeTime = xTaskGetTickCount();
  b0:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <xTaskGetTickCount>
  b4:	9a 83       	std	Y+2, r25	; 0x02
  b6:	89 83       	std	Y+1, r24	; 0x01
	while(1){
		PORTB |= (1 << LIGHT_PIN);
  b8:	28 9a       	sbi	0x05, 0	; 5
		vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(2000));
  ba:	61 e2       	ldi	r22, 0x21	; 33
  bc:	70 e0       	ldi	r23, 0x00	; 0
  be:	ce 01       	movw	r24, r28
  c0:	01 96       	adiw	r24, 0x01	; 1
  c2:	0e 94 3a 06 	call	0xc74	; 0xc74 <vTaskDelayUntil>

		PORTB &= ~(1 << LIGHT_PIN);
  c6:	28 98       	cbi	0x05, 0	; 5
		vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(1000));
  c8:	60 e1       	ldi	r22, 0x10	; 16
  ca:	70 e0       	ldi	r23, 0x00	; 0
  cc:	ce 01       	movw	r24, r28
  ce:	01 96       	adiw	r24, 0x01	; 1
  d0:	0e 94 3a 06 	call	0xc74	; 0xc74 <vTaskDelayUntil>
		//vTaskDelayUntil(&xLastWakeTime,500/portTICK_RATE_MS);
}
  d4:	f1 cf       	rjmp	.-30     	; 0xb8 <vLightTask+0x12>

000000d6 <vFanTask>:
}
void vFanTask(void *pvParameters){
  d6:	cf 93       	push	r28
  d8:	df 93       	push	r29
  da:	00 d0       	rcall	.+0      	; 0xdc <vFanTask+0x6>
  dc:	cd b7       	in	r28, 0x3d	; 61
  de:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	xLastWakeTime = xTaskGetTickCount();
  e0:	0e 94 f1 04 	call	0x9e2	; 0x9e2 <xTaskGetTickCount>
  e4:	9a 83       	std	Y+2, r25	; 0x02
  e6:	89 83       	std	Y+1, r24	; 0x01
	while (1)
	{
		PORTB |= (1 << FAN_PIN);
  e8:	29 9a       	sbi	0x05, 1	; 5
		vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(2000));
  ea:	61 e2       	ldi	r22, 0x21	; 33
  ec:	70 e0       	ldi	r23, 0x00	; 0
  ee:	ce 01       	movw	r24, r28
  f0:	01 96       	adiw	r24, 0x01	; 1
  f2:	0e 94 3a 06 	call	0xc74	; 0xc74 <vTaskDelayUntil>

		PORTB &= ~(1 << FAN_PIN);
  f6:	29 98       	cbi	0x05, 1	; 5
		vTaskDelayUntil(&xLastWakeTime, pdMS_TO_TICKS(1000));
  f8:	60 e1       	ldi	r22, 0x10	; 16
  fa:	70 e0       	ldi	r23, 0x00	; 0
  fc:	ce 01       	movw	r24, r28
  fe:	01 96       	adiw	r24, 0x01	; 1
 100:	0e 94 3a 06 	call	0xc74	; 0xc74 <vTaskDelayUntil>
	}
 104:	f1 cf       	rjmp	.-30     	; 0xe8 <vFanTask+0x12>

00000106 <main>:
void vLightTask(void *pvParameters);
void vFanTask(void *pvParameters);

int main(void) {
	//1- Initialize hardware, ports, and FreeRTOS
	DDRB=0xFF;
 106:	8f ef       	ldi	r24, 0xFF	; 255
 108:	84 b9       	out	0x04, r24	; 4

	//2- create tasks with correct priorities assignation
	xTaskCreate(vLightTask,"vLightTask",256,NULL,1,NULL);
 10a:	a1 2c       	mov	r10, r1
 10c:	b1 2c       	mov	r11, r1
 10e:	c1 2c       	mov	r12, r1
 110:	d1 2c       	mov	r13, r1
 112:	e1 2c       	mov	r14, r1
 114:	f1 2c       	mov	r15, r1
 116:	01 e0       	ldi	r16, 0x01	; 1
 118:	20 e0       	ldi	r18, 0x00	; 0
 11a:	30 e0       	ldi	r19, 0x00	; 0
 11c:	40 e0       	ldi	r20, 0x00	; 0
 11e:	51 e0       	ldi	r21, 0x01	; 1
 120:	64 e0       	ldi	r22, 0x04	; 4
 122:	71 e0       	ldi	r23, 0x01	; 1
 124:	83 e5       	ldi	r24, 0x53	; 83
 126:	90 e0       	ldi	r25, 0x00	; 0
 128:	0e 94 af 03 	call	0x75e	; 0x75e <xTaskGenericCreate>
	xTaskCreate(vFanTask,"vFanTask",256,NULL,2,NULL);	
 12c:	02 e0       	ldi	r16, 0x02	; 2
 12e:	20 e0       	ldi	r18, 0x00	; 0
 130:	30 e0       	ldi	r19, 0x00	; 0
 132:	40 e0       	ldi	r20, 0x00	; 0
 134:	51 e0       	ldi	r21, 0x01	; 1
 136:	6f e0       	ldi	r22, 0x0F	; 15
 138:	71 e0       	ldi	r23, 0x01	; 1
 13a:	8b e6       	ldi	r24, 0x6B	; 107
 13c:	90 e0       	ldi	r25, 0x00	; 0
 13e:	0e 94 af 03 	call	0x75e	; 0x75e <xTaskGenericCreate>
	vTaskStartScheduler();
 142:	0e 94 c0 04 	call	0x980	; 0x980 <vTaskStartScheduler>

	for(;;);
 146:	ff cf       	rjmp	.-2      	; 0x146 <main+0x40>

00000148 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 148:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 14a:	03 96       	adiw	r24, 0x03	; 3
 14c:	92 83       	std	Z+2, r25	; 0x02
 14e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 150:	2f ef       	ldi	r18, 0xFF	; 255
 152:	3f ef       	ldi	r19, 0xFF	; 255
 154:	34 83       	std	Z+4, r19	; 0x04
 156:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 158:	96 83       	std	Z+6, r25	; 0x06
 15a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 15c:	90 87       	std	Z+8, r25	; 0x08
 15e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 160:	10 82       	st	Z, r1
 162:	08 95       	ret

00000164 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 164:	fc 01       	movw	r30, r24
 166:	11 86       	std	Z+9, r1	; 0x09
 168:	10 86       	std	Z+8, r1	; 0x08
 16a:	08 95       	ret

0000016c <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 16c:	cf 93       	push	r28
 16e:	df 93       	push	r29
 170:	9c 01       	movw	r18, r24
 172:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 174:	dc 01       	movw	r26, r24
 176:	11 96       	adiw	r26, 0x01	; 1
 178:	cd 91       	ld	r28, X+
 17a:	dc 91       	ld	r29, X
 17c:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 17e:	d3 83       	std	Z+3, r29	; 0x03
 180:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 182:	8c 81       	ldd	r24, Y+4	; 0x04
 184:	9d 81       	ldd	r25, Y+5	; 0x05
 186:	95 83       	std	Z+5, r25	; 0x05
 188:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 18a:	8c 81       	ldd	r24, Y+4	; 0x04
 18c:	9d 81       	ldd	r25, Y+5	; 0x05
 18e:	dc 01       	movw	r26, r24
 190:	13 96       	adiw	r26, 0x03	; 3
 192:	7c 93       	st	X, r23
 194:	6e 93       	st	-X, r22
 196:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 198:	7d 83       	std	Y+5, r23	; 0x05
 19a:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 19c:	31 87       	std	Z+9, r19	; 0x09
 19e:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 1a0:	f9 01       	movw	r30, r18
 1a2:	80 81       	ld	r24, Z
 1a4:	8f 5f       	subi	r24, 0xFF	; 255
 1a6:	80 83       	st	Z, r24
}
 1a8:	df 91       	pop	r29
 1aa:	cf 91       	pop	r28
 1ac:	08 95       	ret

000001ae <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 1ae:	cf 93       	push	r28
 1b0:	df 93       	push	r29
 1b2:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 1b4:	48 81       	ld	r20, Y
 1b6:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 1b8:	4f 3f       	cpi	r20, 0xFF	; 255
 1ba:	2f ef       	ldi	r18, 0xFF	; 255
 1bc:	52 07       	cpc	r21, r18
 1be:	21 f4       	brne	.+8      	; 0x1c8 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 1c0:	fc 01       	movw	r30, r24
 1c2:	a7 81       	ldd	r26, Z+7	; 0x07
 1c4:	b0 85       	ldd	r27, Z+8	; 0x08
 1c6:	0d c0       	rjmp	.+26     	; 0x1e2 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1c8:	dc 01       	movw	r26, r24
 1ca:	13 96       	adiw	r26, 0x03	; 3
 1cc:	01 c0       	rjmp	.+2      	; 0x1d0 <vListInsert+0x22>
 1ce:	df 01       	movw	r26, r30
 1d0:	12 96       	adiw	r26, 0x02	; 2
 1d2:	ed 91       	ld	r30, X+
 1d4:	fc 91       	ld	r31, X
 1d6:	13 97       	sbiw	r26, 0x03	; 3
 1d8:	20 81       	ld	r18, Z
 1da:	31 81       	ldd	r19, Z+1	; 0x01
 1dc:	42 17       	cp	r20, r18
 1de:	53 07       	cpc	r21, r19
 1e0:	b0 f7       	brcc	.-20     	; 0x1ce <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1e2:	12 96       	adiw	r26, 0x02	; 2
 1e4:	ed 91       	ld	r30, X+
 1e6:	fc 91       	ld	r31, X
 1e8:	13 97       	sbiw	r26, 0x03	; 3
 1ea:	fb 83       	std	Y+3, r31	; 0x03
 1ec:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 1ee:	d5 83       	std	Z+5, r29	; 0x05
 1f0:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 1f2:	bd 83       	std	Y+5, r27	; 0x05
 1f4:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 1f6:	13 96       	adiw	r26, 0x03	; 3
 1f8:	dc 93       	st	X, r29
 1fa:	ce 93       	st	-X, r28
 1fc:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1fe:	99 87       	std	Y+9, r25	; 0x09
 200:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 202:	fc 01       	movw	r30, r24
 204:	20 81       	ld	r18, Z
 206:	2f 5f       	subi	r18, 0xFF	; 255
 208:	20 83       	st	Z, r18
}
 20a:	df 91       	pop	r29
 20c:	cf 91       	pop	r28
 20e:	08 95       	ret

00000210 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 210:	cf 93       	push	r28
 212:	df 93       	push	r29
 214:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 216:	a0 85       	ldd	r26, Z+8	; 0x08
 218:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 21a:	c2 81       	ldd	r28, Z+2	; 0x02
 21c:	d3 81       	ldd	r29, Z+3	; 0x03
 21e:	84 81       	ldd	r24, Z+4	; 0x04
 220:	95 81       	ldd	r25, Z+5	; 0x05
 222:	9d 83       	std	Y+5, r25	; 0x05
 224:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 226:	c4 81       	ldd	r28, Z+4	; 0x04
 228:	d5 81       	ldd	r29, Z+5	; 0x05
 22a:	82 81       	ldd	r24, Z+2	; 0x02
 22c:	93 81       	ldd	r25, Z+3	; 0x03
 22e:	9b 83       	std	Y+3, r25	; 0x03
 230:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 232:	11 96       	adiw	r26, 0x01	; 1
 234:	cd 91       	ld	r28, X+
 236:	dc 91       	ld	r29, X
 238:	12 97       	sbiw	r26, 0x02	; 2
 23a:	ce 17       	cp	r28, r30
 23c:	df 07       	cpc	r29, r31
 23e:	31 f4       	brne	.+12     	; 0x24c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 240:	8c 81       	ldd	r24, Y+4	; 0x04
 242:	9d 81       	ldd	r25, Y+5	; 0x05
 244:	12 96       	adiw	r26, 0x02	; 2
 246:	9c 93       	st	X, r25
 248:	8e 93       	st	-X, r24
 24a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 24c:	11 86       	std	Z+9, r1	; 0x09
 24e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 250:	8c 91       	ld	r24, X
 252:	81 50       	subi	r24, 0x01	; 1
 254:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 256:	df 91       	pop	r29
 258:	cf 91       	pop	r28
 25a:	08 95       	ret

0000025c <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
 25c:	31 e1       	ldi	r19, 0x11	; 17
 25e:	fc 01       	movw	r30, r24
 260:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
 262:	31 97       	sbiw	r30, 0x01	; 1
 264:	22 e2       	ldi	r18, 0x22	; 34
 266:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
 268:	31 97       	sbiw	r30, 0x01	; 1
 26a:	a3 e3       	ldi	r26, 0x33	; 51
 26c:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 26e:	31 97       	sbiw	r30, 0x01	; 1
 270:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 272:	31 97       	sbiw	r30, 0x01	; 1
 274:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
 276:	31 97       	sbiw	r30, 0x01	; 1
 278:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
 27a:	31 97       	sbiw	r30, 0x01	; 1
 27c:	60 e8       	ldi	r22, 0x80	; 128
 27e:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
 280:	31 97       	sbiw	r30, 0x01	; 1
 282:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
 284:	31 97       	sbiw	r30, 0x01	; 1
 286:	62 e0       	ldi	r22, 0x02	; 2
 288:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
 28a:	31 97       	sbiw	r30, 0x01	; 1
 28c:	63 e0       	ldi	r22, 0x03	; 3
 28e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
 290:	31 97       	sbiw	r30, 0x01	; 1
 292:	64 e0       	ldi	r22, 0x04	; 4
 294:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
 296:	31 97       	sbiw	r30, 0x01	; 1
 298:	65 e0       	ldi	r22, 0x05	; 5
 29a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
 29c:	31 97       	sbiw	r30, 0x01	; 1
 29e:	66 e0       	ldi	r22, 0x06	; 6
 2a0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
 2a2:	31 97       	sbiw	r30, 0x01	; 1
 2a4:	67 e0       	ldi	r22, 0x07	; 7
 2a6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
 2a8:	31 97       	sbiw	r30, 0x01	; 1
 2aa:	68 e0       	ldi	r22, 0x08	; 8
 2ac:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
 2ae:	31 97       	sbiw	r30, 0x01	; 1
 2b0:	69 e0       	ldi	r22, 0x09	; 9
 2b2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
 2b4:	31 97       	sbiw	r30, 0x01	; 1
 2b6:	60 e1       	ldi	r22, 0x10	; 16
 2b8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
 2ba:	31 97       	sbiw	r30, 0x01	; 1
 2bc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
 2be:	31 97       	sbiw	r30, 0x01	; 1
 2c0:	32 e1       	ldi	r19, 0x12	; 18
 2c2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
 2c4:	31 97       	sbiw	r30, 0x01	; 1
 2c6:	33 e1       	ldi	r19, 0x13	; 19
 2c8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
 2ca:	31 97       	sbiw	r30, 0x01	; 1
 2cc:	34 e1       	ldi	r19, 0x14	; 20
 2ce:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
 2d0:	31 97       	sbiw	r30, 0x01	; 1
 2d2:	35 e1       	ldi	r19, 0x15	; 21
 2d4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
 2d6:	31 97       	sbiw	r30, 0x01	; 1
 2d8:	36 e1       	ldi	r19, 0x16	; 22
 2da:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
 2dc:	31 97       	sbiw	r30, 0x01	; 1
 2de:	37 e1       	ldi	r19, 0x17	; 23
 2e0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
 2e2:	31 97       	sbiw	r30, 0x01	; 1
 2e4:	38 e1       	ldi	r19, 0x18	; 24
 2e6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
 2e8:	31 97       	sbiw	r30, 0x01	; 1
 2ea:	39 e1       	ldi	r19, 0x19	; 25
 2ec:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
 2ee:	31 97       	sbiw	r30, 0x01	; 1
 2f0:	30 e2       	ldi	r19, 0x20	; 32
 2f2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
 2f4:	31 97       	sbiw	r30, 0x01	; 1
 2f6:	31 e2       	ldi	r19, 0x21	; 33
 2f8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
 2fa:	31 97       	sbiw	r30, 0x01	; 1
 2fc:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
 2fe:	31 97       	sbiw	r30, 0x01	; 1
 300:	23 e2       	ldi	r18, 0x23	; 35
 302:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 304:	31 97       	sbiw	r30, 0x01	; 1
 306:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
 308:	31 97       	sbiw	r30, 0x01	; 1
 30a:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
 30c:	31 97       	sbiw	r30, 0x01	; 1
 30e:	26 e2       	ldi	r18, 0x26	; 38
 310:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
 312:	31 97       	sbiw	r30, 0x01	; 1
 314:	27 e2       	ldi	r18, 0x27	; 39
 316:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
 318:	31 97       	sbiw	r30, 0x01	; 1
 31a:	28 e2       	ldi	r18, 0x28	; 40
 31c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
 31e:	31 97       	sbiw	r30, 0x01	; 1
 320:	29 e2       	ldi	r18, 0x29	; 41
 322:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
 324:	31 97       	sbiw	r30, 0x01	; 1
 326:	20 e3       	ldi	r18, 0x30	; 48
 328:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
 32a:	31 97       	sbiw	r30, 0x01	; 1
 32c:	21 e3       	ldi	r18, 0x31	; 49
 32e:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
 330:	86 97       	sbiw	r24, 0x26	; 38
 332:	08 95       	ret

00000334 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
 334:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
 338:	8c e7       	ldi	r24, 0x7C	; 124
 33a:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
 33e:	8b e0       	ldi	r24, 0x0B	; 11
 340:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
 344:	ef e6       	ldi	r30, 0x6F	; 111
 346:	f0 e0       	ldi	r31, 0x00	; 0
 348:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
 34a:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
 34c:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
 34e:	a0 91 63 07 	lds	r26, 0x0763
 352:	b0 91 64 07 	lds	r27, 0x0764
 356:	cd 91       	ld	r28, X+
 358:	cd bf       	out	0x3d, r28	; 61
 35a:	dd 91       	ld	r29, X+
 35c:	de bf       	out	0x3e, r29	; 62
 35e:	ff 91       	pop	r31
 360:	ef 91       	pop	r30
 362:	df 91       	pop	r29
 364:	cf 91       	pop	r28
 366:	bf 91       	pop	r27
 368:	af 91       	pop	r26
 36a:	9f 91       	pop	r25
 36c:	8f 91       	pop	r24
 36e:	7f 91       	pop	r23
 370:	6f 91       	pop	r22
 372:	5f 91       	pop	r21
 374:	4f 91       	pop	r20
 376:	3f 91       	pop	r19
 378:	2f 91       	pop	r18
 37a:	1f 91       	pop	r17
 37c:	0f 91       	pop	r16
 37e:	ff 90       	pop	r15
 380:	ef 90       	pop	r14
 382:	df 90       	pop	r13
 384:	cf 90       	pop	r12
 386:	bf 90       	pop	r11
 388:	af 90       	pop	r10
 38a:	9f 90       	pop	r9
 38c:	8f 90       	pop	r8
 38e:	7f 90       	pop	r7
 390:	6f 90       	pop	r6
 392:	5f 90       	pop	r5
 394:	4f 90       	pop	r4
 396:	3f 90       	pop	r3
 398:	2f 90       	pop	r2
 39a:	1f 90       	pop	r1
 39c:	0f 90       	pop	r0
 39e:	0f be       	out	0x3f, r0	; 63
 3a0:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
 3a2:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
 3a4:	81 e0       	ldi	r24, 0x01	; 1
 3a6:	08 95       	ret

000003a8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 3a8:	0f 92       	push	r0
 3aa:	0f b6       	in	r0, 0x3f	; 63
 3ac:	f8 94       	cli
 3ae:	0f 92       	push	r0
 3b0:	1f 92       	push	r1
 3b2:	11 24       	eor	r1, r1
 3b4:	2f 92       	push	r2
 3b6:	3f 92       	push	r3
 3b8:	4f 92       	push	r4
 3ba:	5f 92       	push	r5
 3bc:	6f 92       	push	r6
 3be:	7f 92       	push	r7
 3c0:	8f 92       	push	r8
 3c2:	9f 92       	push	r9
 3c4:	af 92       	push	r10
 3c6:	bf 92       	push	r11
 3c8:	cf 92       	push	r12
 3ca:	df 92       	push	r13
 3cc:	ef 92       	push	r14
 3ce:	ff 92       	push	r15
 3d0:	0f 93       	push	r16
 3d2:	1f 93       	push	r17
 3d4:	2f 93       	push	r18
 3d6:	3f 93       	push	r19
 3d8:	4f 93       	push	r20
 3da:	5f 93       	push	r21
 3dc:	6f 93       	push	r22
 3de:	7f 93       	push	r23
 3e0:	8f 93       	push	r24
 3e2:	9f 93       	push	r25
 3e4:	af 93       	push	r26
 3e6:	bf 93       	push	r27
 3e8:	cf 93       	push	r28
 3ea:	df 93       	push	r29
 3ec:	ef 93       	push	r30
 3ee:	ff 93       	push	r31
 3f0:	a0 91 63 07 	lds	r26, 0x0763
 3f4:	b0 91 64 07 	lds	r27, 0x0764
 3f8:	0d b6       	in	r0, 0x3d	; 61
 3fa:	0d 92       	st	X+, r0
 3fc:	0e b6       	in	r0, 0x3e	; 62
 3fe:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 400:	0e 94 b9 06 	call	0xd72	; 0xd72 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 404:	a0 91 63 07 	lds	r26, 0x0763
 408:	b0 91 64 07 	lds	r27, 0x0764
 40c:	cd 91       	ld	r28, X+
 40e:	cd bf       	out	0x3d, r28	; 61
 410:	dd 91       	ld	r29, X+
 412:	de bf       	out	0x3e, r29	; 62
 414:	ff 91       	pop	r31
 416:	ef 91       	pop	r30
 418:	df 91       	pop	r29
 41a:	cf 91       	pop	r28
 41c:	bf 91       	pop	r27
 41e:	af 91       	pop	r26
 420:	9f 91       	pop	r25
 422:	8f 91       	pop	r24
 424:	7f 91       	pop	r23
 426:	6f 91       	pop	r22
 428:	5f 91       	pop	r21
 42a:	4f 91       	pop	r20
 42c:	3f 91       	pop	r19
 42e:	2f 91       	pop	r18
 430:	1f 91       	pop	r17
 432:	0f 91       	pop	r16
 434:	ff 90       	pop	r15
 436:	ef 90       	pop	r14
 438:	df 90       	pop	r13
 43a:	cf 90       	pop	r12
 43c:	bf 90       	pop	r11
 43e:	af 90       	pop	r10
 440:	9f 90       	pop	r9
 442:	8f 90       	pop	r8
 444:	7f 90       	pop	r7
 446:	6f 90       	pop	r6
 448:	5f 90       	pop	r5
 44a:	4f 90       	pop	r4
 44c:	3f 90       	pop	r3
 44e:	2f 90       	pop	r2
 450:	1f 90       	pop	r1
 452:	0f 90       	pop	r0
 454:	0f be       	out	0x3f, r0	; 63
 456:	0f 90       	pop	r0

	asm volatile ( "ret" );
 458:	08 95       	ret

0000045a <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 45a:	0f 92       	push	r0
 45c:	0f b6       	in	r0, 0x3f	; 63
 45e:	f8 94       	cli
 460:	0f 92       	push	r0
 462:	1f 92       	push	r1
 464:	11 24       	eor	r1, r1
 466:	2f 92       	push	r2
 468:	3f 92       	push	r3
 46a:	4f 92       	push	r4
 46c:	5f 92       	push	r5
 46e:	6f 92       	push	r6
 470:	7f 92       	push	r7
 472:	8f 92       	push	r8
 474:	9f 92       	push	r9
 476:	af 92       	push	r10
 478:	bf 92       	push	r11
 47a:	cf 92       	push	r12
 47c:	df 92       	push	r13
 47e:	ef 92       	push	r14
 480:	ff 92       	push	r15
 482:	0f 93       	push	r16
 484:	1f 93       	push	r17
 486:	2f 93       	push	r18
 488:	3f 93       	push	r19
 48a:	4f 93       	push	r20
 48c:	5f 93       	push	r21
 48e:	6f 93       	push	r22
 490:	7f 93       	push	r23
 492:	8f 93       	push	r24
 494:	9f 93       	push	r25
 496:	af 93       	push	r26
 498:	bf 93       	push	r27
 49a:	cf 93       	push	r28
 49c:	df 93       	push	r29
 49e:	ef 93       	push	r30
 4a0:	ff 93       	push	r31
 4a2:	a0 91 63 07 	lds	r26, 0x0763
 4a6:	b0 91 64 07 	lds	r27, 0x0764
 4aa:	0d b6       	in	r0, 0x3d	; 61
 4ac:	0d 92       	st	X+, r0
 4ae:	0e b6       	in	r0, 0x3e	; 62
 4b0:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 4b2:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <xTaskIncrementTick>
 4b6:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 4b8:	0e 94 b9 06 	call	0xd72	; 0xd72 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 4bc:	a0 91 63 07 	lds	r26, 0x0763
 4c0:	b0 91 64 07 	lds	r27, 0x0764
 4c4:	cd 91       	ld	r28, X+
 4c6:	cd bf       	out	0x3d, r28	; 61
 4c8:	dd 91       	ld	r29, X+
 4ca:	de bf       	out	0x3e, r29	; 62
 4cc:	ff 91       	pop	r31
 4ce:	ef 91       	pop	r30
 4d0:	df 91       	pop	r29
 4d2:	cf 91       	pop	r28
 4d4:	bf 91       	pop	r27
 4d6:	af 91       	pop	r26
 4d8:	9f 91       	pop	r25
 4da:	8f 91       	pop	r24
 4dc:	7f 91       	pop	r23
 4de:	6f 91       	pop	r22
 4e0:	5f 91       	pop	r21
 4e2:	4f 91       	pop	r20
 4e4:	3f 91       	pop	r19
 4e6:	2f 91       	pop	r18
 4e8:	1f 91       	pop	r17
 4ea:	0f 91       	pop	r16
 4ec:	ff 90       	pop	r15
 4ee:	ef 90       	pop	r14
 4f0:	df 90       	pop	r13
 4f2:	cf 90       	pop	r12
 4f4:	bf 90       	pop	r11
 4f6:	af 90       	pop	r10
 4f8:	9f 90       	pop	r9
 4fa:	8f 90       	pop	r8
 4fc:	7f 90       	pop	r7
 4fe:	6f 90       	pop	r6
 500:	5f 90       	pop	r5
 502:	4f 90       	pop	r4
 504:	3f 90       	pop	r3
 506:	2f 90       	pop	r2
 508:	1f 90       	pop	r1
 50a:	0f 90       	pop	r0
 50c:	0f be       	out	0x3f, r0	; 63
 50e:	0f 90       	pop	r0

	asm volatile ( "ret" );
 510:	08 95       	ret

00000512 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect(void) __attribute__ ((signal, naked));
	void TIMER1_COMPA_vect(void)
	{
		vPortYieldFromTick();
 512:	0e 94 2d 02 	call	0x45a	; 0x45a <vPortYieldFromTick>
		asm volatile ( "reti" );
 516:	18 95       	reti

00000518 <pvPortMalloc>:
	pxIterator->pxNextFreeBlock = pxBlockToInsert;									\
}
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
 518:	0f 93       	push	r16
 51a:	1f 93       	push	r17
 51c:	cf 93       	push	r28
 51e:	df 93       	push	r29
 520:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;

	vTaskSuspendAll();
 522:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
 526:	80 91 1e 01 	lds	r24, 0x011E
 52a:	81 11       	cpse	r24, r1
 52c:	1d c0       	rjmp	.+58     	; 0x568 <pvPortMalloc+0x50>
	/* Ensure the heap starts on a correctly aligned boundary. */
	pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
 52e:	e3 e2       	ldi	r30, 0x23	; 35
 530:	f1 e0       	ldi	r31, 0x01	; 1
 532:	88 e2       	ldi	r24, 0x28	; 40
 534:	91 e0       	ldi	r25, 0x01	; 1
 536:	91 83       	std	Z+1, r25	; 0x01
 538:	80 83       	st	Z, r24
	xStart.xBlockSize = ( size_t ) 0;
 53a:	13 82       	std	Z+3, r1	; 0x03
 53c:	12 82       	std	Z+2, r1	; 0x02

	/* xEnd is used to mark the end of the list of free blocks. */
	xEnd.xBlockSize = configADJUSTED_HEAP_SIZE;
 53e:	ef e1       	ldi	r30, 0x1F	; 31
 540:	f1 e0       	ldi	r31, 0x01	; 1
 542:	8b ed       	ldi	r24, 0xDB	; 219
 544:	95 e0       	ldi	r25, 0x05	; 5
 546:	93 83       	std	Z+3, r25	; 0x03
 548:	82 83       	std	Z+2, r24	; 0x02
	xEnd.pxNextFreeBlock = NULL;
 54a:	11 82       	std	Z+1, r1	; 0x01
 54c:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = configADJUSTED_HEAP_SIZE;
 54e:	a7 e2       	ldi	r26, 0x27	; 39
 550:	b1 e0       	ldi	r27, 0x01	; 1
 552:	14 96       	adiw	r26, 0x04	; 4
 554:	9c 93       	st	X, r25
 556:	8e 93       	st	-X, r24
 558:	13 97       	sbiw	r26, 0x03	; 3
	pxFirstFreeBlock->pxNextFreeBlock = &xEnd;
 55a:	12 96       	adiw	r26, 0x02	; 2
 55c:	fc 93       	st	X, r31
 55e:	ee 93       	st	-X, r30
 560:	11 97       	sbiw	r26, 0x01	; 1
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( xHeapHasBeenInitialised == pdFALSE )
		{
			prvHeapInit();
			xHeapHasBeenInitialised = pdTRUE;
 562:	81 e0       	ldi	r24, 0x01	; 1
 564:	80 93 1e 01 	sts	0x011E, r24
		}

		/* The wanted size is increased so it can contain a BlockLink_t
		structure in addition to the requested amount of bytes. */
		if( xWantedSize > 0 )
 568:	20 97       	sbiw	r28, 0x00	; 0
 56a:	09 f4       	brne	.+2      	; 0x56e <pvPortMalloc+0x56>
 56c:	5f c0       	rjmp	.+190    	; 0x62c <pvPortMalloc+0x114>
		{
			xWantedSize += heapSTRUCT_SIZE;
 56e:	9e 01       	movw	r18, r28
 570:	2c 5f       	subi	r18, 0xFC	; 252
 572:	3f 4f       	sbci	r19, 0xFF	; 255
				/* Byte alignment required. */
				xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
			}
		}

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
 574:	23 96       	adiw	r28, 0x03	; 3
 576:	ca 3d       	cpi	r28, 0xDA	; 218
 578:	d5 40       	sbci	r29, 0x05	; 5
 57a:	08 f0       	brcs	.+2      	; 0x57e <pvPortMalloc+0x66>
 57c:	5a c0       	rjmp	.+180    	; 0x632 <pvPortMalloc+0x11a>
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
 57e:	e0 91 23 01 	lds	r30, 0x0123
 582:	f0 91 24 01 	lds	r31, 0x0124

		if( ( xWantedSize > 0 ) && ( xWantedSize < configADJUSTED_HEAP_SIZE ) )
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
 586:	a3 e2       	ldi	r26, 0x23	; 35
 588:	b1 e0       	ldi	r27, 0x01	; 1
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 58a:	02 c0       	rjmp	.+4      	; 0x590 <pvPortMalloc+0x78>
 58c:	df 01       	movw	r26, r30
			{
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
 58e:	fc 01       	movw	r30, r24
		{
			/* Blocks are stored in byte order - traverse the list from the start
			(smallest) block until one of adequate size is found. */
			pxPreviousBlock = &xStart;
			pxBlock = xStart.pxNextFreeBlock;
			while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
 590:	82 81       	ldd	r24, Z+2	; 0x02
 592:	93 81       	ldd	r25, Z+3	; 0x03
 594:	82 17       	cp	r24, r18
 596:	93 07       	cpc	r25, r19
 598:	20 f4       	brcc	.+8      	; 0x5a2 <pvPortMalloc+0x8a>
 59a:	80 81       	ld	r24, Z
 59c:	91 81       	ldd	r25, Z+1	; 0x01
 59e:	00 97       	sbiw	r24, 0x00	; 0
 5a0:	a9 f7       	brne	.-22     	; 0x58c <pvPortMalloc+0x74>
				pxPreviousBlock = pxBlock;
				pxBlock = pxBlock->pxNextFreeBlock;
			}

			/* If we found the end marker then a block of adequate size was not found. */
			if( pxBlock != &xEnd )
 5a2:	c1 e0       	ldi	r28, 0x01	; 1
 5a4:	ef 31       	cpi	r30, 0x1F	; 31
 5a6:	fc 07       	cpc	r31, r28
 5a8:	09 f4       	brne	.+2      	; 0x5ac <pvPortMalloc+0x94>
 5aa:	46 c0       	rjmp	.+140    	; 0x638 <pvPortMalloc+0x120>
			{
				/* Return the memory space - jumping over the BlockLink_t structure
				at its start. */
				pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + heapSTRUCT_SIZE );
 5ac:	cd 91       	ld	r28, X+
 5ae:	dc 91       	ld	r29, X
 5b0:	11 97       	sbiw	r26, 0x01	; 1
 5b2:	8e 01       	movw	r16, r28
 5b4:	0c 5f       	subi	r16, 0xFC	; 252
 5b6:	1f 4f       	sbci	r17, 0xFF	; 255

				/* This block is being returned for use so must be taken out of the
				list of free blocks. */
				pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
 5b8:	80 81       	ld	r24, Z
 5ba:	91 81       	ldd	r25, Z+1	; 0x01
 5bc:	8d 93       	st	X+, r24
 5be:	9c 93       	st	X, r25

				/* If the block is larger than required it can be split into two. */
				if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
 5c0:	82 81       	ldd	r24, Z+2	; 0x02
 5c2:	93 81       	ldd	r25, Z+3	; 0x03
 5c4:	82 1b       	sub	r24, r18
 5c6:	93 0b       	sbc	r25, r19
 5c8:	89 30       	cpi	r24, 0x09	; 9
 5ca:	91 05       	cpc	r25, r1
 5cc:	10 f1       	brcs	.+68     	; 0x612 <pvPortMalloc+0xfa>
				{
					/* This block is to be split into two.  Create a new block
					following the number of bytes requested. The void cast is
					used to prevent byte alignment warnings from the compiler. */
					pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
 5ce:	bf 01       	movw	r22, r30
 5d0:	62 0f       	add	r22, r18
 5d2:	73 1f       	adc	r23, r19

					/* Calculate the sizes of two blocks split from the single
					block. */
					pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
 5d4:	db 01       	movw	r26, r22
 5d6:	13 96       	adiw	r26, 0x03	; 3
 5d8:	9c 93       	st	X, r25
 5da:	8e 93       	st	-X, r24
 5dc:	12 97       	sbiw	r26, 0x02	; 2
					pxBlock->xBlockSize = xWantedSize;
 5de:	33 83       	std	Z+3, r19	; 0x03
 5e0:	22 83       	std	Z+2, r18	; 0x02

					/* Insert the new block into the list of free blocks. */
					prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
 5e2:	12 96       	adiw	r26, 0x02	; 2
 5e4:	4d 91       	ld	r20, X+
 5e6:	5c 91       	ld	r21, X
 5e8:	13 97       	sbiw	r26, 0x03	; 3
 5ea:	83 e2       	ldi	r24, 0x23	; 35
 5ec:	91 e0       	ldi	r25, 0x01	; 1
 5ee:	01 c0       	rjmp	.+2      	; 0x5f2 <pvPortMalloc+0xda>
 5f0:	cd 01       	movw	r24, r26
 5f2:	ec 01       	movw	r28, r24
 5f4:	a8 81       	ld	r26, Y
 5f6:	b9 81       	ldd	r27, Y+1	; 0x01
 5f8:	12 96       	adiw	r26, 0x02	; 2
 5fa:	2d 91       	ld	r18, X+
 5fc:	3c 91       	ld	r19, X
 5fe:	13 97       	sbiw	r26, 0x03	; 3
 600:	24 17       	cp	r18, r20
 602:	35 07       	cpc	r19, r21
 604:	a8 f3       	brcs	.-22     	; 0x5f0 <pvPortMalloc+0xd8>
 606:	eb 01       	movw	r28, r22
 608:	b9 83       	std	Y+1, r27	; 0x01
 60a:	a8 83       	st	Y, r26
 60c:	dc 01       	movw	r26, r24
 60e:	6d 93       	st	X+, r22
 610:	7c 93       	st	X, r23
				}

				xFreeBytesRemaining -= pxBlock->xBlockSize;
 612:	80 91 00 01 	lds	r24, 0x0100
 616:	90 91 01 01 	lds	r25, 0x0101
 61a:	22 81       	ldd	r18, Z+2	; 0x02
 61c:	33 81       	ldd	r19, Z+3	; 0x03
 61e:	82 1b       	sub	r24, r18
 620:	93 0b       	sbc	r25, r19
 622:	90 93 01 01 	sts	0x0101, r25
 626:	80 93 00 01 	sts	0x0100, r24
 62a:	08 c0       	rjmp	.+16     	; 0x63c <pvPortMalloc+0x124>

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
static BaseType_t xHeapHasBeenInitialised = pdFALSE;
void *pvReturn = NULL;
 62c:	00 e0       	ldi	r16, 0x00	; 0
 62e:	10 e0       	ldi	r17, 0x00	; 0
 630:	05 c0       	rjmp	.+10     	; 0x63c <pvPortMalloc+0x124>
 632:	00 e0       	ldi	r16, 0x00	; 0
 634:	10 e0       	ldi	r17, 0x00	; 0
 636:	02 c0       	rjmp	.+4      	; 0x63c <pvPortMalloc+0x124>
 638:	00 e0       	ldi	r16, 0x00	; 0
 63a:	10 e0       	ldi	r17, 0x00	; 0
			}
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 63c:	0e 94 b8 05 	call	0xb70	; 0xb70 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 640:	c8 01       	movw	r24, r16
 642:	df 91       	pop	r29
 644:	cf 91       	pop	r28
 646:	1f 91       	pop	r17
 648:	0f 91       	pop	r16
 64a:	08 95       	ret

0000064c <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 64c:	0f 93       	push	r16
 64e:	1f 93       	push	r17
 650:	cf 93       	push	r28
 652:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
 654:	00 97       	sbiw	r24, 0x00	; 0
 656:	41 f1       	breq	.+80     	; 0x6a8 <vPortFree+0x5c>
 658:	ec 01       	movw	r28, r24
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= heapSTRUCT_SIZE;
 65a:	8c 01       	movw	r16, r24
 65c:	04 50       	subi	r16, 0x04	; 4
 65e:	11 09       	sbc	r17, r1

		/* This unexpected casting is to keep some compilers from issuing
		byte alignment warnings. */
		pxLink = ( void * ) puc;

		vTaskSuspendAll();
 660:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <vTaskSuspendAll>
		{
			/* Add this block to the list of free blocks. */
			prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
 664:	f8 01       	movw	r30, r16
 666:	42 81       	ldd	r20, Z+2	; 0x02
 668:	53 81       	ldd	r21, Z+3	; 0x03
 66a:	a3 e2       	ldi	r26, 0x23	; 35
 66c:	b1 e0       	ldi	r27, 0x01	; 1
 66e:	01 c0       	rjmp	.+2      	; 0x672 <vPortFree+0x26>
 670:	df 01       	movw	r26, r30
 672:	ed 91       	ld	r30, X+
 674:	fc 91       	ld	r31, X
 676:	11 97       	sbiw	r26, 0x01	; 1
 678:	22 81       	ldd	r18, Z+2	; 0x02
 67a:	33 81       	ldd	r19, Z+3	; 0x03
 67c:	24 17       	cp	r18, r20
 67e:	35 07       	cpc	r19, r21
 680:	b8 f3       	brcs	.-18     	; 0x670 <vPortFree+0x24>
 682:	24 97       	sbiw	r28, 0x04	; 4
 684:	f9 83       	std	Y+1, r31	; 0x01
 686:	e8 83       	st	Y, r30
 688:	0d 93       	st	X+, r16
 68a:	1c 93       	st	X, r17
			xFreeBytesRemaining += pxLink->xBlockSize;
 68c:	20 91 00 01 	lds	r18, 0x0100
 690:	30 91 01 01 	lds	r19, 0x0101
 694:	8a 81       	ldd	r24, Y+2	; 0x02
 696:	9b 81       	ldd	r25, Y+3	; 0x03
 698:	82 0f       	add	r24, r18
 69a:	93 1f       	adc	r25, r19
 69c:	90 93 01 01 	sts	0x0101, r25
 6a0:	80 93 00 01 	sts	0x0100, r24
			traceFREE( pv, pxLink->xBlockSize );
		}
		( void ) xTaskResumeAll();
 6a4:	0e 94 b8 05 	call	0xb70	; 0xb70 <xTaskResumeAll>
	}
}
 6a8:	df 91       	pop	r29
 6aa:	cf 91       	pop	r28
 6ac:	1f 91       	pop	r17
 6ae:	0f 91       	pop	r16
 6b0:	08 95       	ret

000006b2 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 6b2:	e0 91 2b 07 	lds	r30, 0x072B
 6b6:	f0 91 2c 07 	lds	r31, 0x072C
 6ba:	80 81       	ld	r24, Z
 6bc:	81 11       	cpse	r24, r1
 6be:	07 c0       	rjmp	.+14     	; 0x6ce <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 6c0:	8f ef       	ldi	r24, 0xFF	; 255
 6c2:	9f ef       	ldi	r25, 0xFF	; 255
 6c4:	90 93 03 01 	sts	0x0103, r25
 6c8:	80 93 02 01 	sts	0x0102, r24
 6cc:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 6ce:	e0 91 2b 07 	lds	r30, 0x072B
 6d2:	f0 91 2c 07 	lds	r31, 0x072C
 6d6:	05 80       	ldd	r0, Z+5	; 0x05
 6d8:	f6 81       	ldd	r31, Z+6	; 0x06
 6da:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
 6dc:	06 80       	ldd	r0, Z+6	; 0x06
 6de:	f7 81       	ldd	r31, Z+7	; 0x07
 6e0:	e0 2d       	mov	r30, r0
 6e2:	82 81       	ldd	r24, Z+2	; 0x02
 6e4:	93 81       	ldd	r25, Z+3	; 0x03
 6e6:	90 93 03 01 	sts	0x0103, r25
 6ea:	80 93 02 01 	sts	0x0102, r24
 6ee:	08 95       	ret

000006f0 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
 6f0:	cf 93       	push	r28
 6f2:	df 93       	push	r29
 6f4:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
 6f6:	e0 91 63 07 	lds	r30, 0x0763
 6fa:	f0 91 64 07 	lds	r31, 0x0764
 6fe:	93 83       	std	Z+3, r25	; 0x03
 700:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
 702:	80 91 0a 07 	lds	r24, 0x070A
 706:	90 91 0b 07 	lds	r25, 0x070B
 70a:	c8 17       	cp	r28, r24
 70c:	d9 07       	cpc	r29, r25
 70e:	68 f4       	brcc	.+26     	; 0x72a <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 710:	60 91 63 07 	lds	r22, 0x0763
 714:	70 91 64 07 	lds	r23, 0x0764
 718:	80 91 29 07 	lds	r24, 0x0729
 71c:	90 91 2a 07 	lds	r25, 0x072A
 720:	6e 5f       	subi	r22, 0xFE	; 254
 722:	7f 4f       	sbci	r23, 0xFF	; 255
 724:	0e 94 d7 00 	call	0x1ae	; 0x1ae <vListInsert>
 728:	17 c0       	rjmp	.+46     	; 0x758 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
 72a:	60 91 63 07 	lds	r22, 0x0763
 72e:	70 91 64 07 	lds	r23, 0x0764
 732:	80 91 2b 07 	lds	r24, 0x072B
 736:	90 91 2c 07 	lds	r25, 0x072C
 73a:	6e 5f       	subi	r22, 0xFE	; 254
 73c:	7f 4f       	sbci	r23, 0xFF	; 255
 73e:	0e 94 d7 00 	call	0x1ae	; 0x1ae <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
 742:	80 91 02 01 	lds	r24, 0x0102
 746:	90 91 03 01 	lds	r25, 0x0103
 74a:	c8 17       	cp	r28, r24
 74c:	d9 07       	cpc	r29, r25
 74e:	20 f4       	brcc	.+8      	; 0x758 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
 750:	d0 93 03 01 	sts	0x0103, r29
 754:	c0 93 02 01 	sts	0x0102, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
 758:	df 91       	pop	r29
 75a:	cf 91       	pop	r28
 75c:	08 95       	ret

0000075e <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
 75e:	4f 92       	push	r4
 760:	5f 92       	push	r5
 762:	6f 92       	push	r6
 764:	7f 92       	push	r7
 766:	8f 92       	push	r8
 768:	9f 92       	push	r9
 76a:	af 92       	push	r10
 76c:	bf 92       	push	r11
 76e:	cf 92       	push	r12
 770:	df 92       	push	r13
 772:	ef 92       	push	r14
 774:	ff 92       	push	r15
 776:	0f 93       	push	r16
 778:	1f 93       	push	r17
 77a:	cf 93       	push	r28
 77c:	df 93       	push	r29
 77e:	4c 01       	movw	r8, r24
 780:	eb 01       	movw	r28, r22
 782:	5a 01       	movw	r10, r20
 784:	29 01       	movw	r4, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 786:	c1 14       	cp	r12, r1
 788:	d1 04       	cpc	r13, r1
 78a:	39 f4       	brne	.+14     	; 0x79a <xTaskGenericCreate+0x3c>
 78c:	ca 01       	movw	r24, r20
 78e:	0e 94 8c 02 	call	0x518	; 0x518 <pvPortMalloc>
 792:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
 794:	89 2b       	or	r24, r25
 796:	09 f4       	brne	.+2      	; 0x79a <xTaskGenericCreate+0x3c>
 798:	e1 c0       	rjmp	.+450    	; 0x95c <__stack+0x5d>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
 79a:	86 e2       	ldi	r24, 0x26	; 38
 79c:	90 e0       	ldi	r25, 0x00	; 0
 79e:	0e 94 8c 02 	call	0x518	; 0x518 <pvPortMalloc>
 7a2:	3c 01       	movw	r6, r24

			if( pxNewTCB != NULL )
 7a4:	00 97       	sbiw	r24, 0x00	; 0
 7a6:	79 f0       	breq	.+30     	; 0x7c6 <xTaskGenericCreate+0x68>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
 7a8:	fc 01       	movw	r30, r24
 7aa:	d0 8e       	std	Z+24, r13	; 0x18
 7ac:	c7 8a       	std	Z+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
 7ae:	f1 e0       	ldi	r31, 0x01	; 1
 7b0:	af 1a       	sub	r10, r31
 7b2:	b1 08       	sbc	r11, r1
 7b4:	ca 0c       	add	r12, r10
 7b6:	db 1c       	adc	r13, r11
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 7b8:	88 81       	ld	r24, Y
 7ba:	f3 01       	movw	r30, r6
 7bc:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 7be:	88 81       	ld	r24, Y
 7c0:	81 11       	cpse	r24, r1
 7c2:	05 c0       	rjmp	.+10     	; 0x7ce <xTaskGenericCreate+0x70>
 7c4:	14 c0       	rjmp	.+40     	; 0x7ee <xTaskGenericCreate+0x90>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
 7c6:	c6 01       	movw	r24, r12
 7c8:	0e 94 26 03 	call	0x64c	; 0x64c <vPortFree>
 7cc:	c7 c0       	rjmp	.+398    	; 0x95c <__stack+0x5d>
 7ce:	d3 01       	movw	r26, r6
 7d0:	5a 96       	adiw	r26, 0x1a	; 26
 7d2:	fe 01       	movw	r30, r28
 7d4:	31 96       	adiw	r30, 0x01	; 1
 7d6:	9e 01       	movw	r18, r28
 7d8:	28 5f       	subi	r18, 0xF8	; 248
 7da:	3f 4f       	sbci	r19, 0xFF	; 255
 7dc:	ef 01       	movw	r28, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
 7de:	81 91       	ld	r24, Z+
 7e0:	8d 93       	st	X+, r24

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
 7e2:	88 81       	ld	r24, Y
 7e4:	88 23       	and	r24, r24
 7e6:	19 f0       	breq	.+6      	; 0x7ee <xTaskGenericCreate+0x90>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
 7e8:	e2 17       	cp	r30, r18
 7ea:	f3 07       	cpc	r31, r19
 7ec:	b9 f7       	brne	.-18     	; 0x7dc <xTaskGenericCreate+0x7e>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
 7ee:	f3 01       	movw	r30, r6
 7f0:	10 a2       	std	Z+32, r1	; 0x20
 7f2:	10 2f       	mov	r17, r16
 7f4:	04 30       	cpi	r16, 0x04	; 4
 7f6:	08 f0       	brcs	.+2      	; 0x7fa <xTaskGenericCreate+0x9c>
 7f8:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
 7fa:	f3 01       	movw	r30, r6
 7fc:	16 8b       	std	Z+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
 7fe:	e3 01       	movw	r28, r6
 800:	22 96       	adiw	r28, 0x02	; 2
 802:	ce 01       	movw	r24, r28
 804:	0e 94 b2 00 	call	0x164	; 0x164 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
 808:	c3 01       	movw	r24, r6
 80a:	0c 96       	adiw	r24, 0x0c	; 12
 80c:	0e 94 b2 00 	call	0x164	; 0x164 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
 810:	f3 01       	movw	r30, r6
 812:	71 86       	std	Z+9, r7	; 0x09
 814:	60 86       	std	Z+8, r6	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 816:	84 e0       	ldi	r24, 0x04	; 4
 818:	90 e0       	ldi	r25, 0x00	; 0
 81a:	81 1b       	sub	r24, r17
 81c:	91 09       	sbc	r25, r1
 81e:	95 87       	std	Z+13, r25	; 0x0d
 820:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
 822:	73 8a       	std	Z+19, r7	; 0x13
 824:	62 8a       	std	Z+18, r6	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
 826:	11 a2       	std	Z+33, r1	; 0x21
 828:	12 a2       	std	Z+34, r1	; 0x22
 82a:	13 a2       	std	Z+35, r1	; 0x23
 82c:	14 a2       	std	Z+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
 82e:	15 a2       	std	Z+37, r1	; 0x25
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
 830:	a2 01       	movw	r20, r4
 832:	b4 01       	movw	r22, r8
 834:	c6 01       	movw	r24, r12
 836:	0e 94 2e 01 	call	0x25c	; 0x25c <pxPortInitialiseStack>
 83a:	f3 01       	movw	r30, r6
 83c:	91 83       	std	Z+1, r25	; 0x01
 83e:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
 840:	e1 14       	cp	r14, r1
 842:	f1 04       	cpc	r15, r1
 844:	19 f0       	breq	.+6      	; 0x84c <xTaskGenericCreate+0xee>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
 846:	f7 01       	movw	r30, r14
 848:	71 82       	std	Z+1, r7	; 0x01
 84a:	60 82       	st	Z, r6
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
 84c:	0f b6       	in	r0, 0x3f	; 63
 84e:	f8 94       	cli
 850:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
 852:	80 91 0c 07 	lds	r24, 0x070C
 856:	8f 5f       	subi	r24, 0xFF	; 255
 858:	80 93 0c 07 	sts	0x070C, r24
			if( pxCurrentTCB == NULL )
 85c:	80 91 63 07 	lds	r24, 0x0763
 860:	90 91 64 07 	lds	r25, 0x0764
 864:	89 2b       	or	r24, r25
 866:	d1 f5       	brne	.+116    	; 0x8dc <xTaskGenericCreate+0x17e>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
 868:	70 92 64 07 	sts	0x0764, r7
 86c:	60 92 63 07 	sts	0x0763, r6

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
 870:	80 91 0c 07 	lds	r24, 0x070C
 874:	81 30       	cpi	r24, 0x01	; 1
 876:	09 f0       	breq	.+2      	; 0x87a <xTaskGenericCreate+0x11c>
 878:	40 c0       	rjmp	.+128    	; 0x8fa <xTaskGenericCreate+0x19c>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
 87a:	8f e3       	ldi	r24, 0x3F	; 63
 87c:	97 e0       	ldi	r25, 0x07	; 7
 87e:	0e 94 a4 00 	call	0x148	; 0x148 <vListInitialise>
 882:	88 e4       	ldi	r24, 0x48	; 72
 884:	97 e0       	ldi	r25, 0x07	; 7
 886:	0e 94 a4 00 	call	0x148	; 0x148 <vListInitialise>
 88a:	81 e5       	ldi	r24, 0x51	; 81
 88c:	97 e0       	ldi	r25, 0x07	; 7
 88e:	0e 94 a4 00 	call	0x148	; 0x148 <vListInitialise>
 892:	8a e5       	ldi	r24, 0x5A	; 90
 894:	97 e0       	ldi	r25, 0x07	; 7
 896:	0e 94 a4 00 	call	0x148	; 0x148 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
 89a:	86 e3       	ldi	r24, 0x36	; 54
 89c:	97 e0       	ldi	r25, 0x07	; 7
 89e:	0e 94 a4 00 	call	0x148	; 0x148 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
 8a2:	8d e2       	ldi	r24, 0x2D	; 45
 8a4:	97 e0       	ldi	r25, 0x07	; 7
 8a6:	0e 94 a4 00 	call	0x148	; 0x148 <vListInitialise>
	vListInitialise( &xPendingReadyList );
 8aa:	80 e2       	ldi	r24, 0x20	; 32
 8ac:	97 e0       	ldi	r25, 0x07	; 7
 8ae:	0e 94 a4 00 	call	0x148	; 0x148 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
 8b2:	87 e1       	ldi	r24, 0x17	; 23
 8b4:	97 e0       	ldi	r25, 0x07	; 7
 8b6:	0e 94 a4 00 	call	0x148	; 0x148 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
 8ba:	8d e0       	ldi	r24, 0x0D	; 13
 8bc:	97 e0       	ldi	r25, 0x07	; 7
 8be:	0e 94 a4 00 	call	0x148	; 0x148 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
 8c2:	86 e3       	ldi	r24, 0x36	; 54
 8c4:	97 e0       	ldi	r25, 0x07	; 7
 8c6:	90 93 2c 07 	sts	0x072C, r25
 8ca:	80 93 2b 07 	sts	0x072B, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
 8ce:	8d e2       	ldi	r24, 0x2D	; 45
 8d0:	97 e0       	ldi	r25, 0x07	; 7
 8d2:	90 93 2a 07 	sts	0x072A, r25
 8d6:	80 93 29 07 	sts	0x0729, r24
 8da:	0f c0       	rjmp	.+30     	; 0x8fa <xTaskGenericCreate+0x19c>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
 8dc:	80 91 08 07 	lds	r24, 0x0708
 8e0:	81 11       	cpse	r24, r1
 8e2:	0b c0       	rjmp	.+22     	; 0x8fa <xTaskGenericCreate+0x19c>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
 8e4:	e0 91 63 07 	lds	r30, 0x0763
 8e8:	f0 91 64 07 	lds	r31, 0x0764
 8ec:	86 89       	ldd	r24, Z+22	; 0x16
 8ee:	08 17       	cp	r16, r24
 8f0:	20 f0       	brcs	.+8      	; 0x8fa <xTaskGenericCreate+0x19c>
					{
						pxCurrentTCB = pxNewTCB;
 8f2:	70 92 64 07 	sts	0x0764, r7
 8f6:	60 92 63 07 	sts	0x0763, r6
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
 8fa:	80 91 04 07 	lds	r24, 0x0704
 8fe:	8f 5f       	subi	r24, 0xFF	; 255
 900:	80 93 04 07 	sts	0x0704, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
 904:	f3 01       	movw	r30, r6
 906:	86 89       	ldd	r24, Z+22	; 0x16
 908:	90 91 09 07 	lds	r25, 0x0709
 90c:	98 17       	cp	r25, r24
 90e:	10 f4       	brcc	.+4      	; 0x914 <__stack+0x15>
 910:	80 93 09 07 	sts	0x0709, r24
 914:	90 e0       	ldi	r25, 0x00	; 0
 916:	9c 01       	movw	r18, r24
 918:	22 0f       	add	r18, r18
 91a:	33 1f       	adc	r19, r19
 91c:	22 0f       	add	r18, r18
 91e:	33 1f       	adc	r19, r19
 920:	22 0f       	add	r18, r18
 922:	33 1f       	adc	r19, r19
 924:	82 0f       	add	r24, r18
 926:	93 1f       	adc	r25, r19
 928:	be 01       	movw	r22, r28
 92a:	81 5c       	subi	r24, 0xC1	; 193
 92c:	98 4f       	sbci	r25, 0xF8	; 248
 92e:	0e 94 b6 00 	call	0x16c	; 0x16c <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
 932:	0f 90       	pop	r0
 934:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
 936:	80 91 08 07 	lds	r24, 0x0708
 93a:	88 23       	and	r24, r24
 93c:	59 f0       	breq	.+22     	; 0x954 <__stack+0x55>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
 93e:	e0 91 63 07 	lds	r30, 0x0763
 942:	f0 91 64 07 	lds	r31, 0x0764
 946:	86 89       	ldd	r24, Z+22	; 0x16
 948:	80 17       	cp	r24, r16
 94a:	30 f4       	brcc	.+12     	; 0x958 <__stack+0x59>
			{
				taskYIELD_IF_USING_PREEMPTION();
 94c:	0e 94 d4 01 	call	0x3a8	; 0x3a8 <vPortYield>
 950:	81 e0       	ldi	r24, 0x01	; 1
 952:	05 c0       	rjmp	.+10     	; 0x95e <__stack+0x5f>
 954:	81 e0       	ldi	r24, 0x01	; 1
 956:	03 c0       	rjmp	.+6      	; 0x95e <__stack+0x5f>
 958:	81 e0       	ldi	r24, 0x01	; 1
 95a:	01 c0       	rjmp	.+2      	; 0x95e <__stack+0x5f>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
 95c:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
 95e:	df 91       	pop	r29
 960:	cf 91       	pop	r28
 962:	1f 91       	pop	r17
 964:	0f 91       	pop	r16
 966:	ff 90       	pop	r15
 968:	ef 90       	pop	r14
 96a:	df 90       	pop	r13
 96c:	cf 90       	pop	r12
 96e:	bf 90       	pop	r11
 970:	af 90       	pop	r10
 972:	9f 90       	pop	r9
 974:	8f 90       	pop	r8
 976:	7f 90       	pop	r7
 978:	6f 90       	pop	r6
 97a:	5f 90       	pop	r5
 97c:	4f 90       	pop	r4
 97e:	08 95       	ret

00000980 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
 980:	af 92       	push	r10
 982:	bf 92       	push	r11
 984:	cf 92       	push	r12
 986:	df 92       	push	r13
 988:	ef 92       	push	r14
 98a:	ff 92       	push	r15
 98c:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
 98e:	a1 2c       	mov	r10, r1
 990:	b1 2c       	mov	r11, r1
 992:	c1 2c       	mov	r12, r1
 994:	d1 2c       	mov	r13, r1
 996:	e1 2c       	mov	r14, r1
 998:	f1 2c       	mov	r15, r1
 99a:	00 e0       	ldi	r16, 0x00	; 0
 99c:	20 e0       	ldi	r18, 0x00	; 0
 99e:	30 e0       	ldi	r19, 0x00	; 0
 9a0:	45 e5       	ldi	r20, 0x55	; 85
 9a2:	50 e0       	ldi	r21, 0x00	; 0
 9a4:	68 e1       	ldi	r22, 0x18	; 24
 9a6:	71 e0       	ldi	r23, 0x01	; 1
 9a8:	8c e7       	ldi	r24, 0x7C	; 124
 9aa:	96 e0       	ldi	r25, 0x06	; 6
 9ac:	0e 94 af 03 	call	0x75e	; 0x75e <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
 9b0:	81 30       	cpi	r24, 0x01	; 1
 9b2:	49 f4       	brne	.+18     	; 0x9c6 <vTaskStartScheduler+0x46>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
 9b4:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
 9b6:	80 93 08 07 	sts	0x0708, r24
		xTickCount = ( TickType_t ) 0U;
 9ba:	10 92 0b 07 	sts	0x070B, r1
 9be:	10 92 0a 07 	sts	0x070A, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
 9c2:	0e 94 9a 01 	call	0x334	; 0x334 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
 9c6:	0f 91       	pop	r16
 9c8:	ff 90       	pop	r15
 9ca:	ef 90       	pop	r14
 9cc:	df 90       	pop	r13
 9ce:	cf 90       	pop	r12
 9d0:	bf 90       	pop	r11
 9d2:	af 90       	pop	r10
 9d4:	08 95       	ret

000009d6 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
 9d6:	80 91 03 07 	lds	r24, 0x0703
 9da:	8f 5f       	subi	r24, 0xFF	; 255
 9dc:	80 93 03 07 	sts	0x0703, r24
 9e0:	08 95       	ret

000009e2 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
 9e2:	0f b6       	in	r0, 0x3f	; 63
 9e4:	f8 94       	cli
 9e6:	0f 92       	push	r0
	{
		xTicks = xTickCount;
 9e8:	80 91 0a 07 	lds	r24, 0x070A
 9ec:	90 91 0b 07 	lds	r25, 0x070B
	}
	portTICK_TYPE_EXIT_CRITICAL();
 9f0:	0f 90       	pop	r0
 9f2:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
 9f4:	08 95       	ret

000009f6 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 9f6:	cf 92       	push	r12
 9f8:	df 92       	push	r13
 9fa:	ef 92       	push	r14
 9fc:	ff 92       	push	r15
 9fe:	0f 93       	push	r16
 a00:	1f 93       	push	r17
 a02:	cf 93       	push	r28
 a04:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 a06:	80 91 03 07 	lds	r24, 0x0703
 a0a:	81 11       	cpse	r24, r1
 a0c:	9b c0       	rjmp	.+310    	; 0xb44 <xTaskIncrementTick+0x14e>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
 a0e:	80 91 0a 07 	lds	r24, 0x070A
 a12:	90 91 0b 07 	lds	r25, 0x070B
 a16:	01 96       	adiw	r24, 0x01	; 1
 a18:	90 93 0b 07 	sts	0x070B, r25
 a1c:	80 93 0a 07 	sts	0x070A, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 a20:	e0 90 0a 07 	lds	r14, 0x070A
 a24:	f0 90 0b 07 	lds	r15, 0x070B

			if( xConstTickCount == ( TickType_t ) 0U )
 a28:	e1 14       	cp	r14, r1
 a2a:	f1 04       	cpc	r15, r1
 a2c:	b9 f4       	brne	.+46     	; 0xa5c <xTaskIncrementTick+0x66>
			{
				taskSWITCH_DELAYED_LISTS();
 a2e:	80 91 2b 07 	lds	r24, 0x072B
 a32:	90 91 2c 07 	lds	r25, 0x072C
 a36:	20 91 29 07 	lds	r18, 0x0729
 a3a:	30 91 2a 07 	lds	r19, 0x072A
 a3e:	30 93 2c 07 	sts	0x072C, r19
 a42:	20 93 2b 07 	sts	0x072B, r18
 a46:	90 93 2a 07 	sts	0x072A, r25
 a4a:	80 93 29 07 	sts	0x0729, r24
 a4e:	80 91 05 07 	lds	r24, 0x0705
 a52:	8f 5f       	subi	r24, 0xFF	; 255
 a54:	80 93 05 07 	sts	0x0705, r24
 a58:	0e 94 59 03 	call	0x6b2	; 0x6b2 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
 a5c:	80 91 02 01 	lds	r24, 0x0102
 a60:	90 91 03 01 	lds	r25, 0x0103
 a64:	e8 16       	cp	r14, r24
 a66:	f9 06       	cpc	r15, r25
 a68:	10 f4       	brcc	.+4      	; 0xa6e <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 a6a:	d1 2c       	mov	r13, r1
 a6c:	53 c0       	rjmp	.+166    	; 0xb14 <xTaskIncrementTick+0x11e>
 a6e:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
 a70:	cc 24       	eor	r12, r12
 a72:	c3 94       	inc	r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 a74:	e0 91 2b 07 	lds	r30, 0x072B
 a78:	f0 91 2c 07 	lds	r31, 0x072C
 a7c:	90 81       	ld	r25, Z
 a7e:	91 11       	cpse	r25, r1
 a80:	07 c0       	rjmp	.+14     	; 0xa90 <xTaskIncrementTick+0x9a>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
 a82:	8f ef       	ldi	r24, 0xFF	; 255
 a84:	9f ef       	ldi	r25, 0xFF	; 255
 a86:	90 93 03 01 	sts	0x0103, r25
 a8a:	80 93 02 01 	sts	0x0102, r24
						break;
 a8e:	42 c0       	rjmp	.+132    	; 0xb14 <xTaskIncrementTick+0x11e>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 a90:	e0 91 2b 07 	lds	r30, 0x072B
 a94:	f0 91 2c 07 	lds	r31, 0x072C
 a98:	05 80       	ldd	r0, Z+5	; 0x05
 a9a:	f6 81       	ldd	r31, Z+6	; 0x06
 a9c:	e0 2d       	mov	r30, r0
 a9e:	c6 81       	ldd	r28, Z+6	; 0x06
 aa0:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
 aa2:	2a 81       	ldd	r18, Y+2	; 0x02
 aa4:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
 aa6:	e2 16       	cp	r14, r18
 aa8:	f3 06       	cpc	r15, r19
 aaa:	28 f4       	brcc	.+10     	; 0xab6 <xTaskIncrementTick+0xc0>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
 aac:	30 93 03 01 	sts	0x0103, r19
 ab0:	20 93 02 01 	sts	0x0102, r18
							break;
 ab4:	2f c0       	rjmp	.+94     	; 0xb14 <xTaskIncrementTick+0x11e>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 ab6:	8e 01       	movw	r16, r28
 ab8:	0e 5f       	subi	r16, 0xFE	; 254
 aba:	1f 4f       	sbci	r17, 0xFF	; 255
 abc:	c8 01       	movw	r24, r16
 abe:	0e 94 08 01 	call	0x210	; 0x210 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 ac2:	8c 89       	ldd	r24, Y+20	; 0x14
 ac4:	9d 89       	ldd	r25, Y+21	; 0x15
 ac6:	89 2b       	or	r24, r25
 ac8:	21 f0       	breq	.+8      	; 0xad2 <xTaskIncrementTick+0xdc>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 aca:	ce 01       	movw	r24, r28
 acc:	0c 96       	adiw	r24, 0x0c	; 12
 ace:	0e 94 08 01 	call	0x210	; 0x210 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
 ad2:	2e 89       	ldd	r18, Y+22	; 0x16
 ad4:	80 91 09 07 	lds	r24, 0x0709
 ad8:	82 17       	cp	r24, r18
 ada:	10 f4       	brcc	.+4      	; 0xae0 <xTaskIncrementTick+0xea>
 adc:	20 93 09 07 	sts	0x0709, r18
 ae0:	30 e0       	ldi	r19, 0x00	; 0
 ae2:	c9 01       	movw	r24, r18
 ae4:	88 0f       	add	r24, r24
 ae6:	99 1f       	adc	r25, r25
 ae8:	88 0f       	add	r24, r24
 aea:	99 1f       	adc	r25, r25
 aec:	88 0f       	add	r24, r24
 aee:	99 1f       	adc	r25, r25
 af0:	82 0f       	add	r24, r18
 af2:	93 1f       	adc	r25, r19
 af4:	b8 01       	movw	r22, r16
 af6:	81 5c       	subi	r24, 0xC1	; 193
 af8:	98 4f       	sbci	r25, 0xF8	; 248
 afa:	0e 94 b6 00 	call	0x16c	; 0x16c <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 afe:	e0 91 63 07 	lds	r30, 0x0763
 b02:	f0 91 64 07 	lds	r31, 0x0764
 b06:	9e 89       	ldd	r25, Y+22	; 0x16
 b08:	86 89       	ldd	r24, Z+22	; 0x16
 b0a:	98 17       	cp	r25, r24
 b0c:	08 f4       	brcc	.+2      	; 0xb10 <xTaskIncrementTick+0x11a>
 b0e:	b2 cf       	rjmp	.-156    	; 0xa74 <xTaskIncrementTick+0x7e>
							{
								xSwitchRequired = pdTRUE;
 b10:	dc 2c       	mov	r13, r12
 b12:	b0 cf       	rjmp	.-160    	; 0xa74 <xTaskIncrementTick+0x7e>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 b14:	e0 91 63 07 	lds	r30, 0x0763
 b18:	f0 91 64 07 	lds	r31, 0x0764
 b1c:	86 89       	ldd	r24, Z+22	; 0x16
 b1e:	90 e0       	ldi	r25, 0x00	; 0
 b20:	fc 01       	movw	r30, r24
 b22:	ee 0f       	add	r30, r30
 b24:	ff 1f       	adc	r31, r31
 b26:	ee 0f       	add	r30, r30
 b28:	ff 1f       	adc	r31, r31
 b2a:	ee 0f       	add	r30, r30
 b2c:	ff 1f       	adc	r31, r31
 b2e:	8e 0f       	add	r24, r30
 b30:	9f 1f       	adc	r25, r31
 b32:	fc 01       	movw	r30, r24
 b34:	e1 5c       	subi	r30, 0xC1	; 193
 b36:	f8 4f       	sbci	r31, 0xF8	; 248
 b38:	80 81       	ld	r24, Z
 b3a:	82 30       	cpi	r24, 0x02	; 2
 b3c:	48 f0       	brcs	.+18     	; 0xb50 <xTaskIncrementTick+0x15a>
			{
				xSwitchRequired = pdTRUE;
 b3e:	dd 24       	eor	r13, r13
 b40:	d3 94       	inc	r13
 b42:	06 c0       	rjmp	.+12     	; 0xb50 <xTaskIncrementTick+0x15a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 b44:	80 91 07 07 	lds	r24, 0x0707
 b48:	8f 5f       	subi	r24, 0xFF	; 255
 b4a:	80 93 07 07 	sts	0x0707, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 b4e:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 b50:	80 91 06 07 	lds	r24, 0x0706
 b54:	88 23       	and	r24, r24
 b56:	11 f0       	breq	.+4      	; 0xb5c <xTaskIncrementTick+0x166>
		{
			xSwitchRequired = pdTRUE;
 b58:	dd 24       	eor	r13, r13
 b5a:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 b5c:	8d 2d       	mov	r24, r13
 b5e:	df 91       	pop	r29
 b60:	cf 91       	pop	r28
 b62:	1f 91       	pop	r17
 b64:	0f 91       	pop	r16
 b66:	ff 90       	pop	r15
 b68:	ef 90       	pop	r14
 b6a:	df 90       	pop	r13
 b6c:	cf 90       	pop	r12
 b6e:	08 95       	ret

00000b70 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 b70:	df 92       	push	r13
 b72:	ef 92       	push	r14
 b74:	ff 92       	push	r15
 b76:	0f 93       	push	r16
 b78:	1f 93       	push	r17
 b7a:	cf 93       	push	r28
 b7c:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 b7e:	0f b6       	in	r0, 0x3f	; 63
 b80:	f8 94       	cli
 b82:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
 b84:	80 91 03 07 	lds	r24, 0x0703
 b88:	81 50       	subi	r24, 0x01	; 1
 b8a:	80 93 03 07 	sts	0x0703, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 b8e:	80 91 03 07 	lds	r24, 0x0703
 b92:	81 11       	cpse	r24, r1
 b94:	62 c0       	rjmp	.+196    	; 0xc5a <xTaskResumeAll+0xea>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 b96:	80 91 0c 07 	lds	r24, 0x070C
 b9a:	81 11       	cpse	r24, r1
 b9c:	33 c0       	rjmp	.+102    	; 0xc04 <xTaskResumeAll+0x94>
 b9e:	60 c0       	rjmp	.+192    	; 0xc60 <xTaskResumeAll+0xf0>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 ba0:	d7 01       	movw	r26, r14
 ba2:	15 96       	adiw	r26, 0x05	; 5
 ba4:	ed 91       	ld	r30, X+
 ba6:	fc 91       	ld	r31, X
 ba8:	16 97       	sbiw	r26, 0x06	; 6
 baa:	c6 81       	ldd	r28, Z+6	; 0x06
 bac:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 bae:	ce 01       	movw	r24, r28
 bb0:	0c 96       	adiw	r24, 0x0c	; 12
 bb2:	0e 94 08 01 	call	0x210	; 0x210 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 bb6:	8e 01       	movw	r16, r28
 bb8:	0e 5f       	subi	r16, 0xFE	; 254
 bba:	1f 4f       	sbci	r17, 0xFF	; 255
 bbc:	c8 01       	movw	r24, r16
 bbe:	0e 94 08 01 	call	0x210	; 0x210 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 bc2:	2e 89       	ldd	r18, Y+22	; 0x16
 bc4:	80 91 09 07 	lds	r24, 0x0709
 bc8:	82 17       	cp	r24, r18
 bca:	10 f4       	brcc	.+4      	; 0xbd0 <xTaskResumeAll+0x60>
 bcc:	20 93 09 07 	sts	0x0709, r18
 bd0:	30 e0       	ldi	r19, 0x00	; 0
 bd2:	c9 01       	movw	r24, r18
 bd4:	88 0f       	add	r24, r24
 bd6:	99 1f       	adc	r25, r25
 bd8:	88 0f       	add	r24, r24
 bda:	99 1f       	adc	r25, r25
 bdc:	88 0f       	add	r24, r24
 bde:	99 1f       	adc	r25, r25
 be0:	82 0f       	add	r24, r18
 be2:	93 1f       	adc	r25, r19
 be4:	b8 01       	movw	r22, r16
 be6:	81 5c       	subi	r24, 0xC1	; 193
 be8:	98 4f       	sbci	r25, 0xF8	; 248
 bea:	0e 94 b6 00 	call	0x16c	; 0x16c <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 bee:	e0 91 63 07 	lds	r30, 0x0763
 bf2:	f0 91 64 07 	lds	r31, 0x0764
 bf6:	9e 89       	ldd	r25, Y+22	; 0x16
 bf8:	86 89       	ldd	r24, Z+22	; 0x16
 bfa:	98 17       	cp	r25, r24
 bfc:	58 f0       	brcs	.+22     	; 0xc14 <xTaskResumeAll+0xa4>
					{
						xYieldPending = pdTRUE;
 bfe:	d0 92 06 07 	sts	0x0706, r13
 c02:	08 c0       	rjmp	.+16     	; 0xc14 <xTaskResumeAll+0xa4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 c04:	0f 2e       	mov	r0, r31
 c06:	f0 e2       	ldi	r31, 0x20	; 32
 c08:	ef 2e       	mov	r14, r31
 c0a:	f7 e0       	ldi	r31, 0x07	; 7
 c0c:	ff 2e       	mov	r15, r31
 c0e:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
 c10:	dd 24       	eor	r13, r13
 c12:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 c14:	f7 01       	movw	r30, r14
 c16:	80 81       	ld	r24, Z
 c18:	81 11       	cpse	r24, r1
 c1a:	c2 cf       	rjmp	.-124    	; 0xba0 <xTaskResumeAll+0x30>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
 c1c:	80 91 07 07 	lds	r24, 0x0707
 c20:	88 23       	and	r24, r24
 c22:	99 f0       	breq	.+38     	; 0xc4a <xTaskResumeAll+0xda>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 c24:	80 91 07 07 	lds	r24, 0x0707
 c28:	88 23       	and	r24, r24
 c2a:	79 f0       	breq	.+30     	; 0xc4a <xTaskResumeAll+0xda>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
 c2c:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
 c2e:	0e 94 fb 04 	call	0x9f6	; 0x9f6 <xTaskIncrementTick>
 c32:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
 c34:	c0 93 06 07 	sts	0x0706, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
 c38:	80 91 07 07 	lds	r24, 0x0707
 c3c:	81 50       	subi	r24, 0x01	; 1
 c3e:	80 93 07 07 	sts	0x0707, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
 c42:	80 91 07 07 	lds	r24, 0x0707
 c46:	81 11       	cpse	r24, r1
 c48:	f2 cf       	rjmp	.-28     	; 0xc2e <xTaskResumeAll+0xbe>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
 c4a:	80 91 06 07 	lds	r24, 0x0706
 c4e:	81 30       	cpi	r24, 0x01	; 1
 c50:	31 f4       	brne	.+12     	; 0xc5e <xTaskResumeAll+0xee>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 c52:	0e 94 d4 01 	call	0x3a8	; 0x3a8 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 c56:	81 e0       	ldi	r24, 0x01	; 1
 c58:	03 c0       	rjmp	.+6      	; 0xc60 <xTaskResumeAll+0xf0>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
 c5a:	80 e0       	ldi	r24, 0x00	; 0
 c5c:	01 c0       	rjmp	.+2      	; 0xc60 <xTaskResumeAll+0xf0>
 c5e:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 c60:	0f 90       	pop	r0
 c62:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
 c64:	df 91       	pop	r29
 c66:	cf 91       	pop	r28
 c68:	1f 91       	pop	r17
 c6a:	0f 91       	pop	r16
 c6c:	ff 90       	pop	r15
 c6e:	ef 90       	pop	r14
 c70:	df 90       	pop	r13
 c72:	08 95       	ret

00000c74 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
 c74:	0f 93       	push	r16
 c76:	1f 93       	push	r17
 c78:	cf 93       	push	r28
 c7a:	df 93       	push	r29
 c7c:	8c 01       	movw	r16, r24
 c7e:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
 c80:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
 c84:	80 91 0a 07 	lds	r24, 0x070A
 c88:	90 91 0b 07 	lds	r25, 0x070B

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
 c8c:	f8 01       	movw	r30, r16
 c8e:	20 81       	ld	r18, Z
 c90:	31 81       	ldd	r19, Z+1	; 0x01
 c92:	c2 0f       	add	r28, r18
 c94:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
 c96:	82 17       	cp	r24, r18
 c98:	93 07       	cpc	r25, r19
 c9a:	48 f4       	brcc	.+18     	; 0xcae <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
 c9c:	c2 17       	cp	r28, r18
 c9e:	d3 07       	cpc	r29, r19
 ca0:	10 f5       	brcc	.+68     	; 0xce6 <vTaskDelayUntil+0x72>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 ca2:	d1 83       	std	Z+1, r29	; 0x01
 ca4:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
 ca6:	8c 17       	cp	r24, r28
 ca8:	9d 07       	cpc	r25, r29
 caa:	90 f4       	brcc	.+36     	; 0xcd0 <vTaskDelayUntil+0x5c>
 cac:	07 c0       	rjmp	.+14     	; 0xcbc <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
 cae:	c2 17       	cp	r28, r18
 cb0:	d3 07       	cpc	r29, r19
 cb2:	a8 f0       	brcs	.+42     	; 0xcde <vTaskDelayUntil+0x6a>
 cb4:	8c 17       	cp	r24, r28
 cb6:	9d 07       	cpc	r25, r29
 cb8:	90 f0       	brcs	.+36     	; 0xcde <vTaskDelayUntil+0x6a>
 cba:	15 c0       	rjmp	.+42     	; 0xce6 <vTaskDelayUntil+0x72>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
 cbc:	80 91 63 07 	lds	r24, 0x0763
 cc0:	90 91 64 07 	lds	r25, 0x0764
 cc4:	02 96       	adiw	r24, 0x02	; 2
 cc6:	0e 94 08 01 	call	0x210	; 0x210 <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
 cca:	ce 01       	movw	r24, r28
 ccc:	0e 94 78 03 	call	0x6f0	; 0x6f0 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
 cd0:	0e 94 b8 05 	call	0xb70	; 0xb70 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 cd4:	81 11       	cpse	r24, r1
 cd6:	0b c0       	rjmp	.+22     	; 0xcee <vTaskDelayUntil+0x7a>
		{
			portYIELD_WITHIN_API();
 cd8:	0e 94 d4 01 	call	0x3a8	; 0x3a8 <vPortYield>
 cdc:	08 c0       	rjmp	.+16     	; 0xcee <vTaskDelayUntil+0x7a>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
 cde:	f8 01       	movw	r30, r16
 ce0:	d1 83       	std	Z+1, r29	; 0x01
 ce2:	c0 83       	st	Z, r28
 ce4:	eb cf       	rjmp	.-42     	; 0xcbc <vTaskDelayUntil+0x48>
 ce6:	f8 01       	movw	r30, r16
 ce8:	d1 83       	std	Z+1, r29	; 0x01
 cea:	c0 83       	st	Z, r28
 cec:	f1 cf       	rjmp	.-30     	; 0xcd0 <vTaskDelayUntil+0x5c>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 cee:	df 91       	pop	r29
 cf0:	cf 91       	pop	r28
 cf2:	1f 91       	pop	r17
 cf4:	0f 91       	pop	r16
 cf6:	08 95       	ret

00000cf8 <prvIdleTask>:
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 cf8:	07 e1       	ldi	r16, 0x17	; 23
 cfa:	17 e0       	ldi	r17, 0x07	; 7

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 cfc:	0f 2e       	mov	r0, r31
 cfe:	ff e3       	ldi	r31, 0x3F	; 63
 d00:	ef 2e       	mov	r14, r31
 d02:	f7 e0       	ldi	r31, 0x07	; 7
 d04:	ff 2e       	mov	r15, r31
 d06:	f0 2d       	mov	r31, r0
 d08:	29 c0       	rjmp	.+82     	; 0xd5c <prvIdleTask+0x64>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
 d0a:	0e 94 eb 04 	call	0x9d6	; 0x9d6 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
 d0e:	d8 01       	movw	r26, r16
 d10:	cc 91       	ld	r28, X
			}
			( void ) xTaskResumeAll();
 d12:	0e 94 b8 05 	call	0xb70	; 0xb70 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
 d16:	cc 23       	and	r28, r28
 d18:	09 f1       	breq	.+66     	; 0xd5c <prvIdleTask+0x64>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
 d1a:	0f b6       	in	r0, 0x3f	; 63
 d1c:	f8 94       	cli
 d1e:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
 d20:	d8 01       	movw	r26, r16
 d22:	15 96       	adiw	r26, 0x05	; 5
 d24:	ed 91       	ld	r30, X+
 d26:	fc 91       	ld	r31, X
 d28:	16 97       	sbiw	r26, 0x06	; 6
 d2a:	c6 81       	ldd	r28, Z+6	; 0x06
 d2c:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
 d2e:	ce 01       	movw	r24, r28
 d30:	02 96       	adiw	r24, 0x02	; 2
 d32:	0e 94 08 01 	call	0x210	; 0x210 <uxListRemove>
					--uxCurrentNumberOfTasks;
 d36:	80 91 0c 07 	lds	r24, 0x070C
 d3a:	81 50       	subi	r24, 0x01	; 1
 d3c:	80 93 0c 07 	sts	0x070C, r24
					--uxTasksDeleted;
 d40:	80 91 16 07 	lds	r24, 0x0716
 d44:	81 50       	subi	r24, 0x01	; 1
 d46:	80 93 16 07 	sts	0x0716, r24
				}
				taskEXIT_CRITICAL();
 d4a:	0f 90       	pop	r0
 d4c:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
 d4e:	8f 89       	ldd	r24, Y+23	; 0x17
 d50:	98 8d       	ldd	r25, Y+24	; 0x18
 d52:	0e 94 26 03 	call	0x64c	; 0x64c <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
 d56:	ce 01       	movw	r24, r28
 d58:	0e 94 26 03 	call	0x64c	; 0x64c <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
 d5c:	80 91 16 07 	lds	r24, 0x0716
 d60:	81 11       	cpse	r24, r1
 d62:	d3 cf       	rjmp	.-90     	; 0xd0a <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
 d64:	f7 01       	movw	r30, r14
 d66:	80 81       	ld	r24, Z
 d68:	82 30       	cpi	r24, 0x02	; 2
 d6a:	c0 f3       	brcs	.-16     	; 0xd5c <prvIdleTask+0x64>
			{
				taskYIELD();
 d6c:	0e 94 d4 01 	call	0x3a8	; 0x3a8 <vPortYield>
 d70:	f5 cf       	rjmp	.-22     	; 0xd5c <prvIdleTask+0x64>

00000d72 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 d72:	80 91 03 07 	lds	r24, 0x0703
 d76:	88 23       	and	r24, r24
 d78:	21 f0       	breq	.+8      	; 0xd82 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 d7a:	81 e0       	ldi	r24, 0x01	; 1
 d7c:	80 93 06 07 	sts	0x0706, r24
 d80:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 d82:	10 92 06 07 	sts	0x0706, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 d86:	80 91 09 07 	lds	r24, 0x0709
 d8a:	90 e0       	ldi	r25, 0x00	; 0
 d8c:	fc 01       	movw	r30, r24
 d8e:	ee 0f       	add	r30, r30
 d90:	ff 1f       	adc	r31, r31
 d92:	ee 0f       	add	r30, r30
 d94:	ff 1f       	adc	r31, r31
 d96:	ee 0f       	add	r30, r30
 d98:	ff 1f       	adc	r31, r31
 d9a:	8e 0f       	add	r24, r30
 d9c:	9f 1f       	adc	r25, r31
 d9e:	fc 01       	movw	r30, r24
 da0:	e1 5c       	subi	r30, 0xC1	; 193
 da2:	f8 4f       	sbci	r31, 0xF8	; 248
 da4:	80 81       	ld	r24, Z
 da6:	81 11       	cpse	r24, r1
 da8:	17 c0       	rjmp	.+46     	; 0xdd8 <vTaskSwitchContext+0x66>
 daa:	80 91 09 07 	lds	r24, 0x0709
 dae:	81 50       	subi	r24, 0x01	; 1
 db0:	80 93 09 07 	sts	0x0709, r24
 db4:	80 91 09 07 	lds	r24, 0x0709
 db8:	90 e0       	ldi	r25, 0x00	; 0
 dba:	fc 01       	movw	r30, r24
 dbc:	ee 0f       	add	r30, r30
 dbe:	ff 1f       	adc	r31, r31
 dc0:	ee 0f       	add	r30, r30
 dc2:	ff 1f       	adc	r31, r31
 dc4:	ee 0f       	add	r30, r30
 dc6:	ff 1f       	adc	r31, r31
 dc8:	8e 0f       	add	r24, r30
 dca:	9f 1f       	adc	r25, r31
 dcc:	fc 01       	movw	r30, r24
 dce:	e1 5c       	subi	r30, 0xC1	; 193
 dd0:	f8 4f       	sbci	r31, 0xF8	; 248
 dd2:	80 81       	ld	r24, Z
 dd4:	88 23       	and	r24, r24
 dd6:	49 f3       	breq	.-46     	; 0xdaa <vTaskSwitchContext+0x38>
 dd8:	80 91 09 07 	lds	r24, 0x0709
 ddc:	90 e0       	ldi	r25, 0x00	; 0
 dde:	9c 01       	movw	r18, r24
 de0:	22 0f       	add	r18, r18
 de2:	33 1f       	adc	r19, r19
 de4:	22 0f       	add	r18, r18
 de6:	33 1f       	adc	r19, r19
 de8:	22 0f       	add	r18, r18
 dea:	33 1f       	adc	r19, r19
 dec:	28 0f       	add	r18, r24
 dee:	39 1f       	adc	r19, r25
 df0:	d9 01       	movw	r26, r18
 df2:	a1 5c       	subi	r26, 0xC1	; 193
 df4:	b8 4f       	sbci	r27, 0xF8	; 248
 df6:	11 96       	adiw	r26, 0x01	; 1
 df8:	ed 91       	ld	r30, X+
 dfa:	fc 91       	ld	r31, X
 dfc:	12 97       	sbiw	r26, 0x02	; 2
 dfe:	02 80       	ldd	r0, Z+2	; 0x02
 e00:	f3 81       	ldd	r31, Z+3	; 0x03
 e02:	e0 2d       	mov	r30, r0
 e04:	12 96       	adiw	r26, 0x02	; 2
 e06:	fc 93       	st	X, r31
 e08:	ee 93       	st	-X, r30
 e0a:	11 97       	sbiw	r26, 0x01	; 1
 e0c:	2e 5b       	subi	r18, 0xBE	; 190
 e0e:	38 4f       	sbci	r19, 0xF8	; 248
 e10:	e2 17       	cp	r30, r18
 e12:	f3 07       	cpc	r31, r19
 e14:	29 f4       	brne	.+10     	; 0xe20 <vTaskSwitchContext+0xae>
 e16:	22 81       	ldd	r18, Z+2	; 0x02
 e18:	33 81       	ldd	r19, Z+3	; 0x03
 e1a:	fd 01       	movw	r30, r26
 e1c:	32 83       	std	Z+2, r19	; 0x02
 e1e:	21 83       	std	Z+1, r18	; 0x01
 e20:	fc 01       	movw	r30, r24
 e22:	ee 0f       	add	r30, r30
 e24:	ff 1f       	adc	r31, r31
 e26:	ee 0f       	add	r30, r30
 e28:	ff 1f       	adc	r31, r31
 e2a:	ee 0f       	add	r30, r30
 e2c:	ff 1f       	adc	r31, r31
 e2e:	8e 0f       	add	r24, r30
 e30:	9f 1f       	adc	r25, r31
 e32:	fc 01       	movw	r30, r24
 e34:	e1 5c       	subi	r30, 0xC1	; 193
 e36:	f8 4f       	sbci	r31, 0xF8	; 248
 e38:	01 80       	ldd	r0, Z+1	; 0x01
 e3a:	f2 81       	ldd	r31, Z+2	; 0x02
 e3c:	e0 2d       	mov	r30, r0
 e3e:	86 81       	ldd	r24, Z+6	; 0x06
 e40:	97 81       	ldd	r25, Z+7	; 0x07
 e42:	90 93 64 07 	sts	0x0764, r25
 e46:	80 93 63 07 	sts	0x0763, r24
 e4a:	08 95       	ret

00000e4c <_exit>:
 e4c:	f8 94       	cli

00000e4e <__stop_program>:
 e4e:	ff cf       	rjmp	.-2      	; 0xe4e <__stop_program>
